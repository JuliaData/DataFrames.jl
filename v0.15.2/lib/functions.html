<!DOCTYPE html><HTML lang="en"><head><meta charset="UTF-8"/><meta content="width=device-width, initial-scale=1.0" name="viewport"/><title>Functions · DataFrames.jl</title><link href="https://juliadata.github.io/DataFrames.jl/stable/lib/functions/index.html" rel="canonical"/><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script data-main="../assets/documenter.js" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/><script data-outdated-warner="">function maybeAddWarning () {
    const head = document.getElementsByTagName('head')[0];

    // Add a noindex meta tag (unless one exists) so that search engines don't index this version of the docs.
    if (document.body.querySelector('meta[name="robots"]') === null) {
        const meta = document.createElement('meta');
        meta.name = 'robots';
        meta.content = 'noindex';

        head.appendChild(meta);
    };

    // Add a stylesheet to avoid inline styling
    const style = document.createElement('style');
    style.type = 'text/css';
    style.appendChild(document.createTextNode('.outdated-warning-overlay {  position: fixed;  top: 0;  left: 0;  right: 0;  box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);  z-index: 999;  background-color: #ffaba7;  color: rgba(0, 0, 0, 0.7);  border-bottom: 3px solid #da0b00;  padding: 10px 35px;  text-align: center;  font-size: 15px; }  .outdated-warning-overlay .outdated-warning-closer {    position: absolute;    top: calc(50% - 10px);    right: 18px;    cursor: pointer;    width: 12px; }  .outdated-warning-overlay a {    color: #2e63b8; }    .outdated-warning-overlay a:hover {      color: #363636; }'));
    head.appendChild(style);

    const div = document.createElement('div');
    div.classList.add('outdated-warning-overlay');
    const closer = document.createElement('div');
    closer.classList.add('outdated-warning-closer');

    // Icon by font-awesome (license: https://fontawesome.com/license, link: https://fontawesome.com/icons/times?style=solid)
    closer.innerHTML = '<svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="times" class="svg-inline--fa fa-times fa-w-11" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 352 512"><path fill="currentColor" d="M242.72 256l100.07-100.07c12.28-12.28 12.28-32.19 0-44.48l-22.24-22.24c-12.28-12.28-32.19-12.28-44.48 0L176 189.28 75.93 89.21c-12.28-12.28-32.19-12.28-44.48 0L9.21 111.45c-12.28 12.28-12.28 32.19 0 44.48L109.28 256 9.21 356.07c-12.28 12.28-12.28 32.19 0 44.48l22.24 22.24c12.28 12.28 32.2 12.28 44.48 0L176 322.72l100.07 100.07c12.28 12.28 32.2 12.28 44.48 0l22.24-22.24c12.28-12.28 12.28-32.19 0-44.48L242.72 256z"></path></svg>';
    closer.addEventListener('click', function () {
        document.body.removeChild(div);
    });
    let href = '/stable';
    if (window.documenterBaseURL) {
        href = window.documenterBaseURL + '/../stable';
    }
    div.innerHTML = 'This is an old version of the documentation. <br> <a href="' + href + '">Go to the newest version</a>.';
    div.appendChild(closer);
    document.body.appendChild(div);
};

if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', maybeAddWarning);
} else {
    maybeAddWarning();
};
</script></head><body><nav class="toc"><a href="../index.html"><img alt="DataFrames.jl logo" class="logo" src="../assets/logo.png"/></a><h1>DataFrames.jl</h1><select id="version-selector" onchange="window.location.href=this.value" style="visibility: hidden"></select><form action="../search.html" class="search" id="search-form"><input id="search-query" name="q" placeholder="Search docs" type="text"/></form><ul><li><a class="toctext" href="../index.html">Introduction</a></li><li><span class="toctext">User Guide</span><ul><li><a class="toctext" href="../man/getting_started.html">Getting Started</a></li><li><a class="toctext" href="../man/joins.html">Joins</a></li><li><a class="toctext" href="../man/split_apply_combine.html">Split-apply-combine</a></li><li><a class="toctext" href="../man/reshaping_and_pivoting.html">Reshaping</a></li><li><a class="toctext" href="../man/sorting.html">Sorting</a></li><li><a class="toctext" href="../man/categorical.html">Categorical Data</a></li><li><a class="toctext" href="../man/missing.html">Missing Data</a></li><li><a class="toctext" href="../man/querying_frameworks.html">Querying frameworks</a></li></ul></li><li><span class="toctext">API</span><ul><li><a class="toctext" href="types.html">Types</a></li><li class="current"><a class="toctext" href="functions.html">Functions</a><ul class="internal"><li><a class="toctext" href="#Grouping,-Joining,-and-Split-Apply-Combine-1">Grouping, Joining, and Split-Apply-Combine</a></li><li><a class="toctext" href="#Basics-1">Basics</a></li></ul></li><li><a class="toctext" href="indexing.html">Indexing</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>API</li><li><a href="functions.html">Functions</a></li></ul><a class="edit-page" href="https://github.com/JuliaData/DataFrames.jl/blob/master/docs/src/lib/functions.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Functions</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" href="#Functions-1" id="Functions-1">Functions</a></h1><ul><li><a href="functions.html#Base.filter"><code>Base.filter</code></a></li><li><a href="functions.html#Base.filter!"><code>Base.filter!</code></a></li><li><a href="functions.html#Base.join"><code>Base.join</code></a></li><li><a href="functions.html#Base.map"><code>Base.map</code></a></li><li><a href="functions.html#Base.repeat"><code>Base.repeat</code></a></li><li><a href="functions.html#Base.show"><code>Base.show</code></a></li><li><a href="functions.html#Base.sort"><code>Base.sort</code></a></li><li><a href="functions.html#Base.sort!"><code>Base.sort!</code></a></li><li><a href="functions.html#Base.unique!"><code>Base.unique!</code></a></li><li><a href="functions.html#DataFrames.aggregate"><code>DataFrames.aggregate</code></a></li><li><a href="functions.html#DataFrames.allowmissing!"><code>DataFrames.allowmissing!</code></a></li><li><a href="functions.html#DataFrames.by"><code>DataFrames.by</code></a></li><li><a href="functions.html#DataFrames.colwise"><code>DataFrames.colwise</code></a></li><li><a href="functions.html#DataFrames.combine"><code>DataFrames.combine</code></a></li><li><a href="functions.html#DataFrames.completecases"><code>DataFrames.completecases</code></a></li><li><a href="functions.html#DataFrames.disallowmissing!"><code>DataFrames.disallowmissing!</code></a></li><li><a href="functions.html#DataFrames.dropmissing"><code>DataFrames.dropmissing</code></a></li><li><a href="functions.html#DataFrames.dropmissing!"><code>DataFrames.dropmissing!</code></a></li><li><a href="functions.html#DataFrames.eachcol"><code>DataFrames.eachcol</code></a></li><li><a href="functions.html#DataFrames.eachrow"><code>DataFrames.eachrow</code></a></li><li><a href="functions.html#DataFrames.eltypes"><code>DataFrames.eltypes</code></a></li><li><a href="functions.html#DataFrames.groupby"><code>DataFrames.groupby</code></a></li><li><a href="functions.html#DataFrames.insertcols!"><code>DataFrames.insertcols!</code></a></li><li><a href="functions.html#DataFrames.mapcols"><code>DataFrames.mapcols</code></a></li><li><a href="functions.html#DataFrames.melt"><code>DataFrames.melt</code></a></li><li><a href="functions.html#DataFrames.meltdf"><code>DataFrames.meltdf</code></a></li><li><a href="functions.html#DataFrames.names!"><code>DataFrames.names!</code></a></li><li><a href="functions.html#DataFrames.nonunique"><code>DataFrames.nonunique</code></a></li><li><a href="functions.html#DataFrames.permutecols!"><code>DataFrames.permutecols!</code></a></li><li><a href="functions.html#DataFrames.rename"><code>DataFrames.rename</code></a></li><li><a href="functions.html#DataFrames.rename!"><code>DataFrames.rename!</code></a></li><li><a href="functions.html#DataFrames.stack"><code>DataFrames.stack</code></a></li><li><a href="functions.html#DataFrames.stackdf"><code>DataFrames.stackdf</code></a></li><li><a href="functions.html#DataFrames.unstack"><code>DataFrames.unstack</code></a></li><li><a href="functions.html#StatsBase.describe"><code>StatsBase.describe</code></a></li></ul><h2><a class="nav-anchor" href="#Grouping,-Joining,-and-Split-Apply-Combine-1" id="Grouping,-Joining,-and-Split-Apply-Combine-1">Grouping, Joining, and Split-Apply-Combine</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#DataFrames.aggregate" id="DataFrames.aggregate"><code>DataFrames.aggregate</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Split-apply-combine that applies a set of functions over columns of an AbstractDataFrame or GroupedDataFrame</p><pre><code class="language-julia">aggregate(d::AbstractDataFrame, cols, fs)
aggregate(gd::GroupedDataFrame, fs)</code></pre><p><strong>Arguments</strong></p><ul><li><code>d</code> : an AbstractDataFrame</li><li><code>gd</code> : a GroupedDataFrame</li><li><code>cols</code> : a column indicator (Symbol, Int, Vector{Symbol}, etc.)</li><li><code>fs</code> : a function or vector of functions to be applied to vectors within groups; expects each argument to be a column vector</li></ul><p>Each <code>fs</code> should return a value or vector. All returns must be the same length.</p><p><strong>Returns</strong></p><ul><li><code>::DataFrame</code></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia">using Statistics
df = DataFrame(a = repeat([1, 2, 3, 4], outer=[2]),
               b = repeat([2, 1], outer=[4]),
               c = randn(8))
aggregate(df, :a, sum)
aggregate(df, :a, [sum, x-&gt;mean(skipmissing(x))])
aggregate(groupby(df, :a), [sum, x-&gt;mean(skipmissing(x))])</code></pre></div></div><a class="source-link" href="https://github.com/JuliaData/DataFrames.jl/blob/28e9336db50378d11cd5205a0faaa05ccbd5f5cc/src/groupeddataframe/grouping.jl#L799-L835" target="_blank">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#DataFrames.by" id="DataFrames.by"><code>DataFrames.by</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">by(d::AbstractDataFrame, keys, cols =&gt; f...; sort::Bool = false)
by(d::AbstractDataFrame, keys; (colname = cols =&gt; f)..., sort::Bool = false)
by(d::AbstractDataFrame, keys, f; sort::Bool = false)
by(f, d::AbstractDataFrame, keys; sort::Bool = false)</code></pre><p>Split-apply-combine in one step: apply <code>f</code> to each grouping in <code>d</code> based on grouping columns <code>keys</code>, and return a <code>DataFrame</code>.</p><p><code>keys</code> can be either a single column index, or a vector thereof.</p><p>If the last argument(s) consist(s) in one or more <code>cols =&gt; f</code> pair(s), or if <code>colname = cols =&gt; f</code> keyword arguments are provided, <code>cols</code> must be a column name or index, or a vector or tuple thereof, and <code>f</code> must be a callable. A pair or a (named) tuple of pairs can also be provided as the first or last argument. If <code>cols</code> is a single column index, <code>f</code> is called with a <code>SubArray</code> view into that column for each group; else, <code>f</code> is called with a named tuple holding <code>SubArray</code> views into these columns.</p><p>If the last argument is a callable <code>f</code>, it is passed a <code>SubDataFrame</code> view for each group, and the returned <code>DataFrame</code> then consists of the returned rows plus the grouping columns. Note that this second form is much slower than the first one due to type instability. A method is defined with <code>f</code> as the first argument, so do-block notation can be used.</p><p><code>f</code> can return a single value, a row or multiple rows. The type of the returned value determines the shape of the resulting data frame:</p><ul><li>A single value gives a data frame with a single column and one row per group.</li><li>A named tuple of single values or a <code>DataFrameRow</code> gives a data frame with one column for each field and one row per group.</li><li>A vector gives a data frame with a single column and as many rows for each group as the length of the returned vector for that group.</li><li>A data frame, a named tuple of vectors or a matrix gives a data frame with the same columns and as many rows for each group as the rows returned for that group.</li></ul><p>As a special case, if multiple pairs are passed as last arguments, each function is required to return a single value or vector, which will produce each a separate column.</p><p>In all cases, the resulting data frame contains all the grouping columns in addition to those listed above. Column names are automatically generated when necessary: for functions operating on a single column and returning a single value or vector, the function name is appended to the input colummn name; for other functions, columns are called <code>x1</code>, <code>x2</code> and so on.</p><p>Note that <code>f</code> must always return the same type of object for all groups, and (if a named tuple or data frame) with the same fields or columns. Due to type instability, returning a single value or a named tuple is dramatically faster than returning a data frame.</p><p>The resulting data frame will be sorted on <code>keys</code> if <code>sort=true</code>. Otherwise, ordering of rows is undefined.</p><p><code>by(d, cols, f)</code> is equivalent to <code>combine(f, groupby(d, cols))</code> and to the less efficient <code>combine(map(f, groupby(d, cols)))</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; df = DataFrame(a = repeat([1, 2, 3, 4], outer=[2]),
                      b = repeat([2, 1], outer=[4]),
                      c = 1:8);

julia&gt; by(df, :a, :c =&gt; sum)
4×2 DataFrame
│ Row │ a     │ c_sum │
│     │ Int64 │ Int64 │
├─────┼───────┼───────┤
│ 1   │ 1     │ 6     │
│ 2   │ 2     │ 8     │
│ 3   │ 3     │ 10    │
│ 4   │ 4     │ 12    │

julia&gt; by(df, :a, d -&gt; sum(d.c)) # Slower variant
4×2 DataFrame
│ Row │ a     │ x1    │
│     │ Int64 │ Int64 │
├─────┼───────┼───────┤
│ 1   │ 1     │ 6     │
│ 2   │ 2     │ 8     │
│ 3   │ 3     │ 10    │
│ 4   │ 4     │ 12    │

julia&gt; by(df, :a) do d # do syntax for the slower variant
           sum(d.c)
       end
4×2 DataFrame
│ Row │ a     │ x1    │
│     │ Int64 │ Int64 │
├─────┼───────┼───────┤
│ 1   │ 1     │ 6     │
│ 2   │ 2     │ 8     │
│ 3   │ 3     │ 10    │
│ 4   │ 4     │ 12    │

julia&gt; by(df, :a, :c =&gt; x -&gt; 2 .* x)
8×2 DataFrame
│ Row │ a     │ c_function │
│     │ Int64 │ Int64      │
├─────┼───────┼────────────┤
│ 1   │ 1     │ 2          │
│ 2   │ 1     │ 10         │
│ 3   │ 2     │ 4          │
│ 4   │ 2     │ 12         │
│ 5   │ 3     │ 6          │
│ 6   │ 3     │ 14         │
│ 7   │ 4     │ 8          │
│ 8   │ 4     │ 16         │

julia&gt; by(df, :a, c_sum = :c =&gt; sum, c_sum2 = :c =&gt; x -&gt; sum(x.^2))
4×3 DataFrame
│ Row │ a     │ c_sum │ c_sum2 │
│     │ Int64 │ Int64 │ Int64  │
├─────┼───────┼───────┼────────┤
│ 1   │ 1     │ 6     │ 26     │
│ 2   │ 2     │ 8     │ 40     │
│ 3   │ 3     │ 10    │ 58     │
│ 4   │ 4     │ 12    │ 80     │

julia&gt; by(df, :a, (:b, :c) =&gt; x -&gt; (minb = minimum(x.b), sumc = sum(x.c)))
4×3 DataFrame
│ Row │ a     │ minb  │ sumc  │
│     │ Int64 │ Int64 │ Int64 │
├─────┼───────┼───────┼───────┤
│ 1   │ 1     │ 2     │ 6     │
│ 2   │ 2     │ 1     │ 8     │
│ 3   │ 3     │ 2     │ 10    │
│ 4   │ 4     │ 1     │ 12    │</code></pre></div></div><a class="source-link" href="https://github.com/JuliaData/DataFrames.jl/blob/28e9336db50378d11cd5205a0faaa05ccbd5f5cc/src/groupeddataframe/grouping.jl#L653-L782" target="_blank">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#DataFrames.colwise" id="DataFrames.colwise"><code>DataFrames.colwise</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Apply a function to each column in an AbstractDataFrame or GroupedDataFrame</p><pre><code class="language-julia">colwise(f, d)</code></pre><p><strong>Arguments</strong></p><ul><li><code>f</code> : a function or vector of functions</li><li><code>d</code> : an AbstractDataFrame of GroupedDataFrame</li></ul><p><strong>Returns</strong></p><ul><li>various, depending on the call</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia">df = DataFrame(a = repeat([1, 2, 3, 4], outer=[2]),
               b = repeat([2, 1], outer=[4]),
               c = randn(8))
colwise(sum, df)
colwise([sum, length], df)
colwise((minimum, maximum), df)
colwise(sum, groupby(df, :a))</code></pre></div></div><a class="source-link" href="https://github.com/JuliaData/DataFrames.jl/blob/28e9336db50378d11cd5205a0faaa05ccbd5f5cc/src/groupeddataframe/grouping.jl#L617-L646" target="_blank">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#DataFrames.combine" id="DataFrames.combine"><code>DataFrames.combine</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">combine(gd::GroupedDataFrame)
combine(gd::GroupedDataFrame, cols =&gt; f...)
combine(gd::GroupedDataFrame; (colname = cols =&gt; f)...)
combine(gd::GroupedDataFrame, f)
combine(f, gd::GroupedDataFrame)</code></pre><p>Transform a <code>GroupedDataFrame</code> into a <code>DataFrame</code>.</p><p>If the last argument(s) consist(s) in one or more <code>cols =&gt; f</code> pair(s), or if <code>colname = cols =&gt; f</code> keyword arguments are provided, <code>cols</code> must be a column name or index, or a vector or tuple thereof, and <code>f</code> must be a callable. A pair or a (named) tuple of pairs can also be provided as the first or last argument. If <code>cols</code> is a single column index, <code>f</code> is called with a <code>SubArray</code> view into that column for each group; else, <code>f</code> is called with a named tuple holding <code>SubArray</code> views into these columns.</p><p>If the last argument is a callable <code>f</code>, it is passed a <code>SubDataFrame</code> view for each group, and the returned <code>DataFrame</code> then consists of the returned rows plus the grouping columns. Note that this second form is much slower than the first one due to type instability. A method is defined with <code>f</code> as the first argument, so do-block notation can be used.</p><p><code>f</code> can return a single value, a row or multiple rows. The type of the returned value determines the shape of the resulting data frame:</p><ul><li>A single value gives a data frame with a single column and one row per group.</li><li>A named tuple of single values or a <code>DataFrameRow</code> gives a data frame with one column for each field and one row per group.</li><li>A vector gives a data frame with a single column and as many rows for each group as the length of the returned vector for that group.</li><li>A data frame, a named tuple of vectors or a matrix gives a data frame with the same columns and as many rows for each group as the rows returned for that group.</li></ul><p>As a special case, if a tuple or vector of pairs is passed as the first argument, each function is required to return a single value or vector, which will produce each a separate column.</p><p>In all cases, the resulting data frame contains all the grouping columns in addition to those listed above. Column names are automatically generated when necessary: for functions operating on a single column and returning a single value or vector, the function name is appended to the input column name; for other functions, columns are called <code>x1</code>, <code>x2</code> and so on.</p><p>Note that <code>f</code> must always return the same type of object for all groups, and (if a named tuple or data frame) with the same fields or columns. Due to type instability, returning a single value or a named tuple is dramatically faster than returning a data frame.</p><p>The resulting data frame will be sorted if <code>sort=true</code> was passed to the <a href="functions.html#DataFrames.groupby"><code>groupby</code></a> call from which <code>gd</code> was constructed. Otherwise, ordering of rows is undefined.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; df = DataFrame(a = repeat([1, 2, 3, 4], outer=[2]),
                      b = repeat([2, 1], outer=[4]),
                      c = 1:8);

julia&gt; gd = groupby(df, :a);

julia&gt; combine(gd, :c =&gt; sum)
4×2 DataFrame
│ Row │ a     │ c_sum │
│     │ Int64 │ Int64 │
├─────┼───────┼───────┤
│ 1   │ 1     │ 6     │
│ 2   │ 2     │ 8     │
│ 3   │ 3     │ 10    │
│ 4   │ 4     │ 12    │

julia&gt; combine(:c =&gt; sum, gd)
4×2 DataFrame
│ Row │ a     │ c_sum │
│     │ Int64 │ Int64 │
├─────┼───────┼───────┤
│ 1   │ 1     │ 6     │
│ 2   │ 2     │ 8     │
│ 3   │ 3     │ 10    │
│ 4   │ 4     │ 12    │

julia&gt; combine(df -&gt; sum(df.c), gd) # Slower variant
4×2 DataFrame
│ Row │ a     │ x1    │
│     │ Int64 │ Int64 │
├─────┼───────┼───────┤
│ 1   │ 1     │ 6     │
│ 2   │ 2     │ 8     │
│ 3   │ 3     │ 10    │
│ 4   │ 4     │ 12    │</code></pre><p>See <a href="functions.html#DataFrames.by"><code>by</code></a> for more examples.</p><p><strong>See also</strong></p><p><a href="functions.html#DataFrames.by"><code>by(f, df, cols)</code></a> is a shorthand for <code>combine(f, groupby(df, cols))</code>.</p><p><a href="functions.html#Base.map"><code>map</code></a>: <code>combine(f, groupby(df, cols))</code> is a more efficient equivalent of <code>combine(map(f, groupby(df, cols)))</code>.</p></div></div><a class="source-link" href="https://github.com/JuliaData/DataFrames.jl/blob/28e9336db50378d11cd5205a0faaa05ccbd5f5cc/src/groupeddataframe/grouping.jl#L232-L331" target="_blank">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#DataFrames.groupby" id="DataFrames.groupby"><code>DataFrames.groupby</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>A view of an AbstractDataFrame split into row groups</p><pre><code class="language-julia">groupby(d::AbstractDataFrame, cols; sort = false, skipmissing = false)
groupby(cols; sort = false, skipmissing = false)</code></pre><p><strong>Arguments</strong></p><ul><li><code>d</code> : an AbstractDataFrame to split (optional, see <a href="#returns">Returns</a>)</li><li><code>cols</code> : data table columns to group by</li><li><code>sort</code>: whether to sort rows according to the values of the grouping columns <code>cols</code></li><li><code>skipmissing</code>: whether to skip rows with <code>missing</code> values in one of the grouping columns <code>cols</code></li></ul><p><strong>Returns</strong></p><p>A <code>GroupedDataFrame</code> : a grouped view into <code>d</code></p><p><strong>Details</strong></p><p>An iterator over a <code>GroupedDataFrame</code> returns a <code>SubDataFrame</code> view for each grouping into <code>d</code>. A <code>GroupedDataFrame</code> also supports indexing by groups, <code>map</code> (which applies a function to each group) and <code>combine</code> (which applies a function to each group and combines the result into a data frame).</p><p>See the following for additional split-apply-combine operations:</p><ul><li><code>by</code> : split-apply-combine using functions</li><li><code>aggregate</code> : split-apply-combine; applies functions in the form of a cross product</li><li><code>colwise</code> : apply a function to each column in an <code>AbstractDataFrame</code> or <code>GroupedDataFrame</code></li><li><code>map</code> : apply a function to each group of a <code>GroupedDataFrame</code> (without combining)</li><li><code>combine</code> : combine a <code>GroupedDataFrame</code>, optionally applying a function to each group</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia">df = DataFrame(a = repeat([1, 2, 3, 4], outer=[2]),
               b = repeat([2, 1], outer=[4]),
               c = randn(8))
gd = groupby(df, :a)
gd[1]
last(gd)
vcat([g[:b] for g in gd]...)
for g in gd
    println(g)
end</code></pre></div></div><a class="source-link" href="https://github.com/JuliaData/DataFrames.jl/blob/28e9336db50378d11cd5205a0faaa05ccbd5f5cc/src/groupeddataframe/grouping.jl#L21-L71" target="_blank">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#Base.join" id="Base.join"><code>Base.join</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">join(df1, df2; on = Symbol[], kind = :inner, makeunique = false,
     indicator = nothing, validate = (false, false))</code></pre><p>Join two <code>DataFrame</code> objects</p><p><strong>Arguments</strong></p><ul><li><code>df1</code>, <code>df2</code> : the two AbstractDataFrames to be joined</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><p><code>on</code> : A column, or vector of columns to join df1 and df2 on. If the column(s)   that df1 and df2 will be joined on have different names, then the columns   should be <code>(left, right)</code> tuples or <code>left =&gt; right</code> pairs, or a vector of   such tuples or pairs. <code>on</code> is a required argument for all joins except for   <code>kind = :cross</code></p></li><li><p><code>kind</code> : the type of join, options include:</p><ul><li><code>:inner</code> : only include rows with keys that match in both <code>df1</code> and <code>df2</code>, the default</li><li><code>:outer</code> : include all rows from <code>df1</code> and <code>df2</code></li><li><code>:left</code> : include all rows from <code>df1</code></li><li><code>:right</code> : include all rows from <code>df2</code></li><li><code>:semi</code> : return rows of <code>df1</code> that match with the keys in <code>df2</code></li><li><code>:anti</code> : return rows of <code>df1</code> that do not match with the keys in <code>df2</code></li><li><code>:cross</code> : a full Cartesian product of the key combinations; every row of <code>df1</code> is matched with every row of <code>df2</code></li></ul></li></ul><ul><li><p><code>makeunique</code> : if <code>false</code> (the default), an error will be raised if duplicate names are found in columns not joined on; if <code>true</code>, duplicate names will be suffixed with <code>_i</code> (<code>i</code> starting at 1 for the first duplicate).</p></li><li><p><code>indicator</code> : Default: <code>nothing</code>. If a <code>Symbol</code>, adds categorical indicator  column named <code>Symbol</code> for whether a row appeared in only <code>df1</code> (<code>"left_only"</code>),  only <code>df2</code> (<code>"right_only"</code>) or in both (<code>"both"</code>). If <code>Symbol</code> is already in use,  the column name will be modified if <code>makeunique=true</code>.</p></li><li><p><code>validate</code> : whether to check that columns passed as the <code>on</code> argument  define unique keys in each input data frame (according to <a href="lib/@ref"><code>isequal</code></a>).  Can be a tuple or a pair, with the first element indicating whether to  run check for <code>df1</code> and the second element for <code>df2</code>.  By default no check is performed.</p></li></ul><p>For the three join operations that may introduce missing values (<code>:outer</code>, <code>:left</code>, and <code>:right</code>), all columns of the returned data table will support missing values.</p><p>When merging <code>on</code> categorical columns that differ in the ordering of their levels, the ordering of the left <code>DataFrame</code> takes precedence over the ordering of the right <code>DataFrame</code></p><p><strong>Result</strong></p><ul><li><code>::DataFrame</code> : the joined DataFrame</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia">name = DataFrame(ID = [1, 2, 3], Name = ["John Doe", "Jane Doe", "Joe Blogs"])
job = DataFrame(ID = [1, 2, 4], Job = ["Lawyer", "Doctor", "Farmer"])

join(name, job, on = :ID)
join(name, job, on = :ID, kind = :outer)
join(name, job, on = :ID, kind = :left)
join(name, job, on = :ID, kind = :right)
join(name, job, on = :ID, kind = :semi)
join(name, job, on = :ID, kind = :anti)
join(name, job, kind = :cross)

job2 = DataFrame(identifier = [1, 2, 4], Job = ["Lawyer", "Doctor", "Farmer"])
join(name, job2, on = (:ID, :identifier))
join(name, job2, on = :ID =&gt; :identifier)</code></pre></div></div><a class="source-link" href="https://github.com/JuliaData/DataFrames.jl/blob/28e9336db50378d11cd5205a0faaa05ccbd5f5cc/src/abstractdataframe/join.jl#L215-L291" target="_blank">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#Base.map" id="Base.map"><code>Base.map</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">map(cols =&gt; f, gd::GroupedDataFrame)
map(f, gd::GroupedDataFrame)</code></pre><p>Apply a function to each group of rows and return a <code>GroupedDataFrame</code>.</p><p>If the first argument is a <code>cols =&gt; f</code> pair, <code>cols</code> must be a column name or index, or a vector or tuple thereof, and <code>f</code> must be a callable. If <code>cols</code> is a single column index, <code>f</code> is called with a <code>SubArray</code> view into that column for each group; else, <code>f</code> is called with a named tuple holding <code>SubArray</code> views into these columns.</p><p>If the first argument is a vector, tuple or named tuple of such pairs, each pair is handled as described above. If a named tuple, field names are used to name each generated column.</p><p>If the first argument is a callable, it is passed a <code>SubDataFrame</code> view for each group, and the returned <code>DataFrame</code> then consists of the returned rows plus the grouping columns. Note that this second form is much slower than the first one due to type instability.</p><p><code>f</code> can return a single value, a row or multiple rows. The type of the returned value determines the shape of the resulting data frame:</p><ul><li>A single value gives a data frame with a single column and one row per group.</li><li>A named tuple of single values or a <code>DataFrameRow</code> gives a data frame with one column for each field and one row per group.</li><li>A vector gives a data frame with a single column and as many rows for each group as the length of the returned vector for that group.</li><li>A data frame, a named tuple of vectors or a matrix gives a data frame with the same columns and as many rows for each group as the rows returned for that group.</li></ul><p>As a special case, if a tuple or vector of pairs is passed as the first argument, each function is required to return a single value or vector, which will produce each a separate column.</p><p>In all cases, the resulting <code>GroupedDataFrame</code> contains all the grouping columns in addition to those listed above. Column names are automatically generated when necessary: for functions operating on a single column and returning a single value or vector, the function name is appended to the input column name; for other functions, columns are called <code>x1</code>, <code>x2</code> and so on.</p><p>Note that <code>f</code> must always return the same type of object for all groups, and (if a named tuple or data frame) with the same fields or columns. Due to type instability, returning a single value or a named tuple is dramatically faster than returning a data frame.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; df = DataFrame(a = repeat([1, 2, 3, 4], outer=[2]),
                      b = repeat([2, 1], outer=[4]),
                      c = 1:8);

julia&gt; gd = groupby(df, :a);

julia&gt; map(:c =&gt; sum, gd)
GroupedDataFrame{DataFrame} with 4 groups based on key: :a
First Group: 1 row
│ Row │ a     │ c_sum │
│     │ Int64 │ Int64 │
├─────┼───────┼───────┤
│ 1   │ 1     │ 6     │
⋮
Last Group: 1 row
│ Row │ a     │ c_sum │
│     │ Int64 │ Int64 │
├─────┼───────┼───────┤
│ 1   │ 4     │ 12    │

julia&gt; map(df -&gt; sum(df.c), gd) # Slower variant
GroupedDataFrame{DataFrame} with 4 groups based on key: :a
First Group: 1 row
│ Row │ a     │ x1    │
│     │ Int64 │ Int64 │
├─────┼───────┼───────┤
│ 1   │ 1     │ 6     │
⋮
Last Group: 1 row
│ Row │ a     │ x1    │
│     │ Int64 │ Int64 │
├─────┼───────┼───────┤
│ 1   │ 4     │ 12    │</code></pre><p>See <a href="functions.html#DataFrames.by"><code>by</code></a> for more examples.</p><p><strong>See also</strong></p><p><code>combine(f, gd)</code> returns a <code>DataFrame</code> rather than a <code>GroupedDataFrame</code></p></div></div><a class="source-link" href="https://github.com/JuliaData/DataFrames.jl/blob/28e9336db50378d11cd5205a0faaa05ccbd5f5cc/src/groupeddataframe/grouping.jl#L119-L206" target="_blank">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#DataFrames.melt" id="DataFrames.melt"><code>DataFrames.melt</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Stacks a DataFrame; convert from a wide to long format; see <code>stack</code>.</p></div></div><a class="source-link" href="https://github.com/JuliaData/DataFrames.jl/blob/28e9336db50378d11cd5205a0faaa05ccbd5f5cc/src/abstractdataframe/reshape.jl#L121-L124" target="_blank">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#DataFrames.stack" id="DataFrames.stack"><code>DataFrames.stack</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Stacks a DataFrame; convert from a wide to long format</p><pre><code class="language-julia">stack(df::AbstractDataFrame, [measure_vars], [id_vars];
      variable_name::Symbol=:variable, value_name::Symbol=:value)
melt(df::AbstractDataFrame, [id_vars], [measure_vars];
     variable_name::Symbol=:variable, value_name::Symbol=:value)</code></pre><p><strong>Arguments</strong></p><ul><li><p><code>df</code> : the AbstractDataFrame to be stacked</p></li><li><p><code>measure_vars</code> : the columns to be stacked (the measurement variables), a normal column indexing type, like a Symbol, Vector{Symbol}, Int, etc.; for <code>melt</code>, defaults to all variables that are not <code>id_vars</code>. If neither <code>measure_vars</code> or <code>id_vars</code> are given, <code>measure_vars</code> defaults to all floating point columns.</p></li><li><p><code>id_vars</code> : the identifier columns that are repeated during stacking, a normal column indexing type; for <code>stack</code> defaults to all variables that are not <code>measure_vars</code></p></li><li><p><code>variable_name</code> : the name of the new stacked column that shall hold the names of each of <code>measure_vars</code></p></li><li><p><code>value_name</code> : the name of the new stacked column containing the values from each of <code>measure_vars</code></p></li></ul><p><strong>Result</strong></p><ul><li><code>::DataFrame</code> : the long-format DataFrame with column <code>:value</code> holding the values of the stacked columns (<code>measure_vars</code>), with column <code>:variable</code> a Vector of Symbols with the <code>measure_vars</code> name, and with columns for each of the <code>id_vars</code>.</li></ul><p>See also <code>stackdf</code> and <code>meltdf</code> for stacking methods that return a view into the original DataFrame. See <code>unstack</code> for converting from long to wide format.</p><p><strong>Examples</strong></p><pre><code class="language-julia">d1 = DataFrame(a = repeat([1:3;], inner = [4]),
               b = repeat([1:4;], inner = [3]),
               c = randn(12),
               d = randn(12),
               e = map(string, 'a':'l'))

d1s = stack(d1, [:c, :d])
d1s2 = stack(d1, [:c, :d], [:a])
d1m = melt(d1, [:a, :b, :e])
d1s_name = melt(d1, [:a, :b, :e], variable_name=:somemeasure)</code></pre></div></div><a class="source-link" href="https://github.com/JuliaData/DataFrames.jl/blob/28e9336db50378d11cd5205a0faaa05ccbd5f5cc/src/abstractdataframe/reshape.jl#L16-L76" target="_blank">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#DataFrames.unstack" id="DataFrames.unstack"><code>DataFrames.unstack</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Unstacks a DataFrame; convert from a long to wide format</p><pre><code class="language-julia">unstack(df::AbstractDataFrame, rowkeys::Union{Symbol, Integer},
        colkey::Union{Symbol, Integer}, value::Union{Symbol, Integer})
unstack(df::AbstractDataFrame, rowkeys::AbstractVector{&lt;:Union{Symbol, Integer}},
        colkey::Union{Symbol, Integer}, value::Union{Symbol, Integer})
unstack(df::AbstractDataFrame, colkey::Union{Symbol, Integer},
        value::Union{Symbol, Integer})
unstack(df::AbstractDataFrame)</code></pre><p><strong>Arguments</strong></p><ul><li><p><code>df</code> : the AbstractDataFrame to be unstacked</p></li><li><p><code>rowkeys</code> : the column(s) with a unique key for each row, if not given, find a key by grouping on anything not a <code>colkey</code> or <code>value</code></p></li><li><p><code>colkey</code> : the column holding the column names in wide format, defaults to <code>:variable</code></p></li><li><p><code>value</code> : the value column, defaults to <code>:value</code></p></li></ul><p><strong>Result</strong></p><ul><li><code>::DataFrame</code> : the wide-format DataFrame</li></ul><p>If <code>colkey</code> contains <code>missing</code> values then they will be skipped and a warning will be printed.</p><p>If combination of <code>rowkeys</code> and <code>colkey</code> contains duplicate entries then last <code>value</code> will be retained and a warning will be printed.</p><p><strong>Examples</strong></p><pre><code class="language-julia">wide = DataFrame(id = 1:12,
                 a  = repeat([1:3;], inner = [4]),
                 b  = repeat([1:4;], inner = [3]),
                 c  = randn(12),
                 d  = randn(12))

long = stack(wide)
wide0 = unstack(long)
wide1 = unstack(long, :variable, :value)
wide2 = unstack(long, :id, :variable, :value)
wide3 = unstack(long, [:id, :a], :variable, :value)</code></pre><p>Note that there are some differences between the widened results above.</p></div></div><a class="source-link" href="https://github.com/JuliaData/DataFrames.jl/blob/28e9336db50378d11cd5205a0faaa05ccbd5f5cc/src/abstractdataframe/reshape.jl#L149-L199" target="_blank">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#DataFrames.stackdf" id="DataFrames.stackdf"><code>DataFrames.stackdf</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>A stacked view of a DataFrame (long format)</p><p>Like <code>stack</code> and <code>melt</code>, but a view is returned rather than data copies.</p><pre><code class="language-julia">stackdf(df::AbstractDataFrame, [measure_vars], [id_vars];
        variable_name::Symbol=:variable, value_name::Symbol=:value)
meltdf(df::AbstractDataFrame, [id_vars], [measure_vars];
       variable_name::Symbol=:variable, value_name::Symbol=:value)</code></pre><p><strong>Arguments</strong></p><ul><li><p><code>df</code> : the wide AbstractDataFrame</p></li><li><p><code>measure_vars</code> : the columns to be stacked (the measurement variables), a normal column indexing type, like a Symbol, Vector{Symbol}, Int, etc.; for <code>melt</code>, defaults to all variables that are not <code>id_vars</code></p></li><li><p><code>id_vars</code> : the identifier columns that are repeated during stacking, a normal column indexing type; for <code>stack</code> defaults to all variables that are not <code>measure_vars</code></p></li></ul><p><strong>Result</strong></p><ul><li><code>::DataFrame</code> : the long-format DataFrame with column <code>:value</code> holding the values of the stacked columns (<code>measure_vars</code>), with column <code>:variable</code> a Vector of Symbols with the <code>measure_vars</code> name, and with columns for each of the <code>id_vars</code>.</li></ul><p>The result is a view because the columns are special AbstractVectors that return indexed views into the original DataFrame.</p><p><strong>Examples</strong></p><pre><code class="language-julia">d1 = DataFrame(a = repeat([1:3;], inner = [4]),
               b = repeat([1:4;], inner = [3]),
               c = randn(12),
               d = randn(12),
               e = map(string, 'a':'l'))

d1s = stackdf(d1, [:c, :d])
d1s2 = stackdf(d1, [:c, :d], [:a])
d1m = meltdf(d1, [:a, :b, :e])</code></pre></div></div><a class="source-link" href="https://github.com/JuliaData/DataFrames.jl/blob/28e9336db50378d11cd5205a0faaa05ccbd5f5cc/src/abstractdataframe/reshape.jl#L460-L510" target="_blank">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#DataFrames.meltdf" id="DataFrames.meltdf"><code>DataFrames.meltdf</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>A stacked view of a DataFrame (long format); see <code>stackdf</code></p></div></div><a class="source-link" href="https://github.com/JuliaData/DataFrames.jl/blob/28e9336db50378d11cd5205a0faaa05ccbd5f5cc/src/abstractdataframe/reshape.jl#L550-L552" target="_blank">source</a></section><h2><a class="nav-anchor" href="#Basics-1" id="Basics-1">Basics</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#DataFrames.allowmissing!" id="DataFrames.allowmissing!"><code>DataFrames.allowmissing!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">allowmissing!(df::DataFrame)</code></pre><p>Convert all columns of a <code>df</code> from element type <code>T</code> to <code>Union{T, Missing}</code> to support missing values.</p><pre><code class="language-none">allowmissing!(df::DataFrame, col::Union{Integer, Symbol})</code></pre><p>Convert a single column of a <code>df</code> from element type <code>T</code> to <code>Union{T, Missing}</code> to support missing values.</p><pre><code class="language-none">allowmissing!(df::DataFrame, cols::AbstractVector{&lt;:Union{Integer, Symbol}})</code></pre><p>Convert multiple columns of a <code>df</code> from element type <code>T</code> to <code>Union{T, Missing}</code> to support missing values.</p></div></div><a class="source-link" href="https://github.com/JuliaData/DataFrames.jl/blob/28e9336db50378d11cd5205a0faaa05ccbd5f5cc/src/dataframe/dataframe.jl#L863-L878" target="_blank">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#DataFrames.completecases" id="DataFrames.completecases"><code>DataFrames.completecases</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">completecases(df::AbstractDataFrame)
completecases(df::AbstractDataFrame, cols::AbstractVector)
completecases(df::AbstractDataFrame, cols::Union{Integer, Symbol})</code></pre><p>Return a Boolean vector with <code>true</code> entries indicating rows without missing values (complete cases) in data frame <code>df</code>. If <code>cols</code> is provided, only missing values in the corresponding columns are considered.</p><p>See also: <a href="functions.html#DataFrames.dropmissing"><code>dropmissing</code></a> and <a href="functions.html#DataFrames.dropmissing!"><code>dropmissing!</code></a>. Use <code>findall(completecases(df))</code> to get the indices of the rows.</p><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; df = DataFrame(i = 1:5,
                      x = [missing, 4, missing, 2, 1],
                      y = [missing, missing, "c", "d", "e"])
5×3 DataFrame
│ Row │ i     │ x       │ y       │
│     │ Int64 │ Int64⍰  │ String⍰ │
├─────┼───────┼─────────┼─────────┤
│ 1   │ 1     │ missing │ missing │
│ 2   │ 2     │ 4       │ missing │
│ 3   │ 3     │ missing │ c       │
│ 4   │ 4     │ 2       │ d       │
│ 5   │ 5     │ 1       │ e       │

julia&gt; completecases(df)
5-element BitArray{1}:
 false
 false
 false
  true
  true

julia&gt; completecases(df, :x)
5-element BitArray{1}:
 false
  true
 false
  true
  true

julia&gt; completecases(df, [:x, :y])
5-element BitArray{1}:
 false
 false
 false
  true
  true</code></pre></div></div><a class="source-link" href="https://github.com/JuliaData/DataFrames.jl/blob/28e9336db50378d11cd5205a0faaa05ccbd5f5cc/src/abstractdataframe/abstractdataframe.jl#L524-L577" target="_blank">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#StatsBase.describe" id="StatsBase.describe"><code>StatsBase.describe</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Report descriptive statistics for a data frame</p><pre><code class="language-julia">describe(df::AbstractDataFrame; stats = [:mean, :min, :median, :max, :nmissing, :nunique, :eltype])</code></pre><p><strong>Arguments</strong></p><ul><li><code>df</code> : the AbstractDataFrame</li><li><code>stats::Union{Symbol,AbstractVector{Symbol}}</code> : the summary statistics to report. If a vector, allowed fields are <code>:mean</code>, <code>:std</code>, <code>:min</code>, <code>:q25</code>, <code>:median</code>, <code>:q75</code>, <code>:max</code>, <code>:eltype</code>, <code>:nunique</code>, <code>:first</code>, <code>:last</code>, and <code>:nmissing</code>. If set to <code>:all</code>, all summary statistics are reported.</li></ul><p><strong>Result</strong></p><ul><li>A <code>DataFrame</code> where each row represents a variable and each column a summary statistic.</li></ul><p><strong>Details</strong></p><p>For <code>Real</code> columns, compute the mean, standard deviation, minimum, first quantile, median, third quantile, and maximum. If a column does not derive from <code>Real</code>, <code>describe</code> will attempt to calculate all statistics, using <code>nothing</code> as a fall-back in the case of an error.</p><p>When <code>stats</code> contains <code>:nunique</code>, <code>describe</code> will report the number of unique values in a column. If a column's base type derives from <code>Real</code>, <code>:nunique</code> will return <code>nothing</code>s.</p><p>Missing values are filtered in the calculation of all statistics, however the column <code>:nmissing</code> will report the number of missing values of that variable. If the column does not allow missing values, <code>nothing</code> is returned. Consequently, <code>nmissing = 0</code> indicates that the column allows missing values, but does not currently contain any.</p><p><strong>Examples</strong></p><pre><code class="language-julia">df = DataFrame(i = 1:10, x = rand(10), y = rand(["a", "b", "c"], 10))
describe(df)
describe(df, stats = :all)
describe(df, stats = [:min, :max])</code></pre></div></div><a class="source-link" href="https://github.com/JuliaData/DataFrames.jl/blob/28e9336db50378d11cd5205a0faaa05ccbd5f5cc/src/abstractdataframe/abstractdataframe.jl#L359-L403" target="_blank">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#DataFrames.disallowmissing!" id="DataFrames.disallowmissing!"><code>DataFrames.disallowmissing!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">disallowmissing!(df::DataFrame)</code></pre><p>Convert all columns of a <code>df</code> from element type <code>Union{T, Missing}</code> to <code>T</code> to drop support for missing values.</p><pre><code class="language-none">disallowmissing!(df::DataFrame, col::Union{Integer, Symbol})</code></pre><p>Convert a single column of a <code>df</code> from element type <code>Union{T, Missing}</code> to <code>T</code> to drop support for missing values.</p><pre><code class="language-none">disallowmissing!(df::DataFrame, cols::AbstractVector{&lt;:Union{Integer, Symbol}})</code></pre><p>Convert multiple columns of a <code>df</code> from element type <code>Union{T, Missing}</code> to <code>T</code> to drop support for missing values.</p></div></div><a class="source-link" href="https://github.com/JuliaData/DataFrames.jl/blob/28e9336db50378d11cd5205a0faaa05ccbd5f5cc/src/dataframe/dataframe.jl#L893-L908" target="_blank">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#DataFrames.dropmissing" id="DataFrames.dropmissing"><code>DataFrames.dropmissing</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">dropmissing(df::AbstractDataFrame)
dropmissing(df::AbstractDataFrame, cols::AbstractVector)
dropmissing(df::AbstractDataFrame, cols::Union{Integer, Symbol})</code></pre><p>Return a copy of data frame <code>df</code> excluding rows with missing values. If <code>cols</code> is provided, only missing values in the corresponding columns are considered.</p><p>See also: <a href="functions.html#DataFrames.completecases"><code>completecases</code></a> and <a href="functions.html#DataFrames.dropmissing!"><code>dropmissing!</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; df = DataFrame(i = 1:5,
                      x = [missing, 4, missing, 2, 1],
                      y = [missing, missing, "c", "d", "e"])
5×3 DataFrame
│ Row │ i     │ x       │ y       │
│     │ Int64 │ Int64⍰  │ String⍰ │
├─────┼───────┼─────────┼─────────┤
│ 1   │ 1     │ missing │ missing │
│ 2   │ 2     │ 4       │ missing │
│ 3   │ 3     │ missing │ c       │
│ 4   │ 4     │ 2       │ d       │
│ 5   │ 5     │ 1       │ e       │

julia&gt; dropmissing(df)
2×3 DataFrame
│ Row │ i     │ x      │ y       │
│     │ Int64 │ Int64⍰ │ String⍰ │
├─────┼───────┼────────┼─────────┤
│ 1   │ 4     │ 2      │ d       │
│ 2   │ 5     │ 1      │ e       │

julia&gt; dropmissing(df, :x)
3×3 DataFrame
│ Row │ i     │ x      │ y       │
│     │ Int64 │ Int64⍰ │ String⍰ │
├─────┼───────┼────────┼─────────┤
│ 1   │ 2     │ 4      │ missing │
│ 2   │ 4     │ 2      │ d       │
│ 3   │ 5     │ 1      │ e       │

julia&gt; dropmissing(df, [:x, :y])
2×3 DataFrame
│ Row │ i     │ x      │ y       │
│     │ Int64 │ Int64⍰ │ String⍰ │
├─────┼───────┼────────┼─────────┤
│ 1   │ 4     │ 2      │ d       │
│ 2   │ 5     │ 1      │ e       │</code></pre></div></div><a class="source-link" href="https://github.com/JuliaData/DataFrames.jl/blob/28e9336db50378d11cd5205a0faaa05ccbd5f5cc/src/abstractdataframe/abstractdataframe.jl#L595-L647" target="_blank">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#DataFrames.dropmissing!" id="DataFrames.dropmissing!"><code>DataFrames.dropmissing!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">dropmissing!(df::AbstractDataFrame)
dropmissing!(df::AbstractDataFrame, cols::AbstractVector)
dropmissing!(df::AbstractDataFrame, cols::Union{Integer, Symbol})</code></pre><p>Remove rows with missing values from data frame <code>df</code> and return it. If <code>cols</code> is provided, only missing values in the corresponding columns are considered.</p><p>See also: <a href="functions.html#DataFrames.dropmissing"><code>dropmissing</code></a> and <a href="functions.html#DataFrames.completecases"><code>completecases</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; df = DataFrame(i = 1:5,
                      x = [missing, 4, missing, 2, 1],
                      y = [missing, missing, "c", "d", "e"])
5×3 DataFrame
│ Row │ i     │ x       │ y       │
│     │ Int64 │ Int64⍰  │ String⍰ │
├─────┼───────┼─────────┼─────────┤
│ 1   │ 1     │ missing │ missing │
│ 2   │ 2     │ 4       │ missing │
│ 3   │ 3     │ missing │ c       │
│ 4   │ 4     │ 2       │ d       │
│ 5   │ 5     │ 1       │ e       │

julia&gt; df1 = copy(df);

julia&gt; dropmissing!(df1);

julia&gt; df1
2×3 DataFrame
│ Row │ i     │ x      │ y       │
│     │ Int64 │ Int64⍰ │ String⍰ │
├─────┼───────┼────────┼─────────┤
│ 1   │ 4     │ 2      │ d       │
│ 2   │ 5     │ 1      │ e       │

julia&gt; df2 = copy(df);

julia&gt; dropmissing!(df2, :x);

julia&gt; df2
3×3 DataFrame
│ Row │ i     │ x      │ y       │
│     │ Int64 │ Int64⍰ │ String⍰ │
├─────┼───────┼────────┼─────────┤
│ 1   │ 2     │ 4      │ missing │
│ 2   │ 4     │ 2      │ d       │
│ 3   │ 5     │ 1      │ e       │

julia&gt; df3 = copy(df);

julia&gt; dropmissing!(df3, [:x, :y]);


julia&gt; df3
2×3 DataFrame
│ Row │ i     │ x      │ y       │
│     │ Int64 │ Int64⍰ │ String⍰ │
├─────┼───────┼────────┼─────────┤
│ 1   │ 4     │ 2      │ d       │
│ 2   │ 5     │ 1      │ e       │</code></pre></div></div><a class="source-link" href="https://github.com/JuliaData/DataFrames.jl/blob/28e9336db50378d11cd5205a0faaa05ccbd5f5cc/src/abstractdataframe/abstractdataframe.jl#L652-L717" target="_blank">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#DataFrames.eachrow" id="DataFrames.eachrow"><code>DataFrames.eachrow</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">eachrow(df::AbstractDataFrame)</code></pre><p>Return a <code>DataFrameRows</code> that iterates an <code>AbstractDataFrame</code> row by row, with each row represented as a <code>DataFrameRow</code>.</p></div></div><a class="source-link" href="https://github.com/JuliaData/DataFrames.jl/blob/28e9336db50378d11cd5205a0faaa05ccbd5f5cc/src/abstractdataframe/iteration.jl#L22-L27" target="_blank">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#DataFrames.eachcol" id="DataFrames.eachcol"><code>DataFrames.eachcol</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">eachcol(df::AbstractDataFrame, names::Bool=true)</code></pre><p>Return a <code>DataFrameColumns</code> that iterates an <code>AbstractDataFrame</code> column by column. If <code>names</code> is equal to <code>true</code> (currently the default, in the future the default will be set to <code>false</code>) iteration returns a pair consisting of column name and column vector. If <code>names</code> is equal to <code>false</code> then column vectors are yielded.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; df = DataFrame(x=1:4, y=11:14)
4×2 DataFrame
│ Row │ x     │ y     │
│     │ Int64 │ Int64 │
├─────┼───────┼───────┤
│ 1   │ 1     │ 11    │
│ 2   │ 2     │ 12    │
│ 3   │ 3     │ 13    │
│ 4   │ 4     │ 14    │

julia&gt; collect(eachcol(df, true))
2-element Array{Pair{Symbol,AbstractArray{T,1} where T},1}:
 :x =&gt; [1, 2, 3, 4]
 :y =&gt; [11, 12, 13, 14]

julia&gt; collect(eachcol(df, false))
2-element Array{AbstractArray{T,1} where T,1}:
 [1, 2, 3, 4]
 [11, 12, 13, 14]

julia&gt; sum.(eachcol(df, false))
2-element Array{Int64,1}:
 10
 50

julia&gt; map(eachcol(df, false)) do col
           maximum(col) - minimum(col)
       end
2-element Array{Int64,1}:
 3
 3</code></pre></div></div><a class="source-link" href="https://github.com/JuliaData/DataFrames.jl/blob/28e9336db50378d11cd5205a0faaa05ccbd5f5cc/src/abstractdataframe/iteration.jl#L51-L95" target="_blank">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#DataFrames.eltypes" id="DataFrames.eltypes"><code>DataFrames.eltypes</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Return element types of columns</p><pre><code class="language-julia">eltypes(df::AbstractDataFrame)</code></pre><p><strong>Arguments</strong></p><ul><li><code>df</code> : the AbstractDataFrame</li></ul><p><strong>Result</strong></p><ul><li><code>::Vector{Type}</code> : the element type of each column</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia">df = DataFrame(i = 1:10, x = rand(10), y = rand(["a", "b", "c"], 10))
eltypes(df)</code></pre></div></div><a class="source-link" href="https://github.com/JuliaData/DataFrames.jl/blob/28e9336db50378d11cd5205a0faaa05ccbd5f5cc/src/abstractdataframe/abstractdataframe.jl#L182-L204" target="_blank">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#Base.filter" id="Base.filter"><code>Base.filter</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">filter(function, df::AbstractDataFrame)</code></pre><p>Return a copy of data frame <code>df</code> containing only rows for which <code>function</code> returns <code>true</code>. The function is passed a <code>DataFrameRow</code> as its only argument.</p><p><strong>Examples</strong></p><pre><code class="language-none">julia&gt; df = DataFrame(x = [3, 1, 2, 1], y = ["b", "c", "a", "b"])
4×2 DataFrame
│ Row │ x     │ y      │
│     │ Int64 │ String │
├─────┼───────┼────────┤
│ 1   │ 3     │ b      │
│ 2   │ 1     │ c      │
│ 3   │ 2     │ a      │
│ 4   │ 1     │ b      │

julia&gt; filter(row -&gt; row[:x] &gt; 1, df)
2×2 DataFrame
│ Row │ x     │ y      │
│     │ Int64 │ String │
├─────┼───────┼────────┤
│ 1   │ 3     │ b      │
│ 2   │ 2     │ a      │</code></pre></div></div><a class="source-link" href="https://github.com/JuliaData/DataFrames.jl/blob/28e9336db50378d11cd5205a0faaa05ccbd5f5cc/src/abstractdataframe/abstractdataframe.jl#L722-L748" target="_blank">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#Base.filter!" id="Base.filter!"><code>Base.filter!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">filter!(function, df::AbstractDataFrame)</code></pre><p>Remove rows from data frame <code>df</code> for which <code>function</code> returns <code>false</code>. The function is passed a <code>DataFrameRow</code> as its only argument.</p><p><strong>Examples</strong></p><pre><code class="language-none">julia&gt; df = DataFrame(x = [3, 1, 2, 1], y = ["b", "c", "a", "b"])
4×2 DataFrame
│ Row │ x     │ y      │
│     │ Int64 │ String │
├─────┼───────┼────────┤
│ 1   │ 3     │ b      │
│ 2   │ 1     │ c      │
│ 3   │ 2     │ a      │
│ 4   │ 1     │ b      │

julia&gt; filter!(row -&gt; row[:x] &gt; 1, df);

julia&gt; df
2×2 DataFrame
│ Row │ x     │ y      │
│     │ Int64 │ String │
├─────┼───────┼────────┤
│ 1   │ 3     │ b      │
│ 2   │ 2     │ a      │</code></pre></div></div><a class="source-link" href="https://github.com/JuliaData/DataFrames.jl/blob/28e9336db50378d11cd5205a0faaa05ccbd5f5cc/src/abstractdataframe/abstractdataframe.jl#L751-L779" target="_blank">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#DataFrames.insertcols!" id="DataFrames.insertcols!"><code>DataFrames.insertcols!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Insert a column into a data frame in place.</p><pre><code class="language-julia">insertcols!(df::DataFrame, ind::Int; name=col,
            makeunique::Bool=false)
insertcols!(df::DataFrame, ind::Int, (:name =&gt; col)::Pair{Symbol,&lt;:AbstractVector};
            makeunique::Bool=false)</code></pre><p><strong>Arguments</strong></p><ul><li><p><code>df</code> : the DataFrame to which we want to add a column</p></li><li><p><code>ind</code> : a position at which we want to insert a column</p></li><li><p><code>name</code> : the name of the new column</p></li><li><p><code>col</code> : an <code>AbstractVector</code> giving the contents of the new column</p></li><li><p><code>makeunique</code> : Defines what to do if <code>name</code> already exists in <code>df</code>; if it is <code>false</code> an error will be thrown; if it is <code>true</code> a new unique name will be generated by adding a suffix</p></li></ul><p><strong>Result</strong></p><ul><li><code>::DataFrame</code> : a <code>DataFrame</code> with added column.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; d = DataFrame(a=1:3)
3×1 DataFrame
│ Row │ a     │
│     │ Int64 │
├─────┼───────┤
│ 1   │ 1     │
│ 2   │ 2     │
│ 3   │ 3     │

julia&gt; insertcols!(d, 1, b=['a', 'b', 'c'])
3×2 DataFrame
│ Row │ b    │ a     │
│     │ Char │ Int64 │
├─────┼──────┼───────┤
│ 1   │ 'a'  │ 1     │
│ 2   │ 'b'  │ 2     │
│ 3   │ 'c'  │ 3     │

julia&gt; insertcols!(d, 1, :c =&gt; [2, 3, 4])
3×3 DataFrame
│ Row │ c     │ b    │ a     │
│     │ Int64 │ Char │ Int64 │
├─────┼───────┼──────┼───────┤
│ 1   │ 2     │ 'a'  │ 1     │
│ 2   │ 3     │ 'b'  │ 2     │
│ 3   │ 4     │ 'c'  │ 3     │</code></pre></div></div><a class="source-link" href="https://github.com/JuliaData/DataFrames.jl/blob/28e9336db50378d11cd5205a0faaa05ccbd5f5cc/src/dataframe/dataframe.jl#L644-L704" target="_blank">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#DataFrames.mapcols" id="DataFrames.mapcols"><code>DataFrames.mapcols</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">mapcols(f::Union{Function,Type}, df::AbstractDataFrame)</code></pre><p>Return a <code>DataFrame</code> where each column of <code>df</code> is transformed using function <code>f</code>. <code>f</code> must return <code>AbstractVector</code> objects all with the same length or scalars.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; df = DataFrame(x=1:4, y=11:14)
4×2 DataFrame
│ Row │ x     │ y     │
│     │ Int64 │ Int64 │
├─────┼───────┼───────┤
│ 1   │ 1     │ 11    │
│ 2   │ 2     │ 12    │
│ 3   │ 3     │ 13    │
│ 4   │ 4     │ 14    │

julia&gt; mapcols(x -&gt; x.^2, df)
4×2 DataFrame
│ Row │ x     │ y     │
│     │ Int64 │ Int64 │
├─────┼───────┼───────┤
│ 1   │ 1     │ 121   │
│ 2   │ 4     │ 144   │
│ 3   │ 9     │ 169   │
│ 4   │ 16    │ 196   │</code></pre></div></div><a class="source-link" href="https://github.com/JuliaData/DataFrames.jl/blob/28e9336db50378d11cd5205a0faaa05ccbd5f5cc/src/abstractdataframe/iteration.jl#L148-L177" target="_blank">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#DataFrames.names!" id="DataFrames.names!"><code>DataFrames.names!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Set column names</p><pre><code class="language-julia">names!(df::AbstractDataFrame, vals)</code></pre><p><strong>Arguments</strong></p><ul><li><code>df</code> : the AbstractDataFrame</li><li><code>vals</code> : column names, normally a Vector{Symbol} the same length as the number of columns in <code>df</code></li><li><code>makeunique</code> : if <code>false</code> (the default), an error will be raised if duplicate names are found; if <code>true</code>, duplicate names will be suffixed with <code>_i</code> (<code>i</code> starting at 1 for the first duplicate).</li></ul><p><strong>Result</strong></p><ul><li><code>::AbstractDataFrame</code> : the updated result</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia">df = DataFrame(i = 1:10, x = rand(10), y = rand(["a", "b", "c"], 10))
names!(df, [:a, :b, :c])
names!(df, [:a, :b, :a])  # throws ArgumentError
names!(df, [:a, :b, :a], makeunique=true)  # renames second :a to :a_1</code></pre></div></div><a class="source-link" href="https://github.com/JuliaData/DataFrames.jl/blob/28e9336db50378d11cd5205a0faaa05ccbd5f5cc/src/abstractdataframe/abstractdataframe.jl#L87-L118" target="_blank">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#DataFrames.nonunique" id="DataFrames.nonunique"><code>DataFrames.nonunique</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Indexes of duplicate rows (a row that is a duplicate of a prior row)</p><pre><code class="language-julia">nonunique(df::AbstractDataFrame)
nonunique(df::AbstractDataFrame, cols)</code></pre><p><strong>Arguments</strong></p><ul><li><code>df</code> : the AbstractDataFrame</li><li><code>cols</code> : a column indicator (Symbol, Int, Vector{Symbol}, etc.) specifying the column(s) to compare</li></ul><p><strong>Result</strong></p><ul><li><code>::Vector{Bool}</code> : indicates whether the row is a duplicate of some prior row</li></ul><p>See also <a href="lib/@ref"><code>unique</code></a> and <a href="functions.html#Base.unique!"><code>unique!</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia">df = DataFrame(i = 1:10, x = rand(10), y = rand(["a", "b", "c"], 10))
df = vcat(df, df)
nonunique(df)
nonunique(df, 1)</code></pre></div></div><a class="source-link" href="https://github.com/JuliaData/DataFrames.jl/blob/28e9336db50378d11cd5205a0faaa05ccbd5f5cc/src/abstractdataframe/abstractdataframe.jl#L815-L844" target="_blank">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#DataFrames.rename!" id="DataFrames.rename!"><code>DataFrames.rename!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Rename columns</p><pre><code class="language-julia">rename!(df::AbstractDataFrame, (from =&gt; to)::Pair{Symbol, Symbol}...)
rename!(df::AbstractDataFrame, d::AbstractDict{Symbol,Symbol})
rename!(df::AbstractDataFrame, d::AbstractArray{Pair{Symbol,Symbol}})
rename!(f::Function, df::AbstractDataFrame)
rename(df::AbstractDataFrame, (from =&gt; to)::Pair{Symbol, Symbol}...)
rename(df::AbstractDataFrame, d::AbstractDict{Symbol,Symbol})
rename(df::AbstractDataFrame, d::AbstractArray{Pair{Symbol,Symbol}})
rename(f::Function, df::AbstractDataFrame)</code></pre><p><strong>Arguments</strong></p><ul><li><code>df</code> : the AbstractDataFrame</li><li><code>d</code> : an Associative type or an AbstractArray of pairs that maps the original names to new names</li><li><code>f</code> : a function which for each column takes the old name (a Symbol) and returns the new name (a Symbol)</li></ul><p><strong>Result</strong></p><ul><li><code>::AbstractDataFrame</code> : the updated result</li></ul><p>New names are processed sequentially. A new name must not already exist in the <code>DataFrame</code> at the moment an attempt to rename a column is performed.</p><p><strong>Examples</strong></p><pre><code class="language-julia">df = DataFrame(i = 1:10, x = rand(10), y = rand(["a", "b", "c"], 10))
rename(df, :i =&gt; :A, :x =&gt; :X)
rename(df, [:i =&gt; :A, :x =&gt; :X])
rename(df, Dict(:i =&gt; :A, :x =&gt; :X))
rename(x -&gt; Symbol(uppercase(string(x))), df)
rename(df) do x
    Symbol(uppercase(string(x)))
end
rename!(df, Dict(:i =&gt;: A, :x =&gt; :X))</code></pre></div></div><a class="source-link" href="https://github.com/JuliaData/DataFrames.jl/blob/28e9336db50378d11cd5205a0faaa05ccbd5f5cc/src/abstractdataframe/abstractdataframe.jl#L136-L179" target="_blank">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#DataFrames.rename" id="DataFrames.rename"><code>DataFrames.rename</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Rename columns</p><pre><code class="language-julia">rename!(df::AbstractDataFrame, (from =&gt; to)::Pair{Symbol, Symbol}...)
rename!(df::AbstractDataFrame, d::AbstractDict{Symbol,Symbol})
rename!(df::AbstractDataFrame, d::AbstractArray{Pair{Symbol,Symbol}})
rename!(f::Function, df::AbstractDataFrame)
rename(df::AbstractDataFrame, (from =&gt; to)::Pair{Symbol, Symbol}...)
rename(df::AbstractDataFrame, d::AbstractDict{Symbol,Symbol})
rename(df::AbstractDataFrame, d::AbstractArray{Pair{Symbol,Symbol}})
rename(f::Function, df::AbstractDataFrame)</code></pre><p><strong>Arguments</strong></p><ul><li><code>df</code> : the AbstractDataFrame</li><li><code>d</code> : an Associative type or an AbstractArray of pairs that maps the original names to new names</li><li><code>f</code> : a function which for each column takes the old name (a Symbol) and returns the new name (a Symbol)</li></ul><p><strong>Result</strong></p><ul><li><code>::AbstractDataFrame</code> : the updated result</li></ul><p>New names are processed sequentially. A new name must not already exist in the <code>DataFrame</code> at the moment an attempt to rename a column is performed.</p><p><strong>Examples</strong></p><pre><code class="language-julia">df = DataFrame(i = 1:10, x = rand(10), y = rand(["a", "b", "c"], 10))
rename(df, :i =&gt; :A, :x =&gt; :X)
rename(df, [:i =&gt; :A, :x =&gt; :X])
rename(df, Dict(:i =&gt; :A, :x =&gt; :X))
rename(x -&gt; Symbol(uppercase(string(x))), df)
rename(df) do x
    Symbol(uppercase(string(x)))
end
rename!(df, Dict(:i =&gt;: A, :x =&gt; :X))</code></pre></div></div><a class="source-link" href="https://github.com/JuliaData/DataFrames.jl/blob/28e9336db50378d11cd5205a0faaa05ccbd5f5cc/src/abstractdataframe/abstractdataframe.jl#L136-L179" target="_blank">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#Base.repeat" id="Base.repeat"><code>Base.repeat</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">repeat(df::AbstractDataFrame; inner::Integer = 1, outer::Integer = 1)</code></pre><p>Construct a data frame by repeating rows in <code>df</code>. <code>inner</code> specifies how many times each row is repeated, and <code>outer</code> specifies how many times the full set of rows is repeated.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; df = DataFrame(a = 1:2, b = 3:4)
2×2 DataFrame
│ Row │ a     │ b     │
│     │ Int64 │ Int64 │
├─────┼───────┼───────┤
│ 1   │ 1     │ 3     │
│ 2   │ 2     │ 4     │

julia&gt; repeat(df, inner = 2, outer = 3)
12×2 DataFrame
│ Row │ a     │ b     │
│     │ Int64 │ Int64 │
├─────┼───────┼───────┤
│ 1   │ 1     │ 3     │
│ 2   │ 1     │ 3     │
│ 3   │ 2     │ 4     │
│ 4   │ 2     │ 4     │
│ 5   │ 1     │ 3     │
│ 6   │ 1     │ 3     │
│ 7   │ 2     │ 4     │
│ 8   │ 2     │ 4     │
│ 9   │ 1     │ 3     │
│ 10  │ 1     │ 3     │
│ 11  │ 2     │ 4     │
│ 12  │ 2     │ 4     │</code></pre></div></div><a class="source-link" href="https://github.com/JuliaData/DataFrames.jl/blob/28e9336db50378d11cd5205a0faaa05ccbd5f5cc/src/abstractdataframe/abstractdataframe.jl#L1047-L1082" target="_blank">source</a><div><div><pre><code class="language-none">repeat(df::AbstractDataFrame, count::Integer)</code></pre><p>Construct a data frame by repeating each row in <code>df</code> the number of times specified by <code>count</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; df = DataFrame(a = 1:2, b = 3:4)
2×2 DataFrame
│ Row │ a     │ b     │
│     │ Int64 │ Int64 │
├─────┼───────┼───────┤
│ 1   │ 1     │ 3     │
│ 2   │ 2     │ 4     │

julia&gt; repeat(df, 2)
4×2 DataFrame
│ Row │ a     │ b     │
│     │ Int64 │ Int64 │
├─────┼───────┼───────┤
│ 1   │ 1     │ 3     │
│ 2   │ 2     │ 4     │
│ 3   │ 1     │ 3     │
│ 4   │ 2     │ 4     │</code></pre></div></div><a class="source-link" href="https://github.com/JuliaData/DataFrames.jl/blob/28e9336db50378d11cd5205a0faaa05ccbd5f5cc/src/abstractdataframe/abstractdataframe.jl#L1086-L1112" target="_blank">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#Base.show" id="Base.show"><code>Base.show</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">show([io::IO,] df::AbstractDataFrame;
     allrows::Bool = !get(io, :limit, false),
     allcols::Bool = !get(io, :limit, false),
     allgroups::Bool = !get(io, :limit, false),
     splitcols::Bool = get(io, :limit, false),
     rowlabel::Symbol = :Row,
     summary::Bool = true)</code></pre><p>Render a data frame to an I/O stream. The specific visual representation chosen depends on the width of the display.</p><p>If <code>io</code> is omitted, the result is printed to <code>stdout</code>, and <code>allrows</code>, <code>allcols</code> and <code>allgroups</code> default to <code>false</code> while <code>splitcols</code> defaults to <code>true</code>.</p><p><strong>Arguments</strong></p><ul><li><code>io::IO</code>: The I/O stream to which <code>df</code> will be printed.</li><li><code>df::AbstractDataFrame</code>: The data frame to print.</li><li><code>allrows::Bool</code>: Whether to print all rows, rather than a subset that fits the device height. By default this is the case only if <code>io</code> does not have the <code>IOContext</code> property <code>limit</code> set.</li><li><code>allcols::Bool</code>: Whether to print all columns, rather than a subset that fits the device width. By default this is the case only if <code>io</code> does not have the <code>IOContext</code> property <code>limit</code> set.</li><li><code>allgroups::Bool</code>: Whether to print all groups rather than the first and last, when <code>df</code> is a <code>GroupedDataFrame</code>. By default this is the case only if <code>io</code> does not have the <code>IOContext</code> property <code>limit</code> set.</li><li><code>splitcols::Bool</code>: Whether to split printing in chunks of columns fitting the screen width rather than printing all columns in the same block. Only applies if <code>allcols</code> is <code>true</code>. By default this is the case only if <code>io</code> has the <code>IOContext</code> property <code>limit</code> set.</li><li><code>rowlabel::Symbol = :Row</code>: The label to use for the column containing row numbers.</li><li><code>summary::Bool = true</code>: Whether to print a brief string summary of the data frame.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using DataFrames

julia&gt; df = DataFrame(A = 1:3, B = ["x", "y", "z"]);

julia&gt; show(df, allcols=true)
3×2 DataFrame
│ Row │ A     │ B      │
│     │ Int64 │ String │
├─────┼───────┼────────┤
│ 1   │ 1     │ x      │
│ 2   │ 2     │ y      │
│ 3   │ 3     │ z      │</code></pre></div></div><a class="source-link" href="https://github.com/JuliaData/DataFrames.jl/blob/28e9336db50378d11cd5205a0faaa05ccbd5f5cc/src/abstractdataframe/show.jl#L491-L541" target="_blank">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#Base.sort" id="Base.sort"><code>Base.sort</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">sort(df::AbstractDataFrame, cols;
     alg::Union{Algorithm, Nothing}=nothing, lt=isless, by=identity,
     rev::Bool=false, order::Ordering=Forward)</code></pre><p>Return a copy of data frame <code>df</code> sorted by column(s) <code>cols</code>. <code>cols</code> can be either a <code>Symbol</code> or <code>Integer</code> column index, or a tuple or vector of such indices.</p><p>If <code>alg</code> is <code>nothing</code> (the default), the most appropriate algorithm is chosen automatically among <code>TimSort</code>, <code>MergeSort</code> and <code>RadixSort</code> depending on the type of the sorting columns and on the number of rows in <code>df</code>. If <code>rev</code> is <code>true</code>, reverse sorting is performed. To enable reverse sorting only for some columns, pass <code>order(c, rev=true)</code> in <code>cols</code>, with <code>c</code> the corresponding column index (see example below). See <a href="functions.html#Base.sort!"><code>sort!</code></a> for a description of other keyword arguments.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; df = DataFrame(x = [3, 1, 2, 1], y = ["b", "c", "a", "b"])
4×2 DataFrame
│ Row │ x     │ y      │
│     │ Int64 │ String │
├─────┼───────┼────────┤
│ 1   │ 3     │ b      │
│ 2   │ 1     │ c      │
│ 3   │ 2     │ a      │
│ 4   │ 1     │ b      │

julia&gt; sort(df, :x)
4×2 DataFrame
│ Row │ x     │ y      │
│     │ Int64 │ String │
├─────┼───────┼────────┤
│ 1   │ 1     │ c      │
│ 2   │ 1     │ b      │
│ 3   │ 2     │ a      │
│ 4   │ 3     │ b      │

julia&gt; sort(df, (:x, :y))
4×2 DataFrame
│ Row │ x     │ y      │
│     │ Int64 │ String │
├─────┼───────┼────────┤
│ 1   │ 1     │ b      │
│ 2   │ 1     │ c      │
│ 3   │ 2     │ a      │
│ 4   │ 3     │ b      │

julia&gt; sort(df, (:x, :y), rev=true)
4×2 DataFrame
│ Row │ x     │ y      │
│     │ Int64 │ String │
├─────┼───────┼────────┤
│ 1   │ 3     │ b      │
│ 2   │ 2     │ a      │
│ 3   │ 1     │ c      │
│ 4   │ 1     │ b      │

julia&gt; sort(df, (:x, order(:y, rev=true)))
4×2 DataFrame
│ Row │ x     │ y      │
│     │ Int64 │ String │
├─────┼───────┼────────┤
│ 1   │ 1     │ c      │
│ 2   │ 1     │ b      │
│ 3   │ 2     │ a      │
│ 4   │ 3     │ b      │</code></pre></div></div><a class="source-link" href="https://github.com/JuliaData/DataFrames.jl/blob/28e9336db50378d11cd5205a0faaa05ccbd5f5cc/src/abstractdataframe/sort.jl#L304-L373" target="_blank">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#Base.sort!" id="Base.sort!"><code>Base.sort!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">sort!(df::AbstractDataFrame, cols;
      alg::Union{Algorithm, Nothing}=nothing, lt=isless, by=identity,
      rev::Bool=false, order::Ordering=Forward)</code></pre><p>Sort data frame <code>df</code> by column(s) <code>cols</code>. <code>cols</code> can be either a <code>Symbol</code> or <code>Integer</code> column index, or a tuple or vector of such indices.</p><p>If <code>alg</code> is <code>nothing</code> (the default), the most appropriate algorithm is chosen automatically among <code>TimSort</code>, <code>MergeSort</code> and <code>RadixSort</code> depending on the type of the sorting columns and on the number of rows in <code>df</code>. If <code>rev</code> is <code>true</code>, reverse sorting is performed. To enable reverse sorting only for some columns, pass <code>order(c, rev=true)</code> in <code>cols</code>, with <code>c</code> the corresponding column index (see example below). See other methods for a description of other keyword arguments.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; df = DataFrame(x = [3, 1, 2, 1], y = ["b", "c", "a", "b"])
4×2 DataFrame
│ Row │ x     │ y      │
│     │ Int64 │ String │
├─────┼───────┼────────┤
│ 1   │ 3     │ b      │
│ 2   │ 1     │ c      │
│ 3   │ 2     │ a      │
│ 4   │ 1     │ b      │

julia&gt; sort!(df, :x)
4×2 DataFrame
│ Row │ x     │ y      │
│     │ Int64 │ String │
├─────┼───────┼────────┤
│ 1   │ 1     │ c      │
│ 2   │ 1     │ b      │
│ 3   │ 2     │ a      │
│ 4   │ 3     │ b      │

julia&gt; sort!(df, (:x, :y))
4×2 DataFrame
│ Row │ x     │ y      │
│     │ Int64 │ String │
├─────┼───────┼────────┤
│ 1   │ 1     │ b      │
│ 2   │ 1     │ c      │
│ 3   │ 2     │ a      │
│ 4   │ 3     │ b      │

julia&gt; sort!(df, (:x, :y), rev=true)
4×2 DataFrame
│ Row │ x     │ y      │
│     │ Int64 │ String │
├─────┼───────┼────────┤
│ 1   │ 3     │ b      │
│ 2   │ 2     │ a      │
│ 3   │ 1     │ c      │
│ 4   │ 1     │ b      │

julia&gt; sort!(df, (:x, order(:y, rev=true)))
4×2 DataFrame
│ Row │ x     │ y      │
│     │ Int64 │ String │
├─────┼───────┼────────┤
│ 1   │ 1     │ c      │
│ 2   │ 1     │ b      │
│ 3   │ 2     │ a      │
│ 4   │ 3     │ b      │</code></pre></div></div><a class="source-link" href="https://github.com/JuliaData/DataFrames.jl/blob/28e9336db50378d11cd5205a0faaa05ccbd5f5cc/src/dataframe/sort.jl#L2-L71" target="_blank">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#Base.unique!" id="Base.unique!"><code>Base.unique!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Delete duplicate rows</p><pre><code class="language-julia">unique(df::AbstractDataFrame)
unique(df::AbstractDataFrame, cols)
unique!(df::AbstractDataFrame)
unique!(df::AbstractDataFrame, cols)</code></pre><p><strong>Arguments</strong></p><ul><li><code>df</code> : the AbstractDataFrame</li><li><code>cols</code> :  column indicator (Symbol, Int, Vector{Symbol}, etc.)</li></ul><p>specifying the column(s) to compare.</p><p><strong>Result</strong></p><ul><li><code>::AbstractDataFrame</code> : the updated version of <code>df</code> with unique rows.</li></ul><p>When <code>cols</code> is specified, the return DataFrame contains complete rows, retaining in each case the first instance for which <code>df[cols]</code> is unique.</p><p>See also <a href="functions.html#DataFrames.nonunique"><code>nonunique</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia">df = DataFrame(i = 1:10, x = rand(10), y = rand(["a", "b", "c"], 10))
df = vcat(df, df)
unique(df)   # doesn't modify df
unique(df, 1)
unique!(df)  # modifies df</code></pre></div></div><a class="source-link" href="https://github.com/JuliaData/DataFrames.jl/blob/28e9336db50378d11cd5205a0faaa05ccbd5f5cc/src/abstractdataframe/abstractdataframe.jl#L876-L910" target="_blank">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#DataFrames.permutecols!" id="DataFrames.permutecols!"><code>DataFrames.permutecols!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">permutecols!(df::DataFrame, p::AbstractVector)</code></pre><p>Permute the columns of <code>df</code> in-place, according to permutation <code>p</code>. Elements of <code>p</code> may be either column indices (<code>Int</code>) or names (<code>Symbol</code>), but cannot be a combination of both. All columns must be listed.</p><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; df = DataFrame(a=1:5, b=2:6, c=3:7)
5×3 DataFrame
│ Row │ a     │ b     │ c     │
│     │ Int64 │ Int64 │ Int64 │
├─────┼───────┼───────┼───────┤
│ 1   │ 1     │ 2     │ 3     │
│ 2   │ 2     │ 3     │ 4     │
│ 3   │ 3     │ 4     │ 5     │
│ 4   │ 4     │ 5     │ 6     │
│ 5   │ 5     │ 6     │ 7     │

julia&gt; permutecols!(df, [2, 1, 3]);

julia&gt; df
5×3 DataFrame
│ Row │ b     │ a     │ c     │
│     │ Int64 │ Int64 │ Int64 │
├─────┼───────┼───────┼───────┤
│ 1   │ 2     │ 1     │ 3     │
│ 2   │ 3     │ 2     │ 4     │
│ 3   │ 4     │ 3     │ 5     │
│ 4   │ 5     │ 4     │ 6     │
│ 5   │ 6     │ 5     │ 7     │

julia&gt; permutecols!(df, [:c, :a, :b]);

julia&gt; df
5×3 DataFrame
│ Row │ c     │ a     │ b     │
│     │ Int64 │ Int64 │ Int64 │
├─────┼───────┼───────┼───────┤
│ 1   │ 3     │ 1     │ 2     │
│ 2   │ 4     │ 2     │ 3     │
│ 3   │ 5     │ 3     │ 4     │
│ 4   │ 6     │ 4     │ 5     │
│ 5   │ 7     │ 5     │ 6     │</code></pre></div></div><a class="source-link" href="https://github.com/JuliaData/DataFrames.jl/blob/28e9336db50378d11cd5205a0faaa05ccbd5f5cc/src/dataframe/dataframe.jl#L1034-L1081" target="_blank">source</a></section><footer><hr/><a class="previous" href="types.html"><span class="direction">Previous</span><span class="title">Types</span></a><a class="next" href="indexing.html"><span class="direction">Next</span><span class="title">Indexing</span></a></footer></article></body></HTML>