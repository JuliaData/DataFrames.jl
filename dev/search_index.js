var documenterSearchIndex = {"docs":
[{"location":"lib/internals/","page":"Internals","title":"Internals","text":"CurrentModule = DataFrames","category":"page"},{"location":"lib/internals/#Internals","page":"Internals","title":"Internals","text":"","category":"section"},{"location":"lib/internals/","page":"Internals","title":"Internals","text":"warning: Internal API\nThe functions, methods and types listed on this page are internal to DataFrames and are not considered to be part of the public API.","category":"page"},{"location":"lib/internals/","page":"Internals","title":"Internals","text":"compacttype\ngennames\ngetmaxwidths\nourshow\nourstrwidth\n@spawn_for_chunks","category":"page"},{"location":"lib/internals/#DataFrames.compacttype","page":"Internals","title":"DataFrames.compacttype","text":"compacttype(T::Type, maxwidth::Int=8, initial::Bool=true)\n\nReturn compact string representation of type T.\n\nFor displaying data frame we do not want string representation of type to be longer than maxwidth. This function implements rules how type names are cropped if they are longer than maxwidth.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#DataFrames.gennames","page":"Internals","title":"DataFrames.gennames","text":"gennames(n::Integer)\n\nGenerate standardized names for columns of a DataFrame. The first name will be :x1, the second :x2, etc.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#DataFrames.getmaxwidths","page":"Internals","title":"DataFrames.getmaxwidths","text":"DataFrames.getmaxwidths(df::AbstractDataFrame,\n                        io::IO,\n                        rowindices1::AbstractVector{Int},\n                        rowindices2::AbstractVector{Int},\n                        rowlabel::Symbol,\n                        rowid::Union{Integer, Nothing},\n                        show_eltype::Bool,\n                        buffer::IOBuffer)\n\nCalculate, for each column of an AbstractDataFrame, the maximum string width used to render the name of that column, its type, and the longest entry in that column – among the rows of the data frame will be rendered to IO. The widths for all columns are returned as a vector.\n\nReturn a Vector{Int} giving the maximum string widths required to render each column, including that column's name and type.\n\nNOTE: The last entry of the result vector is the string width of the implicit row ID column contained in every AbstractDataFrame.\n\nArguments\n\ndf::AbstractDataFrame: The data frame whose columns will be printed.\nio::IO: The IO to which df is to be printed\n`rowindices1::AbstractVector{Int}: A set of indices of the first chunk of the AbstractDataFrame that would be rendered to IO.\n`rowindices2::AbstractVector{Int}: A set of indices of the second chunk of the AbstractDataFrame that would be rendered to IO. Can be empty if the AbstractDataFrame would be printed without any ellipses.\nrowlabel::AbstractString: The label that will be used when rendered the numeric ID's of each row. Typically, this will be set to \"Row\".\nrowid: Used to handle showing DataFrameRow.\nshow_eltype: Whether to print the column type  under the column name in the heading.\nbuffer: buffer passed around to avoid reallocations in ourstrwidth\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#DataFrames.ourshow","page":"Internals","title":"DataFrames.ourshow","text":"DataFrames.ourshow(io::IO, x::Any, truncstring::Int)\n\nRender a value to an IO object compactly using print. truncstring indicates the approximate number of text characters width to truncate the output (if it is a non-positive value then no truncation is applied).\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#DataFrames.ourstrwidth","page":"Internals","title":"DataFrames.ourstrwidth","text":"DataFrames.ourstrwidth(io::IO, x::Any, buffer::IOBuffer, truncstring::Int)\n\nDetermine the number of characters that would be used to print a value.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#DataFrames.@spawn_for_chunks","page":"Internals","title":"DataFrames.@spawn_for_chunks","text":"@spawn_for_chunks basesize for i in range ... end\n\nParallelize a for loop by spawning separate tasks iterating each over a chunk of at least basesize elements in range.\n\nA number of task higher than Threads.nthreads() may be spawned, since that can allow for a more efficient load balancing in case some threads are busy (nested parallelism).\n\n\n\n\n\n","category":"macro"},{"location":"man/basics/#First-Steps-with-DataFrames.jl","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"","category":"section"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"The tutorial section of the manual is still work in progress. Please report any questions or comments as issues in DataFrames.jl GitHub repository. Thank you!","category":"page"},{"location":"man/basics/#Setting-up-the-Environment","page":"First Steps with DataFrames.jl","title":"Setting up the Environment","text":"","category":"section"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"If want to use the DataFrames.jl package you need to install it first. You can do it using the following commands:","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"julia> using Pkg\njulia> Pkg.add(\"DataFrames\")","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"or","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"julia> ] # ']' should be pressed\n\n(@v1.6) pkg> add DataFrames","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"If you want to make sure everything works as expected you can run the tests bundled with DataFrames.jl, but be warned that it will take more than 30 minutes:","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"julia> using Pkg\njulia> Pkg.test(\"DataFrames\") # Warning! This will take more than 30 minutes.","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"Additionally, it is recommended to check the version of DataFrames.jl that you have installed with the status command.","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"julia> ]\n\n(@v1.6) pkg> status DataFrames\n      Status `C:\\Users\\TeAmp0is0N\\.julia\\environments\\v1.6\\Project.toml`\n  [a93c6f00] DataFrames v1.1.1","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"Throughout the rest of the tutorial we will assume that you have installed the DataFrames.jl package and have already typed using DataFrames which loads the package:","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"julia> using DataFrames","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"The most fundamental type provided by DataFrames.jl is DataFrame, where typically each row is interpreted as an observation and each column as a feature.","category":"page"},{"location":"man/basics/#Constructors-and-Basic-Utility-Functions","page":"First Steps with DataFrames.jl","title":"Constructors and Basic Utility Functions","text":"","category":"section"},{"location":"man/basics/#Constructors","page":"First Steps with DataFrames.jl","title":"Constructors","text":"","category":"section"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"In this section you will see several ways to create a DataFrame using the constructor. You can find a detailed list of supported constructors along with more examples in the documentation of the DataFrame object.","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"We start by creating an empty DataFrame:","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"julia> DataFrame()\n0×0 DataFrame","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"Now let us initialize a DataFrame with several columns. This is a basic way to do it is the following:","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"julia> DataFrame(A=1:3, B=5:7, fixed=1)\n3×3 DataFrame\n Row │ A      B      fixed\n     │ Int64  Int64  Int64\n─────┼─────────────────────\n   1 │     1      5      1\n   2 │     2      6      1\n   3 │     3      7      1","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"Observe that using this constructor scalars, like 1 for the column :fixed get automatically broadcasted to fill all rows of the created DataFrame.","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"Sometimes one needs to create a data frame whose column names are not valid Julia identifiers. In such a case the following form, where = is replaced by => is handy:","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"julia> DataFrame(\"customer age\" => [15, 20, 25],\n                 \"first name\" => [\"Rohit\", \"Rahul\", \"Akshat\"])\n3×2 DataFrame\n Row │ customer age  first name\n     │ Int64         String\n─────┼──────────────────────────\n   1 │           15  Rohit\n   2 │           20  Rahul\n   3 │           25  Akshat","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"Notice that this time we have passed column names as strings.","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"Often you have your source data stored in a dictionary. Provided that the keys of the dictionary are strings or Symbols you can also easily create a DataFrame from it:","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"julia> dict = Dict(\"customer age\" => [15, 20, 25],\n                   \"first name\" => [\"Rohit\", \"Rahul\", \"Akshat\"])\nDict{String, Vector{T} where T} with 2 entries:\n  \"first name\"   => [\"Rohit\", \"Rahul\", \"Akshat\"]\n  \"customer age\" => [15, 20, 25]\n\njulia> DataFrame(dict)\n3×2 DataFrame\n Row │ customer age  first name\n     │ Int64         String\n─────┼──────────────────────────\n   1 │           15  Rohit\n   2 │           20  Rahul\n   3 │           25  Akshat\n\njulia> dict = Dict(:customer_age => [15, 20, 25],\n                   :first_name => [\"Rohit\", \"Rahul\", \"Akshat\"])\nDict{Symbol, Vector{T} where T} with 2 entries:\n  :customer_age => [15, 20, 25]\n  :first_name   => [\"Rohit\", \"Rahul\", \"Akshat\"]\n\njulia> DataFrame(dict)\n3×2 DataFrame\n Row │ customer_age  first_name\n     │ Int64         String\n─────┼──────────────────────────\n   1 │           15  Rohit\n   2 │           20  Rahul\n   3 │           25  Akshat","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"Using Symbols, e.g. :customer_age rather than strings, e.g. \"customer age\" to denote column names is preferred as it is faster. However, as you can see in the example above if our column name contains a space it is not very convenient to pass it as a Symbol (you would have to write Symbol(\"customer age\"), which is verbose) so using a string is more convenient.","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"It is also quite common to create a DataFrame from a NamedTuple of vectors or a vector of NamedTuples. Here are some examples of these operations:","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"julia> DataFrame((a=[1, 2], b=[3, 4]))\n2×2 DataFrame\n Row │ a      b\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1      3\n   2 │     2      4\n\njulia> DataFrame([(a=1, b=0), (a=2, b=0)])\n2×2 DataFrame\n Row │ a      b\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1      0\n   2 │     2      0","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"Let us finish our review of constructors by showing how to create a DataFrame from a matrix. In this case you pass a matrix as a first argument. If the second argument is just :auto then column names x1, x2, ... will be auto generated.","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"julia> DataFrame([1 0; 2 0], :auto)\n2×2 DataFrame\n Row │ x1     x2\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1      0\n   2 │     2      0","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"Alternatively you can pass a vector of column names as a second argument to the DataFrame constructor:","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"julia> mat = [1 2 4 5; 15 58 69 41; 23 21 26 69]\n3×4 Matrix{Int64}:\n  1   2   4   5\n 15  58  69  41\n 23  21  26  69\n\njulia> nms = [\"a\", \"b\", \"c\", \"d\"]\n4-element Vector{String}:\n \"a\"\n \"b\"\n \"c\"\n \"d\"\n\njulia> DataFrame(mat, nms)\n3×4 DataFrame\n Row │ a      b      c      d\n     │ Int64  Int64  Int64  Int64\n─────┼────────────────────────────\n   1 │     1      2      4      5\n   2 │    15     58     69     41\n   3 │    23     21     26     69","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"You now know how to create a DataFrame from data that you already have in your Julia session. In the next section we show how to load data to a DataFrame from disk.","category":"page"},{"location":"man/basics/#Reading-Data-From-CSV-Files","page":"First Steps with DataFrames.jl","title":"Reading Data From CSV Files","text":"","category":"section"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"Here we focus on one of the most common scenarios, where one has data stored on disk in the CSV format.","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"First make sure you have CSV.jl installed. You can do it using the following instructions:","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"julia> using Pkg\njulia> Pkg.add(\"CSV\")","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"In order to read the file in we will use the CSV.read function.","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"julia> using CSV\n\njulia> german_ref = CSV.read(joinpath(dirname(pathof(DataFrames)),\n                                      \"..\", \"docs\", \"src\", \"assets\", \"german.csv\"),\n                             DataFrame)\n1000×10 DataFrame\n  Row │ id     Age    Sex     Job    Housing  Saving accounts  Checking accoun ⋯\n      │ Int64  Int64  String  Int64  String   String           String          ⋯\n──────┼─────────────────────────────────────────────────────────────────────────\n    1 │     0     67  male        2  own      NA               little          ⋯\n    2 │     1     22  female      2  own      little           moderate\n    3 │     2     49  male        1  own      little           NA\n    4 │     3     45  male        2  free     little           little\n    5 │     4     53  male        2  free     little           little          ⋯\n    6 │     5     35  male        1  free     NA               NA\n    7 │     6     53  male        2  own      quite rich       NA\n    8 │     7     35  male        3  rent     little           moderate\n  ⋮   │   ⋮      ⋮      ⋮       ⋮       ⋮            ⋮                ⋮        ⋱\n  994 │   993     30  male        3  own      little           little          ⋯\n  995 │   994     50  male        2  own      NA               NA\n  996 │   995     31  female      1  own      little           NA\n  997 │   996     40  male        3  own      little           little\n  998 │   997     38  male        2  own      little           NA              ⋯\n  999 │   998     23  male        2  free     little           little\n 1000 │   999     27  male        2  own      moderate         moderate\n                                                  4 columns and 985 rows omitted","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"As you can see the data frame is wider and taller than the display width, so it got cropped and its 4 rightmost columns and middle 985 rows were not printed. Later in the tutorial we will discuss how to force Julia to show the whole data frame if we wanted so.","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"Also observe that DataFrames.jl displays the data type of the column below its name. In our case, it is an Int64, or String.","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"Let us now explain in detail the following code block:","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"german_ref = CSV.read(joinpath(dirname(pathof(DataFrames)),\n                               \"..\", \"docs\", \"src\", \"assets\", \"german.csv\"),\n                      DataFrame)","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"we are storing the german.csv file in the DataFrames.jl repository to make user's life easier and avoid having to download it each time;\npathof(DataFrames) gives us the full path of the file that was used to import the DataFrames.jl package;\nfirst we split the directory part from it using dirname;\nthen from this directory we need to move to the directory where the german.csv file is stored; we use joinpath as this is a recommended way to compose paths to resources stored on disk in an operating system independent way (remember that Widnows and Unix differ as they use either / or \\ as path separator; the joinpath function ensures we are not running into issues with this);\nthen we read the CSV file; the second argument to CSV.read is DataFrame to indicate that we want to read in the file into a DataFrame (as CSV.read allows for many different target formats of data it can read-into).","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"Before proceeding copy the reference data frame:","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"julia> german = copy(german_ref); # we copy the data frame","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"In this way we can always easily restore our data even if we mess up the german data frame by modifying it.","category":"page"},{"location":"man/basics/#Basic-Operations-on-Data-Frames","page":"First Steps with DataFrames.jl","title":"Basic Operations on Data Frames","text":"","category":"section"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"To access the columns of a data frame directly (i.e. without copying) you can use one of the following syntaxes: german.Sex, german.\"Sex\", german[!, :Sex] or german[!, \"Sex\"].","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"The two latter syntaxes using indexing are more flexible as they allow us passing a variable holding the name of the column, and not only a literal name as in the case of the syntax using a ..","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"julia> german.Sex\n1000-element PooledArrays.PooledVector{String, UInt32, Vector{UInt32}}:\n \"male\"\n \"female\"\n \"male\"\n \"male\"\n \"male\"\n \"male\"\n \"male\"\n \"male\"\n \"male\"\n \"male\"\n ⋮\n \"male\"\n \"male\"\n \"male\"\n \"male\"\n \"female\"\n \"male\"\n \"male\"\n \"male\"\n \"male\"\n\njulia> colname = \"Sex\"\n\"Sex\"\n\njulia> german[!, colname]\n1000-element PooledArrays.PooledVector{String, UInt32, Vector{UInt32}}:\n \"male\"\n \"female\"\n \"male\"\n \"male\"\n \"male\"\n \"male\"\n \"male\"\n \"male\"\n \"male\"\n \"male\"\n ⋮\n \"male\"\n \"male\"\n \"male\"\n \"male\"\n \"female\"\n \"male\"\n \"male\"\n \"male\"\n \"male\"","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"Since german.Sex does not make a copy, changing the elements of the column vector returned by this operation will affect the values stored in the original german data frame. To get a copy of the column you can use german[:, :Sex] or german[:, \"Sex\"]. In this case changing the vector returned by this operation does not affect the data stored in the german data frame.","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"The === function allows us to check if both expressions produce the same object and confirm the behavior described above:","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"julia> german.Sex === german[!, :Sex]\ntrue\n\njulia> german.Sex === german[:, :Sex]\nfalse","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"You can obtain a vector of column names of the data frame as Strings using the names function:","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"julia> names(german)\n10-element Vector{String}:\n \"id\"\n \"Age\"\n \"Sex\"\n \"Job\"\n \"Housing\"\n \"Saving accounts\"\n \"Checking account\"\n \"Credit amount\"\n \"Duration\"\n \"Purpose\"","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"Sometimes you are interested in names of columns that meet a particular condition.","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"For example you can get column names with a given element type by passing this type as a second argument to the names function:","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"julia> names(german, String)\n5-element Vector{String}:\n \"Sex\"\n \"Housing\"\n \"Saving accounts\"\n \"Checking account\"\n \"Purpose\"","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"You can explore more options of filtering column naes in the documentation of the names function.","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"If instead you wanted to get column names of a data frame as Symbols use the propertynames function:","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"julia> propertynames(german)\n10-element Vector{Symbol}:\n :id\n :Age\n :Sex\n :Job\n :Housing\n Symbol(\"Saving accounts\")\n Symbol(\"Checking account\")\n Symbol(\"Credit amount\")\n :Duration\n :Purpose","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"As you can see the column names containing spaces are not very convenient to work with as Symbols because they require more typing and introduce some visual noise.","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"If you were interested in element types of the columns instead. You can use the eachcol(german) function to get an iterator over the columns of the data frame. Then you can broadcast the eltype function over it to get the desired result:","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"julia> eltype.(eachcol(german))\n10-element Vector{DataType}:\n Int64\n Int64\n String\n Int64\n String\n String\n String\n Int64\n Int64\n String","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"note: Note\nRemember that DataFrames.jl allows to use Symbols (like :id) and strings (like \"id\") for all column indexing operations for convenience. However, using Symbols is slightly faster, but strings are simpler to work with when non standard characters are present in column names or one wants to manipulate them.","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"Before we wrap up let us discuss the empty and empty! functions that To remove all rows from a DataFrame. Understanding the difference between the behavior of these two functions will help you to understand the function naming scheme in DataFrames.jl in general.","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"Let us start with the example of using the empty and empty! functions:","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"julia> empty(german)\n0×10 DataFrame\n\njulia> german\n1000×10 DataFrame\n  Row │ id     Age    Sex     Job    Housing  Saving accounts  Checking accoun ⋯\n      │ Int64  Int64  String  Int64  String   String           String          ⋯\n──────┼─────────────────────────────────────────────────────────────────────────\n    1 │     0     67  male        2  own      NA               little          ⋯\n    2 │     1     22  female      2  own      little           moderate\n    3 │     2     49  male        1  own      little           NA\n    4 │     3     45  male        2  free     little           little\n    5 │     4     53  male        2  free     little           little          ⋯\n    6 │     5     35  male        1  free     NA               NA\n    7 │     6     53  male        2  own      quite rich       NA\n    8 │     7     35  male        3  rent     little           moderate\n  ⋮   │   ⋮      ⋮      ⋮       ⋮       ⋮            ⋮                ⋮        ⋱\n  994 │   993     30  male        3  own      little           little          ⋯\n  995 │   994     50  male        2  own      NA               NA\n  996 │   995     31  female      1  own      little           NA\n  997 │   996     40  male        3  own      little           little\n  998 │   997     38  male        2  own      little           NA              ⋯\n  999 │   998     23  male        2  free     little           little\n 1000 │   999     27  male        2  own      moderate         moderate\n                                                  4 columns and 985 rows omitted\n\njulia> empty!(german)\n0×10 DataFrame\n\njulia> german\n0×10 DataFrame","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"In the above example empty function created a new DataFrame with the same column names and column element types as german but with zero rows. On the other hand empty! function removed all rows from german in-place and made each of its columns empty.","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"The difference between the behavior of the empty and empty! functions is an application of the stylistic convention employed in the Julia language. This convention is followed in all functions provided by the DataFrames.jl package.","category":"page"},{"location":"man/basics/#Getting-Basic-Information-about-a-Data-Frame","page":"First Steps with DataFrames.jl","title":"Getting Basic Information about a Data Frame","text":"","category":"section"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"In this section we will learn about how to get basic information on our german DataFrame:","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"The size function returns the dimensions of the data frame. First we restore the german data frame, as we have just emptied it above.","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"julia> german = copy(german_ref);\n\njulia> size(german)\n(1000, 10)\n\njulia> size(german, 1)\n1000\n\njulia> size(german, 2)\n10","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"Additionally the nrow and ncol functions can be used to get the number of rows and columns in a data frame:","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"julia> nrow(german)\n1000\n\njulia> ncol(german)\n10","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"To get basic statistics of data in your data frame use the describe function (check out the help of describe for information on how to customize the shown statistics).","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"julia> describe(german)\n10×7 DataFrame\n Row │ variable          mean     min       median  max              nmissing  ⋯\n     │ Symbol            Union…   Any       Union…  Any              Int64     ⋯\n─────┼──────────────────────────────────────────────────────────────────────────\n   1 │ id                499.5    0         499.5   999                     0  ⋯\n   2 │ Age               35.546   19        33.0    75                      0\n   3 │ Sex                        female            male                    0\n   4 │ Job               1.904    0         2.0     3                       0\n   5 │ Housing                    free              rent                    0  ⋯\n   6 │ Saving accounts            NA                rich                    0\n   7 │ Checking account           NA                rich                    0\n   8 │ Credit amount     3271.26  250       2319.5  18424                   0\n   9 │ Duration          20.903   4         18.0    72                      0  ⋯\n  10 │ Purpose                    business          vacation/others         0\n                                                                1 column omitted","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"To limit the columns processed by desribe use cols keyword argument, e.g.:","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"julia> describe(german, cols=1:3)\n3×7 DataFrame\n Row │ variable  mean    min     median  max   nmissing  eltype\n     │ Symbol    Union…  Any     Union…  Any   Int64     DataType\n─────┼────────────────────────────────────────────────────────────\n   1 │ id        499.5   0       499.5   999          0  Int64\n   2 │ Age       35.546  19      33.0    75           0  Int64\n   3 │ Sex               female          male         0  String","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"The default statistics reported are mean, min, median, max, number of missing values, and element type of the column. missing values are skipped when computing the summary statistics.","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"You can adjust how data frame is displayed by calling the show function manually: show(german, allrows=true) prints all rows even if they do not fit on screen and show(german, allcols=true) does the same for columns, e.g.:","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"julia> show(german, allcols=true)\n1000×10 DataFrame\n  Row │ id     Age    Sex     Job    Housing  Saving accounts  Checking account  Credit amount  Duration  Purpose\n      │ Int64  Int64  String  Int64  String   String           String            Int64          Int64     String\n──────┼───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────\n    1 │     0     67  male        2  own      NA               little                     1169         6  radio/TV\n    2 │     1     22  female      2  own      little           moderate                   5951        48  radio/TV\n    3 │     2     49  male        1  own      little           NA                         2096        12  education\n    4 │     3     45  male        2  free     little           little                     7882        42  furniture/equipment\n    5 │     4     53  male        2  free     little           little                     4870        24  car\n    6 │     5     35  male        1  free     NA               NA                         9055        36  education\n    7 │     6     53  male        2  own      quite rich       NA                         2835        24  furniture/equipment\n    8 │     7     35  male        3  rent     little           moderate                   6948        36  car\n  ⋮   │   ⋮      ⋮      ⋮       ⋮       ⋮            ⋮                ⋮                ⋮           ⋮               ⋮\n  994 │   993     30  male        3  own      little           little                     3959        36  furniture/equipment\n  995 │   994     50  male        2  own      NA               NA                         2390        12  car\n  996 │   995     31  female      1  own      little           NA                         1736        12  furniture/equipment\n  997 │   996     40  male        3  own      little           little                     3857        30  car\n  998 │   997     38  male        2  own      little           NA                          804        12  radio/TV\n  999 │   998     23  male        2  free     little           little                     1845        45  radio/TV\n 1000 │   999     27  male        2  own      moderate         moderate                   4576        45  car\n                                                                                                              985 rows omitted","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"It is easy to compute descriptive statistics directly on individual columns using the functions defined in the Statistics module:","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"julia> using Statistics\n\njulia> mean(german.Age)\n35.546","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"If instead we want to apply some function to all columns of a data frame we can use the mapcols function. It returns a DataFrame where each column of the source data frame is transformed using a function passed as a first argument. Note that mapcols guarantees not to reuse the columns from german in the returned DataFrame. If the transformation returns its argument then it gets copied before being stored.","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"julia> mapcols(id -> id .^ 2, german)\n1000×10 DataFrame\n  Row │ id      Age    Sex           Job    Housing   Saving accounts       Ch ⋯\n      │ Int64   Int64  String        Int64  String    String                St ⋯\n──────┼─────────────────────────────────────────────────────────────────────────\n    1 │      0   4489  malemale          4  ownown    NANA                  li ⋯\n    2 │      1    484  femalefemale      4  ownown    littlelittle          mo\n    3 │      4   2401  malemale          1  ownown    littlelittle          NA\n    4 │      9   2025  malemale          4  freefree  littlelittle          li\n    5 │     16   2809  malemale          4  freefree  littlelittle          li ⋯\n    6 │     25   1225  malemale          1  freefree  NANA                  NA\n    7 │     36   2809  malemale          4  ownown    quite richquite rich  NA\n    8 │     49   1225  malemale          9  rentrent  littlelittle          mo\n  ⋮   │   ⋮       ⋮         ⋮          ⋮       ⋮               ⋮               ⋱\n  994 │ 986049    900  malemale          9  ownown    littlelittle          li ⋯\n  995 │ 988036   2500  malemale          4  ownown    NANA                  NA\n  996 │ 990025    961  femalefemale      1  ownown    littlelittle          NA\n  997 │ 992016   1600  malemale          9  ownown    littlelittle          li\n  998 │ 994009   1444  malemale          4  ownown    littlelittle          NA ⋯\n  999 │ 996004    529  malemale          4  freefree  littlelittle          li\n 1000 │ 998001    729  malemale          4  ownown    moderatemoderate      mo\n                                                  4 columns and 985 rows omitted","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"If you want to look at first and last rows of a data frame then you can do this using the first and last functions respectively:","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"julia> first(german, 6)\n6×10 DataFrame\n Row │ id     Age    Sex     Job    Housing  Saving accounts  Checking account ⋯\n     │ Int64  Int64  String  Int64  String   String           String           ⋯\n─────┼──────────────────────────────────────────────────────────────────────────\n   1 │     0     67  male        2  own      NA               little           ⋯\n   2 │     1     22  female      2  own      little           moderate\n   3 │     2     49  male        1  own      little           NA\n   4 │     3     45  male        2  free     little           little\n   5 │     4     53  male        2  free     little           little           ⋯\n   6 │     5     35  male        1  free     NA               NA\n                                                               3 columns omitted\n\njulia> last(german, 5)\n5×10 DataFrame\n Row │ id     Age    Sex     Job    Housing  Saving accounts  Checking account ⋯\n     │ Int64  Int64  String  Int64  String   String           String           ⋯\n─────┼──────────────────────────────────────────────────────────────────────────\n   1 │   995     31  female      1  own      little           NA               ⋯\n   2 │   996     40  male        3  own      little           little\n   3 │   997     38  male        2  own      little           NA\n   4 │   998     23  male        2  free     little           little\n   5 │   999     27  male        2  own      moderate         moderate         ⋯\n                                                               3 columns omitted","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"Using first and last without passing the number of rows will return a first/last DataFrameRow in the data frame. DataFrameRow is a view into a single row of an AbstractDataFrame. It stores a reference to a parent DataFrame and information about which row and columns from the parent are selected. You can think of DataFrameRow as a NamedTuple that is mutable, i.e. allows to update the source data frame, which is often useful.","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"julia> first(german)\nDataFrameRow\n Row │ id     Age    Sex     Job    Housing  Saving accounts  Checking account ⋯\n     │ Int64  Int64  String  Int64  String   String           String           ⋯\n─────┼──────────────────────────────────────────────────────────────────────────\n   1 │     0     67  male        2  own      NA               little           ⋯\n                                                               3 columns omitted\n\njulia> last(german)\nDataFrameRow\n  Row │ id     Age    Sex     Job    Housing  Saving accounts  Checking accoun ⋯\n      │ Int64  Int64  String  Int64  String   String           String          ⋯\n──────┼─────────────────────────────────────────────────────────────────────────\n 1000 │   999     27  male        2  own      moderate         moderate        ⋯\n                                                               4 columns omitted","category":"page"},{"location":"man/basics/#Getting-and-Setting-Data-in-a-Data-Frame","page":"First Steps with DataFrames.jl","title":"Getting and Setting Data in a Data Frame","text":"","category":"section"},{"location":"man/basics/#Indexing-Syntax","page":"First Steps with DataFrames.jl","title":"Indexing Syntax","text":"","category":"section"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"Data frame can be indexed in a similar way to matrices. In the Indexing section of the manual you can find all details about all the available options. Here we highlight the basic ones.","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"The general syntax fir indexing is data_frame[selected_rows, selected_columns]. Observe that, as opposed to matrices in Julia Base, it is required to always pass both row and column selector. The colon : indicates that all items (rows or columns depending on its position) should be retained. Here are a few examples:","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"julia> german[1:5, [:Sex, :Age]]\n5×2 DataFrame\n Row │ Sex     Age\n     │ String  Int64\n─────┼───────────────\n   1 │ male       67\n   2 │ female     22\n   3 │ male       49\n   4 │ male       45\n   5 │ male       53\n\njulia> german[1:5, :]\n5×10 DataFrame\n Row │ id     Age    Sex     Job    Housing  Saving accounts  Checking account ⋯\n     │ Int64  Int64  String  Int64  String   String           String           ⋯\n─────┼──────────────────────────────────────────────────────────────────────────\n   1 │     0     67  male        2  own      NA               little           ⋯\n   2 │     1     22  female      2  own      little           moderate\n   3 │     2     49  male        1  own      little           NA\n   4 │     3     45  male        2  free     little           little\n   5 │     4     53  male        2  free     little           little           ⋯\n                                                               3 columns omitted\n\njulia> german[[1, 6, 15], :]\n3×10 DataFrame\n Row │ id     Age    Sex     Job    Housing  Saving accounts  Checking account ⋯\n     │ Int64  Int64  String  Int64  String   String           String           ⋯\n─────┼──────────────────────────────────────────────────────────────────────────\n   1 │     0     67  male        2  own      NA               little           ⋯\n   2 │     5     35  male        1  free     NA               NA\n   3 │    14     28  female      2  rent     little           little\n                                                               3 columns omitted\n\njulia> german[:, [:Age, :Sex]]\n1000×2 DataFrame\n  Row │ Age    Sex\n      │ Int64  String\n──────┼───────────────\n    1 │    67  male\n    2 │    22  female\n    3 │    49  male\n    4 │    45  male\n    5 │    53  male\n    6 │    35  male\n    7 │    53  male\n    8 │    35  male\n  ⋮   │   ⋮      ⋮\n  994 │    30  male\n  995 │    50  male\n  996 │    31  female\n  997 │    40  male\n  998 │    38  male\n  999 │    23  male\n 1000 │    27  male\n      985 rows omitted","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"Pay attention that german[!, [:Sex]] and german[:, [:Sex]] returns a data frame object, while german[!, :Sex] and german[:, :Sex] returns a vector. In the first case, [:Sex] is a vector, indicating that the resulting object should be a data frame. On the other hand, :Sex is a single Symbol, indicating that a single column vector should be extracted. Note that in the first case a vector is required to be passed (not just any iterable), so e.g. german[:, (:Age, :Sex)] is not allowed, but german[:, [:Age, :Sex]] is valid. Below we show both operations to highlight this difference:","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"julia> german[!, [:Sex]]\n1000×1 DataFrame\n  Row │ Sex\n      │ String\n──────┼────────\n    1 │ male\n    2 │ female\n    3 │ male\n    4 │ male\n    5 │ male\n    6 │ male\n    7 │ male\n    8 │ male\n  ⋮   │   ⋮\n  994 │ male\n  995 │ male\n  996 │ female\n  997 │ male\n  998 │ male\n  999 │ male\n 1000 │ male\n985 rows omitted\n\njulia> german[!, :Sex]\n1000-element PooledArrays.PooledVector{String, UInt32, Vector{UInt32}}:\n \"male\"\n \"female\"\n \"male\"\n \"male\"\n \"male\"\n \"male\"\n \"male\"\n \"male\"\n \"male\"\n \"male\"\n ⋮\n \"male\"\n \"male\"\n \"male\"\n \"male\"\n \"female\"\n \"male\"\n \"male\"\n \"male\"\n \"male\"","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"As it was explained earler in this tutorial the difference between using ! and : when passing a row index is that ! does not perform a copy of columns, while : does. Therefore german[!, [:Sex]] data frame stores the same vector as the source german data frame, while german[:, [:Sex]] stores its copy.","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"The ! selector normally should be avoided as using it can lead to hard to catch bugs. However, when working with very large data frames it can be useful to save memory and improve performance of operations.","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"Recapping what we have already learned, To get the column :Age from the german data frame you can do the following:","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"to copy the vector: german[:, :Age], german[:, \"Age\"] or german[:, 2];\nto get a vector without copying: german.Age, german.\"Age\", german[:, :Age], german[:, \"Age\"] or german[:, 2].","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"To get the first two columns as a DataFrame, we can index as follows:","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"to get the copied columns: german[:, 1:2], german[:, [:id, :Age]], or german[:, [\"id\", \"Age\"]];\nto reuse the columns without copying: german[!, 1:2], german[!, [:id, :Age]], or german[!, [\"id\", \"Age\"]].","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"If you want to can get a single cell of a data frame use the same syntax as the one that gets a cell of a matrix:","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"julia> german[4, 4]\n2","category":"page"},{"location":"man/basics/#Views","page":"First Steps with DataFrames.jl","title":"Views","text":"","category":"section"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"We can also create a view of a data frame. It is often useful as it is more memory efficient than creating a materialized selection. You can create it using a view function:","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"julia> view(german, :, 2:5)\n1000×4 SubDataFrame\n  Row │ Age    Sex     Job    Housing\n      │ Int64  String  Int64  String\n──────┼───────────────────────────────\n    1 │    67  male        2  own\n    2 │    22  female      2  own\n    3 │    49  male        1  own\n    4 │    45  male        2  free\n    5 │    53  male        2  free\n    6 │    35  male        1  free\n    7 │    53  male        2  own\n    8 │    35  male        3  rent\n  ⋮   │   ⋮      ⋮       ⋮       ⋮\n  994 │    30  male        3  own\n  995 │    50  male        2  own\n  996 │    31  female      1  own\n  997 │    40  male        3  own\n  998 │    38  male        2  own\n  999 │    23  male        2  free\n 1000 │    27  male        2  own\n                      985 rows omitted","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"or using a @view macro:","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"julia> @view german[end:-1:1, [1, 4]]\n1000×2 SubDataFrame\n  Row │ id     Job\n      │ Int64  Int64\n──────┼──────────────\n    1 │   999      2\n    2 │   998      2\n    3 │   997      2\n    4 │   996      3\n    5 │   995      1\n    6 │   994      2\n    7 │   993      3\n    8 │   992      1\n  ⋮   │   ⋮      ⋮\n  994 │     6      2\n  995 │     5      1\n  996 │     4      2\n  997 │     3      2\n  998 │     2      1\n  999 │     1      2\n 1000 │     0      2\n     985 rows omitted","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"Similarly we can get a view of one column of a data frame:","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"julia> @view german[1:5, 1]\n5-element view(::Vector{Int64}, 1:5) with eltype Int64:\n 0\n 1\n 2\n 3\n 4","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"its single cell:","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"julia> @view german[2, 2]\n0-dimensional view(::Vector{Int64}, 2) with eltype Int64:\n22","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"or a single row:","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"julia> @view german[3, 2:5]\nDataFrameRow\n Row │ Age    Sex     Job    Housing\n     │ Int64  String  Int64  String\n─────┼───────────────────────────────\n   3 │    49  male        1  own","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"As you can see the row and column indexing syntax is exactly the same as for indexing. The only difference is that we do not create a new object, but a view into an existing one.","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"In order to compare the performance of indexing vs creation of a view let us run the following benchmark using the BenchmarkTools.jl package (please install it if you want to re-run this comparison):","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"julia> using BenchmarkTools\n\njulia> @btime $german[1:end-1, 1:end-1];\n  9.900 μs (44 allocations: 57.56 KiB)\n\njulia> @btime @view $german[1:end-1, 1:end-1];\n  67.332 ns (2 allocations: 32 bytes)","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"As you can see creation of a view is:","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"an order of magnitude faster;\nallocates much less memory.","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"The downside of the view is that:","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"it points to the same memory as its parent (so changing a view changes the parent, which is sometimes undesirable);\nsome operations might be a bit slower (as DataFrames.jl needs to perform a mapping of indices of a view to indices of the parent).","category":"page"},{"location":"man/basics/#Changing-the-Data-Stored-in-a-Data-Frame","page":"First Steps with DataFrames.jl","title":"Changing the Data Stored in a Data Frame","text":"","category":"section"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"In order to show how to perform mutating operations on a data frame we make a subset of a german data frame first:","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"julia> df1 = german[1:6, 2:4]\n6×3 DataFrame\n Row │ Age    Sex     Job\n     │ Int64  String  Int64\n─────┼──────────────────────\n   1 │    67  male        2\n   2 │    22  female      2\n   3 │    49  male        1\n   4 │    45  male        2\n   5 │    53  male        2\n   6 │    35  male        1","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"In the following example we replace the column :Age in our df1 data frame with a new vector:","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"julia> val = [80, 85, 98, 95, 78, 89]\n6-element Vector{Int64}:\n 80\n 85\n 98\n 95\n 78\n 89\n\njulia> df1.Age = val\n6-element Vector{Int64}:\n 80\n 85\n 98\n 95\n 78\n 89\n\njulia> df1\n6×3 DataFrame\n Row │ Age    Sex     Job\n     │ Int64  String  Int64\n─────┼──────────────────────\n   1 │    80  male        2\n   2 │    85  female      2\n   3 │    98  male        1\n   4 │    95  male        2\n   5 │    78  male        2\n   6 │    89  male        1","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"This is a non-copying operation. One can perform it only if val vector has the same length as number of rows of df1 or as a special case if df1 would not have any columns.","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"julia> df1.Age === val # no copy is performed\ntrue","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"If in indexing you select a subset of rows from a data frame the mutation is performed in place, i.e. writing to an existing vector. Below setting values of column :Job in rows 1:3 to values [2, 4, 6]:","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"julia> df1[1:3, :Job] = [2, 3, 2]\n3-element Vector{Int64}:\n 2\n 3\n 2\n\njulia> df1\n6×3 DataFrame\n Row │ Age    Sex     Job\n     │ Int64  String  Int64\n─────┼──────────────────────\n   1 │    80  male        2\n   2 │    85  female      3\n   3 │    98  male        2\n   4 │    95  male        2\n   5 │    78  male        2\n   6 │    89  male        1","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"As a special rule using ! as row selector replaces column without copying (just like in the df1.Age = val example above). For example below we replace the :Sex column:","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"julia> df1[!, :Sex] = [\"male\", \"female\", \"female\", \"transgender\", \"female\", \"male\"]\n6-element Vector{String}:\n \"male\"\n \"female\"\n \"female\"\n \"transgender\"\n \"female\"\n \"male\"\n\njulia> df1\n6×3 DataFrame\n Row │ Age    Sex          Job\n     │ Int64  String       Int64\n─────┼───────────────────────────\n   1 │    80  male             2\n   2 │    85  female           3\n   3 │    98  female           2\n   4 │    95  transgender      2\n   5 │    78  female           2\n   6 │    89  male             1","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"Similarly to setting selected rows of a single column we can also set selected columns of a given row of a data frame:","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"julia> df1[3, 1:3] = [78, \"male\", 4]\n3-element Vector{Any}:\n 78\n   \"male\"\n  4\n\njulia> df1\n6×3 DataFrame\n Row │ Age    Sex          Job\n     │ Int64  String       Int64\n─────┼───────────────────────────\n   1 │    80  male             2\n   2 │    85  female           3\n   3 │    78  male             4\n   4 │    95  transgender      2\n   5 │    78  female           2\n   6 │    89  male             1","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"We have already mentioned that DataFrameRow can be used to mutate its parent data frame. Here are a few examples:","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"julia> dfr = df1[2, :] # DataFrameRow with the second row and all columns of df1\nDataFrameRow\n Row │ Age    Sex     Job\n     │ Int64  String  Int64\n─────┼──────────────────────\n   2 │    85  female      3\n\njulia> dfr.Age = 98 # set value of col `:Age` in row `2` to `98` in-place\n98\n\njulia> dfr\nDataFrameRow\n Row │ Age    Sex     Job\n     │ Int64  String  Int64\n─────┼──────────────────────\n   2 │    98  female      3\n\njulia> dfr[2:3] = [\"male\", 2] # set values of entries in columns `:Sex` and `:Job`\n2-element Vector{Any}:\n  \"male\"\n 2\n\njulia> dfr\nDataFrameRow\n Row │ Age    Sex     Job\n     │ Int64  String  Int64\n─────┼──────────────────────\n   2 │    98  male        2","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"This operations updated the data stored in the df1 data frame.","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"In a similar fashion views can be used to update data stored in their parent data frame. Here are some examples:","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"julia> sdf = view(df1, :, 2:3)\n6×2 SubDataFrame\n Row │ Sex          Job\n     │ String       Int64\n─────┼────────────────────\n   1 │ male             2\n   2 │ male             2\n   3 │ male             4\n   4 │ transgender      2\n   5 │ female           2\n   6 │ male             1\n\njulia> sdf[2, :Sex] = \"female\" # set value of col `:Sex` in second row to `female` in-place\n\"female\"\n\njulia> sdf\n6×2 SubDataFrame\n Row │ Sex          Job\n     │ String       Int64\n─────┼────────────────────\n   1 │ male             2\n   2 │ female           2\n   3 │ male             4\n   4 │ transgender      2\n   5 │ female           2\n   6 │ male             1\n\njulia> sdf[6, 1:2] = [\"female\", 3]\n2-element Vector{Any}:\n  \"female\"\n 3\n\njulia> sdf\n6×2 SubDataFrame\n Row │ Sex          Job\n     │ String       Int64\n─────┼────────────────────\n   1 │ male             2\n   2 │ female           2\n   3 │ male             4\n   4 │ transgender      2\n   5 │ female           2\n   6 │ female           3","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"In all these cases the parent of sdf view was also updated.","category":"page"},{"location":"man/basics/#Broadcasting-Assignment","page":"First Steps with DataFrames.jl","title":"Broadcasting Assignment","text":"","category":"section"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"Apart from normal assignment one can perform broadcasting assignment using the .= operation.","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"Before we move forward let us explain how broadcasting works in Julia. The standard syntax to perform broadcasting is to use .. For example, as opposed to R this operation fails:","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"julia> s = [25, 26, 35, 56]\n4-element Vector{Int64}:\n 25\n 26\n 35\n 56\n\njulia> s[2:3] = 0\nERROR: ArgumentError: indexed assignment with a single value to many locations is not supported; perhaps use broadcasting `.=` instead?","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"Instead we have to write:","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"julia> s[2:3] .= 0\n2-element view(::Vector{Int64}, 2:3) with eltype Int64:\n 0\n 0\n\njulia> s\n4-element Vector{Int64}:\n 25\n  0\n  0\n 56","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"Similar syntax is fully supported in DataFrames.jl. Here, Column :Age is replaced freshly allocated vector because of broadcasting assignment:","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"julia> df1[!, :Age] .= [85, 89, 78, 58, 96, 68] # col `:Age` is replaced freshly allocated vector\n6-element Vector{Int64}:\n 85\n 89\n 78\n 58\n 96\n 68\n\njulia> df1\n6×3 DataFrame\n Row │ Age    Sex          Job\n     │ Int64  String       Int64\n─────┼───────────────────────────\n   1 │    85  male             2\n   2 │    89  female           2\n   3 │    78  male             4\n   4 │    58  transgender      2\n   5 │    96  female           2\n   6 │    68  female           3","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"Using the : instead of ! above would perform a broadcasting assignment in-place into an existing column. The major difference between in-place and replace operations is that replacing columns is needed if new values have a different type than the old ones.","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"In the examples below we operate on columns :Customers and :City that are not present in df1. In this case using ! and : are equivalent and a new column is allocated:","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"julia> df1[!, :Customers] .= [\"Rohit\", \"Akshat\", \"Rahul\", \"Aayush\", \"Prateek\", \"Anam\"]\n6-element Vector{String}:\n \"Rohit\"\n \"Akshat\"\n \"Rahul\"\n \"Aayush\"\n \"Prateek\"\n \"Anam\"\n\njulia> df1[:, :City] .= [\"Kanpur\", \"Lucknow\", \"Bhuvneshwar\", \"Jaipur\", \"Ranchi\", \"Dehradoon\"]\n6-element Vector{String}:\n \"Kanpur\"\n \"Lucknow\"\n \"Bhuvneshwar\"\n \"Jaipur\"\n \"Ranchi\"\n \"Dehradoon\"\n\njulia> df1\n6×5 DataFrame\n Row │ Age    Sex          Job    Customers  City\n     │ Int64  String       Int64  String     String\n─────┼───────────────────────────────────────────────────\n   1 │    85  male             2  Rohit      Kanpur\n   2 │    89  female           2  Akshat     Lucknow\n   3 │    78  male             4  Rahul      Bhuvneshwar\n   4 │    58  transgender      2  Aayush     Jaipur\n   5 │    96  female           2  Prateek    Ranchi\n   6 │    68  female           3  Anam       Dehradoon","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"A most common broadcasting assignment operation is when a scalar is used on the right hand side, e.g:","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"julia> df1[:, 3] .= 4 # an in-place replacement of values stored in column number 3 by 4\n6-element view(::Vector{Int64}, :) with eltype Int64:\n 4\n 4\n 4\n 4\n 4\n 4\n\njulia> df1\n6×5 DataFrame\n Row │ Age    Sex          Job    Customers  City\n     │ Int64  String       Int64  String     String\n─────┼───────────────────────────────────────────────────\n   1 │    85  male             4  Rohit      Kanpur\n   2 │    89  female           4  Akshat     Lucknow\n   3 │    78  male             4  Rahul      Bhuvneshwar\n   4 │    58  transgender      4  Aayush     Jaipur\n   5 │    96  female           4  Prateek    Ranchi\n   6 │    68  female           4  Anam       Dehradoon","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"For : row selector the broadcasting assignment operation works in-place, so the following operation throws an error:","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"julia> df1[:, :Age] .= \"Economics\"\nERROR: MethodError: Cannot `convert` an object of type String to an object of type Int64","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"We need to use ! instead as it replaces the old vector with a freshly allocated one:","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"julia> df1[!, :Age] .= \"Economics\"\n6-element Vector{String}:\n \"Economics\"\n \"Economics\"\n \"Economics\"\n \"Economics\"\n \"Economics\"\n \"Economics\"\n\njulia> df1\n6×5 DataFrame\n Row │ Age        Sex          Job    Customers  City\n     │ String     String       Int64  String     String\n─────┼───────────────────────────────────────────────────────\n   1 │ Economics  male             4  Rohit      Kanpur\n   2 │ Economics  female           4  Akshat     Lucknow\n   3 │ Economics  male             4  Rahul      Bhuvneshwar\n   4 │ Economics  transgender      4  Aayush     Jaipur\n   5 │ Economics  female           4  Prateek    Ranchi\n   6 │ Economics  female           4  Anam       Dehradoon","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"There are some scenarios in DataFrames.jl, when we naturally want a broadcasting-like behaviour, but do not allow for the use of . operation. In such cases a so-called pseudo-broadcasting is performed for user convenience. We have already seen it in examples of DataFrame constructor. Below we show pseudo-broadcasting at work in the insertcols! function, that inserts a column into a data frame in an arbitrary position.","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"In the example below we are creating a column :Country with the insertcols! function. Since we pass a scalar \"India\" value of the column it is broadcasted to all rows in the output data frame:","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"julia> insertcols!(df1, 1, :Country => \"India\")\n6×6 DataFrame\n Row │ Country  Age        Sex          Job    Customers  City\n     │ String   String     String       Int64  String     String\n─────┼────────────────────────────────────────────────────────────────\n   1 │ India    Economics  male             4  Rohit      Kanpur\n   2 │ India    Economics  female           4  Akshat     Lucknow\n   3 │ India    Economics  male             4  Rahul      Bhuvneshwar\n   4 │ India    Economics  transgender      4  Aayush     Jaipur\n   5 │ India    Economics  female           4  Prateek    Ranchi\n   6 │ India    Economics  female           4  Anam       Dehradoon","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"You can pass a column location where you want to put the inserted column as a second argument to the insertcols! function:","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"julia> insertcols!(df1, 4, :b => exp(4))\n6×7 DataFrame\n Row │ Country  Age        Sex          b        Job    Customers  City        ⋯\n     │ String   String     String       Float64  Int64  String     String      ⋯\n─────┼──────────────────────────────────────────────────────────────────────────\n   1 │ India    Economics  male         54.5982      4  Rohit      Kanpur      ⋯\n   2 │ India    Economics  female       54.5982      4  Akshat     Lucknow\n   3 │ India    Economics  male         54.5982      4  Rahul      Bhuvneshwar\n   4 │ India    Economics  transgender  54.5982      4  Aayush     Jaipur\n   5 │ India    Economics  female       54.5982      4  Prateek    Ranchi      ⋯\n   6 │ India    Economics  female       54.5982      4  Anam       Dehradoon","category":"page"},{"location":"man/basics/#Not,-Between,-Cols,-and-All-Column-Selectors","page":"First Steps with DataFrames.jl","title":"Not, Between, Cols, and All Column Selectors","text":"","category":"section"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"You can use Not, Between, Cols, and All selectors in more complex column selection scenarios:","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"Not selector (from the InvertedIndices.jl package) allows us to specify the columns we want to exclude from the resulting data frame. We can put any valid other column selector inside Not;\nBetween selector allows us to specify a range of columns (we can pass the start and stop column using any of the single column selector syntaxes);\nCols(...) selector picks a union of other selectors passed as its arguments;\nAll() allows us to select all columns of DataFrame; this is the same as passing :;\nregular expression to select columns whose names match it.","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"Let us give some examples of these selectors.","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"Drop :Age column:","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"julia> german[:, Not(:Age)]\n1000×9 DataFrame\n  Row │ id     Sex     Job    Housing  Saving accounts  Checking account  Cred ⋯\n      │ Int64  String  Int64  String   String           String            Int6 ⋯\n──────┼─────────────────────────────────────────────────────────────────────────\n    1 │     0  male        2  own      NA               little                 ⋯\n    2 │     1  female      2  own      little           moderate\n    3 │     2  male        1  own      little           NA\n    4 │     3  male        2  free     little           little\n    5 │     4  male        2  free     little           little                 ⋯\n    6 │     5  male        1  free     NA               NA\n    7 │     6  male        2  own      quite rich       NA\n    8 │     7  male        3  rent     little           moderate\n  ⋮   │   ⋮      ⋮       ⋮       ⋮            ⋮                ⋮               ⋱\n  994 │   993  male        3  own      little           little                 ⋯\n  995 │   994  male        2  own      NA               NA\n  996 │   995  female      1  own      little           NA\n  997 │   996  male        3  own      little           little\n  998 │   997  male        2  own      little           NA                     ⋯\n  999 │   998  male        2  free     little           little\n 1000 │   999  male        2  own      moderate         moderate\n                                                  3 columns and 985 rows omitted","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"Select columns starting from :Sex and ending at :Housing:","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"julia> german[:, Between(:Sex, :Housing)]\n1000×3 DataFrame\n  Row │ Sex     Job    Housing\n      │ String  Int64  String\n──────┼────────────────────────\n    1 │ male        2  own\n    2 │ female      2  own\n    3 │ male        1  own\n    4 │ male        2  free\n    5 │ male        2  free\n    6 │ male        1  free\n    7 │ male        2  own\n    8 │ male        3  rent\n  ⋮   │   ⋮       ⋮       ⋮\n  994 │ male        3  own\n  995 │ male        2  own\n  996 │ female      1  own\n  997 │ male        3  own\n  998 │ male        2  own\n  999 │ male        2  free\n 1000 │ male        2  own\n               985 rows omitted","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"In the example below Cols selector is picking a union of \"Age\" and Between(\"Sex\", \"Job\") selectors passed as its arguments:","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"julia> german[:, Cols(\"Age\", Between(\"Sex\", \"Job\"))]\n1000×3 DataFrame\n  Row │ Age    Sex     Job\n      │ Int64  String  Int64\n──────┼──────────────────────\n    1 │    67  male        2\n    2 │    22  female      2\n    3 │    49  male        1\n    4 │    45  male        2\n    5 │    53  male        2\n    6 │    35  male        1\n    7 │    53  male        2\n    8 │    35  male        3\n  ⋮   │   ⋮      ⋮       ⋮\n  994 │    30  male        3\n  995 │    50  male        2\n  996 │    31  female      1\n  997 │    40  male        3\n  998 │    38  male        2\n  999 │    23  male        2\n 1000 │    27  male        2\n             985 rows omitted","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"You can also use Regex (regular expressions) to select columns. In the example below we select columns that have \"S\" in their name and also we use Not to drop row number 5:","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"julia> german[Not(5), r\"S\"]\n999×2 DataFrame\n Row │ Sex     Saving accounts\n     │ String  String\n─────┼─────────────────────────\n   1 │ male    NA\n   2 │ female  little\n   3 │ male    little\n   4 │ male    little\n   5 │ male    NA\n   6 │ male    quite rich\n   7 │ male    little\n   8 │ male    rich\n  ⋮  │   ⋮            ⋮\n 993 │ male    little\n 994 │ male    NA\n 995 │ female  little\n 996 │ male    little\n 997 │ male    little\n 998 │ male    little\n 999 │ male    moderate\n               984 rows omitted","category":"page"},{"location":"man/basics/#Basic-Usage-of-Transformation-Functions","page":"First Steps with DataFrames.jl","title":"Basic Usage of Transformation Functions","text":"","category":"section"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"In DataFrames.jl we have five functions that we can be used to perform transformations of columns of a data frame:","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"combine: creates a new data frame populated with columns that are results of transformation applied to the source data frame columns, potentially combining its rows;\nselect: creates a new data frame that has the same number of rows as the source data frame populated with columns that are results of transformations applied to the source data frame columns;\nselect!: the same as select but updates the passed data frame in place;\ntransform: the same as select but keeps the columns that were already present in the data frame (note though that these columns can be potentially modified by the transformation passed to transform);\ntransform!: the same as transform but updates the passed data frame in place.","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"The fundamental ways to specify a transformation are:","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"source_column => transformation => target_column_name; In this scenario the source_column is passed as an argument to transformation function and stored in target_column_name column.\nsource_column => transformation; In this scenario we apply the transformation function to source_column and the target column names is automatically generated.\nsource_column => target_column_name renames the source_column to target_column_name.\nsource_column just keep the source column as is in the result without any transformation;","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"These rules are typically called transformation mini-language.","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"Let us move to the examples of application of these rules","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"julia> using Statistics\n\njulia> combine(german, :Age => mean => :mean_age)\n1×1 DataFrame\n Row │ mean_age\n     │ Float64\n─────┼──────────\n   1 │   35.546\n\njulia> select(german, :Age => mean => :mean_age)\n1000×1 DataFrame\n  Row │ mean_age\n      │ Float64\n──────┼──────────\n    1 │   35.546\n    2 │   35.546\n    3 │   35.546\n    4 │   35.546\n    5 │   35.546\n    6 │   35.546\n    7 │   35.546\n    8 │   35.546\n  ⋮   │    ⋮\n  994 │   35.546\n  995 │   35.546\n  996 │   35.546\n  997 │   35.546\n  998 │   35.546\n  999 │   35.546\n 1000 │   35.546\n 985 rows omitted","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"As you can see in both cases the mean function was applied to :Age column and the result was stored in the :mean_age column. The difference between the combine and select functions is that the combine aggregates data and produces as many rows as were returned by the transformation function. On the other hand the select function always keeps the number of rows in a data frame to be the same as in the source data frame. Therefore in this case the result of the mean function got broadcasted.","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"As combine potentially allows any number of rows to be produced as a result of the transformation if we have a combination of transformations where some of them produce a vector, and other produce scalars then scalars get broadcasted exactly like in  select. Here is an example:","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"julia> combine(german, :Age => mean => :mean_age, :Housing => unique => :housing)\n3×2 DataFrame\n Row │ mean_age  housing\n     │ Float64   String\n─────┼───────────────────\n   1 │   35.546  own\n   2 │   35.546  free\n   3 │   35.546  rent","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"Note, however, that it is not allowed to return vectors of different lengths in different transformations:","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"julia> combine(german, :Age, :Housing => unique => :Housing)\nERROR: ArgumentError: New columns must have the same length as old columns","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"Let us discuss some other examples using select. Often we want to apply some function not to the whole column of a data frame, but rather to its individual elements. Normally we can achieve this using broadcasting like this:","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"julia> select(german, :Sex => (x -> uppercase.(x)) => :Sex)\n1000×1 DataFrame\n  Row │ Sex\n      │ String\n──────┼────────\n    1 │ MALE\n    2 │ FEMALE\n    3 │ MALE\n    4 │ MALE\n    5 │ MALE\n    6 │ MALE\n    7 │ MALE\n    8 │ MALE\n  ⋮   │   ⋮\n  994 │ MALE\n  995 │ MALE\n  996 │ FEMALE\n  997 │ MALE\n  998 │ MALE\n  999 │ MALE\n 1000 │ MALE\n985 rows omitted","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"This pattern is encountered very often in practice, therefore there is a ByRow convenience wrapper for a function that creates its broadcasted variant. In these examples ByRow is a special type used for selection operations to signal that the wrapped function should be applied to each element (row) of the selection. Here we are passing ByRow wrapper to target column name :Sex using uppercase function:","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"julia> select(german, :Sex => ByRow(uppercase) => :SEX)\n1000×1 DataFrame\n  Row │ SEX\n      │ String\n──────┼────────\n    1 │ MALE\n    2 │ FEMALE\n    3 │ MALE\n    4 │ MALE\n    5 │ MALE\n    6 │ MALE\n    7 │ MALE\n    8 │ MALE\n  ⋮   │   ⋮\n  994 │ MALE\n  995 │ MALE\n  996 │ FEMALE\n  997 │ MALE\n  998 │ MALE\n  999 │ MALE\n 1000 │ MALE\n985 rows omitted","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"In this case we transform our source column :Age using ByRow wrapper and automatically generate the target column name:","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"julia> select(german, :Age, :Age => ByRow(sqrt))\n1000×2 DataFrame\n  Row │ Age    Age_sqrt\n      │ Int64  Float64\n──────┼─────────────────\n    1 │    67   8.18535\n    2 │    22   4.69042\n    3 │    49   7.0\n    4 │    45   6.7082\n    5 │    53   7.28011\n    6 │    35   5.91608\n    7 │    53   7.28011\n    8 │    35   5.91608\n  ⋮   │   ⋮       ⋮\n  994 │    30   5.47723\n  995 │    50   7.07107\n  996 │    31   5.56776\n  997 │    40   6.32456\n  998 │    38   6.16441\n  999 │    23   4.79583\n 1000 │    27   5.19615\n        985 rows omitted","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"When we pass just a column (without the => part) we can use any column selector that is allowed in indexing. Here we exclude the column :Age from the resulting data frame:","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"julia> select(german, Not(:Age))\n1000×9 DataFrame\n  Row │ id     Sex     Job    Housing  Saving accounts  Checking account  Cred ⋯\n      │ Int64  String  Int64  String   String           String            Int6 ⋯\n──────┼─────────────────────────────────────────────────────────────────────────\n    1 │     0  male        2  own      NA               little                 ⋯\n    2 │     1  female      2  own      little           moderate\n    3 │     2  male        1  own      little           NA\n    4 │     3  male        2  free     little           little\n    5 │     4  male        2  free     little           little                 ⋯\n    6 │     5  male        1  free     NA               NA\n    7 │     6  male        2  own      quite rich       NA\n    8 │     7  male        3  rent     little           moderate\n  ⋮   │   ⋮      ⋮       ⋮       ⋮            ⋮                ⋮               ⋱\n  994 │   993  male        3  own      little           little                 ⋯\n  995 │   994  male        2  own      NA               NA\n  996 │   995  female      1  own      little           NA\n  997 │   996  male        3  own      little           little\n  998 │   997  male        2  own      little           NA                     ⋯\n  999 │   998  male        2  free     little           little\n 1000 │   999  male        2  own      moderate         moderate\n                                                  3 columns and 985 rows omitted","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"In order to select a column we just passed them as argument. As another example let us present that the r\"S\" regular expression we used above also works as we have described above:","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"julia> select(german, r\"S\")\n1000×2 DataFrame\n  Row │ Sex     Saving accounts\n      │ String  String\n──────┼─────────────────────────\n    1 │ male    NA\n    2 │ female  little\n    3 │ male    little\n    4 │ male    little\n    5 │ male    little\n    6 │ male    NA\n    7 │ male    quite rich\n    8 │ male    little\n  ⋮   │   ⋮            ⋮\n  994 │ male    little\n  995 │ male    NA\n  996 │ female  little\n  997 │ male    little\n  998 │ male    little\n  999 │ male    little\n 1000 │ male    moderate\n                985 rows omitted","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"The benefit of select or combine over indexing is that it is easier to combine several column selectors, e.g.:","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"julia> select(german, r\"S\", \"Job\", 1)\n1000×4 DataFrame\n  Row │ Sex     Saving accounts  Job    id\n      │ String  String           Int64  Int64\n──────┼───────────────────────────────────────\n    1 │ male    NA                   2      0\n    2 │ female  little               2      1\n    3 │ male    little               1      2\n    4 │ male    little               2      3\n    5 │ male    little               2      4\n    6 │ male    NA                   1      5\n    7 │ male    quite rich           2      6\n    8 │ male    little               3      7\n  ⋮   │   ⋮            ⋮           ⋮      ⋮\n  994 │ male    little               3    993\n  995 │ male    NA                   2    994\n  996 │ female  little               1    995\n  997 │ male    little               3    996\n  998 │ male    little               2    997\n  999 │ male    little               2    998\n 1000 │ male    moderate             2    999\n                              985 rows omitted","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"Taking advantage of this flexibility here is an idiomatic pattern to move some column to the front of a data frame:","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"julia> select(german, \"Sex\", :)\n1000×10 DataFrame\n  Row │ Sex     id     Age    Job    Housing  Saving accounts  Checking accoun ⋯\n      │ String  Int64  Int64  Int64  String   String           String          ⋯\n──────┼─────────────────────────────────────────────────────────────────────────\n    1 │ male        0     67      2  own      NA               little          ⋯\n    2 │ female      1     22      2  own      little           moderate\n    3 │ male        2     49      1  own      little           NA\n    4 │ male        3     45      2  free     little           little\n    5 │ male        4     53      2  free     little           little          ⋯\n    6 │ male        5     35      1  free     NA               NA\n    7 │ male        6     53      2  own      quite rich       NA\n    8 │ male        7     35      3  rent     little           moderate\n  ⋮   │   ⋮       ⋮      ⋮      ⋮       ⋮            ⋮                ⋮        ⋱\n  994 │ male      993     30      3  own      little           little          ⋯\n  995 │ male      994     50      2  own      NA               NA\n  996 │ female    995     31      1  own      little           NA\n  997 │ male      996     40      3  own      little           little\n  998 │ male      997     38      2  own      little           NA              ⋯\n  999 │ male      998     23      2  free     little           little\n 1000 │ male      999     27      2  own      moderate         moderate\n                                                  4 columns and 985 rows omitted","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"Below, we are simply passing source column and target column name to rename them (without specifying the transformation part):","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"julia> select(german, :Sex => :x1, :Age => :x2)\n1000×2 DataFrame\n  Row │ x1      x2\n      │ String  Int64\n──────┼───────────────\n    1 │ male       67\n    2 │ female     22\n    3 │ male       49\n    4 │ male       45\n    5 │ male       53\n    6 │ male       35\n    7 │ male       53\n    8 │ male       35\n  ⋮   │   ⋮       ⋮\n  994 │ male       30\n  995 │ male       50\n  996 │ female     31\n  997 │ male       40\n  998 │ male       38\n  999 │ male       23\n 1000 │ male       27\n      985 rows omitted","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"It is important to note that select always returns a data frame, even if a single column selected as opposed to indexing syntax. Compare the following:","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"julia> select(german, :Age)\n1000×1 DataFrame\n  Row │ Age\n      │ Int64\n──────┼───────\n    1 │    67\n    2 │    22\n    3 │    49\n    4 │    45\n    5 │    53\n    6 │    35\n    7 │    53\n    8 │    35\n  ⋮   │   ⋮\n  994 │    30\n  995 │    50\n  996 │    31\n  997 │    40\n  998 │    38\n  999 │    23\n 1000 │    27\n985 rows omitted\n\njulia> german[:, :Age]\n1000-element Vector{Int64}:\n 67\n 22\n 49\n 45\n 53\n 35\n 53\n 35\n 61\n 28\n  ⋮\n 34\n 23\n 30\n 50\n 31\n 40\n 38\n 23\n 27","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"By default select copies columns of a passed source data frame. In order to avoid copying, pass the copycols=false keyword argument:","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"julia> df = select(german, :Sex)\n1000×1 DataFrame\n  Row │ Sex\n      │ String\n──────┼────────\n    1 │ male\n    2 │ female\n    3 │ male\n    4 │ male\n    5 │ male\n    6 │ male\n    7 │ male\n    8 │ male\n  ⋮   │   ⋮\n  994 │ male\n  995 │ male\n  996 │ female\n  997 │ male\n  998 │ male\n  999 │ male\n 1000 │ male\n985 rows omitted\n\njulia> df.Sex === german.Sex # copy\nfalse\n\njulia> df = select(german, :Sex, copycols=false)\n1000×1 DataFrame\n  Row │ Sex\n      │ String\n──────┼────────\n    1 │ male\n    2 │ female\n    3 │ male\n    4 │ male\n    5 │ male\n    6 │ male\n    7 │ male\n    8 │ male\n  ⋮   │   ⋮\n  994 │ male\n  995 │ male\n  996 │ female\n  997 │ male\n  998 │ male\n  999 │ male\n 1000 │ male\n985 rows omitted\n\njulia> df.Sex === german.Sex # no-copy is performed\ntrue","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"To perform the selection operation in-place use select!:","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"julia> select!(german, Not(:Age));\n\njulia> german\n1000×9 DataFrame\n  Row │ id     Sex     Job    Housing  Saving accounts  Checking account  Cred ⋯\n      │ Int64  String  Int64  String   String           String            Int6 ⋯\n──────┼─────────────────────────────────────────────────────────────────────────\n    1 │     0  male        2  own      NA               little                 ⋯\n    2 │     1  female      2  own      little           moderate\n    3 │     2  male        1  own      little           NA\n    4 │     3  male        2  free     little           little\n    5 │     4  male        2  free     little           little                 ⋯\n    6 │     5  male        1  free     NA               NA\n    7 │     6  male        2  own      quite rich       NA\n    8 │     7  male        3  rent     little           moderate\n  ⋮   │   ⋮      ⋮       ⋮       ⋮            ⋮                ⋮               ⋱\n  994 │   993  male        3  own      little           little                 ⋯\n  995 │   994  male        2  own      NA               NA\n  996 │   995  female      1  own      little           NA\n  997 │   996  male        3  own      little           little\n  998 │   997  male        2  own      little           NA                     ⋯\n  999 │   998  male        2  free     little           little\n 1000 │   999  male        2  own      moderate         moderate\n                                                  3 columns and 985 rows omitted","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"As you can see the :Age column was dropped from the german data frame.","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"The transform and transform! functions work identically to select and select! with the only difference that they retain all columns that are present in the source data frame. Here are some examples:","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"julia> german = copy(german_ref);\n\njulia> df = german_ref[1:8, 1:5]\n8×5 DataFrame\n Row │ id     Age    Sex     Job    Housing\n     │ Int64  Int64  String  Int64  String\n─────┼──────────────────────────────────────\n   1 │     0     67  male        2  own\n   2 │     1     22  female      2  own\n   3 │     2     49  male        1  own\n   4 │     3     45  male        2  free\n   5 │     4     53  male        2  free\n   6 │     5     35  male        1  free\n   7 │     6     53  male        2  own\n   8 │     7     35  male        3  rent\n\njulia> transform(df, :Age => maximum)\n8×6 DataFrame\n Row │ id     Age    Sex     Job    Housing  Age_maximum\n     │ Int64  Int64  String  Int64  String   Int64\n─────┼───────────────────────────────────────────────────\n   1 │     0     67  male        2  own               67\n   2 │     1     22  female      2  own               67\n   3 │     2     49  male        1  own               67\n   4 │     3     45  male        2  free              67\n   5 │     4     53  male        2  free              67\n   6 │     5     35  male        1  free              67\n   7 │     6     53  male        2  own               67\n   8 │     7     35  male        3  rent              67","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"In the example below we are swapping values stored in columns :Sex and :Age:","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"julia> transform(german, :Age => :Sex, :Sex => :Age)\n1000×10 DataFrame\n  Row │ id     Age     Sex    Job    Housing  Saving accounts  Checking accoun ⋯\n      │ Int64  String  Int64  Int64  String   String           String          ⋯\n──────┼─────────────────────────────────────────────────────────────────────────\n    1 │     0  male       67      2  own      NA               little          ⋯\n    2 │     1  female     22      2  own      little           moderate\n    3 │     2  male       49      1  own      little           NA\n    4 │     3  male       45      2  free     little           little\n    5 │     4  male       53      2  free     little           little          ⋯\n    6 │     5  male       35      1  free     NA               NA\n    7 │     6  male       53      2  own      quite rich       NA\n    8 │     7  male       35      3  rent     little           moderate\n  ⋮   │   ⋮      ⋮       ⋮      ⋮       ⋮            ⋮                ⋮        ⋱\n  994 │   993  male       30      3  own      little           little          ⋯\n  995 │   994  male       50      2  own      NA               NA\n  996 │   995  female     31      1  own      little           NA\n  997 │   996  male       40      3  own      little           little\n  998 │   997  male       38      2  own      little           NA              ⋯\n  999 │   998  male       23      2  free     little           little\n 1000 │   999  male       27      2  own      moderate         moderate\n                                                  4 columns and 985 rows omitted","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"If we give more than one source column to a transformation they are passed as consecutive positional arguments. So for example the [:Age, :Job] => (+) => :res transformation below evaluates +(df1.Age, df1.Job) (which adds two columns) and stores the result in the :res column:","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"julia> select(german, :Age, :Job, [:Age, :Job] => (+) => :res)\n1000×3 DataFrame\n  Row │ Age    Job    res\n      │ Int64  Int64  Int64\n──────┼─────────────────────\n    1 │    67      2     69\n    2 │    22      2     24\n    3 │    49      1     50\n    4 │    45      2     47\n    5 │    53      2     55\n    6 │    35      1     36\n    7 │    53      2     55\n    8 │    35      3     38\n  ⋮   │   ⋮      ⋮      ⋮\n  994 │    30      3     33\n  995 │    50      2     52\n  996 │    31      1     32\n  997 │    40      3     43\n  998 │    38      2     40\n  999 │    23      2     25\n 1000 │    27      2     29\n            985 rows omitted","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"In the examples given in this introductory tutorial we did not cover all options of the transformation mini-language. More advanced examples, in particular showing how to pass or produce multiple columns using the AsTable operation (which you might have seen in some DataFrames.jl demos) are given in the later sections of the manual.","category":"page"},{"location":"man/importing_and_exporting/#Importing-and-Exporting-Data-(I/O)","page":"Importing and Exporting Data (I/O)","title":"Importing and Exporting Data (I/O)","text":"","category":"section"},{"location":"man/importing_and_exporting/#CSV-Files","page":"Importing and Exporting Data (I/O)","title":"CSV Files","text":"","category":"section"},{"location":"man/importing_and_exporting/","page":"Importing and Exporting Data (I/O)","title":"Importing and Exporting Data (I/O)","text":"For reading and writing tabular data from CSV and other delimited text files, use the CSV.jl package.","category":"page"},{"location":"man/importing_and_exporting/","page":"Importing and Exporting Data (I/O)","title":"Importing and Exporting Data (I/O)","text":"If you have not used the CSV.jl package before then you may need to install it first:","category":"page"},{"location":"man/importing_and_exporting/","page":"Importing and Exporting Data (I/O)","title":"Importing and Exporting Data (I/O)","text":"using Pkg\nPkg.add(\"CSV\")","category":"page"},{"location":"man/importing_and_exporting/","page":"Importing and Exporting Data (I/O)","title":"Importing and Exporting Data (I/O)","text":"The CSV.jl functions are not loaded automatically and must be imported into the session.","category":"page"},{"location":"man/importing_and_exporting/","page":"Importing and Exporting Data (I/O)","title":"Importing and Exporting Data (I/O)","text":"using CSV","category":"page"},{"location":"man/importing_and_exporting/","page":"Importing and Exporting Data (I/O)","title":"Importing and Exporting Data (I/O)","text":"A dataset can now be read from a CSV file at path input using","category":"page"},{"location":"man/importing_and_exporting/","page":"Importing and Exporting Data (I/O)","title":"Importing and Exporting Data (I/O)","text":"DataFrame(CSV.File(input))","category":"page"},{"location":"man/importing_and_exporting/","page":"Importing and Exporting Data (I/O)","title":"Importing and Exporting Data (I/O)","text":"A DataFrame can be written to a CSV file at path output using","category":"page"},{"location":"man/importing_and_exporting/","page":"Importing and Exporting Data (I/O)","title":"Importing and Exporting Data (I/O)","text":"df = DataFrame(x = 1, y = 2)\nCSV.write(output, df)","category":"page"},{"location":"man/importing_and_exporting/","page":"Importing and Exporting Data (I/O)","title":"Importing and Exporting Data (I/O)","text":"The behavior of CSV functions can be adapted via keyword arguments. For more information, see ?CSV.File, ?CSV.read and ?CSV.write, or checkout the online CSV.jl documentation.","category":"page"},{"location":"man/importing_and_exporting/","page":"Importing and Exporting Data (I/O)","title":"Importing and Exporting Data (I/O)","text":"In simple cases, when compilation latency of CSV.jl might be an issue, using the DelimitedFiles module from the Julia standard library can be considered. Here is an example showing how to read in the data and perform its post-processing:","category":"page"},{"location":"man/importing_and_exporting/","page":"Importing and Exporting Data (I/O)","title":"Importing and Exporting Data (I/O)","text":"julia> using DelimitedFiles, DataFrames\n\njulia> data, header = readdlm(joinpath(dirname(pathof(DataFrames)),\n                                       \"..\", \"docs\", \"src\", \"assets\", \"iris.csv\"),\n                              ',', header=true);\n\njulia> iris_raw = DataFrame(data, vec(header))\n150×5 DataFrame\n Row │ SepalLength  SepalWidth  PetalLength  PetalWidth  Species\n     │ Any          Any         Any          Any         Any\n─────┼──────────────────────────────────────────────────────────────────\n   1 │ 5.1          3.5         1.4          0.2         Iris-setosa\n   2 │ 4.9          3.0         1.4          0.2         Iris-setosa\n   3 │ 4.7          3.2         1.3          0.2         Iris-setosa\n   4 │ 4.6          3.1         1.5          0.2         Iris-setosa\n   5 │ 5.0          3.6         1.4          0.2         Iris-setosa\n   6 │ 5.4          3.9         1.7          0.4         Iris-setosa\n   7 │ 4.6          3.4         1.4          0.3         Iris-setosa\n   8 │ 5.0          3.4         1.5          0.2         Iris-setosa\n  ⋮  │      ⋮           ⋮            ⋮           ⋮             ⋮\n 144 │ 6.8          3.2         5.9          2.3         Iris-virginica\n 145 │ 6.7          3.3         5.7          2.5         Iris-virginica\n 146 │ 6.7          3.0         5.2          2.3         Iris-virginica\n 147 │ 6.3          2.5         5.0          1.9         Iris-virginica\n 148 │ 6.5          3.0         5.2          2.0         Iris-virginica\n 149 │ 6.2          3.4         5.4          2.3         Iris-virginica\n 150 │ 5.9          3.0         5.1          1.8         Iris-virginica\n                                                        135 rows omitted\n\njulia> iris = identity.(iris_raw)\n150×5 DataFrame\n Row │ SepalLength  SepalWidth  PetalLength  PetalWidth  Species\n     │ Float64      Float64     Float64      Float64     SubStrin…\n─────┼──────────────────────────────────────────────────────────────────\n   1 │         5.1         3.5          1.4         0.2  Iris-setosa\n   2 │         4.9         3.0          1.4         0.2  Iris-setosa\n   3 │         4.7         3.2          1.3         0.2  Iris-setosa\n   4 │         4.6         3.1          1.5         0.2  Iris-setosa\n   5 │         5.0         3.6          1.4         0.2  Iris-setosa\n   6 │         5.4         3.9          1.7         0.4  Iris-setosa\n   7 │         4.6         3.4          1.4         0.3  Iris-setosa\n   8 │         5.0         3.4          1.5         0.2  Iris-setosa\n  ⋮  │      ⋮           ⋮            ⋮           ⋮             ⋮\n 144 │         6.8         3.2          5.9         2.3  Iris-virginica\n 145 │         6.7         3.3          5.7         2.5  Iris-virginica\n 146 │         6.7         3.0          5.2         2.3  Iris-virginica\n 147 │         6.3         2.5          5.0         1.9  Iris-virginica\n 148 │         6.5         3.0          5.2         2.0  Iris-virginica\n 149 │         6.2         3.4          5.4         2.3  Iris-virginica\n 150 │         5.9         3.0          5.1         1.8  Iris-virginica\n                                                        135 rows omitted","category":"page"},{"location":"man/importing_and_exporting/","page":"Importing and Exporting Data (I/O)","title":"Importing and Exporting Data (I/O)","text":"Observe that in our example:","category":"page"},{"location":"man/importing_and_exporting/","page":"Importing and Exporting Data (I/O)","title":"Importing and Exporting Data (I/O)","text":"header is a Matrix therefore we had to pass vec(header) to the DataFrame constructor;\nwe broadcasted the identity function over the iris_raw data frame to perform narrowing of eltype of columns of iris_raw; the reason is that read in by the readdlm function is stored into a data Matrix so all columns in iris_raw initially have the same eltype – in this case it had to be Any as some of the columns are numeric and some are string.","category":"page"},{"location":"man/importing_and_exporting/","page":"Importing and Exporting Data (I/O)","title":"Importing and Exporting Data (I/O)","text":"All such operations (and many more) are automatically handled by CSV.jl.","category":"page"},{"location":"man/importing_and_exporting/","page":"Importing and Exporting Data (I/O)","title":"Importing and Exporting Data (I/O)","text":"Similarly, you can use the writedlm function from the DelimitedFiles module to save a data frame like this:","category":"page"},{"location":"man/importing_and_exporting/","page":"Importing and Exporting Data (I/O)","title":"Importing and Exporting Data (I/O)","text":"writedlm(\"test.csv\", Iterators.flatten(([names(iris)], eachrow(iris))), ',')","category":"page"},{"location":"man/importing_and_exporting/","page":"Importing and Exporting Data (I/O)","title":"Importing and Exporting Data (I/O)","text":"As you can see the code required to transform iris into a proper input to the writedlm function so that you can create the CSV file having the expected format is not easy. Therefore CSV.jl is the preferred package to write CSV files for data stored in data frames.","category":"page"},{"location":"man/importing_and_exporting/#Other-formats","page":"Importing and Exporting Data (I/O)","title":"Other formats","text":"","category":"section"},{"location":"man/importing_and_exporting/","page":"Importing and Exporting Data (I/O)","title":"Importing and Exporting Data (I/O)","text":"Other data formats are supported for reading and writing in the following packages (non exhaustive list):","category":"page"},{"location":"man/importing_and_exporting/","page":"Importing and Exporting Data (I/O)","title":"Importing and Exporting Data (I/O)","text":"Apache Arrow (including Feather v2): Arrow.jl\nApache Feather (v1): Feather.jl\nApache Avro: Avro.jl\nJSON: JSONTables.jl\nParquet: Parquet.jl\nStata, SPSS, and SAS: StatFiles.jl\nMicrosoft Excel (XLSX): XLSX.jl","category":"page"},{"location":"man/querying_frameworks/#Data-manipulation-frameworks","page":"Data manipulation frameworks","title":"Data manipulation frameworks","text":"","category":"section"},{"location":"man/querying_frameworks/","page":"Data manipulation frameworks","title":"Data manipulation frameworks","text":"Two popular frameworks provide convenience methods to manipulate DataFrames: DataFramesMeta.jl and Query.jl. They implement a functionality similar to dplyr or LINQ.","category":"page"},{"location":"man/querying_frameworks/#DataFramesMeta.jl","page":"Data manipulation frameworks","title":"DataFramesMeta.jl","text":"","category":"section"},{"location":"man/querying_frameworks/","page":"Data manipulation frameworks","title":"Data manipulation frameworks","text":"The DataFramesMeta.jl package provides a convenient yet fast macro-based interface to work with DataFrames. The instructions below are for version 0.6.0 of DataFramesMeta.jl.","category":"page"},{"location":"man/querying_frameworks/","page":"Data manipulation frameworks","title":"Data manipulation frameworks","text":"First install the DataFramesMeta.jl package:","category":"page"},{"location":"man/querying_frameworks/","page":"Data manipulation frameworks","title":"Data manipulation frameworks","text":"using Pkg\nPkg.add(\"DataFramesMeta\")","category":"page"},{"location":"man/querying_frameworks/","page":"Data manipulation frameworks","title":"Data manipulation frameworks","text":"The major benefit of the package is that it allows you to refer to columns of a DataFrame as Symbols. Therefore instead of writing verylongdataframename.variable you can simply write :variable in expressions. Additionally you can chain a sequence of transformations of a DataFrame using the @linq macro.","category":"page"},{"location":"man/querying_frameworks/","page":"Data manipulation frameworks","title":"Data manipulation frameworks","text":"When a DataFramesMeta.jl macro such as @select, @transform, @by, @combine,  @where, or @orderby is called inside a @linq block, you can omit the @. Therefore transform inside @linq is not the same as transform outside of a @linq block. ","category":"page"},{"location":"man/querying_frameworks/","page":"Data manipulation frameworks","title":"Data manipulation frameworks","text":"Here is a minimal example of usage of the package. Observe that we refer to names of columns using only their names and that chaining is performed using the @linq macro and the |> operator:","category":"page"},{"location":"man/querying_frameworks/","page":"Data manipulation frameworks","title":"Data manipulation frameworks","text":"julia> using DataFramesMeta\n\njulia> df = DataFrame(name=[\"John\", \"Sally\", \"Roger\"],\n                      age=[54.0, 34.0, 79.0],\n                      children=[0, 2, 4])\n3×3 DataFrame\n Row │ name    age      children\n     │ String  Float64  Int64\n─────┼───────────────────────────\n   1 │ John       54.0         0\n   2 │ Sally      34.0         2\n   3 │ Roger      79.0         4\n\njulia> @linq df |>\n           where(:age .> 40) |>\n           select(number_of_children=:children, :name)\n2×2 DataFrame\n Row │ number_of_children  name\n     │ Int64               String\n─────┼────────────────────────────\n   1 │                  0  John\n   2 │                  4  Roger","category":"page"},{"location":"man/querying_frameworks/","page":"Data manipulation frameworks","title":"Data manipulation frameworks","text":"In the following examples we show that DataFramesMeta.jl also supports the split-apply-combine pattern:","category":"page"},{"location":"man/querying_frameworks/","page":"Data manipulation frameworks","title":"Data manipulation frameworks","text":"julia> df = DataFrame(key=repeat(1:3, 4), value=1:12)\n12×2 DataFrame\n Row │ key    value\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1      1\n   2 │     2      2\n   3 │     3      3\n   4 │     1      4\n   5 │     2      5\n   6 │     3      6\n   7 │     1      7\n   8 │     2      8\n   9 │     3      9\n  10 │     1     10\n  11 │     2     11\n  12 │     3     12\n\njulia> @linq df |>\n           where(:value .> 3) |>\n           by(:key, min=minimum(:value), max=maximum(:value)) |>\n           select(:key, range=:max - :min)\n3×2 DataFrame\n Row │ key    range\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1      6\n   2 │     2      6\n   3 │     3      6\n\njulia> @linq df |>\n           groupby(:key) |>\n           transform(value0 = :value .- minimum(:value))\n12×3 DataFrame\n Row │ key    value  value0\n     │ Int64  Int64  Int64\n─────┼──────────────────────\n   1 │     1      1       0\n   2 │     2      2       0\n   3 │     3      3       0\n   4 │     1      4       3\n   5 │     2      5       3\n   6 │     3      6       3\n   7 │     1      7       6\n   8 │     2      8       6\n   9 │     3      9       6\n  10 │     1     10       9\n  11 │     2     11       9\n  12 │     3     12       9","category":"page"},{"location":"man/querying_frameworks/","page":"Data manipulation frameworks","title":"Data manipulation frameworks","text":"You can find more details about how this package can be used on the DataFramesMeta.jl GitHub page.","category":"page"},{"location":"man/querying_frameworks/#Query.jl","page":"Data manipulation frameworks","title":"Query.jl","text":"","category":"section"},{"location":"man/querying_frameworks/","page":"Data manipulation frameworks","title":"Data manipulation frameworks","text":"The Query.jl package provides advanced data manipulation capabilities for DataFrames (and many other data structures). This section provides a short introduction to the package, the Query.jl documentation has a more comprehensive documentation of the package. The instructions here are for version 1.0.0 of Query.jl.","category":"page"},{"location":"man/querying_frameworks/","page":"Data manipulation frameworks","title":"Data manipulation frameworks","text":"To get started, install the Query.jl package:","category":"page"},{"location":"man/querying_frameworks/","page":"Data manipulation frameworks","title":"Data manipulation frameworks","text":"using Pkg\nPkg.add(\"Query\")","category":"page"},{"location":"man/querying_frameworks/","page":"Data manipulation frameworks","title":"Data manipulation frameworks","text":"A query is started with the @from macro and consists of a series of query commands. Query.jl provides commands that can filter, project, join, flatten and group data from a DataFrame. A query can return an iterator, or one can materialize the results of a query into a variety of data structures, including a new DataFrame.","category":"page"},{"location":"man/querying_frameworks/","page":"Data manipulation frameworks","title":"Data manipulation frameworks","text":"A simple example of a query looks like this:","category":"page"},{"location":"man/querying_frameworks/","page":"Data manipulation frameworks","title":"Data manipulation frameworks","text":"julia> using DataFrames, Query\n\njulia> df = DataFrame(name=[\"John\", \"Sally\", \"Roger\"],\n                      age=[54.0, 34.0, 79.0],\n                      children=[0, 2, 4])\n3×3 DataFrame\n Row │ name    age      children\n     │ String  Float64  Int64\n─────┼───────────────────────────\n   1 │ John       54.0         0\n   2 │ Sally      34.0         2\n   3 │ Roger      79.0         4\n\njulia> q1 = @from i in df begin\n            @where i.age > 40\n            @select {number_of_children=i.children, i.name}\n            @collect DataFrame\n       end\n2×2 DataFrame\n Row │ number_of_children  name\n     │ Int64               String\n─────┼────────────────────────────\n   1 │                  0  John\n   2 │                  4  Roger","category":"page"},{"location":"man/querying_frameworks/","page":"Data manipulation frameworks","title":"Data manipulation frameworks","text":"The query starts with the @from macro. The first argument i is the name of the range variable that will be used to refer to an individual row in later query commands. The next argument df is the data source that one wants to query. The @where command in this query will filter the source data by applying the filter condition i.age > 40. This filters out any rows in which the age column is not larger than 40. The @select command then projects the columns of the source data onto a new column structure. The example here applies three specific modifications: 1) it only keeps a subset of the columns in the source DataFrame, i.e. the age column will not be part of the transformed data; 2) it changes the order of the two columns that are selected; and 3) it renames one of the columns that is selected from children to number_of_children. The example query uses the {} syntax to achieve this. A {} in a Query.jl expression instantiates a new NamedTuple, i.e. it is a shortcut for writing @NT(number_of_children=>i.children, name=>i.name). The @collect statement determines the data structure that the query returns. In this example the results are returned as a DataFrame.","category":"page"},{"location":"man/querying_frameworks/","page":"Data manipulation frameworks","title":"Data manipulation frameworks","text":"A query without a @collect statement returns a standard julia iterator that can be used with any normal julia language construct that can deal with iterators. The following code returns a julia iterator for the query results:","category":"page"},{"location":"man/querying_frameworks/","page":"Data manipulation frameworks","title":"Data manipulation frameworks","text":"julia> q2 = @from i in df begin\n                   @where i.age > 40\n                   @select {number_of_children=i.children, i.name}\n              end; # suppress printing the iterator type\n","category":"page"},{"location":"man/querying_frameworks/","page":"Data manipulation frameworks","title":"Data manipulation frameworks","text":"One can loop over the results using a standard julia for statement:","category":"page"},{"location":"man/querying_frameworks/","page":"Data manipulation frameworks","title":"Data manipulation frameworks","text":"julia> total_children = 0\n0\n\njulia> for i in q2\n           global total_children += i.number_of_children\n       end\n\njulia> total_children\n4\n","category":"page"},{"location":"man/querying_frameworks/","page":"Data manipulation frameworks","title":"Data manipulation frameworks","text":"Or one can use a comprehension to extract the name of a subset of rows:","category":"page"},{"location":"man/querying_frameworks/","page":"Data manipulation frameworks","title":"Data manipulation frameworks","text":"julia> y = [i.name for i in q2 if i.number_of_children > 0]\n1-element Vector{String}:\n \"Roger\"\n","category":"page"},{"location":"man/querying_frameworks/","page":"Data manipulation frameworks","title":"Data manipulation frameworks","text":"The last example (extracting only the name and applying a second filter) could of course be completely expressed as a query expression:","category":"page"},{"location":"man/querying_frameworks/","page":"Data manipulation frameworks","title":"Data manipulation frameworks","text":"julia> q3 = @from i in df begin\n            @where i.age > 40 && i.children > 0\n            @select i.name\n            @collect\n       end\n1-element Vector{String}:\n \"Roger\"\n","category":"page"},{"location":"man/querying_frameworks/","page":"Data manipulation frameworks","title":"Data manipulation frameworks","text":"A query that ends with a @collect statement without a specific type will materialize the query results into an array. Note also the difference in the @select statement: The previous queries all used the {} syntax in the @select statement to project results into a tabular format. The last query instead just selects a single value from each row in the @select statement.","category":"page"},{"location":"man/querying_frameworks/","page":"Data manipulation frameworks","title":"Data manipulation frameworks","text":"These examples only scratch the surface of what one can do with Query.jl, and the interested reader is referred to the Query.jl documentation for more information.","category":"page"},{"location":"lib/indexing/","page":"Indexing","title":"Indexing","text":"CurrentModule = DataFrames","category":"page"},{"location":"lib/indexing/#Indexing","page":"Indexing","title":"Indexing","text":"","category":"section"},{"location":"lib/indexing/","page":"Indexing","title":"Indexing","text":"Pages = [\"indexing.md\"]","category":"page"},{"location":"lib/indexing/#General-rules","page":"Indexing","title":"General rules","text":"","category":"section"},{"location":"lib/indexing/","page":"Indexing","title":"Indexing","text":"The following rules explain target functionality of how getindex, setindex!, view, and broadcasting are intended to work with DataFrame, SubDataFrame and DataFrameRow objects.","category":"page"},{"location":"lib/indexing/","page":"Indexing","title":"Indexing","text":"The rules for a valid type of index into a column are the following:","category":"page"},{"location":"lib/indexing/","page":"Indexing","title":"Indexing","text":"a value, later denoted as col:\na Symbol;\nan AbstractString;\nan Integer that is not Bool;\na vector, later denoted as cols:\na vector of Symbol (does not have to be a subtype of AbstractVector{Symbol});\na vector of AbstractString (does not have to be a subtype of AbstractVector{<:AbstractString});\na vector of Integer other than Bool (does not have to be a subtype of AbstractVector{<:Integer});\na vector of Bool that has to be a subtype of AbstractVector{Bool};\na regular expression, which gets expanded to a vector of matching column names;\na Not expression (see InvertedIndices.jl);\nan Cols, All or Between expression (see DataAPI.jl);\na colon literal :.","category":"page"},{"location":"lib/indexing/","page":"Indexing","title":"Indexing","text":"The rules for a valid type of index into a row are the following:","category":"page"},{"location":"lib/indexing/","page":"Indexing","title":"Indexing","text":"a value, later denoted as row:\nan Integer that is not Bool;\na vector, later denoted as rows:\na vector of Integer other than Bool (does not have to be a subtype of AbstractVector{<:Integer});\na vector of Bool that has to be a subtype of AbstractVector{Bool};\na Not expression;\na colon literal :;\nan exclamation mark !.","category":"page"},{"location":"lib/indexing/","page":"Indexing","title":"Indexing","text":"Additionally it is allowed to index into an AbstractDataFrame using a two-dimensional CartesianIndex.","category":"page"},{"location":"lib/indexing/","page":"Indexing","title":"Indexing","text":"In the descriptions below df represents a DataFrame, sdf is a SubDataFrame and dfr is a DataFrameRow.","category":"page"},{"location":"lib/indexing/","page":"Indexing","title":"Indexing","text":": always expands to axes(df, 1) or axes(sdf, 1).","category":"page"},{"location":"lib/indexing/","page":"Indexing","title":"Indexing","text":"df.col works like df[!, col] and sdf.col works like sdf[!, col] in all cases except that df.col .= v and sdf.col .= v perform in-place broadcasting if col is present in df/sdf and is a valid identifier.","category":"page"},{"location":"lib/indexing/#getindex-and-view","page":"Indexing","title":"getindex and view","text":"","category":"section"},{"location":"lib/indexing/","page":"Indexing","title":"Indexing","text":"The following list specifies the behavior of getindex and view operations depending on argument types.","category":"page"},{"location":"lib/indexing/","page":"Indexing","title":"Indexing","text":"In particular a description explicitly mentions that the data is copied or reused without copying.","category":"page"},{"location":"lib/indexing/","page":"Indexing","title":"Indexing","text":"For performance reasons, accessing, via getindex or view, a single row and multiple cols of a DataFrame, a SubDataFrame or a DataFrameRow always returns a DataFrameRow (which is a view type).","category":"page"},{"location":"lib/indexing/","page":"Indexing","title":"Indexing","text":"getindex on DataFrame:","category":"page"},{"location":"lib/indexing/","page":"Indexing","title":"Indexing","text":"df[row, col] -> the value contained in row row of column col, the same as df[!, col][row];\ndf[CartesianIndex(row, col)] -> the same as df[row, col];\ndf[row, cols] -> a DataFrameRow with parent df;\ndf[rows, col] -> a copy of the vector df[!, col] with only the entries corresponding to rows selected,                    the same as df[!, col][rows];\ndf[rows, cols] -> a DataFrame containing copies of columns cols with only the entries corresponding to rows selected;\ndf[!, col] -> the vector contained in column col returned without copying; the same as df.col if col is a valid identifier.\ndf[!, cols] -> create a new DataFrame with columns cols without copying of columns;                  the same as select(df, cols, copycols=false).","category":"page"},{"location":"lib/indexing/","page":"Indexing","title":"Indexing","text":"view on DataFrame:","category":"page"},{"location":"lib/indexing/","page":"Indexing","title":"Indexing","text":"@view df[row, col] -> a 0-dimensional view into df[!, col] in row row, the same as view(df[!, col], row);\n@view df[CartesianIndex(row, col)] -> the same as @view df[row, col];\n@view df[row, cols] -> the same as df[row, cols];\n@view df[rows, col] -> a view into df[!, col] with rows selected, the same as view(df[!, col], rows);\n@view df[rows, cols] -> a SubDataFrame with rows selected with parent df;\n@view df[!, col] -> a view into df[!, col]  with all rows.\n@view df[!, cols] -> the same as @view df[:, cols].","category":"page"},{"location":"lib/indexing/","page":"Indexing","title":"Indexing","text":"getindex on SubDataFrame:","category":"page"},{"location":"lib/indexing/","page":"Indexing","title":"Indexing","text":"sdf[row, col] -> a value contained in row row of column col;\nsdf[CartesianIndex(row, col)] -> the same as sdf[row, col];\nsdf[row, cols] -> a DataFrameRow with parent parent(sdf);\nsdf[rows, col] -> a copy of sdf[!, col] with only rows rows selected, the same as sdf[!, col][rows];\nsdf[rows, cols] -> a DataFrame containing columns cols and sdf[rows, col] as a vector for each col in cols;\nsdf[!, col] -> a view of entries corresponding to sdf in the vector parent(sdf)[!, col];                  the same as sdf.col if col is a valid identifier.\nsdf[!, cols] -> create a new SubDataFrame with columns cols, the same parent as sdf, and the same rows selected;                   the same as select(sdf, cols, copycols=false).","category":"page"},{"location":"lib/indexing/","page":"Indexing","title":"Indexing","text":"view on SubDataFrame:","category":"page"},{"location":"lib/indexing/","page":"Indexing","title":"Indexing","text":"@view sdf[row, col] -> a 0-dimensional view into df[!, col] at row row, the same as view(sdf[!, col], row);\n@view sdf[CartesianIndex(row, col)] -> the same as @view sdf[row, col];\n@view sdf[row, cols] -> a DataFrameRow with parent parent(sdf);\n@view sdf[rows, col] -> a view into sdf[!, col] vector with rows selected, the same as view(sdf[!, col], rows);\n@view sdf[rows, cols] -> a SubDataFrame with parent parent(sdf);\n@view sdf[!, col] -> a view into sdf[!, col] vector with all rows.\n@view sdf[!, cols] -> the same as @view sdf[:, cols].","category":"page"},{"location":"lib/indexing/","page":"Indexing","title":"Indexing","text":"getindex on DataFrameRow:","category":"page"},{"location":"lib/indexing/","page":"Indexing","title":"Indexing","text":"dfr[col] -> the value contained in column col of dfr; the same as dfr.col if col is a valid identifier;\ndfr[cols] -> a DataFrameRow with parent parent(dfr);","category":"page"},{"location":"lib/indexing/","page":"Indexing","title":"Indexing","text":"view on DataFrameRow:","category":"page"},{"location":"lib/indexing/","page":"Indexing","title":"Indexing","text":"@view dfr[col] -> a 0-dimensional view into parent(dfr)[DataFrames.row(dfr), col];\n@view dfr[cols] -> a DataFrameRow with parent parent(dfr);","category":"page"},{"location":"lib/indexing/","page":"Indexing","title":"Indexing","text":"Note that views created with columns selector set to : change their columns' count if columns are added/removed/renamed in the parent; if column selector is other than : then view points to selected columns by their number at the moment of creation of the view.","category":"page"},{"location":"lib/indexing/#setindex!","page":"Indexing","title":"setindex!","text":"","category":"section"},{"location":"lib/indexing/","page":"Indexing","title":"Indexing","text":"The following list specifies the behavior of setindex! operations depending on argument types.","category":"page"},{"location":"lib/indexing/","page":"Indexing","title":"Indexing","text":"In particular a description explicitly mentions if the assignment is in-place.","category":"page"},{"location":"lib/indexing/","page":"Indexing","title":"Indexing","text":"Note that if a setindex! operation throws an error the target data frame may be partially changed so it is unsafe to use it afterwards (the column length correctness will be preserved).","category":"page"},{"location":"lib/indexing/","page":"Indexing","title":"Indexing","text":"setindex! on DataFrame:","category":"page"},{"location":"lib/indexing/","page":"Indexing","title":"Indexing","text":"df[row, col] = v -> set value of col in row row to v in-place;\ndf[CartesianIndex(row, col)] = v -> the same as df[row, col] = v;\ndf[row, cols] = v -> set row row of columns cols in-place; the same as dfr = df[row, cols]; dfr[:] = v;\ndf[rows, col] = v -> set rows rows of column col in-place; v must be an AbstractVector;                        if rows is : and col is a Symbol or AbstractString                        that is not present in df then a new column in df is created and holds a copy of v; equivalent to df.col = copy(v) if col is a valid identifier;\ndf[rows, cols] = v -> set rows rows of columns cols in-place; v must be an AbstractMatrix or an AbstractDataFrame                     (in this case column names must match);\ndf[!, col] = v -> replaces col with v without copying                     (with the exception that if v is an AbstractRange it gets converted to a Vector);                     also if col is a Symbol or AbstractString that is not present in df then                     a new column in df is created and holds v;                     equivalent to df.col = v if col is a valid identifier;                     this is allowed if ncol(df) == 0 || length(v) == nrow(df);\ndf[!, cols] = v -> replaces existing columns cols in data frame df with copying;                      v must be an AbstractMatrix or an AbstractDataFrame                      (in the latter case column names must match);","category":"page"},{"location":"lib/indexing/","page":"Indexing","title":"Indexing","text":"setindex! on SubDataFrame:","category":"page"},{"location":"lib/indexing/","page":"Indexing","title":"Indexing","text":"sdf[row, col] = v -> set value of col in row row to v in-place;\nsdf[CartesianIndex(row, col)] = v -> the same as sdf[row, col] = v;\nsdf[row, cols] = v -> the same as dfr = df[row, cols]; dfr[:] = v in-place;\nsdf[rows, col] = v -> set rows rows of column col, in-place; v must be an abstract vector;\nsdf[rows, cols] = v -> set rows rows of columns cols in-place;                          v can be an AbstractMatrix or v can be AbstractDataFrame when column names must match;","category":"page"},{"location":"lib/indexing/","page":"Indexing","title":"Indexing","text":"Note that sdf[!, col] = v, sdf[!, cols] = v and sdf.col = v are not allowed as sdf can be only modified in-place.","category":"page"},{"location":"lib/indexing/","page":"Indexing","title":"Indexing","text":"setindex! on DataFrameRow:","category":"page"},{"location":"lib/indexing/","page":"Indexing","title":"Indexing","text":"dfr[col] = v -> set value of col in row row to v in-place;                   equivalent to dfr.col = v if col is a valid identifier;\ndfr[cols] = v -> set values of entries in columns cols in dfr by elements of v in place;                    v can be:                    1) a Tuple or an AbstractArray,                       in which cases it must have a number of elements equal to length(dfr),                    2) an AbstractDict, in which case column names must match,                    3) a NamedTuple or DataFrameRow, in which case column names and order must match;","category":"page"},{"location":"lib/indexing/#Broadcasting","page":"Indexing","title":"Broadcasting","text":"","category":"section"},{"location":"lib/indexing/","page":"Indexing","title":"Indexing","text":"The following broadcasting rules apply to AbstractDataFrame objects:","category":"page"},{"location":"lib/indexing/","page":"Indexing","title":"Indexing","text":"AbstractDataFrame behaves in broadcasting like a two-dimensional collection compatible with matrices.\nIf an AbstractDataFrame takes part in broadcasting then a DataFrame is always produced as a result. In this case the requested broadcasting operation produces an object with exactly two dimensions. An exception is when an AbstractDataFrame is used only as a source of broadcast assignment into an object of dimensionality higher than two.\nIf multiple AbstractDataFrame objects take part in broadcasting then they have to have identical column names.","category":"page"},{"location":"lib/indexing/","page":"Indexing","title":"Indexing","text":"Note that if broadcasting assignment operation throws an error the target data frame may be partially changed so it is unsafe to use it afterwards (the column length correctness will be preserved).","category":"page"},{"location":"lib/indexing/","page":"Indexing","title":"Indexing","text":"Broadcasting DataFrameRow is currently not allowed (which is consistent with NamedTuple).","category":"page"},{"location":"lib/indexing/","page":"Indexing","title":"Indexing","text":"It is possible to assign a value to AbstractDataFrame and DataFrameRow objects using the .= operator. In such an operation AbstractDataFrame is considered as two-dimensional and DataFrameRow as single-dimensional.","category":"page"},{"location":"lib/indexing/","page":"Indexing","title":"Indexing","text":"note: Note\nThe rule above means that, similar to single-dimensional objects in Base (e.g. vectors), DataFrameRow is considered to be column-oriented.","category":"page"},{"location":"lib/indexing/","page":"Indexing","title":"Indexing","text":"Additional rules:","category":"page"},{"location":"lib/indexing/","page":"Indexing","title":"Indexing","text":"in the df[CartesianIndex(row, col)] .= v, df[row, col] .= v syntaxes v is broadcasted into the contents of df[row, col] (this is consistent with Julia Base);\nin the df[row, cols] .= v syntaxes the assignment to df is performed in-place;\nin the df[rows, col] .= v and df[rows, cols] .= v syntaxes the assignment to df is performed in-place; if rows is : and col is Symbol or AbstractString and it is missing from df then a new column is allocated and added; the length of the column is always the value of nrow(df) before the assignment takes place;\nin the df[!, col] .= v syntax column col is replaced by a freshly allocated vector; if col is Symbol or AbstractString and it is missing from df then a new column is allocated added; the length of the column is always the value of nrow(df) before the assignment takes place;\nthe df[!, cols] .= v syntax replaces existing columns cols in data frame df with freshly allocated vectors;\ndf.col .= v syntax currently performs in-place assignment to an existing vector df.col; this behavior is deprecated and a new column will be allocated in the future. Starting from Julia 1.7 if :col is not present in df then a new column will be created in df.\nin the sdf[CartesianIndex(row, col)] .= v, sdf[row, col] .= v and sdf[row, cols] .= v syntaxes the assignment to sdf is performed in-place;\nin the sdf[rows, col] .= v and sdf[rows, cols] .= v syntaxes the assignment to sdf is performed in-place;\nsdf.col .= v syntax is performs an in-place assignment to an existing vector sdf.col and is deprecated; in the future this operation will not be allowed.\ndfr.col .= v syntax is allowed and performs in-place assignment to a value extracted by dfr.col.","category":"page"},{"location":"lib/indexing/","page":"Indexing","title":"Indexing","text":"Note that sdf[!, col] .= v and sdf[!, cols] .= v syntaxes are not allowed as sdf can be only modified in-place.","category":"page"},{"location":"lib/indexing/","page":"Indexing","title":"Indexing","text":"If column indexing using Symbol or AbstractString names in cols is performed, the order of columns in the operation is specified by the order of names.","category":"page"},{"location":"lib/indexing/#Indexing-GroupedDataFrames","page":"Indexing","title":"Indexing GroupedDataFrames","text":"","category":"section"},{"location":"lib/indexing/","page":"Indexing","title":"Indexing","text":"A GroupedDataFrame can behave as either an AbstractVector or AbstractDict depending on the type of index used. Integers (or arrays of them) trigger vector-like indexing while Tupless and NamedTuples trigger dictionary-like indexing. An intermediate between the two is the GroupKey type returned by keys(::GroupedDataFrame), which behaves similarly to a NamedTuple but has performance on par with integer indexing.","category":"page"},{"location":"lib/indexing/","page":"Indexing","title":"Indexing","text":"The elements of a GroupedDataFrame are SubDataFrames of its parent.","category":"page"},{"location":"lib/indexing/","page":"Indexing","title":"Indexing","text":"gd[i::Integer] -> Get the ith group.\ngd[key::NamedTuple] -> Get the group corresponding to the given values of the grouping columns. The fields of the NamedTuple must match the grouping columns columns passed to groupby (including order).\ngd[key::Tuple] -> Same as previous, but omitting the names on key.\nget(gd, key::Union{Tuple, NamedTuple}, default) -> Get group for key key, returning default if it does not exist.\ngd[key::GroupKey] -> Get the group corresponding to the GroupKey key (one of the elements of the vector returned by keys(::GroupedDataFrame)). This should be nearly as fast as integer indexing.\ngd[a::AbstractVector] -> Select multiple groups and return them in a new GroupedDataFrame object. Groups may be selected by integer position using an array of Integers or Bools, similar to a standard array. Alternatively the array may contain keys of any of the types supported for dictionary-like indexing (GroupKey, Tuple, or NamedTuple). Selected groups must be unique, and different types of indices cannot be mixed.\ngd[n::Not] -> Any of the above types wrapped in Not. The result  will be a new GroupedDataFrame containing all groups in gd not selected  by the wrapped index.","category":"page"},{"location":"lib/indexing/#Common-API-for-types-defined-in-DataFrames.jl","page":"Indexing","title":"Common API for types defined in DataFrames.jl","text":"","category":"section"},{"location":"lib/indexing/","page":"Indexing","title":"Indexing","text":"This table presents return value types of calling names, propertynames, keys, length and ndims on types exposed to the user by DataFrames.jl:","category":"page"},{"location":"lib/indexing/","page":"Indexing","title":"Indexing","text":"Type names propertynames keys length ndims\nAbstractDataFrame Vector{String} Vector{Symbol} undefined undefined 2\nDataFrameRow Vector{String} Vector{Symbol} Vector{Symbol} Int 1\nDataFrameRows Vector{String} Vector{Symbol} vector of Int Int 1\nDataFrameColumns Vector{String} Vector{Symbol} Vector{Symbol} Int 1\nGroupedDataFrame Vector{String} tuple of fields GroupKeys Int 1\nGroupKeys undefined tuple of fields vector of Int Int 1\nGroupKey Vector{String} Vector{Symbol} Vector{Symbol} Int 1","category":"page"},{"location":"lib/indexing/","page":"Indexing","title":"Indexing","text":"Additionally the above types T (i.e. AbstractDataFrame, DataFrameRow, DataFrameRows, DataFrameColumns, GroupedDataFrame, GroupKeys, GroupKey) the following methods are defined:","category":"page"},{"location":"lib/indexing/","page":"Indexing","title":"Indexing","text":"size(::T) returning a Tuple of Int.\nsize(::T, ::Integer) returning an Int.\naxes(::T) returning a Tuple of Int vectors.\naxes(::T, ::Integer) returning an Int vector for a valid dimension (except  DataFrameRows and GroupKeys for which Base.OneTo(1) is also returned for  a dimension higher than a valid one because they are AbstractVector).\nfirstindex(::T) returning 1 (except AbstractDataFrame for which it is undefined).\nfirstindex(::T, ::Integer) returning 1 for a valid dimension (except DataFrameRows  and GroupKeys for which 1 is also returned for a dimension higher than a valid one  because they are AbstractVector).\nlastindex(::T) returning Int (except AbstractDataFrame for which it is undefined).\nlastindex(::T, ::Integer) returning Int for a valid dimension  (except DataFrameRows  and GroupKeys for which 1 is also returned for a dimension higher than a valid one  because they are AbstractVector).","category":"page"},{"location":"man/reshaping_and_pivoting/#Reshaping-and-Pivoting-Data","page":"Reshaping","title":"Reshaping and Pivoting Data","text":"","category":"section"},{"location":"man/reshaping_and_pivoting/","page":"Reshaping","title":"Reshaping","text":"Reshape data from wide to long format using the stack function:","category":"page"},{"location":"man/reshaping_and_pivoting/","page":"Reshaping","title":"Reshaping","text":"julia> using DataFrames, CSV\n\njulia> iris = CSV.read((joinpath(dirname(pathof(DataFrames)),\n                                 \"..\", \"docs\", \"src\", \"assets\", \"iris.csv\")),\n                       DataFrame)\n150×5 DataFrame\n Row │ SepalLength  SepalWidth  PetalLength  PetalWidth  Species\n     │ Float64      Float64     Float64      Float64     String\n─────┼──────────────────────────────────────────────────────────────────\n   1 │         5.1         3.5          1.4         0.2  Iris-setosa\n   2 │         4.9         3.0          1.4         0.2  Iris-setosa\n   3 │         4.7         3.2          1.3         0.2  Iris-setosa\n   4 │         4.6         3.1          1.5         0.2  Iris-setosa\n   5 │         5.0         3.6          1.4         0.2  Iris-setosa\n   6 │         5.4         3.9          1.7         0.4  Iris-setosa\n   7 │         4.6         3.4          1.4         0.3  Iris-setosa\n   8 │         5.0         3.4          1.5         0.2  Iris-setosa\n  ⋮  │      ⋮           ⋮            ⋮           ⋮             ⋮\n 144 │         6.8         3.2          5.9         2.3  Iris-virginica\n 145 │         6.7         3.3          5.7         2.5  Iris-virginica\n 146 │         6.7         3.0          5.2         2.3  Iris-virginica\n 147 │         6.3         2.5          5.0         1.9  Iris-virginica\n 148 │         6.5         3.0          5.2         2.0  Iris-virginica\n 149 │         6.2         3.4          5.4         2.3  Iris-virginica\n 150 │         5.9         3.0          5.1         1.8  Iris-virginica\n                                                        135 rows omitted\n\njulia> stack(iris, 1:4)\n600×3 DataFrame\n Row │ Species         variable     value\n     │ String          String       Float64\n─────┼──────────────────────────────────────\n   1 │ Iris-setosa     SepalLength      5.1\n   2 │ Iris-setosa     SepalLength      4.9\n   3 │ Iris-setosa     SepalLength      4.7\n   4 │ Iris-setosa     SepalLength      4.6\n   5 │ Iris-setosa     SepalLength      5.0\n   6 │ Iris-setosa     SepalLength      5.4\n   7 │ Iris-setosa     SepalLength      4.6\n   8 │ Iris-setosa     SepalLength      5.0\n  ⋮  │       ⋮              ⋮          ⋮\n 594 │ Iris-virginica  PetalWidth       2.3\n 595 │ Iris-virginica  PetalWidth       2.5\n 596 │ Iris-virginica  PetalWidth       2.3\n 597 │ Iris-virginica  PetalWidth       1.9\n 598 │ Iris-virginica  PetalWidth       2.0\n 599 │ Iris-virginica  PetalWidth       2.3\n 600 │ Iris-virginica  PetalWidth       1.8\n                            585 rows omitted","category":"page"},{"location":"man/reshaping_and_pivoting/","page":"Reshaping","title":"Reshaping","text":"The second optional argument to stack indicates the columns to be stacked. These are normally referred to as the measured variables. Column names can also be given:","category":"page"},{"location":"man/reshaping_and_pivoting/","page":"Reshaping","title":"Reshaping","text":"julia> stack(iris, [:SepalLength, :SepalWidth, :PetalLength, :PetalWidth])\n600×3 DataFrame\n Row │ Species         variable     value\n     │ String          String       Float64\n─────┼──────────────────────────────────────\n   1 │ Iris-setosa     SepalLength      5.1\n   2 │ Iris-setosa     SepalLength      4.9\n   3 │ Iris-setosa     SepalLength      4.7\n   4 │ Iris-setosa     SepalLength      4.6\n   5 │ Iris-setosa     SepalLength      5.0\n   6 │ Iris-setosa     SepalLength      5.4\n   7 │ Iris-setosa     SepalLength      4.6\n   8 │ Iris-setosa     SepalLength      5.0\n  ⋮  │       ⋮              ⋮          ⋮\n 594 │ Iris-virginica  PetalWidth       2.3\n 595 │ Iris-virginica  PetalWidth       2.5\n 596 │ Iris-virginica  PetalWidth       2.3\n 597 │ Iris-virginica  PetalWidth       1.9\n 598 │ Iris-virginica  PetalWidth       2.0\n 599 │ Iris-virginica  PetalWidth       2.3\n 600 │ Iris-virginica  PetalWidth       1.8\n                            585 rows omitted","category":"page"},{"location":"man/reshaping_and_pivoting/","page":"Reshaping","title":"Reshaping","text":"Note that all columns can be of different types. Type promotion follows the rules of vcat.","category":"page"},{"location":"man/reshaping_and_pivoting/","page":"Reshaping","title":"Reshaping","text":"The stacked DataFrame that results includes all of the columns not specified to be stacked. These are repeated for each stacked column. These are normally refered to as identifier (id) columns. In addition to the id columns, two additional columns labeled :variable and :values contain the column identifier and the stacked columns.","category":"page"},{"location":"man/reshaping_and_pivoting/","page":"Reshaping","title":"Reshaping","text":"A third optional argument to stack represents the id columns that are repeated. This makes it easier to specify which variables you want included in the long format:","category":"page"},{"location":"man/reshaping_and_pivoting/","page":"Reshaping","title":"Reshaping","text":"julia> stack(iris, [:SepalLength, :SepalWidth], :Species)\n300×3 DataFrame\n Row │ Species         variable     value\n     │ String          String       Float64\n─────┼──────────────────────────────────────\n   1 │ Iris-setosa     SepalLength      5.1\n   2 │ Iris-setosa     SepalLength      4.9\n   3 │ Iris-setosa     SepalLength      4.7\n   4 │ Iris-setosa     SepalLength      4.6\n   5 │ Iris-setosa     SepalLength      5.0\n   6 │ Iris-setosa     SepalLength      5.4\n   7 │ Iris-setosa     SepalLength      4.6\n   8 │ Iris-setosa     SepalLength      5.0\n  ⋮  │       ⋮              ⋮          ⋮\n 294 │ Iris-virginica  SepalWidth       3.2\n 295 │ Iris-virginica  SepalWidth       3.3\n 296 │ Iris-virginica  SepalWidth       3.0\n 297 │ Iris-virginica  SepalWidth       2.5\n 298 │ Iris-virginica  SepalWidth       3.0\n 299 │ Iris-virginica  SepalWidth       3.4\n 300 │ Iris-virginica  SepalWidth       3.0\n                            285 rows omitted","category":"page"},{"location":"man/reshaping_and_pivoting/","page":"Reshaping","title":"Reshaping","text":"If you prefer to specify the id columns then use Not with stack like this:","category":"page"},{"location":"man/reshaping_and_pivoting/","page":"Reshaping","title":"Reshaping","text":"julia> stack(iris, Not(:Species))\n600×3 DataFrame\n Row │ Species         variable     value\n     │ String          String       Float64\n─────┼──────────────────────────────────────\n   1 │ Iris-setosa     SepalLength      5.1\n   2 │ Iris-setosa     SepalLength      4.9\n   3 │ Iris-setosa     SepalLength      4.7\n   4 │ Iris-setosa     SepalLength      4.6\n   5 │ Iris-setosa     SepalLength      5.0\n   6 │ Iris-setosa     SepalLength      5.4\n   7 │ Iris-setosa     SepalLength      4.6\n   8 │ Iris-setosa     SepalLength      5.0\n  ⋮  │       ⋮              ⋮          ⋮\n 594 │ Iris-virginica  PetalWidth       2.3\n 595 │ Iris-virginica  PetalWidth       2.5\n 596 │ Iris-virginica  PetalWidth       2.3\n 597 │ Iris-virginica  PetalWidth       1.9\n 598 │ Iris-virginica  PetalWidth       2.0\n 599 │ Iris-virginica  PetalWidth       2.3\n 600 │ Iris-virginica  PetalWidth       1.8\n                            585 rows omitted","category":"page"},{"location":"man/reshaping_and_pivoting/","page":"Reshaping","title":"Reshaping","text":"unstack converts from a long format to a wide format. The default is requires specifying which columns are an id variable, column variable names, and column values:","category":"page"},{"location":"man/reshaping_and_pivoting/","page":"Reshaping","title":"Reshaping","text":"julia> iris.id = 1:size(iris, 1)\n1:150\n\njulia> longdf = stack(iris, Not([:Species, :id]))\n600×4 DataFrame\n Row │ Species         id     variable     value\n     │ String          Int64  String       Float64\n─────┼─────────────────────────────────────────────\n   1 │ Iris-setosa         1  SepalLength      5.1\n   2 │ Iris-setosa         2  SepalLength      4.9\n   3 │ Iris-setosa         3  SepalLength      4.7\n   4 │ Iris-setosa         4  SepalLength      4.6\n   5 │ Iris-setosa         5  SepalLength      5.0\n   6 │ Iris-setosa         6  SepalLength      5.4\n   7 │ Iris-setosa         7  SepalLength      4.6\n   8 │ Iris-setosa         8  SepalLength      5.0\n  ⋮  │       ⋮           ⋮         ⋮          ⋮\n 594 │ Iris-virginica    144  PetalWidth       2.3\n 595 │ Iris-virginica    145  PetalWidth       2.5\n 596 │ Iris-virginica    146  PetalWidth       2.3\n 597 │ Iris-virginica    147  PetalWidth       1.9\n 598 │ Iris-virginica    148  PetalWidth       2.0\n 599 │ Iris-virginica    149  PetalWidth       2.3\n 600 │ Iris-virginica    150  PetalWidth       1.8\n                                   585 rows omitted\n\njulia> unstack(longdf, :id, :variable, :value)\n150×5 DataFrame\n Row │ id     SepalLength  SepalWidth  PetalLength  PetalWidth\n     │ Int64  Float64?     Float64?    Float64?     Float64?\n─────┼─────────────────────────────────────────────────────────\n   1 │     1          5.1         3.5          1.4         0.2\n   2 │     2          4.9         3.0          1.4         0.2\n   3 │     3          4.7         3.2          1.3         0.2\n   4 │     4          4.6         3.1          1.5         0.2\n   5 │     5          5.0         3.6          1.4         0.2\n   6 │     6          5.4         3.9          1.7         0.4\n   7 │     7          4.6         3.4          1.4         0.3\n   8 │     8          5.0         3.4          1.5         0.2\n  ⋮  │   ⋮         ⋮           ⋮            ⋮           ⋮\n 144 │   144          6.8         3.2          5.9         2.3\n 145 │   145          6.7         3.3          5.7         2.5\n 146 │   146          6.7         3.0          5.2         2.3\n 147 │   147          6.3         2.5          5.0         1.9\n 148 │   148          6.5         3.0          5.2         2.0\n 149 │   149          6.2         3.4          5.4         2.3\n 150 │   150          5.9         3.0          5.1         1.8\n                                               135 rows omitted","category":"page"},{"location":"man/reshaping_and_pivoting/","page":"Reshaping","title":"Reshaping","text":"If the remaining columns are unique, you can skip the id variable and use:","category":"page"},{"location":"man/reshaping_and_pivoting/","page":"Reshaping","title":"Reshaping","text":"julia> unstack(longdf, :variable, :value)\n150×6 DataFrame\n Row │ Species         id     SepalLength  SepalWidth  PetalLength  PetalWidth ⋯\n     │ String          Int64  Float64?     Float64?    Float64?     Float64?   ⋯\n─────┼──────────────────────────────────────────────────────────────────────────\n   1 │ Iris-setosa         1          5.1         3.5          1.4         0.2 ⋯\n   2 │ Iris-setosa         2          4.9         3.0          1.4         0.2\n   3 │ Iris-setosa         3          4.7         3.2          1.3         0.2\n   4 │ Iris-setosa         4          4.6         3.1          1.5         0.2\n   5 │ Iris-setosa         5          5.0         3.6          1.4         0.2 ⋯\n   6 │ Iris-setosa         6          5.4         3.9          1.7         0.4\n   7 │ Iris-setosa         7          4.6         3.4          1.4         0.3\n   8 │ Iris-setosa         8          5.0         3.4          1.5         0.2\n  ⋮  │       ⋮           ⋮         ⋮           ⋮            ⋮           ⋮      ⋱\n 144 │ Iris-virginica    144          6.8         3.2          5.9         2.3 ⋯\n 145 │ Iris-virginica    145          6.7         3.3          5.7         2.5\n 146 │ Iris-virginica    146          6.7         3.0          5.2         2.3\n 147 │ Iris-virginica    147          6.3         2.5          5.0         1.9\n 148 │ Iris-virginica    148          6.5         3.0          5.2         2.0 ⋯\n 149 │ Iris-virginica    149          6.2         3.4          5.4         2.3\n 150 │ Iris-virginica    150          5.9         3.0          5.1         1.8\n                                                               135 rows omitted","category":"page"},{"location":"man/reshaping_and_pivoting/","page":"Reshaping","title":"Reshaping","text":"You can even skip passing the :variable and :value values as positional arguments, as they will be used by default, and write:","category":"page"},{"location":"man/reshaping_and_pivoting/","page":"Reshaping","title":"Reshaping","text":"julia> unstack(longdf)\n150×6 DataFrame\n Row │ Species         id     SepalLength  SepalWidth  PetalLength  PetalWidth ⋯\n     │ String          Int64  Float64?     Float64?    Float64?     Float64?   ⋯\n─────┼──────────────────────────────────────────────────────────────────────────\n   1 │ Iris-setosa         1          5.1         3.5          1.4         0.2 ⋯\n   2 │ Iris-setosa         2          4.9         3.0          1.4         0.2\n   3 │ Iris-setosa         3          4.7         3.2          1.3         0.2\n   4 │ Iris-setosa         4          4.6         3.1          1.5         0.2\n   5 │ Iris-setosa         5          5.0         3.6          1.4         0.2 ⋯\n   6 │ Iris-setosa         6          5.4         3.9          1.7         0.4\n   7 │ Iris-setosa         7          4.6         3.4          1.4         0.3\n   8 │ Iris-setosa         8          5.0         3.4          1.5         0.2\n  ⋮  │       ⋮           ⋮         ⋮           ⋮            ⋮           ⋮      ⋱\n 144 │ Iris-virginica    144          6.8         3.2          5.9         2.3 ⋯\n 145 │ Iris-virginica    145          6.7         3.3          5.7         2.5\n 146 │ Iris-virginica    146          6.7         3.0          5.2         2.3\n 147 │ Iris-virginica    147          6.3         2.5          5.0         1.9\n 148 │ Iris-virginica    148          6.5         3.0          5.2         2.0 ⋯\n 149 │ Iris-virginica    149          6.2         3.4          5.4         2.3\n 150 │ Iris-virginica    150          5.9         3.0          5.1         1.8\n                                                               135 rows omitted","category":"page"},{"location":"man/reshaping_and_pivoting/","page":"Reshaping","title":"Reshaping","text":"Passing view=true to stack returns a data frame whose columns are views into the original wide data frame. Here is an example:","category":"page"},{"location":"man/reshaping_and_pivoting/","page":"Reshaping","title":"Reshaping","text":"julia> stack(iris, view=true)\n600×4 DataFrame\n Row │ Species         id     variable     value\n     │ String          Int64  String       Float64\n─────┼─────────────────────────────────────────────\n   1 │ Iris-setosa         1  SepalLength      5.1\n   2 │ Iris-setosa         2  SepalLength      4.9\n   3 │ Iris-setosa         3  SepalLength      4.7\n   4 │ Iris-setosa         4  SepalLength      4.6\n   5 │ Iris-setosa         5  SepalLength      5.0\n   6 │ Iris-setosa         6  SepalLength      5.4\n   7 │ Iris-setosa         7  SepalLength      4.6\n   8 │ Iris-setosa         8  SepalLength      5.0\n  ⋮  │       ⋮           ⋮         ⋮          ⋮\n 594 │ Iris-virginica    144  PetalWidth       2.3\n 595 │ Iris-virginica    145  PetalWidth       2.5\n 596 │ Iris-virginica    146  PetalWidth       2.3\n 597 │ Iris-virginica    147  PetalWidth       1.9\n 598 │ Iris-virginica    148  PetalWidth       2.0\n 599 │ Iris-virginica    149  PetalWidth       2.3\n 600 │ Iris-virginica    150  PetalWidth       1.8\n                                   585 rows omitted","category":"page"},{"location":"man/reshaping_and_pivoting/","page":"Reshaping","title":"Reshaping","text":"This saves memory. To create the view, several AbstractVectors are defined:","category":"page"},{"location":"man/reshaping_and_pivoting/","page":"Reshaping","title":"Reshaping","text":":variable column – EachRepeatedVector This repeats the variables N times where N is the number of rows of the original AbstractDataFrame.","category":"page"},{"location":"man/reshaping_and_pivoting/","page":"Reshaping","title":"Reshaping","text":":value column – StackedVector This is provides a view of the original columns stacked together.","category":"page"},{"location":"man/reshaping_and_pivoting/","page":"Reshaping","title":"Reshaping","text":"Id columns – RepeatedVector This repeats the original columns N times where N is the number of columns stacked.","category":"page"},{"location":"man/reshaping_and_pivoting/","page":"Reshaping","title":"Reshaping","text":"None of these reshaping functions perform any aggregation. To do aggregation, use the split-apply-combine functions in combination with reshaping. Here is an example:","category":"page"},{"location":"man/reshaping_and_pivoting/","page":"Reshaping","title":"Reshaping","text":"julia> using Statistics\n\njulia> d = stack(iris, Not(:Species))\n750×3 DataFrame\n Row │ Species         variable     value\n     │ String          String       Float64\n─────┼──────────────────────────────────────\n   1 │ Iris-setosa     SepalLength      5.1\n   2 │ Iris-setosa     SepalLength      4.9\n   3 │ Iris-setosa     SepalLength      4.7\n   4 │ Iris-setosa     SepalLength      4.6\n   5 │ Iris-setosa     SepalLength      5.0\n   6 │ Iris-setosa     SepalLength      5.4\n   7 │ Iris-setosa     SepalLength      4.6\n   8 │ Iris-setosa     SepalLength      5.0\n  ⋮  │       ⋮              ⋮          ⋮\n 744 │ Iris-virginica  id             144.0\n 745 │ Iris-virginica  id             145.0\n 746 │ Iris-virginica  id             146.0\n 747 │ Iris-virginica  id             147.0\n 748 │ Iris-virginica  id             148.0\n 749 │ Iris-virginica  id             149.0\n 750 │ Iris-virginica  id             150.0\n                            735 rows omitted\n\njulia> x = combine(groupby(d, [:variable, :Species]), :value => mean => :vsum)\n15×3 DataFrame\n Row │ variable     Species          vsum\n     │ String       String           Float64\n─────┼───────────────────────────────────────\n   1 │ SepalLength  Iris-setosa        5.006\n   2 │ SepalLength  Iris-versicolor    5.936\n   3 │ SepalLength  Iris-virginica     6.588\n   4 │ SepalWidth   Iris-setosa        3.418\n   5 │ SepalWidth   Iris-versicolor    2.77\n   6 │ SepalWidth   Iris-virginica     2.974\n   7 │ PetalLength  Iris-setosa        1.464\n   8 │ PetalLength  Iris-versicolor    4.26\n   9 │ PetalLength  Iris-virginica     5.552\n  10 │ PetalWidth   Iris-setosa        0.244\n  11 │ PetalWidth   Iris-versicolor    1.326\n  12 │ PetalWidth   Iris-virginica     2.026\n  13 │ id           Iris-setosa       25.5\n  14 │ id           Iris-versicolor   75.5\n  15 │ id           Iris-virginica   125.5\n\njulia> first(unstack(x, :Species, :vsum), 6)\n5×4 DataFrame\n Row │ variable     Iris-setosa  Iris-versicolor  Iris-virginica\n     │ String       Float64?     Float64?         Float64?\n─────┼───────────────────────────────────────────────────────────\n   1 │ SepalLength        5.006            5.936           6.588\n   2 │ SepalWidth         3.418            2.77            2.974\n   3 │ PetalLength        1.464            4.26            5.552\n   4 │ PetalWidth         0.244            1.326           2.026\n   5 │ id                25.5             75.5           125.5","category":"page"},{"location":"man/reshaping_and_pivoting/","page":"Reshaping","title":"Reshaping","text":"To turn an AbstractDataFrame on its side, use permutedims.","category":"page"},{"location":"man/reshaping_and_pivoting/","page":"Reshaping","title":"Reshaping","text":"julia> df1 = DataFrame(a=[\"x\", \"y\"], b=[1.0, 2.0], c=[3, 4], d=[true, false])\n2×4 DataFrame\n Row │ a       b        c      d\n     │ String  Float64  Int64  Bool\n─────┼───────────────────────────────\n   1 │ x           1.0      3   true\n   2 │ y           2.0      4  false\n\njulia> permutedims(df1, 1)\n3×3 DataFrame\n Row │ a       x        y\n     │ String  Float64  Float64\n─────┼──────────────────────────\n   1 │ b           1.0      2.0\n   2 │ c           3.0      4.0\n   3 │ d           1.0      0.0","category":"page"},{"location":"man/reshaping_and_pivoting/","page":"Reshaping","title":"Reshaping","text":"Note that the column indexed by src_colnames in the original df becomes the column names in the permuted result, and the column names of the original become a new column. Typically, this would be used on columns with homogenous element types, since the element types of the other columns are the result of promote_type on all the permuted columns. Note also that, by default, the new column created from the column names of the original df has the same name as src_namescol. An optional positional argument dest_namescol can alter this:","category":"page"},{"location":"man/reshaping_and_pivoting/","page":"Reshaping","title":"Reshaping","text":"julia> df2 = DataFrame(a=[\"x\", \"y\"], b=[1, \"two\"], c=[3, 4], d=[true, false])\n2×4 DataFrame\n Row │ a       b    c      d\n     │ String  Any  Int64  Bool\n─────┼───────────────────────────\n   1 │ x       1        3   true\n   2 │ y       two      4  false\n\njulia> permutedims(df2, 1, \"different_name\")\n3×3 DataFrame\n Row │ different_name  x     y\n     │ String          Any   Any\n─────┼─────────────────────────────\n   1 │ b               1     two\n   2 │ c               3     4\n   3 │ d               true  false","category":"page"},{"location":"man/categorical/#Categorical-Data","page":"Categorical Data","title":"Categorical Data","text":"","category":"section"},{"location":"man/categorical/","page":"Categorical Data","title":"Categorical Data","text":"Often, we have to deal with factors that take on a small number of levels:","category":"page"},{"location":"man/categorical/","page":"Categorical Data","title":"Categorical Data","text":"julia> v = [\"Group A\", \"Group A\", \"Group A\", \"Group B\", \"Group B\", \"Group B\"]\n6-element Vector{String}:\n \"Group A\"\n \"Group A\"\n \"Group A\"\n \"Group B\"\n \"Group B\"\n \"Group B\"\n","category":"page"},{"location":"man/categorical/","page":"Categorical Data","title":"Categorical Data","text":"The naive encoding used in an Array represents every entry of this vector as a full string. In contrast, we can represent the data more efficiently by replacing the strings with indices into a small pool of levels. This is what the CategoricalArray type does:","category":"page"},{"location":"man/categorical/","page":"Categorical Data","title":"Categorical Data","text":"julia> using CategoricalArrays\n\njulia> cv = CategoricalArray(v)\n6-element CategoricalArray{String,1,UInt32}:\n \"Group A\"\n \"Group A\"\n \"Group A\"\n \"Group B\"\n \"Group B\"\n \"Group B\"","category":"page"},{"location":"man/categorical/","page":"Categorical Data","title":"Categorical Data","text":"CategoricalArrays support missing values.","category":"page"},{"location":"man/categorical/","page":"Categorical Data","title":"Categorical Data","text":"julia> cv = CategoricalArray([\"Group A\", missing, \"Group A\",\n                              \"Group B\", \"Group B\", missing])\n6-element CategoricalArray{Union{Missing, String},1,UInt32}:\n \"Group A\"\n missing\n \"Group A\"\n \"Group B\"\n \"Group B\"\n missing","category":"page"},{"location":"man/categorical/","page":"Categorical Data","title":"Categorical Data","text":"In addition to representing repeated data efficiently, the CategoricalArray type allows us to determine efficiently the allowed levels of the variable at any time using the levels function (note that levels may or may not be actually used in the data):","category":"page"},{"location":"man/categorical/","page":"Categorical Data","title":"Categorical Data","text":"julia> levels(cv)\n2-element Vector{String}:\n \"Group A\"\n \"Group B\"","category":"page"},{"location":"man/categorical/","page":"Categorical Data","title":"Categorical Data","text":"The levels! function also allows changing the order of appearance of the levels, which can be useful for display purposes or when working with ordered variables.","category":"page"},{"location":"man/categorical/","page":"Categorical Data","title":"Categorical Data","text":"julia> levels!(cv, [\"Group B\", \"Group A\"])\n6-element CategoricalArray{Union{Missing, String},1,UInt32}:\n \"Group A\"\n missing\n \"Group A\"\n \"Group B\"\n \"Group B\"\n missing\n\njulia> levels(cv)\n2-element Vector{String}:\n \"Group B\"\n \"Group A\"\n\njulia> sort(cv)\n6-element CategoricalArray{Union{Missing, String},1,UInt32}:\n \"Group B\"\n \"Group B\"\n \"Group A\"\n \"Group A\"\n missing\n missing","category":"page"},{"location":"man/categorical/","page":"Categorical Data","title":"Categorical Data","text":"By default, a CategoricalArray is able to represent 2^32 different levels. You can use less memory by calling the compress function:","category":"page"},{"location":"man/categorical/","page":"Categorical Data","title":"Categorical Data","text":"julia> cv = compress(cv)\n6-element CategoricalArray{Union{Missing, String},1,UInt8}:\n \"Group A\"\n missing\n \"Group A\"\n \"Group B\"\n \"Group B\"\n missing\n","category":"page"},{"location":"man/categorical/","page":"Categorical Data","title":"Categorical Data","text":"Instead of using the CategoricalArray constructor directly you can use categorical function. It additionally accepts a keyword argument compress which when set to true is equivalent to calling compress on the new vector:","category":"page"},{"location":"man/categorical/","page":"Categorical Data","title":"Categorical Data","text":"julia> cv1 = categorical([\"A\", \"B\"], compress=true)\n2-element CategoricalArray{String,1,UInt8}:\n \"A\"\n \"B\"","category":"page"},{"location":"man/categorical/","page":"Categorical Data","title":"Categorical Data","text":"If the ordered keyword argument is set to true, the resulting CategoricalArray will be ordered, which means that its levels can be tested for order (rather than throwing an error):","category":"page"},{"location":"man/categorical/","page":"Categorical Data","title":"Categorical Data","text":"julia> cv2 = categorical([\"A\", \"B\"], ordered=true)\n2-element CategoricalArray{String,1,UInt32}:\n \"A\"\n \"B\"\n\njulia> cv1[1] < cv1[2]\nERROR: ArgumentError: Unordered CategoricalValue objects cannot be tested for order using <. Use isless instead, or call the ordered! function on the parent array to change this\n\njulia> cv2[1] < cv2[2]\ntrue","category":"page"},{"location":"man/categorical/","page":"Categorical Data","title":"Categorical Data","text":"You can check if a CategoricalArray is ordered using the isordered function and change between ordered and unordered using ordered! function.","category":"page"},{"location":"man/categorical/","page":"Categorical Data","title":"Categorical Data","text":"julia> isordered(cv1)\nfalse\n\njulia> ordered!(cv1, true)\n2-element CategoricalArray{String,1,UInt8}:\n \"A\"\n \"B\"\n\njulia> isordered(cv1)\ntrue\n\njulia> cv1[1] < cv1[2]\ntrue","category":"page"},{"location":"man/categorical/","page":"Categorical Data","title":"Categorical Data","text":"Using categorical arrays is important for working with the GLM package. When fitting regression models, CategoricalVector columns in the input are translated into 0/1 indicator columns in the ModelMatrix with one column for each of the levels of the CategoricalVector. This allows one to analyze categorical data efficiently.","category":"page"},{"location":"man/categorical/","page":"Categorical Data","title":"Categorical Data","text":"See the CategoricalArrays package for more information regarding categorical arrays.","category":"page"},{"location":"man/sorting/#Sorting","page":"Sorting","title":"Sorting","text":"","category":"section"},{"location":"man/sorting/","page":"Sorting","title":"Sorting","text":"Sorting is a fundamental component of data analysis. Basic sorting is trivial: just calling sort! will sort all columns, in place:","category":"page"},{"location":"man/sorting/","page":"Sorting","title":"Sorting","text":"julia> using DataFrames, CSV\n\njulia> iris = CSV.read((joinpath(dirname(pathof(DataFrames)),\n                                 \"..\", \"docs\", \"src\", \"assets\", \"iris.csv\")),\n                       DataFrame)\n150×5 DataFrame\n Row │ SepalLength  SepalWidth  PetalLength  PetalWidth  Species\n     │ Float64      Float64     Float64      Float64     String\n─────┼──────────────────────────────────────────────────────────────────\n   1 │         5.1         3.5          1.4         0.2  Iris-setosa\n   2 │         4.9         3.0          1.4         0.2  Iris-setosa\n   3 │         4.7         3.2          1.3         0.2  Iris-setosa\n   4 │         4.6         3.1          1.5         0.2  Iris-setosa\n   5 │         5.0         3.6          1.4         0.2  Iris-setosa\n   6 │         5.4         3.9          1.7         0.4  Iris-setosa\n   7 │         4.6         3.4          1.4         0.3  Iris-setosa\n   8 │         5.0         3.4          1.5         0.2  Iris-setosa\n  ⋮  │      ⋮           ⋮            ⋮           ⋮             ⋮\n 144 │         6.8         3.2          5.9         2.3  Iris-virginica\n 145 │         6.7         3.3          5.7         2.5  Iris-virginica\n 146 │         6.7         3.0          5.2         2.3  Iris-virginica\n 147 │         6.3         2.5          5.0         1.9  Iris-virginica\n 148 │         6.5         3.0          5.2         2.0  Iris-virginica\n 149 │         6.2         3.4          5.4         2.3  Iris-virginica\n 150 │         5.9         3.0          5.1         1.8  Iris-virginica\n                                                        135 rows omitted\n\njulia> sort!(iris)\n150×5 DataFrame\n Row │ SepalLength  SepalWidth  PetalLength  PetalWidth  Species\n     │ Float64      Float64     Float64      Float64     String\n─────┼──────────────────────────────────────────────────────────────────\n   1 │         4.3         3.0          1.1         0.1  Iris-setosa\n   2 │         4.4         2.9          1.4         0.2  Iris-setosa\n   3 │         4.4         3.0          1.3         0.2  Iris-setosa\n   4 │         4.4         3.2          1.3         0.2  Iris-setosa\n   5 │         4.5         2.3          1.3         0.3  Iris-setosa\n   6 │         4.6         3.1          1.5         0.2  Iris-setosa\n   7 │         4.6         3.2          1.4         0.2  Iris-setosa\n   8 │         4.6         3.4          1.4         0.3  Iris-setosa\n  ⋮  │      ⋮           ⋮            ⋮           ⋮             ⋮\n 144 │         7.4         2.8          6.1         1.9  Iris-virginica\n 145 │         7.6         3.0          6.6         2.1  Iris-virginica\n 146 │         7.7         2.6          6.9         2.3  Iris-virginica\n 147 │         7.7         2.8          6.7         2.0  Iris-virginica\n 148 │         7.7         3.0          6.1         2.3  Iris-virginica\n 149 │         7.7         3.8          6.7         2.2  Iris-virginica\n 150 │         7.9         3.8          6.4         2.0  Iris-virginica\n                                                        135 rows omitted","category":"page"},{"location":"man/sorting/","page":"Sorting","title":"Sorting","text":"Observe that all columns are taken into account lexicographically when sorting the DataFrame.","category":"page"},{"location":"man/sorting/","page":"Sorting","title":"Sorting","text":"You can also call the sort function to create a new DataFrame with freshly allocated sorted vectors.","category":"page"},{"location":"man/sorting/","page":"Sorting","title":"Sorting","text":"In sorting DataFrames, you may want to sort different columns with different options. Here are some examples showing most of the possible options:","category":"page"},{"location":"man/sorting/","page":"Sorting","title":"Sorting","text":"julia> sort!(iris, rev = true)\n150×5 DataFrame\n Row │ SepalLength  SepalWidth  PetalLength  PetalWidth  Species\n     │ Float64      Float64     Float64      Float64     String\n─────┼──────────────────────────────────────────────────────────────────\n   1 │         7.9         3.8          6.4         2.0  Iris-virginica\n   2 │         7.7         3.8          6.7         2.2  Iris-virginica\n   3 │         7.7         3.0          6.1         2.3  Iris-virginica\n   4 │         7.7         2.8          6.7         2.0  Iris-virginica\n   5 │         7.7         2.6          6.9         2.3  Iris-virginica\n   6 │         7.6         3.0          6.6         2.1  Iris-virginica\n   7 │         7.4         2.8          6.1         1.9  Iris-virginica\n   8 │         7.3         2.9          6.3         1.8  Iris-virginica\n  ⋮  │      ⋮           ⋮            ⋮           ⋮             ⋮\n 144 │         4.6         3.2          1.4         0.2  Iris-setosa\n 145 │         4.6         3.1          1.5         0.2  Iris-setosa\n 146 │         4.5         2.3          1.3         0.3  Iris-setosa\n 147 │         4.4         3.2          1.3         0.2  Iris-setosa\n 148 │         4.4         3.0          1.3         0.2  Iris-setosa\n 149 │         4.4         2.9          1.4         0.2  Iris-setosa\n 150 │         4.3         3.0          1.1         0.1  Iris-setosa\n                                                        135 rows omitted\n\njulia> sort!(iris, [:Species, :SepalWidth])\n150×5 DataFrame\n Row │ SepalLength  SepalWidth  PetalLength  PetalWidth  Species\n     │ Float64      Float64     Float64      Float64     String\n─────┼──────────────────────────────────────────────────────────────────\n   1 │         4.5         2.3          1.3         0.3  Iris-setosa\n   2 │         4.4         2.9          1.4         0.2  Iris-setosa\n   3 │         5.0         3.0          1.6         0.2  Iris-setosa\n   4 │         4.9         3.0          1.4         0.2  Iris-setosa\n   5 │         4.8         3.0          1.4         0.3  Iris-setosa\n   6 │         4.8         3.0          1.4         0.1  Iris-setosa\n   7 │         4.4         3.0          1.3         0.2  Iris-setosa\n   8 │         4.3         3.0          1.1         0.1  Iris-setosa\n  ⋮  │      ⋮           ⋮            ⋮           ⋮             ⋮\n 144 │         6.7         3.3          5.7         2.1  Iris-virginica\n 145 │         6.3         3.3          6.0         2.5  Iris-virginica\n 146 │         6.3         3.4          5.6         2.4  Iris-virginica\n 147 │         6.2         3.4          5.4         2.3  Iris-virginica\n 148 │         7.2         3.6          6.1         2.5  Iris-virginica\n 149 │         7.9         3.8          6.4         2.0  Iris-virginica\n 150 │         7.7         3.8          6.7         2.2  Iris-virginica\n                                                        135 rows omitted\n\njulia> sort!(iris, [order(:Species, by=length), order(:SepalLength, rev=true)])\n150×5 DataFrame\n Row │ SepalLength  SepalWidth  PetalLength  PetalWidth  Species\n     │ Float64      Float64     Float64      Float64     String\n─────┼───────────────────────────────────────────────────────────────────\n   1 │         5.8         4.0          1.2         0.2  Iris-setosa\n   2 │         5.7         3.8          1.7         0.3  Iris-setosa\n   3 │         5.7         4.4          1.5         0.4  Iris-setosa\n   4 │         5.5         3.5          1.3         0.2  Iris-setosa\n   5 │         5.5         4.2          1.4         0.2  Iris-setosa\n   6 │         5.4         3.4          1.7         0.2  Iris-setosa\n   7 │         5.4         3.4          1.5         0.4  Iris-setosa\n   8 │         5.4         3.7          1.5         0.2  Iris-setosa\n  ⋮  │      ⋮           ⋮            ⋮           ⋮              ⋮\n 144 │         5.5         2.6          4.4         1.2  Iris-versicolor\n 145 │         5.4         3.0          4.5         1.5  Iris-versicolor\n 146 │         5.2         2.7          3.9         1.4  Iris-versicolor\n 147 │         5.1         2.5          3.0         1.1  Iris-versicolor\n 148 │         5.0         2.0          3.5         1.0  Iris-versicolor\n 149 │         5.0         2.3          3.3         1.0  Iris-versicolor\n 150 │         4.9         2.4          3.3         1.0  Iris-versicolor\n                                                         135 rows omitted","category":"page"},{"location":"man/sorting/","page":"Sorting","title":"Sorting","text":"Keywords used above include rev (to sort in reverse), and by (to apply a function to values before comparing them). Each keyword can either be a single value, a vector with values corresponding to individual columns, or a selector: :, Cols, All, Not, Between, or Regex.","category":"page"},{"location":"man/sorting/","page":"Sorting","title":"Sorting","text":"As an alternative to using a vector values you can use order to specify an ordering for a particular column within a set of columns.","category":"page"},{"location":"man/sorting/","page":"Sorting","title":"Sorting","text":"The following two examples show two ways to sort the iris dataset with the same result: :Species will be ordered in reverse order, and within groups, rows will be sorted by increasing :PetalLength:","category":"page"},{"location":"man/sorting/","page":"Sorting","title":"Sorting","text":"julia> sort!(iris, [:Species, :PetalLength], rev=(true, false))\n150×5 DataFrame\n Row │ SepalLength  SepalWidth  PetalLength  PetalWidth  Species\n     │ Float64      Float64     Float64      Float64     String\n─────┼──────────────────────────────────────────────────────────────────\n   1 │         4.9         2.5          4.5         1.7  Iris-virginica\n   2 │         6.2         2.8          4.8         1.8  Iris-virginica\n   3 │         6.0         3.0          4.8         1.8  Iris-virginica\n   4 │         6.3         2.7          4.9         1.8  Iris-virginica\n   5 │         6.1         3.0          4.9         1.8  Iris-virginica\n   6 │         5.6         2.8          4.9         2.0  Iris-virginica\n   7 │         6.3         2.5          5.0         1.9  Iris-virginica\n   8 │         6.0         2.2          5.0         1.5  Iris-virginica\n  ⋮  │      ⋮           ⋮            ⋮           ⋮             ⋮\n 144 │         4.7         3.2          1.6         0.2  Iris-setosa\n 145 │         5.7         3.8          1.7         0.3  Iris-setosa\n 146 │         5.4         3.4          1.7         0.2  Iris-setosa\n 147 │         5.4         3.9          1.7         0.4  Iris-setosa\n 148 │         5.1         3.3          1.7         0.5  Iris-setosa\n 149 │         5.1         3.8          1.9         0.4  Iris-setosa\n 150 │         4.8         3.4          1.9         0.2  Iris-setosa\n                                                        135 rows omitted\n\njulia> sort!(iris, [order(:Species, rev=true), :PetalLength])\n150×5 DataFrame\n Row │ SepalLength  SepalWidth  PetalLength  PetalWidth  Species\n     │ Float64      Float64     Float64      Float64     String\n─────┼──────────────────────────────────────────────────────────────────\n   1 │         4.9         2.5          4.5         1.7  Iris-virginica\n   2 │         6.2         2.8          4.8         1.8  Iris-virginica\n   3 │         6.0         3.0          4.8         1.8  Iris-virginica\n   4 │         6.3         2.7          4.9         1.8  Iris-virginica\n   5 │         6.1         3.0          4.9         1.8  Iris-virginica\n   6 │         5.6         2.8          4.9         2.0  Iris-virginica\n   7 │         6.3         2.5          5.0         1.9  Iris-virginica\n   8 │         6.0         2.2          5.0         1.5  Iris-virginica\n  ⋮  │      ⋮           ⋮            ⋮           ⋮             ⋮\n 144 │         4.7         3.2          1.6         0.2  Iris-setosa\n 145 │         5.7         3.8          1.7         0.3  Iris-setosa\n 146 │         5.4         3.4          1.7         0.2  Iris-setosa\n 147 │         5.4         3.9          1.7         0.4  Iris-setosa\n 148 │         5.1         3.3          1.7         0.5  Iris-setosa\n 149 │         5.1         3.8          1.9         0.4  Iris-setosa\n 150 │         4.8         3.4          1.9         0.2  Iris-setosa\n                                                        135 rows omitted","category":"page"},{"location":"man/working_with_dataframes/#Working-with-Data-Frames","page":"Working with DataFrames","title":"Working with Data Frames","text":"","category":"section"},{"location":"man/working_with_dataframes/#Examining-the-Data","page":"Working with DataFrames","title":"Examining the Data","text":"","category":"section"},{"location":"man/working_with_dataframes/","page":"Working with DataFrames","title":"Working with DataFrames","text":"The default printing of DataFrame objects only includes a sample of rows and columns that fits on screen:","category":"page"},{"location":"man/working_with_dataframes/","page":"Working with DataFrames","title":"Working with DataFrames","text":"julia> using DataFrames\n\njulia> df = DataFrame(A = 1:2:1000, B = repeat(1:10, inner=50), C = 1:500)\n500×3 DataFrame\n Row │ A      B      C\n     │ Int64  Int64  Int64\n─────┼─────────────────────\n   1 │     1      1      1\n   2 │     3      1      2\n   3 │     5      1      3\n   4 │     7      1      4\n   5 │     9      1      5\n   6 │    11      1      6\n   7 │    13      1      7\n   8 │    15      1      8\n  ⋮  │   ⋮      ⋮      ⋮\n 494 │   987     10    494\n 495 │   989     10    495\n 496 │   991     10    496\n 497 │   993     10    497\n 498 │   995     10    498\n 499 │   997     10    499\n 500 │   999     10    500\n           485 rows omitted","category":"page"},{"location":"man/working_with_dataframes/","page":"Working with DataFrames","title":"Working with DataFrames","text":"Printing options can be adjusted by calling the show function manually: show(df, allrows=true) prints all rows even if they do not fit on screen and show(df, allcols=true) does the same for columns.","category":"page"},{"location":"man/working_with_dataframes/","page":"Working with DataFrames","title":"Working with DataFrames","text":"The first and last functions can be used to look at the first and last rows of a data frame (respectively):","category":"page"},{"location":"man/working_with_dataframes/","page":"Working with DataFrames","title":"Working with DataFrames","text":"julia> first(df, 6)\n6×3 DataFrame\n Row │ A      B      C\n     │ Int64  Int64  Int64\n─────┼─────────────────────\n   1 │     1      1      1\n   2 │     3      1      2\n   3 │     5      1      3\n   4 │     7      1      4\n   5 │     9      1      5\n   6 │    11      1      6\n\njulia> last(df, 6)\n6×3 DataFrame\n Row │ A      B      C\n     │ Int64  Int64  Int64\n─────┼─────────────────────\n   1 │   989     10    495\n   2 │   991     10    496\n   3 │   993     10    497\n   4 │   995     10    498\n   5 │   997     10    499\n   6 │   999     10    500","category":"page"},{"location":"man/working_with_dataframes/","page":"Working with DataFrames","title":"Working with DataFrames","text":"Also notice that when DataFrame is printed to the console or rendered in HTML (e.g. in Jupyter Notebook) you get an information about type of elements held in its columns. For example in this case:","category":"page"},{"location":"man/working_with_dataframes/","page":"Working with DataFrames","title":"Working with DataFrames","text":"julia> using CategoricalArrays\n\njulia> DataFrame(a = 1:2, b = [1.0, missing],\n                 c = categorical('a':'b'), d = [1//2, missing])\n2×4 DataFrame\n Row │ a      b          c     d\n     │ Int64  Float64?   Cat…  Rational…?\n─────┼────────────────────────────────────\n   1 │     1        1.0  a           1//2\n   2 │     2  missing    b        missing\n","category":"page"},{"location":"man/working_with_dataframes/","page":"Working with DataFrames","title":"Working with DataFrames","text":"we can observe that:","category":"page"},{"location":"man/working_with_dataframes/","page":"Working with DataFrames","title":"Working with DataFrames","text":"the first column :a can hold elements of type Int64;\nthe second column :b can hold Float64 or Missing, which is indicated by ? printed after the name of type;\nthe third column :c can hold categorical data; here we notice …, which indicates that the actual name of the type was long and got truncated;\nthe type information in fourth column :d presents a situation where the name is both truncated and the type allows Missing.","category":"page"},{"location":"man/working_with_dataframes/#Taking-a-Subset","page":"Working with DataFrames","title":"Taking a Subset","text":"","category":"section"},{"location":"man/working_with_dataframes/#Indexing-syntax","page":"Working with DataFrames","title":"Indexing syntax","text":"","category":"section"},{"location":"man/working_with_dataframes/","page":"Working with DataFrames","title":"Working with DataFrames","text":"Specific subsets of a data frame can be extracted using the indexing syntax, similar to matrices. In the Indexing section of the manual you can find all the details about the available options. Here we highlight the basic options.","category":"page"},{"location":"man/working_with_dataframes/","page":"Working with DataFrames","title":"Working with DataFrames","text":"The colon : indicates that all items (rows or columns depending on its position) should be retained:","category":"page"},{"location":"man/working_with_dataframes/","page":"Working with DataFrames","title":"Working with DataFrames","text":"julia> df[1:3, :]\n3×3 DataFrame\n Row │ A      B      C\n     │ Int64  Int64  Int64\n─────┼─────────────────────\n   1 │     1      1      1\n   2 │     3      1      2\n   3 │     5      1      3\n\njulia> df[[1, 5, 10], :]\n3×3 DataFrame\n Row │ A      B      C\n     │ Int64  Int64  Int64\n─────┼─────────────────────\n   1 │     1      1      1\n   2 │     9      1      5\n   3 │    19      1     10\n\njulia> df[:, [:A, :B]]\n500×2 DataFrame\n Row │ A      B\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1      1\n   2 │     3      1\n   3 │     5      1\n   4 │     7      1\n   5 │     9      1\n   6 │    11      1\n   7 │    13      1\n   8 │    15      1\n  ⋮  │   ⋮      ⋮\n 494 │   987     10\n 495 │   989     10\n 496 │   991     10\n 497 │   993     10\n 498 │   995     10\n 499 │   997     10\n 500 │   999     10\n    485 rows omitted\n\njulia> df[1:3, [:B, :A]]\n3×2 DataFrame\n Row │ B      A\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1      1\n   2 │     1      3\n   3 │     1      5\n\njulia> df[[3, 1], [:C]]\n2×1 DataFrame\n Row │ C\n     │ Int64\n─────┼───────\n   1 │     3\n   2 │     1","category":"page"},{"location":"man/working_with_dataframes/","page":"Working with DataFrames","title":"Working with DataFrames","text":"Do note that df[!, [:A]] and df[:, [:A]] return a DataFrame object, while df[!, :A] and df[:, :A] return a vector:","category":"page"},{"location":"man/working_with_dataframes/","page":"Working with DataFrames","title":"Working with DataFrames","text":"julia> df[!, [:A]]\n500×1 DataFrame\n Row │ A\n     │ Int64\n─────┼───────\n   1 │     1\n   2 │     3\n   3 │     5\n   4 │     7\n   5 │     9\n   6 │    11\n   7 │    13\n   8 │    15\n  ⋮  │   ⋮\n 494 │   987\n 495 │   989\n 496 │   991\n 497 │   993\n 498 │   995\n 499 │   997\n 500 │   999\n485 rows omitted\n\njulia> df[!, [:A]] == df[:, [:A]]\ntrue\n\njulia> df[!, :A]\n500-element Vector{Int64}:\n   1\n   3\n   5\n   7\n   9\n  11\n  13\n  15\n  17\n  19\n   ⋮\n 983\n 985\n 987\n 989\n 991\n 993\n 995\n 997\n 999\n\njulia> df[!, :A] == df[:, :A]\ntrue","category":"page"},{"location":"man/working_with_dataframes/","page":"Working with DataFrames","title":"Working with DataFrames","text":"In the first case, [:A] is a vector, indicating that the resulting object should be a DataFrame. On the other hand, :A is a single symbol, indicating that a single column vector should be extracted. Note that in the first case a vector is required to be passed (not just any iterable), so e.g. df[:, (:x1, :x2)] is not allowed, but df[:, [:x1, :x2]] is valid.","category":"page"},{"location":"man/working_with_dataframes/","page":"Working with DataFrames","title":"Working with DataFrames","text":"It is also possible to use a regular expression as a selector of columns matching it:","category":"page"},{"location":"man/working_with_dataframes/","page":"Working with DataFrames","title":"Working with DataFrames","text":"julia> df = DataFrame(x1=1, x2=2, y=3)\n1×3 DataFrame\n Row │ x1     x2     y\n     │ Int64  Int64  Int64\n─────┼─────────────────────\n   1 │     1      2      3\n\njulia> df[!, r\"x\"]\n1×2 DataFrame\n Row │ x1     x2\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1      2","category":"page"},{"location":"man/working_with_dataframes/","page":"Working with DataFrames","title":"Working with DataFrames","text":"A Not selector (from the InvertedIndices package) can be used to select all columns excluding a specific subset:","category":"page"},{"location":"man/working_with_dataframes/","page":"Working with DataFrames","title":"Working with DataFrames","text":"julia> df[!, Not(:x1)]\n1×2 DataFrame\n Row │ x2     y\n     │ Int64  Int64\n─────┼──────────────\n   1 │     2      3","category":"page"},{"location":"man/working_with_dataframes/","page":"Working with DataFrames","title":"Working with DataFrames","text":"Finally, you can use Not, Between, Cols and All selectors in more complex column selection scenarios (note that Cols() selects no columns while All() selects all columns therefore Cols is a preferred selector if you write generic code). The following examples move all columns whose names match r\"x\" regular expression respectively to the front and to the end of a data frame:","category":"page"},{"location":"man/working_with_dataframes/","page":"Working with DataFrames","title":"Working with DataFrames","text":"julia> df = DataFrame(r=1, x1=2, x2=3, y=4)\n1×4 DataFrame\n Row │ r      x1     x2     y\n     │ Int64  Int64  Int64  Int64\n─────┼────────────────────────────\n   1 │     1      2      3      4\n\njulia> df[:, Cols(r\"x\", :)]\n1×4 DataFrame\n Row │ x1     x2     r      y\n     │ Int64  Int64  Int64  Int64\n─────┼────────────────────────────\n   1 │     2      3      1      4\n\njulia> df[:, Cols(Not(r\"x\"), :)]\n1×4 DataFrame\n Row │ r      y      x1     x2\n     │ Int64  Int64  Int64  Int64\n─────┼────────────────────────────\n   1 │     1      4      2      3","category":"page"},{"location":"man/working_with_dataframes/","page":"Working with DataFrames","title":"Working with DataFrames","text":"The indexing syntax can also be used to select rows based on conditions on variables:","category":"page"},{"location":"man/working_with_dataframes/","page":"Working with DataFrames","title":"Working with DataFrames","text":"julia> df = DataFrame(A = 1:2:1000, B = repeat(1:10, inner=50), C = 1:500)\n500×3 DataFrame\n Row │ A      B      C\n     │ Int64  Int64  Int64\n─────┼─────────────────────\n   1 │     1      1      1\n   2 │     3      1      2\n   3 │     5      1      3\n   4 │     7      1      4\n   5 │     9      1      5\n   6 │    11      1      6\n   7 │    13      1      7\n   8 │    15      1      8\n  ⋮  │   ⋮      ⋮      ⋮\n 494 │   987     10    494\n 495 │   989     10    495\n 496 │   991     10    496\n 497 │   993     10    497\n 498 │   995     10    498\n 499 │   997     10    499\n 500 │   999     10    500\n           485 rows omitted\n\njulia> df[df.A .> 500, :]\n250×3 DataFrame\n Row │ A      B      C\n     │ Int64  Int64  Int64\n─────┼─────────────────────\n   1 │   501      6    251\n   2 │   503      6    252\n   3 │   505      6    253\n   4 │   507      6    254\n   5 │   509      6    255\n   6 │   511      6    256\n   7 │   513      6    257\n   8 │   515      6    258\n  ⋮  │   ⋮      ⋮      ⋮\n 244 │   987     10    494\n 245 │   989     10    495\n 246 │   991     10    496\n 247 │   993     10    497\n 248 │   995     10    498\n 249 │   997     10    499\n 250 │   999     10    500\n           235 rows omitted\n\njulia> df[(df.A .> 500) .& (300 .< df.C .< 400), :]\n99×3 DataFrame\n Row │ A      B      C\n     │ Int64  Int64  Int64\n─────┼─────────────────────\n   1 │   601      7    301\n   2 │   603      7    302\n   3 │   605      7    303\n   4 │   607      7    304\n   5 │   609      7    305\n   6 │   611      7    306\n   7 │   613      7    307\n   8 │   615      7    308\n  ⋮  │   ⋮      ⋮      ⋮\n  93 │   785      8    393\n  94 │   787      8    394\n  95 │   789      8    395\n  96 │   791      8    396\n  97 │   793      8    397\n  98 │   795      8    398\n  99 │   797      8    399\n            84 rows omitted","category":"page"},{"location":"man/working_with_dataframes/","page":"Working with DataFrames","title":"Working with DataFrames","text":"Where a specific subset of values needs to be matched, the in() function can be applied:","category":"page"},{"location":"man/working_with_dataframes/","page":"Working with DataFrames","title":"Working with DataFrames","text":"julia> df[in.(df.A, Ref([1, 5, 601])), :]\n3×3 DataFrame\n Row │ A      B      C\n     │ Int64  Int64  Int64\n─────┼─────────────────────\n   1 │     1      1      1\n   2 │     5      1      3\n   3 │   601      7    301","category":"page"},{"location":"man/working_with_dataframes/","page":"Working with DataFrames","title":"Working with DataFrames","text":"Equivalently, the in function can be called with a single argument to create a function object that tests whether each value belongs to the subset (partial application of in): df[in([1, 5, 601]).(df.A), :].","category":"page"},{"location":"man/working_with_dataframes/","page":"Working with DataFrames","title":"Working with DataFrames","text":"note: Note\nAs with matrices, subsetting from a data frame will usually return a copy of columns, not a view or direct reference.The only indexing situations where data frames will not return a copy are:when a ! is placed in the first indexing position (df[!, :A], or df[!, [:A, :B]]),\nwhen using . (getpropery) notation (df.A),\nwhen a single row is selected using an integer (df[1, [:A, :B]])\nwhen view or @view is used (e.g. @view df[1:3, :A]).More details on copies, views, and references can be found in the getindex and view section.","category":"page"},{"location":"man/working_with_dataframes/#Selecting-and-transforming-columns","page":"Working with DataFrames","title":"Selecting and transforming columns","text":"","category":"section"},{"location":"man/working_with_dataframes/","page":"Working with DataFrames","title":"Working with DataFrames","text":"You can also use the select/select! and transform/transform! functions to select, rename and transform columns in a data frame.","category":"page"},{"location":"man/working_with_dataframes/","page":"Working with DataFrames","title":"Working with DataFrames","text":"The select function creates a new data frame:","category":"page"},{"location":"man/working_with_dataframes/","page":"Working with DataFrames","title":"Working with DataFrames","text":"julia> df = DataFrame(x1=[1, 2], x2=[3, 4], y=[5, 6])\n2×3 DataFrame\n Row │ x1     x2     y\n     │ Int64  Int64  Int64\n─────┼─────────────────────\n   1 │     1      3      5\n   2 │     2      4      6\n\njulia> select(df, Not(:x1)) # drop column :x1 in a new data frame\n2×2 DataFrame\n Row │ x2     y\n     │ Int64  Int64\n─────┼──────────────\n   1 │     3      5\n   2 │     4      6\n\njulia> select(df, r\"x\") # select columns containing 'x' character\n2×2 DataFrame\n Row │ x1     x2\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1      3\n   2 │     2      4\n\njulia> select(df, :x1 => :a1, :x2 => :a2) # rename columns\n2×2 DataFrame\n Row │ a1     a2\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1      3\n   2 │     2      4\n\njulia> select(df, :x1, :x2 => (x -> x .- minimum(x)) => :x2) # transform columns\n2×2 DataFrame\n Row │ x1     x2\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1      0\n   2 │     2      1\n\njulia> select(df, :x2, :x2 => ByRow(sqrt)) # transform columns by row\n2×2 DataFrame\n Row │ x2     x2_sqrt\n     │ Int64  Float64\n─────┼────────────────\n   1 │     3  1.73205\n   2 │     4  2.0\n\njulia> select(df, AsTable(:) => ByRow(extrema) => [:lo, :hi]) # return multiple columns\n2×2 DataFrame\n Row │ lo     hi\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1      5\n   2 │     2      6","category":"page"},{"location":"man/working_with_dataframes/","page":"Working with DataFrames","title":"Working with DataFrames","text":"It is important to note that select always returns a data frame, even if a single column is selected (as opposed to indexing syntax).","category":"page"},{"location":"man/working_with_dataframes/","page":"Working with DataFrames","title":"Working with DataFrames","text":"julia> select(df, :x1)\n2×1 DataFrame\n Row │ x1\n     │ Int64\n─────┼───────\n   1 │     1\n   2 │     2\n\njulia> df[:, :x1]\n2-element Vector{Int64}:\n 1\n 2","category":"page"},{"location":"man/working_with_dataframes/","page":"Working with DataFrames","title":"Working with DataFrames","text":"By default select copies columns of a passed source data frame. In order to avoid copying, pass copycols=false:","category":"page"},{"location":"man/working_with_dataframes/","page":"Working with DataFrames","title":"Working with DataFrames","text":"julia> df2 = select(df, :x1)\n2×1 DataFrame\n Row │ x1\n     │ Int64\n─────┼───────\n   1 │     1\n   2 │     2\n\njulia> df2.x1 === df.x1\nfalse\n\njulia> df2 = select(df, :x1, copycols=false)\n2×1 DataFrame\n Row │ x1\n     │ Int64\n─────┼───────\n   1 │     1\n   2 │     2\n\njulia> df2.x1 === df.x1\ntrue","category":"page"},{"location":"man/working_with_dataframes/","page":"Working with DataFrames","title":"Working with DataFrames","text":"To perform the selection operation in-place use select!:","category":"page"},{"location":"man/working_with_dataframes/","page":"Working with DataFrames","title":"Working with DataFrames","text":"julia> select!(df, Not(:x1));\n\njulia> df\n2×2 DataFrame\n Row │ x2     y\n     │ Int64  Int64\n─────┼──────────────\n   1 │     3      5\n   2 │     4      6","category":"page"},{"location":"man/working_with_dataframes/","page":"Working with DataFrames","title":"Working with DataFrames","text":"transform and transform! functions work identically to select and select! with the only difference that they retain all columns that are present in the source data frame. Here are some more advanced examples.","category":"page"},{"location":"man/working_with_dataframes/","page":"Working with DataFrames","title":"Working with DataFrames","text":"First we show how to generate a column that is a sum of all other columns in the data frame using the All() selector:","category":"page"},{"location":"man/working_with_dataframes/","page":"Working with DataFrames","title":"Working with DataFrames","text":"julia> df = DataFrame(x1=[1, 2], x2=[3, 4], y=[5, 6])\n2×3 DataFrame\n Row │ x1     x2     y\n     │ Int64  Int64  Int64\n─────┼─────────────────────\n   1 │     1      3      5\n   2 │     2      4      6\n\njulia> transform(df, All() => +)\n2×4 DataFrame\n Row │ x1     x2     y      x1_x2_y_+\n     │ Int64  Int64  Int64  Int64\n─────┼────────────────────────────────\n   1 │     1      3      5          9\n   2 │     2      4      6         12","category":"page"},{"location":"man/working_with_dataframes/","page":"Working with DataFrames","title":"Working with DataFrames","text":"Using the ByRow wrapper, we can easily compute for each row the name of column with the highest score:","category":"page"},{"location":"man/working_with_dataframes/","page":"Working with DataFrames","title":"Working with DataFrames","text":"julia> using Random\n\njulia> Random.seed!(1);\n\njulia> df = DataFrame(rand(10, 3), [:a, :b, :c])\n10×3 DataFrame\n Row │ a           b          c\n     │ Float64     Float64    Float64\n─────┼──────────────────────────────────\n   1 │ 0.236033    0.555751   0.0769509\n   2 │ 0.346517    0.437108   0.640396\n   3 │ 0.312707    0.424718   0.873544\n   4 │ 0.00790928  0.773223   0.278582\n   5 │ 0.488613    0.28119    0.751313\n   6 │ 0.210968    0.209472   0.644883\n   7 │ 0.951916    0.251379   0.0778264\n   8 │ 0.999905    0.0203749  0.848185\n   9 │ 0.251662    0.287702   0.0856352\n  10 │ 0.986666    0.859512   0.553206\n\njulia> transform(df, AsTable(:) => ByRow(argmax) => :prediction)\n10×4 DataFrame\n Row │ a           b          c          prediction\n     │ Float64     Float64    Float64    Symbol\n─────┼──────────────────────────────────────────────\n   1 │ 0.236033    0.555751   0.0769509  b\n   2 │ 0.346517    0.437108   0.640396   c\n   3 │ 0.312707    0.424718   0.873544   c\n   4 │ 0.00790928  0.773223   0.278582   b\n   5 │ 0.488613    0.28119    0.751313   c\n   6 │ 0.210968    0.209472   0.644883   c\n   7 │ 0.951916    0.251379   0.0778264  a\n   8 │ 0.999905    0.0203749  0.848185   a\n   9 │ 0.251662    0.287702   0.0856352  b\n  10 │ 0.986666    0.859512   0.553206   a","category":"page"},{"location":"man/working_with_dataframes/","page":"Working with DataFrames","title":"Working with DataFrames","text":"In the following, most complex, example below we compute row-wise sum, number of elements, and mean, while ignoring missing values.","category":"page"},{"location":"man/working_with_dataframes/","page":"Working with DataFrames","title":"Working with DataFrames","text":"julia> using Statistics\n\njulia> df = DataFrame(x=[1, 2, missing], y=[1, missing, missing])\n3×2 DataFrame\n Row │ x        y\n     │ Int64?   Int64?\n─────┼──────────────────\n   1 │       1        1\n   2 │       2  missing\n   3 │ missing  missing\n\njulia> transform(df, AsTable(:) .=>\n                     ByRow.([sum∘skipmissing,\n                             x -> count(!ismissing, x),\n                             mean∘skipmissing]) .=>\n                     [:sum, :n, :mean])\n3×5 DataFrame\n Row │ x        y        sum    n      mean\n     │ Int64?   Int64?   Int64  Int64  Float64\n─────┼─────────────────────────────────────────\n   1 │       1        1      2      2      1.0\n   2 │       2  missing      2      1      2.0\n   3 │ missing  missing      0      0    NaN","category":"page"},{"location":"man/working_with_dataframes/","page":"Working with DataFrames","title":"Working with DataFrames","text":"While the DataFrames.jl package provides basic data manipulation capabilities, users are encouraged to use querying frameworks for more convenient and powerful operations:","category":"page"},{"location":"man/working_with_dataframes/","page":"Working with DataFrames","title":"Working with DataFrames","text":"the Query.jl package provides a","category":"page"},{"location":"man/working_with_dataframes/","page":"Working with DataFrames","title":"Working with DataFrames","text":"LINQ-like interface to a large number of data sources","category":"page"},{"location":"man/working_with_dataframes/","page":"Working with DataFrames","title":"Working with DataFrames","text":"the DataFramesMeta.jl","category":"page"},{"location":"man/working_with_dataframes/","page":"Working with DataFrames","title":"Working with DataFrames","text":"package provides interfaces similar to LINQ and dplyr","category":"page"},{"location":"man/working_with_dataframes/","page":"Working with DataFrames","title":"Working with DataFrames","text":"See the Data manipulation frameworks section for more information.","category":"page"},{"location":"man/working_with_dataframes/#Summarizing-Data","page":"Working with DataFrames","title":"Summarizing Data","text":"","category":"section"},{"location":"man/working_with_dataframes/","page":"Working with DataFrames","title":"Working with DataFrames","text":"The describe function returns a data frame summarizing the elementary statistics and information about each column:","category":"page"},{"location":"man/working_with_dataframes/","page":"Working with DataFrames","title":"Working with DataFrames","text":"julia> df = DataFrame(A = 1:4, B = [\"M\", \"F\", \"F\", \"M\"])\n4×2 DataFrame\n Row │ A      B\n     │ Int64  String\n─────┼───────────────\n   1 │     1  M\n   2 │     2  F\n   3 │     3  F\n   4 │     4  M\n\njulia> describe(df)\n2×7 DataFrame\n Row │ variable  mean    min  median  max  nmissing  eltype\n     │ Symbol    Union…  Any  Union…  Any  Int64     DataType\n─────┼────────────────────────────────────────────────────────\n   1 │ A         2.5     1    2.5     4           0  Int64\n   2 │ B                 F            M           0  String","category":"page"},{"location":"man/working_with_dataframes/","page":"Working with DataFrames","title":"Working with DataFrames","text":"If you are interested in describing only a subset of columns then the easiest way to do it is to pass a subset of an original data frame to describe like this:","category":"page"},{"location":"man/working_with_dataframes/","page":"Working with DataFrames","title":"Working with DataFrames","text":"julia> describe(df[!, [:A]])\n1×7 DataFrame\n Row │ variable  mean     min    median   max    nmissing  eltype\n     │ Symbol    Float64  Int64  Float64  Int64  Int64     DataType\n─────┼──────────────────────────────────────────────────────────────\n   1 │ A             2.5      1      2.5      4         0  Int64","category":"page"},{"location":"man/working_with_dataframes/","page":"Working with DataFrames","title":"Working with DataFrames","text":"Of course, one can also compute descriptive statistics directly on individual columns:","category":"page"},{"location":"man/working_with_dataframes/","page":"Working with DataFrames","title":"Working with DataFrames","text":"julia> using Statistics\n\njulia> mean(df.A)\n2.5","category":"page"},{"location":"man/working_with_dataframes/","page":"Working with DataFrames","title":"Working with DataFrames","text":"We can also apply a function to each column of a DataFrame using combine. For example:","category":"page"},{"location":"man/working_with_dataframes/","page":"Working with DataFrames","title":"Working with DataFrames","text":"julia> df = DataFrame(A = 1:4, B = 4.0:-1.0:1.0)\n4×2 DataFrame\n Row │ A      B\n     │ Int64  Float64\n─────┼────────────────\n   1 │     1      4.0\n   2 │     2      3.0\n   3 │     3      2.0\n   4 │     4      1.0\n\njulia> combine(df, names(df) .=> sum)\n1×2 DataFrame\n Row │ A_sum  B_sum\n     │ Int64  Float64\n─────┼────────────────\n   1 │    10     10.0\n\njulia> combine(df, names(df) .=> sum, names(df) .=> prod)\n1×4 DataFrame\n Row │ A_sum  B_sum    A_prod  B_prod\n     │ Int64  Float64  Int64   Float64\n─────┼─────────────────────────────────\n   1 │    10     10.0      24     24.0","category":"page"},{"location":"man/working_with_dataframes/","page":"Working with DataFrames","title":"Working with DataFrames","text":"If you would prefer the result to have the same number of rows as the source data frame use select instead of combine.","category":"page"},{"location":"man/working_with_dataframes/#Handling-of-Columns-Stored-in-a-DataFrame","page":"Working with DataFrames","title":"Handling of Columns Stored in a DataFrame","text":"","category":"section"},{"location":"man/working_with_dataframes/","page":"Working with DataFrames","title":"Working with DataFrames","text":"Functions that transform a DataFrame to produce a new DataFrame always perform a copy of the columns by default, for example:","category":"page"},{"location":"man/working_with_dataframes/","page":"Working with DataFrames","title":"Working with DataFrames","text":"julia> df = DataFrame(A = 1:4, B = 4.0:-1.0:1.0)\n4×2 DataFrame\n Row │ A      B\n     │ Int64  Float64\n─────┼────────────────\n   1 │     1      4.0\n   2 │     2      3.0\n   3 │     3      2.0\n   4 │     4      1.0\n\njulia> df2 = copy(df);\n\njulia> df2.A === df.A\nfalse","category":"page"},{"location":"man/working_with_dataframes/","page":"Working with DataFrames","title":"Working with DataFrames","text":"On the other hand, in-place functions, whose names end with !, may mutate the column vectors of the DataFrame they take as an argument, for example:","category":"page"},{"location":"man/working_with_dataframes/","page":"Working with DataFrames","title":"Working with DataFrames","text":"julia> x = [3, 1, 2];\n\njulia> df = DataFrame(x=x)\n3×1 DataFrame\n Row │ x\n     │ Int64\n─────┼───────\n   1 │     3\n   2 │     1\n   3 │     2\n\njulia> sort!(df)\n3×1 DataFrame\n Row │ x\n     │ Int64\n─────┼───────\n   1 │     1\n   2 │     2\n   3 │     3\n\njulia> x\n3-element Vector{Int64}:\n 3\n 1\n 2\n\njulia> df.x[1] = 100\n100\n\njulia> df\n3×1 DataFrame\n Row │ x\n     │ Int64\n─────┼───────\n   1 │   100\n   2 │     2\n   3 │     3\n\njulia> x\n3-element Vector{Int64}:\n 3\n 1\n 2","category":"page"},{"location":"man/working_with_dataframes/","page":"Working with DataFrames","title":"Working with DataFrames","text":"Note, that in the above example the original x vector is not mutated in the process as the DataFrame(x=x) constructor makes a copy by default.","category":"page"},{"location":"man/working_with_dataframes/","page":"Working with DataFrames","title":"Working with DataFrames","text":"In-place functions are safe to call, except when a view of the DataFrame (created via a view, @view or groupby) or when a DataFrame created with copycols=false are in use.","category":"page"},{"location":"man/working_with_dataframes/","page":"Working with DataFrames","title":"Working with DataFrames","text":"It is possible to have a direct access to a column col of a DataFrame df using the syntaxes df.col, df[!, :col], via the eachcol function, by accessing a parent of a view of a column of a DataFrame, or simply by storing the reference to the column vector before the DataFrame was created with copycols=false.","category":"page"},{"location":"man/working_with_dataframes/","page":"Working with DataFrames","title":"Working with DataFrames","text":"julia> x = [3, 1, 2];\n\njulia> df = DataFrame(x=x)\n3×1 DataFrame\n Row │ x\n     │ Int64\n─────┼───────\n   1 │     3\n   2 │     1\n   3 │     2\n\njulia> df.x == x\ntrue\n\njulia> df[!, 1] !== x\ntrue\n\njulia> eachcol(df)[1] === df.x\ntrue","category":"page"},{"location":"man/working_with_dataframes/","page":"Working with DataFrames","title":"Working with DataFrames","text":"Note that a column obtained from a DataFrame using one of these methods should not be mutated without caution.","category":"page"},{"location":"man/working_with_dataframes/","page":"Working with DataFrames","title":"Working with DataFrames","text":"The exact rules of handling columns of a DataFrame are explained in The design of handling of columns of a DataFrame section of the manual.","category":"page"},{"location":"man/working_with_dataframes/#Replacing-Data","page":"Working with DataFrames","title":"Replacing Data","text":"","category":"section"},{"location":"man/working_with_dataframes/","page":"Working with DataFrames","title":"Working with DataFrames","text":"Several approaches can be used to replace some values with others in a data frame. Some apply the replacement to all values in a data frame, and others to individual columns or subset of columns.","category":"page"},{"location":"man/working_with_dataframes/","page":"Working with DataFrames","title":"Working with DataFrames","text":"Do note that in-place replacement requires that the replacement value can be converted to the column's element type. In particular, this implies that replacing a value with missing requires a call to allowmissing! if the column did not allow for missing values.","category":"page"},{"location":"man/working_with_dataframes/","page":"Working with DataFrames","title":"Working with DataFrames","text":"Replacement operations affecting a single column can be performed using replace!:","category":"page"},{"location":"man/working_with_dataframes/","page":"Working with DataFrames","title":"Working with DataFrames","text":"julia> using DataFrames\n\njulia> df = DataFrame(a = [\"a\", \"None\", \"b\", \"None\"], b = 1:4, c = [\"None\", \"j\", \"k\", \"h\"], d = [\"x\", \"y\", \"None\", \"z\"])\n4×4 DataFrame\n Row │ a       b      c       d\n     │ String  Int64  String  String\n─────┼───────────────────────────────\n   1 │ a           1  None    x\n   2 │ None        2  j       y\n   3 │ b           3  k       None\n   4 │ None        4  h       z\n\njulia> replace!(df.a, \"None\" => \"c\")\n4-element Vector{String}:\n \"a\"\n \"c\"\n \"b\"\n \"c\"\n\njulia> df\n4×4 DataFrame\n Row │ a       b      c       d\n     │ String  Int64  String  String\n─────┼───────────────────────────────\n   1 │ a           1  None    x\n   2 │ c           2  j       y\n   3 │ b           3  k       None\n   4 │ c           4  h       z","category":"page"},{"location":"man/working_with_dataframes/","page":"Working with DataFrames","title":"Working with DataFrames","text":"This is equivalent to df.a = replace(df.a, \"None\" => \"c\"), but operates in-place, without allocating a new column vector.","category":"page"},{"location":"man/working_with_dataframes/","page":"Working with DataFrames","title":"Working with DataFrames","text":"Replacement operations on multiple columns or on the whole data frame can be performed in-place using the broadcasting syntax:","category":"page"},{"location":"man/working_with_dataframes/","page":"Working with DataFrames","title":"Working with DataFrames","text":"# replacement on a subset of columns [:c, :d]\njulia> df[:, [:c, :d]] .= ifelse.(df[!, [:c, :d]] .== \"None\", \"c\", df[!, [:c, :d]])\n4×2 SubDataFrame\n Row │ c       d\n     │ String  String\n─────┼────────────────\n   1 │ c       x\n   2 │ j       y\n   3 │ k       c\n   4 │ h       z\n\njulia> df\n4×4 DataFrame\n Row │ a       b      c       d\n     │ String  Int64  String  String\n─────┼───────────────────────────────\n   1 │ a           1  c       x\n   2 │ c           2  j       y\n   3 │ b           3  k       c\n   4 │ c           4  h       z\n\njulia> df .= ifelse.(df .== \"c\", \"None\", df) # replacement on entire data frame\n4×4 DataFrame\n Row │ a       b      c       d\n     │ String  Int64  String  String\n─────┼───────────────────────────────\n   1 │ a           1  None    x\n   2 │ None        2  j       y\n   3 │ b           3  k       None\n   4 │ None        4  h       z","category":"page"},{"location":"man/working_with_dataframes/","page":"Working with DataFrames","title":"Working with DataFrames","text":"Do note that in the above examples, changing .= to just = will allocate new column vectors instead of applying the operation in-place.","category":"page"},{"location":"man/working_with_dataframes/","page":"Working with DataFrames","title":"Working with DataFrames","text":"When replacing values with missing, if the columns do not already allow for missing values, one has to either avoid in-place operation and use = instead of .=, or call allowmissing! beforehand:","category":"page"},{"location":"man/working_with_dataframes/","page":"Working with DataFrames","title":"Working with DataFrames","text":"julia> df2 = ifelse.(df .== \"None\", missing, df) # do not operate in-place (`df = ` would also work)\n4×4 DataFrame\n Row │ a        b      c        d\n     │ String?  Int64  String?  String?\n─────┼──────────────────────────────────\n   1 │ a            1  missing  x\n   2 │ missing      2  j        y\n   3 │ b            3  k        missing\n   4 │ missing      4  h        z\n\njulia> allowmissing!(df) # operate in-place after allowing for missing\n4×4 DataFrame\n Row │ a        b       c        d\n     │ String?  Int64?  String?  String?\n─────┼───────────────────────────────────\n   1 │ a             1  None     x\n   2 │ None          2  j        y\n   3 │ b             3  k        None\n   4 │ None          4  h        z\n\njulia> df .= ifelse.(df .== \"None\", missing, df)\n4×4 DataFrame\n Row │ a        b       c        d\n     │ String?  Int64?  String?  String?\n─────┼───────────────────────────────────\n   1 │ a             1  missing  x\n   2 │ missing       2  j        y\n   3 │ b             3  k        missing\n   4 │ missing       4  h        z","category":"page"},{"location":"man/comparisons/#Comparisons","page":"Comparison with Python/R/Stata","title":"Comparisons","text":"","category":"section"},{"location":"man/comparisons/","page":"Comparison with Python/R/Stata","title":"Comparison with Python/R/Stata","text":"This section compares DataFrames.jl with other data manipulation frameworks in Python, R, and Stata.","category":"page"},{"location":"man/comparisons/","page":"Comparison with Python/R/Stata","title":"Comparison with Python/R/Stata","text":"A sample data set can be created using the following code:","category":"page"},{"location":"man/comparisons/","page":"Comparison with Python/R/Stata","title":"Comparison with Python/R/Stata","text":"using DataFrames\nusing Statistics\n\ndf = DataFrame(grp = repeat(1:2, 3), x = 6:-1:1, y = 4:9, z = [3:7; missing], id = 'a':'f')\ndf2 = DataFrame(grp = [1, 3], w = [10, 11])","category":"page"},{"location":"man/comparisons/","page":"Comparison with Python/R/Stata","title":"Comparison with Python/R/Stata","text":"note: Note\nSome of the operations mutate the tables so every operation assumes that it is done on the original data frame.","category":"page"},{"location":"man/comparisons/","page":"Comparison with Python/R/Stata","title":"Comparison with Python/R/Stata","text":"Note that in the comparisons presented below predicates like x -> x >= 1 can be more compactly written as =>(1). The latter form has an additional benefit that it is compiled only once per Julia session (as opposed to x -> x >= 1 which defines a new anonymous function every time it is introduced).","category":"page"},{"location":"man/comparisons/#Comparison-with-the-Python-package-pandas","page":"Comparison with Python/R/Stata","title":"Comparison with the Python package pandas","text":"","category":"section"},{"location":"man/comparisons/","page":"Comparison with Python/R/Stata","title":"Comparison with Python/R/Stata","text":"The following table compares the main functions of DataFrames.jl with the Python package pandas (version 1.1.0):","category":"page"},{"location":"man/comparisons/","page":"Comparison with Python/R/Stata","title":"Comparison with Python/R/Stata","text":"import pandas as pd\nimport numpy as np\n\ndf = pd.DataFrame({'grp': [1, 2, 1, 2, 1, 2],\n                   'x': range(6, 0, -1),\n                   'y': range(4, 10),\n                   'z': [3, 4, 5, 6, 7, None]},\n                   index = list('abcdef'))\ndf2 = pd.DataFrame({'grp': [1, 3], 'w': [10, 11]})","category":"page"},{"location":"man/comparisons/","page":"Comparison with Python/R/Stata","title":"Comparison with Python/R/Stata","text":"Because pandas supports multi-index, this example data frame is set up with a to f as row indices rather than a separate id column.","category":"page"},{"location":"man/comparisons/#Accessing-data","page":"Comparison with Python/R/Stata","title":"Accessing data","text":"","category":"section"},{"location":"man/comparisons/","page":"Comparison with Python/R/Stata","title":"Comparison with Python/R/Stata","text":"Operation pandas DataFrames.jl\nCell indexing by location df.iloc[1, 1] df[2, 2]\nRow slicing by location df.iloc[1:3] df[2:3, :]\nColumn slicing by location df.iloc[:, 1:] df[:, 2:end]\nRow indexing by label df.loc['c'] df[findfirst(==('c'), df.id), :]\nColumn indexing by label df.loc[:, 'x'] df[:, :x]\nColumn slicing by label df.loc[:, ['x', 'z']] df[:, [:x, :z]]\n df.loc[:, 'x':'z'] df[:, Between(:x, :z)]\nMixed indexing df.loc['c'][1] df[findfirst(==('c'), df.id), 2]","category":"page"},{"location":"man/comparisons/","page":"Comparison with Python/R/Stata","title":"Comparison with Python/R/Stata","text":"Note that Julia uses 1-based indexing, inclusive on both ends. A special keyword end can be used to indicate the last index. Likewise, the begin keyword can be used to indicate the first index.","category":"page"},{"location":"man/comparisons/","page":"Comparison with Python/R/Stata","title":"Comparison with Python/R/Stata","text":"In addition, when indexing a data frame with the findfirst function, a single DataFrameRow object is returned. In the case that id is not unique, you can use the findall function or boolean indexing instead. It would then return a DataFrame object containing all matched rows. The following two lines of code are functionally equivalent:","category":"page"},{"location":"man/comparisons/","page":"Comparison with Python/R/Stata","title":"Comparison with Python/R/Stata","text":"df[findall(==('c'), df.id), :]\ndf[df.id .== 'c', :]","category":"page"},{"location":"man/comparisons/","page":"Comparison with Python/R/Stata","title":"Comparison with Python/R/Stata","text":"DataFrames.jl's indexing always produces a consistent and predictable return type. By contrast, pandas' loc function returns a Series object when there is exactly one 'c' value in the index, and it returns a DataFrame object when there are multiple rows having the index value of 'c'.","category":"page"},{"location":"man/comparisons/#Common-operations","page":"Comparison with Python/R/Stata","title":"Common operations","text":"","category":"section"},{"location":"man/comparisons/","page":"Comparison with Python/R/Stata","title":"Comparison with Python/R/Stata","text":"Operation pandas DataFrames.jl\nReduce multiple values df['z'].mean(skipna = False) mean(df.z)\n df['z'].mean() mean(skipmissing(df.z))\n df[['z']].agg(['mean']) combine(df, :z => mean ∘ skipmissing)\nAdd new columns df.assign(z1 = df['z'] + 1) transform(df, :z => (v -> v .+ 1) => :z1)\nRename columns df.rename(columns = {'x': 'x_new'}) rename(df, :x => :x_new)\nPick & transform columns df.assign(x_mean = df['x'].mean())[['x_mean', 'y']] select(df, :x => mean, :y)\nSort rows df.sort_values(by = 'x') sort(df, :x)\n df.sort_values(by = ['grp', 'x'], ascending = [True, False]) sort(df, [:grp, order(:x, rev = true)])\nDrop missing rows df.dropna() dropmissing(df)\nSelect unique rows df.drop_duplicates() unique(df)","category":"page"},{"location":"man/comparisons/","page":"Comparison with Python/R/Stata","title":"Comparison with Python/R/Stata","text":"Note that pandas skips NaN values in its analytic functions by default. By contrast, Julia functions do not skip NaN's. If necessary, you can filter out the NaN's before processing, for example, mean(Iterators.filter(!isnan, x)).","category":"page"},{"location":"man/comparisons/","page":"Comparison with Python/R/Stata","title":"Comparison with Python/R/Stata","text":"Pandas uses NaN for representing both missing data and the floating point \"not a number\" value. Julia defines a special value missing for representing missing data. DataFrames.jl respects general rules in Julia in propagating missing values by default. If necessary, the skipmissing function can be used to remove missing data. See the Missing Data section for more information.","category":"page"},{"location":"man/comparisons/","page":"Comparison with Python/R/Stata","title":"Comparison with Python/R/Stata","text":"In addition, pandas keeps the original column name after applying a function. DataFrames.jl appends a suffix to the column name by default. To keep it simple, the examples above do not synchronize the column names between pandas and DataFrames.jl (you can pass renamecols=false keyword argument to select, transform and combine functions to retain old column names).","category":"page"},{"location":"man/comparisons/#Mutating-operations","page":"Comparison with Python/R/Stata","title":"Mutating operations","text":"","category":"section"},{"location":"man/comparisons/","page":"Comparison with Python/R/Stata","title":"Comparison with Python/R/Stata","text":"Operation pandas DataFrames.jl\nAdd new columns df['z1'] = df['z'] + 1 df.z1 = df.z .+ 1\n  transform!(df, :z => (x -> x .+ 1) => :z1)\n df.insert(1, 'const', 10) insertcols!(df, 2, :const => 10)\nRename columns df.rename(columns = {'x': 'x_new'}, inplace = True) rename!(df, :x => :x_new)\nSort rows df.sort_values(by = 'x', inplace = True) sort!(df, :x)\nDrop missing rows df.dropna(inplace = True) dropmissing!(df)\nSelect unique rows df.drop_duplicates(inplace = True) unique!(df)","category":"page"},{"location":"man/comparisons/","page":"Comparison with Python/R/Stata","title":"Comparison with Python/R/Stata","text":"Generally speaking, DataFrames.jl follows the Julia convention of using ! in the function name to indicate mutation behavior.","category":"page"},{"location":"man/comparisons/#Grouping-data-and-aggregation","page":"Comparison with Python/R/Stata","title":"Grouping data and aggregation","text":"","category":"section"},{"location":"man/comparisons/","page":"Comparison with Python/R/Stata","title":"Comparison with Python/R/Stata","text":"DataFrames.jl provides a groupby function to apply operations over each group independently. The result of groupby is a GroupedDataFrame object which may be processed using the combine, transform, or select functions. The following table illustrates some common grouping and aggregation usages.","category":"page"},{"location":"man/comparisons/","page":"Comparison with Python/R/Stata","title":"Comparison with Python/R/Stata","text":"Operation pandas DataFrames.jl\nAggregate by groups df.groupby('grp')['x'].mean() combine(groupby(df, :grp), :x => mean)\nRename column after aggregation df.groupby('grp')['x'].mean().rename(\"my_mean\") combine(groupby(df, :grp), :x => mean => :my_mean)\nAdd aggregated data as column df.join(df.groupby('grp')['x'].mean(), on='grp', rsuffix='_mean') transform(groupby(df, :grp), :x => mean)\n...and select output columns df.join(df.groupby('grp')['x'].mean(), on='grp', rsuffix='_mean')[['grp', 'x_mean']] select(groupby(df, :grp), :id, :x => mean)","category":"page"},{"location":"man/comparisons/","page":"Comparison with Python/R/Stata","title":"Comparison with Python/R/Stata","text":"Note that pandas returns a Series object for 1-dimensional result unless reset_index is called afterwards. The corresponding DataFrames.jl examples return an equivalent DataFrame object. Consider the first example:","category":"page"},{"location":"man/comparisons/","page":"Comparison with Python/R/Stata","title":"Comparison with Python/R/Stata","text":">>> df.groupby('grp')['x'].mean()\ngrp\n1    4\n2    3\nName: x, dtype: int64","category":"page"},{"location":"man/comparisons/","page":"Comparison with Python/R/Stata","title":"Comparison with Python/R/Stata","text":"For DataFrames.jl, it looks like this:","category":"page"},{"location":"man/comparisons/","page":"Comparison with Python/R/Stata","title":"Comparison with Python/R/Stata","text":"julia> combine(groupby(df, :grp), :x => mean)\n2×2 DataFrame\n Row │ grp    x_mean\n     │ Int64  Float64\n─────┼────────────────\n   1 │     1      4.0\n   2 │     2      3.0","category":"page"},{"location":"man/comparisons/","page":"Comparison with Python/R/Stata","title":"Comparison with Python/R/Stata","text":"In DataFrames.jl, the GroupedDataFrame object supports an efficient key lookup. Hence, it performs well when you need to perform lookups repeatedly.","category":"page"},{"location":"man/comparisons/#More-advanced-commands","page":"Comparison with Python/R/Stata","title":"More advanced commands","text":"","category":"section"},{"location":"man/comparisons/","page":"Comparison with Python/R/Stata","title":"Comparison with Python/R/Stata","text":"This section includes more complex examples.","category":"page"},{"location":"man/comparisons/","page":"Comparison with Python/R/Stata","title":"Comparison with Python/R/Stata","text":"Operation pandas DataFrames.jl\nComplex Function df[['z']].agg(lambda v: np.mean(np.cos(v))) combine(df, :z => v -> mean(cos, skipmissing(v)))\nAggregate multiple columns df.agg({'x': max, 'y': min}) combine(df, :x => maximum, :y => minimum)\n df[['x', 'y']].mean() combine(df, [:x, :y] .=> mean)\n df.filter(regex=(\"^x\")).mean() combine(df, names(df, r\"^x\") .=> mean)\nApply function over multiple variables df.assign(x_y_cor = np.corrcoef(df.x, df.y)[0, 1]) transform(df, [:x, :y] => cor)\nRow-wise operation df.assign(x_y_min = df.apply(lambda v: min(v.x, v.y), axis=1)) transform(df, [:x, :y] => ByRow(min))\n df.assign(x_y_argmax = df.apply(lambda v: df.columns[v.argmax()], axis=1)) transform(df, AsTable([:x, :y]) => ByRow(argmax))\nDataFrame as input df.groupby('grp').head(2) combine(d -> first(d, 2), groupby(df, :grp))\nDataFrame as output df[['x']].agg(lambda x: [min(x), max(x)]) combine(df, :x => (x -> (x = [minimum(x), maximum(x)],)) => AsTable)","category":"page"},{"location":"man/comparisons/","page":"Comparison with Python/R/Stata","title":"Comparison with Python/R/Stata","text":"Note that pandas preserves the same row order after groupby whereas DataFrames.jl shows them grouped by the provided keys after the combine operation, but select and transform retain an original row ordering.","category":"page"},{"location":"man/comparisons/#Joining-data-frames","page":"Comparison with Python/R/Stata","title":"Joining data frames","text":"","category":"section"},{"location":"man/comparisons/","page":"Comparison with Python/R/Stata","title":"Comparison with Python/R/Stata","text":"DataFrames.jl supports join operations similar to a relational database.","category":"page"},{"location":"man/comparisons/","page":"Comparison with Python/R/Stata","title":"Comparison with Python/R/Stata","text":"Operation pandas DataFrames.jl\nInner join pd.merge(df, df2, how = 'inner', on = 'grp') innerjoin(df, df2, on = :grp)\nOuter join pd.merge(df, df2, how = 'outer', on = 'grp') outerjoin(df, df2, on = :grp)\nLeft join pd.merge(df, df2, how = 'left', on = 'grp') leftjoin(df, df2, on = :grp)\nRight join pd.merge(df, df2, how = 'right', on = 'grp') rightjoin(df, df2, on = :grp)\nSemi join (filtering) df[df.grp.isin(df2.grp)] semijoin(df, df2, on = :grp)\nAnti join (filtering) df[~df.grp.isin(df2.grp)] antijoin(df, df2, on = :grp)","category":"page"},{"location":"man/comparisons/","page":"Comparison with Python/R/Stata","title":"Comparison with Python/R/Stata","text":"For multi-column joins, both pandas and DataFrames.jl accept an array for the on keyword argument.","category":"page"},{"location":"man/comparisons/","page":"Comparison with Python/R/Stata","title":"Comparison with Python/R/Stata","text":"In the cases of semi joins and anti joins, the isin function in pandas can still be used as long as the join keys are combined in a tuple. In DataFrames.jl, it just works normally with an array of join keys specified in the on keyword argument.","category":"page"},{"location":"man/comparisons/#Comparison-with-the-R-package-dplyr","page":"Comparison with Python/R/Stata","title":"Comparison with the R package dplyr","text":"","category":"section"},{"location":"man/comparisons/","page":"Comparison with Python/R/Stata","title":"Comparison with Python/R/Stata","text":"The following table compares the main functions of DataFrames.jl with the R package dplyr (version 1):","category":"page"},{"location":"man/comparisons/","page":"Comparison with Python/R/Stata","title":"Comparison with Python/R/Stata","text":"df <- tibble(grp = rep(1:2, 3), x = 6:1, y = 4:9,\n             z = c(3:7, NA), id = letters[1:6])","category":"page"},{"location":"man/comparisons/","page":"Comparison with Python/R/Stata","title":"Comparison with Python/R/Stata","text":"Operation dplyr DataFrames.jl\nReduce multiple values summarize(df, mean(x)) combine(df, :x => mean)\nAdd new columns mutate(df, x_mean = mean(x)) transform(df, :x => mean => :x_mean)\nRename columns rename(df, x_new = x) rename(df, :x => :x_new)\nPick columns select(df, x, y) select(df, :x, :y)\nPick & transform columns transmute(df, mean(x), y) select(df, :x => mean, :y)\nPick rows filter(df, x >= 1) subset(df, :x => ByRow(x -> x >= 1))\nSort rows arrange(df, x) sort(df, :x)","category":"page"},{"location":"man/comparisons/","page":"Comparison with Python/R/Stata","title":"Comparison with Python/R/Stata","text":"As in dplyr, some of these functions can be applied to grouped data frames, in which case they operate by group:","category":"page"},{"location":"man/comparisons/","page":"Comparison with Python/R/Stata","title":"Comparison with Python/R/Stata","text":"Operation dplyr DataFrames.jl\nReduce multiple values summarize(group_by(df, grp), mean(x)) combine(groupby(df, :grp), :x => mean)\nAdd new columns mutate(group_by(df, grp), mean(x)) transform(groupby(df, :grp), :x => mean)\nPick & transform columns transmute(group_by(df, grp), mean(x), y) select(groupby(df, :grp), :x => mean, :y)","category":"page"},{"location":"man/comparisons/","page":"Comparison with Python/R/Stata","title":"Comparison with Python/R/Stata","text":"The table below compares more advanced commands:","category":"page"},{"location":"man/comparisons/","page":"Comparison with Python/R/Stata","title":"Comparison with Python/R/Stata","text":"Operation dplyr DataFrames.jl\nComplex Function summarize(df, mean(x, na.rm = T)) combine(df, :x => x -> mean(skipmissing(x)))\nTransform several columns summarize(df, max(x), min(y)) combine(df, :x => maximum,  :y => minimum)\n summarize(df, across(c(x, y), mean)) combine(df, [:x, :y] .=> mean)\n summarize(df, across(starts_with(\"x\"), mean)) combine(df, names(df, r\"^x\") .=> mean)\n summarize(df, across(c(x, y), list(max, min))) combine(df, ([:x, :y] .=> [maximum minimum])...)\nMultivariate function mutate(df, cor(x, y)) transform(df, [:x, :y] => cor)\nRow-wise mutate(rowwise(df), min(x, y)) transform(df, [:x, :y] => ByRow(min))\n mutate(rowwise(df), which.max(c_across(matches(\"^x\")))) transform(df, AsTable(r\"^x\") => ByRow(argmax))\nDataFrame as input summarize(df, head(across(), 2)) combine(d -> first(d, 2), df)\nDataFrame as output summarize(df, tibble(value = c(min(x), max(x)))) combine(df, :x => (x -> (value = [minimum(x), maximum(x)],)) => AsTable)","category":"page"},{"location":"man/comparisons/#Comparison-with-the-R-package-data.table","page":"Comparison with Python/R/Stata","title":"Comparison with the R package data.table","text":"","category":"section"},{"location":"man/comparisons/","page":"Comparison with Python/R/Stata","title":"Comparison with Python/R/Stata","text":"The following table compares the main functions of DataFrames.jl with the R package data.table (version 1.14.1).","category":"page"},{"location":"man/comparisons/","page":"Comparison with Python/R/Stata","title":"Comparison with Python/R/Stata","text":"library(data.table)\ndf  <- data.table(grp = rep(1:2, 3), x = 6:1, y = 4:9,\n                  z = c(3:7, NA), id = letters[1:6])\ndf2 <- data.table(grp=c(1,3), w = c(10,11))                 ","category":"page"},{"location":"man/comparisons/","page":"Comparison with Python/R/Stata","title":"Comparison with Python/R/Stata","text":"Operation data.table DataFrames.jl\nReduce multiple values df[, .(mean(x))] combine(df, :x => mean)\nAdd new columns df[, x_mean:=mean(x) ] transform!(df, :x => mean => :x_mean)\nRename column (in place) setnames(df, \"x\", \"x_new\") rename!(df, :x => :x_new)\nRename multiple columns (in place) setnames(df, c(\"x\", \"y\"), c(\"x_new\", \"y_new\")) rename!(df, [:x, :y] .=> [:x_new, :y_new])\nPick columns as dataframe df[, .(x, y)] select(df, :x, :y)\nPick column as a vector df[, x] df[!, :x]\nRemove columns df[, -\"x\"] select(df, Not(:x))\nRemove columns (in place) df[, x:=NULL] select!(df, Not(:x))\nRemove columns (in place) df[, c(\"x\", \"y\"):=NULL] select!(df, Not([:x, :y]))\nPick & transform columns df[, .(mean(x), y)] select(df, :x => mean, :y)\nPick rows df[ x >= 1 ] filter(:x => >=(1), df)\nSort rows (in place) setorder(df, x) sort!(df, :x)\nSort rows df[ order(x) ] sort(df, :x)","category":"page"},{"location":"man/comparisons/#Grouping-data-and-aggregation-2","page":"Comparison with Python/R/Stata","title":"Grouping data and aggregation","text":"","category":"section"},{"location":"man/comparisons/","page":"Comparison with Python/R/Stata","title":"Comparison with Python/R/Stata","text":"Operation data.table DataFrames.jl\nReduce multiple values df[, mean(x), by=id ] combine(groupby(df, :id), :x => mean)\nAdd new columns (in place) df[, x_mean:=mean(x), by=id] transform!(groupby(df, :id), :x => mean)\nPick & transform columns df[, .(x_mean = mean(x), y), by=id] select(groupby(df, :id), :x => mean, :y)","category":"page"},{"location":"man/comparisons/#More-advanced-commands-2","page":"Comparison with Python/R/Stata","title":"More advanced commands","text":"","category":"section"},{"location":"man/comparisons/","page":"Comparison with Python/R/Stata","title":"Comparison with Python/R/Stata","text":"Operation data.table DataFrames.jl\nComplex Function df[, .(mean(x, na.rm=TRUE)) ] combine(df, :x => x -> mean(skipmissing(x)))\nTransform certain rows (in place) df[x<=0, x:=0] df.x[df.x .<= 0] .= 0\nTransform several columns df[, .(max(x), min(y)) ] combine(df, :x => maximum, :y => minimum)\n df[, lapply(.SD, mean), .SDcols = c(\"x\", \"y\") ] combine(df, [:x, :y] .=> mean)\n df[, lapply(.SD, mean), .SDcols = patterns(\"*x\") ] combine(df, names(df, r\"^x\") .=> mean)\n df[, unlist(lapply(.SD, function(x) c(max=max(x), min=min(x)))), .SDcols = c(\"x\", \"y\") ] combine(df, ([:x, :y] .=> [maximum minimum])...)\nMultivariate function df[, .(cor(x,y)) ] transform(df, [:x, :y] => cor)\nRow-wise df[, min_xy := min(x, y), by = 1:nrow(df)] transform!(df, [:x, :y] => ByRow(min))\n df[, argmax_xy := which.max(.SD) , .SDcols = patterns(\"*x\"), by = 1:nrow(df) ] transform!(df, AsTable(r\"^x\") => ByRow(argmax))\nDataFrame as output df[, .SD[1], by=grp] combine(groupby(df, :grp), first)\nDataFrame as output df[, .SD[which.max(x)], by=grp] combine(groupby(df, :grp), sdf -> sdf[argmax(sdf.x), :])","category":"page"},{"location":"man/comparisons/#Joining-data-frames-2","page":"Comparison with Python/R/Stata","title":"Joining data frames","text":"","category":"section"},{"location":"man/comparisons/","page":"Comparison with Python/R/Stata","title":"Comparison with Python/R/Stata","text":"Operation data.table DataFrames.jl\nInner join merge(df, df2, on = \"grp\") innerjoin(df, df2, on = :grp)\nOuter join merge(df, df2, all = TRUE, on = \"grp\") outerjoin(df, df2, on = :grp)\nLeft join merge(df, df2, all.x = TRUE, on = \"grp\") leftjoin(df, df2, on = :grp)\nRight join merge(df, df2, all.y = TRUE, on = \"grp\") rightjoin(df, df2, on = :grp)\nAnti join (filtering) df[!df2, on = \"grp\" ] antijoin(df, df2, on = :grp)\nSemi join (filtering) merge(df1, df2[, .(grp)]) semijoin(df, df2, on = :grp)","category":"page"},{"location":"man/comparisons/#Comparison-with-Stata-(version-8-and-above)","page":"Comparison with Python/R/Stata","title":"Comparison with Stata (version 8 and above)","text":"","category":"section"},{"location":"man/comparisons/","page":"Comparison with Python/R/Stata","title":"Comparison with Python/R/Stata","text":"The following table compares the main functions of DataFrames.jl with Stata:","category":"page"},{"location":"man/comparisons/","page":"Comparison with Python/R/Stata","title":"Comparison with Python/R/Stata","text":"Operation Stata DataFrames.jl\nReduce multiple values collapse (mean) x combine(df, :x => mean)\nAdd new columns egen x_mean = mean(x) transform!(df, :x => mean => :x_mean)\nRename columns rename x x_new rename!(df, :x => :x_new)\nPick columns keep x y select!(df, :x, :y)\nPick rows keep if x >= 1 subset!(df, :x => ByRow(x -> x >= 1))\nSort rows sort x sort!(df, :x)","category":"page"},{"location":"man/comparisons/","page":"Comparison with Python/R/Stata","title":"Comparison with Python/R/Stata","text":"Note that the suffix ! (i.e. transform!, select!, etc) ensures that the operation transforms the dataframe in place, as in Stata","category":"page"},{"location":"man/comparisons/","page":"Comparison with Python/R/Stata","title":"Comparison with Python/R/Stata","text":"Some of these functions can be applied to grouped data frames, in which case they operate by group:","category":"page"},{"location":"man/comparisons/","page":"Comparison with Python/R/Stata","title":"Comparison with Python/R/Stata","text":"Operation Stata DataFrames.jl\nAdd new columns egen x_mean = mean(x), by(grp) transform!(groupby(df, :grp), :x => mean)\nReduce multiple values collapse (mean) x, by(grp) combine(groupby(df, :grp), :x => mean)","category":"page"},{"location":"man/comparisons/","page":"Comparison with Python/R/Stata","title":"Comparison with Python/R/Stata","text":"The table below compares more advanced commands:","category":"page"},{"location":"man/comparisons/","page":"Comparison with Python/R/Stata","title":"Comparison with Python/R/Stata","text":"Operation Stata DataFrames.jl\nTransform certain rows replace x = 0 if x <= 0 transform(df, :x => (x -> ifelse.(x .<= 0, 0, x)) => :x)\nTransform several columns collapse (max) x (min) y combine(df, :x => maximum,  :y => minimum)\n collapse (mean) x y combine(df, [:x, :y] .=> mean)\n collapse (mean) x* combine(df, names(df, r\"^x\") .=> mean)\n collapse (max) x y (min) x y combine(df, ([:x, :y] .=> [maximum minimum])...)\nMultivariate function egen z = corr(x y) transform!(df, [:x, :y] => cor => :z)\nRow-wise egen z = rowmin(x y) transform!(df, [:x, :y] => ByRow(min) => :z)","category":"page"},{"location":"lib/types/","page":"Types","title":"Types","text":"CurrentModule = DataFrames","category":"page"},{"location":"lib/types/#Types","page":"Types","title":"Types","text":"","category":"section"},{"location":"lib/types/","page":"Types","title":"Types","text":"Pages = [\"types.md\"]","category":"page"},{"location":"lib/types/#Type-hierarchy-design","page":"Types","title":"Type hierarchy design","text":"","category":"section"},{"location":"lib/types/","page":"Types","title":"Types","text":"AbstractDataFrame is an abstract type that provides an interface for data frame types. It is not intended as a fully generic interface for working with tabular data, which is the role of interfaces defined by Tables.jl instead.","category":"page"},{"location":"lib/types/","page":"Types","title":"Types","text":"DataFrame is the most fundamental subtype of AbstractDataFrame, which stores a set of columns as AbstractVector objects. Indexing of all stored columns must be 1-based. Also, all functions exposed by DataFrames.jl API make sure to collect passed AbstractRange source columns before storing them in a DataFrame.","category":"page"},{"location":"lib/types/","page":"Types","title":"Types","text":"SubDataFrame is an AbstractDataFrame subtype representing a view into a DataFrame. It stores only a reference to the parent DataFrame and information about which rows and columns from the parent are selected (both as integer indices referring to the parent). Typically it is created using the view function or is returned by indexing into a GroupedDataFrame object.","category":"page"},{"location":"lib/types/","page":"Types","title":"Types","text":"GroupedDataFrame is a type that stores the result of a  grouping operation performed on an AbstractDataFrame. It is intended to be created as a result of a call to the groupby function.","category":"page"},{"location":"lib/types/","page":"Types","title":"Types","text":"DataFrameRow is a view into a single row of an AbstractDataFrame. It stores only a reference to a parent DataFrame and information about which row and columns from the parent are selected (both as integer indices referring to the parent). The DataFrameRow type supports iteration over columns of the row and is similar in functionality to the NamedTuple type, but allows for modification of data stored in the parent DataFrame and reflects changes done to the parent after the creation of the view. Typically objects of the DataFrameRow type are encountered when returned by the eachrow function, or when accessing a single row of a DataFrame or SubDataFrame via getindex or view.","category":"page"},{"location":"lib/types/","page":"Types","title":"Types","text":"The eachrow function returns a value of the DataFrameRows type, which serves as an iterator over rows of an AbstractDataFrame, returning DataFrameRow objects. The DataFrameRows is a subtype of AbstractVector and supports its interface with the exception that it is read-only.","category":"page"},{"location":"lib/types/","page":"Types","title":"Types","text":"Similarly, the eachcol function returns a value of the DataFrameColumns type, which is not an AbstractVector, but supports most of its API. The key differences are that it is read-only and that the keys function returns a vector of Symbols (and not integers as for normal vectors).","category":"page"},{"location":"lib/types/","page":"Types","title":"Types","text":"Note that DataFrameRows and DataFrameColumns are not exported and should not be constructed directly, but using the eachrow and eachcol functions.","category":"page"},{"location":"lib/types/","page":"Types","title":"Types","text":"The RepeatedVector and StackedVector types are subtypes of AbstractVector and support its interface with the exception that they are read only. Note that they are not exported and should not be constructed directly, but they are columns of a DataFrame returned by stack with view=true.","category":"page"},{"location":"lib/types/","page":"Types","title":"Types","text":"The ByRow type is a special type used for selection operations to signal that the wrapped function should be applied to each element (row) of the selection.","category":"page"},{"location":"lib/types/","page":"Types","title":"Types","text":"The AsTable type is a special type used for selection operations to signal that the columns selected by a wrapped selector should be passed as a NamedTuple to the function or to signal that it is requested to expand the return value of a transformation into multiple columns.","category":"page"},{"location":"lib/types/#man-columnhandling","page":"Types","title":"The design of handling of columns of a DataFrame","text":"","category":"section"},{"location":"lib/types/","page":"Types","title":"Types","text":"When a DataFrame is constructed columns are copied by default. You can disable this behavior by setting copycols keyword argument to false. The exception is if an AbstractRange is passed as a column, then it is always collected to a Vector.","category":"page"},{"location":"lib/types/","page":"Types","title":"Types","text":"Also functions that transform a DataFrame to produce a new DataFrame perform a copy of the columns, unless they are passed copycols=false (available only for functions that could perform a transformation without copying the columns). Examples of such functions are vcat, hcat, filter, dropmissing, getindex, copy or the DataFrame constructor mentioned above.","category":"page"},{"location":"lib/types/","page":"Types","title":"Types","text":"The generic single-argument constructor DataFrame(table) has copycols=nothing by default, meaning that columns are copied unless table signals that a copy of columns doesn't need to be made (this is done by wrapping the source table in Tables.CopiedColumns). CSV.jl does this when CSV.read(file, DataFrame) is called, since columns are built only for the purpose of use in a DataFrame constructor. Another example is Arrow.Table, where arrow data is inherently immutable so columns can't be accidentally mutated anyway. To be able to mutate arrow data, columns must be materialized, which can be accomplished via DataFrame(arrow_table, copycols=true).","category":"page"},{"location":"lib/types/","page":"Types","title":"Types","text":"On the contrary, functions that create a view of a DataFrame do not by definition make copies of the columns, and therefore require particular caution. This includes view, which returns a SubDataFrame or a DataFrameRow, and groupby, which returns a GroupedDataFrame.","category":"page"},{"location":"lib/types/","page":"Types","title":"Types","text":"A partial exception to this rule is the stack function with view=true which creates a DataFrame that contains views of the columns from the source DataFrame.","category":"page"},{"location":"lib/types/","page":"Types","title":"Types","text":"In-place functions whose names end with ! (like sort! or dropmissing!, setindex!, push!, append!) may mutate the column vectors of the DataFrame they take as an argument. These functions are safe to call due to the rules described above, except when a view of the DataFrame is in use (via a SubDataFrame, a DataFrameRow or a GroupedDataFrame). In the latter case, calling such a function on the parent might corrupt the view, which make trigger errors, silently return invalid data or even cause Julia to crash. The same caution applies when DataFrame was created using columns of another DataFrame without copying (for instance when copycols=false in functions such as DataFrame or hcat).","category":"page"},{"location":"lib/types/","page":"Types","title":"Types","text":"It is possible to have a direct access to a column col of a DataFrame df (e.g. this can be useful in performance critical code to avoid copying), using one of the following methods:","category":"page"},{"location":"lib/types/","page":"Types","title":"Types","text":"via the getproperty function using the syntax df.col;\nvia the getindex function using the syntax df[!, :col] (note this is in contrast to df[:, :col] which copies);\nby creating a DataFrameColumns object using the eachcol function;\nby calling the parent function on a view of a column of the DataFrame, e.g. parent(@view df[:, :col]);\nby storing the reference to the column before creating a DataFrame with copycols=false;","category":"page"},{"location":"lib/types/","page":"Types","title":"Types","text":"A column obtained from a DataFrame using one of the above methods should not be mutated without caution because:","category":"page"},{"location":"lib/types/","page":"Types","title":"Types","text":"resizing a column vector will corrupt its parent DataFrame and any associated views as methods only check the length of the column when it is added to the DataFrame and later assume that all columns have the same length;\nreordering values in a column vector (e.g. using sort!) will break the consistency of rows with other columns, which will also affect views (if any);\nchanging values contained in a column vector is acceptable as long as it is not used as a grouping column in a GroupedDataFrame created based on the DataFrame.","category":"page"},{"location":"lib/types/#Types-specification","page":"Types","title":"Types specification","text":"","category":"section"},{"location":"lib/types/","page":"Types","title":"Types","text":"AbstractDataFrame\nAsTable\nByRow\nDataFrame\nDataFrameRow\nGroupedDataFrame\nGroupKey\nGroupKeys\nSubDataFrame\nDataFrameRows\nDataFrameColumns\nRepeatedVector\nStackedVector","category":"page"},{"location":"lib/types/#DataFrames.AbstractDataFrame","page":"Types","title":"DataFrames.AbstractDataFrame","text":"AbstractDataFrame\n\nAn abstract type for which all concrete types expose an interface for working with tabular data.\n\nCommon methods\n\nAn AbstractDataFrame is a two-dimensional table with Symbols or strings for column names.\n\nThe following are normally implemented for AbstractDataFrames:\n\ndescribe : summarize columns\nsummary : show number of rows and columns\nhcat : horizontal concatenation\nvcat : vertical concatenation\nrepeat : repeat rows\nnames : columns names\nrename! : rename columns names based on keyword arguments\nlength : number of columns\nsize : (nrows, ncols)\nfirst : first n rows\nlast : last n rows\nconvert : convert to an array\ncompletecases : boolean vector of complete cases (rows with no missings)\ndropmissing : remove rows with missing values\ndropmissing! : remove rows with missing values in-place\nnonunique : indexes of duplicate rows\nunique : remove duplicate rows\nunique! : remove duplicate rows in-place\ndisallowmissing : drop support for missing values in columns\ndisallowmissing! : drop support for missing values in columns in-place\nallowmissing : add support for missing values in columns\nallowmissing! : add support for missing values in columns in-place\nsimilar : a DataFrame with similar columns as d\nfilter : remove rows\nfilter! : remove rows in-place\n\nIndexing and broadcasting\n\nAbstractDataFrame can be indexed by passing two indices specifying row and column selectors. The allowed indices are a superset of indices that can be used for standard arrays. You can also access a single column of an AbstractDataFrame using getproperty and setproperty! functions. Columns can be selected using integers, Symbols, or strings. In broadcasting AbstractDataFrame behavior is similar to a Matrix.\n\nA detailed description of getindex, setindex!, getproperty, setproperty!, broadcasting and broadcasting assignment for data frames is given in the \"Indexing\" section of the manual.\n\n\n\n\n\n","category":"type"},{"location":"lib/types/#DataFrames.AsTable","page":"Types","title":"DataFrames.AsTable","text":"AsTable(cols)\n\nA type used for selection operations to signal that the columns selected by the wrapped selector should be passed as a NamedTuple to the function.\n\n\n\n\n\n","category":"type"},{"location":"lib/types/#DataFrames.ByRow","page":"Types","title":"DataFrames.ByRow","text":"ByRow\n\nA type used for selection operations to signal that the wrapped function should be applied to each element (row) of the selection.\n\nNote that ByRow always collects values returned by fun in a vector.\n\n\n\n\n\n","category":"type"},{"location":"lib/types/#DataFrames.DataFrame","page":"Types","title":"DataFrames.DataFrame","text":"DataFrame <: AbstractDataFrame\n\nAn AbstractDataFrame that stores a set of named columns\n\nThe columns are normally AbstractVectors stored in memory, particularly a Vector or CategoricalVector.\n\nConstructors\n\nDataFrame(pairs::Pair...; makeunique::Bool=false, copycols::Bool=true)\nDataFrame(pairs::AbstractVector{<:Pair}; makeunique::Bool=false, copycols::Bool=true)\nDataFrame(ds::AbstractDict; copycols::Bool=true)\nDataFrame(kwargs..., copycols::Bool=true)\n\nDataFrame(columns::AbstractVecOrMat, names::Union{AbstractVector, Symbol};\n          makeunique::Bool=false, copycols::Bool=true)\n\nDataFrame(table; copycols::Union{Bool, Nothing}=nothing)\nDataFrame(::DataFrameRow)\nDataFrame(::GroupedDataFrame; keepkeys::Bool=true)\n\nKeyword arguments\n\ncopycols : whether vectors passed as columns should be copied; by default set to true and the vectors are copied; if set to false then the constructor will still copy the passed columns if it is not possible to construct a DataFrame without materializing new columns. Note the copycols=nothing default in the Tables.jl compatible constructor; it is provided as certain input table types may have already made a copy of columns or the columns may otherwise be immutable, in which case columns are not copied by default. To force a copy in such cases, or to get mutable columns from an immutable input table (like Arrow.Table), pass copycols=true explicitly.\nmakeunique : if false (the default), an error will be raised\n\n(note that not all constructors support these keyword arguments)\n\nDetails on behavior of different constructors\n\nIt is allowed to pass a vector of Pairs, a list of Pairs as positional arguments, or a list of keyword arguments. In this case each pair is considered to represent a column name to column value mapping and column name must be a Symbol or string. Alternatively a dictionary can be passed to the constructor in which case its entries are considered to define the column name and column value pairs. If the dictionary is a Dict then column names will be sorted in the returned DataFrame.\n\nIn all the constructors described above column value can be a vector which is consumed as is or an object of any other type (except AbstractArray). In the latter case the passed value is automatically repeated to fill a new vector of the appropriate length. As a particular rule values stored in a Ref or a 0-dimensional AbstractArray are unwrapped and treated in the same way.\n\nIt is also allowed to pass a vector of vectors or a matrix as as the first argument. In this case the second argument must be a vector of Symbols or strings specifying column names, or the symbol :auto to generate column names x1, x2, ... automatically.\n\nIf a single positional argument is passed to a DataFrame constructor then it is assumed to be of type that implements the Tables.jl interface using which the returned DataFrame is materialized.\n\nFinally it is allowed to construct a DataFrame from a DataFrameRow or a GroupedDataFrame. In the latter case the keepkeys keyword argument specifies whether the resulting DataFrame should contain the grouping columns of the passed GroupedDataFrame and the order of rows in the result follows the order of groups in the GroupedDataFrame passed.\n\nNotes\n\nThe DataFrame constructor by default copies all columns vectors passed to it. Pass the copycols=false keyword argument (where supported) to reuse vectors without copying them.\n\nBy default an error will be raised if duplicates in column names are found. Pass makeunique=true keyword argument (where supported) to accept duplicate names, in which case they will be suffixed with _i (i starting at 1 for the first duplicate).\n\nIf an AbstractRange is passed to a DataFrame constructor as a column it is always collected to a Vector (even if copycols=false). As a general rule AbstractRange values are always materialized to a Vector by all functions in DataFrames.jl before being stored in a DataFrame.\n\nDataFrame can store only columns that use 1-based indexing. Attempting to store a vector using non-standard indexing raises an error.\n\nThe DataFrame type is designed to allow column types to vary and to be dynamically changed also after it is constructed. Therefore DataFrames are not type stable. For performance-critical code that requires type-stability either use the functionality provided by select/transform/combine functions, use Tables.columntable and Tables.namedtupleiterator functions, use barrier functions, or provide type assertions to the variables that hold columns extracted from a DataFrame.\n\nExamples\n\njulia> DataFrame((a=[1, 2], b=[3, 4])) # Tables.jl table constructor\n2×2 DataFrame\n Row │ a      b\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1      3\n   2 │     2      4\n\njulia> DataFrame([(a=1, b=0), (a=2, b=0)]) # Tables.jl table constructor\n2×2 DataFrame\n Row │ a      b\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1      0\n   2 │     2      0\n\njulia> DataFrame(\"a\" => 1:2, \"b\" => 0) # Pair constructor\n2×2 DataFrame\n Row │ a      b\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1      0\n   2 │     2      0\n\njulia> DataFrame([:a => 1:2, :b => 0]) # vector of Pairs constructor\n2×2 DataFrame\n Row │ a      b\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1      0\n   2 │     2      0\n\njulia> DataFrame(Dict(:a => 1:2, :b => 0)) # dictionary constructor\n2×2 DataFrame\n Row │ a      b\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1      0\n   2 │     2      0\n\njulia> DataFrame(a=1:2, b=0) # keyword argument constructor\n2×2 DataFrame\n Row │ a      b\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1      0\n   2 │     2      0\n\njulia> DataFrame([[1, 2], [0, 0]], [:a, :b]) # vector of vectors constructor\n2×2 DataFrame\n Row │ a      b\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1      0\n   2 │     2      0\n\njulia> DataFrame([1 0; 2 0], :auto) # matrix constructor\n2×2 DataFrame\n Row │ x1     x2\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1      0\n   2 │     2      0\n\n\n\n\n\n","category":"type"},{"location":"lib/types/#DataFrames.DataFrameRow","page":"Types","title":"DataFrames.DataFrameRow","text":"DataFrameRow{<:AbstractDataFrame, <:AbstractIndex}\n\nA view of one row of an AbstractDataFrame.\n\nA DataFrameRow is returned by getindex or view functions when one row and a selection of columns are requested, or when iterating the result of the call to the eachrow function.\n\nThe DataFrameRow constructor can also be called directly:\n\nDataFrameRow(parent::AbstractDataFrame, row::Integer, cols=:)\n\nA DataFrameRow supports the iteration interface and can therefore be passed to functions that expect a collection as an argument. Its element type is always Any.\n\nIndexing is one-dimensional like specifying a column of a DataFrame. You can also access the data in a DataFrameRow using the getproperty and setproperty! functions and convert it to a Tuple, NamedTuple, or Vector using the corresponding functions.\n\nIf the selection of columns in a parent data frame is passed as : (a colon) then DataFrameRow will always have all columns from the parent, even if they are added or removed after its creation.\n\nExamples\n\njulia> df = DataFrame(a = repeat([1, 2], outer=[2]),\n                      b = repeat([\"a\", \"b\"], inner=[2]),\n                      c = 1:4)\n4×3 DataFrame\n Row │ a      b       c\n     │ Int64  String  Int64\n─────┼──────────────────────\n   1 │     1  a           1\n   2 │     2  a           2\n   3 │     1  b           3\n   4 │     2  b           4\n\njulia> df[1, :]\nDataFrameRow\n Row │ a      b       c\n     │ Int64  String  Int64\n─────┼──────────────────────\n   1 │     1  a           1\n\njulia> @view df[end, [:a]]\nDataFrameRow\n Row │ a\n     │ Int64\n─────┼───────\n   4 │     2\n\njulia> eachrow(df)[1]\nDataFrameRow\n Row │ a      b       c\n     │ Int64  String  Int64\n─────┼──────────────────────\n   1 │     1  a           1\n\njulia> Tuple(df[1, :])\n(1, \"a\", 1)\n\njulia> NamedTuple(df[1, :])\n(a = 1, b = \"a\", c = 1)\n\njulia> Vector(df[1, :])\n3-element Vector{Any}:\n 1\n  \"a\"\n 1\n\n\n\n\n\n","category":"type"},{"location":"lib/types/#DataFrames.GroupedDataFrame","page":"Types","title":"DataFrames.GroupedDataFrame","text":"GroupedDataFrame\n\nThe result of a groupby operation on an AbstractDataFrame; a view into the AbstractDataFrame grouped by rows.\n\nNot meant to be constructed directly, see groupby.\n\nOne can get the names of columns used to create GroupedDataFrame using the groupcols function. Similarly the groupindices function returns a vector of group indices for each row of the parent data frame.\n\nAfter its creation, a GroupedDataFrame reflects the grouping of rows that was valid at the its creation time. Therefore grouping columns of its parent data frame must not be mutated, and rows must not be added nor removed from it. To safeguard the user against such cases, if the number of rows in the parent data frame changes then trying to use GroupedDataFrame will throw an error. However, one can add or remove columns to the parent data frame without invalidating the GroupedDataFrame provided that columns used for grouping are not changed.\n\n\n\n\n\n","category":"type"},{"location":"lib/types/#DataFrames.GroupKey","page":"Types","title":"DataFrames.GroupKey","text":"GroupKey{T<:GroupedDataFrame}\n\nKey for one of the groups of a GroupedDataFrame. Contains the values of the corresponding grouping columns and behaves similarly to a NamedTuple, but using it to index its GroupedDataFrame is more efficient than using the equivalent Tuple and NamedTuple, and much more efficient than using the equivalent AbstractDict.\n\nInstances of this type are returned by keys(::GroupedDataFrame) and are not meant to be constructed directly.\n\nIndexing fields of GroupKey is allowed using an integer, a Symbol, or a string. It is also possible to access the data in a GroupKey using the getproperty function. A GroupKey can be converted to a Tuple, NamedTuple, a Vector, or a Dict. When converted to a Dict, the keys of the Dict are Symbols.\n\nSee keys(::GroupedDataFrame) for more information.\n\n\n\n\n\n","category":"type"},{"location":"lib/types/#DataFrames.GroupKeys","page":"Types","title":"DataFrames.GroupKeys","text":"GroupKeys{T<:GroupedDataFrame} <: AbstractVector{GroupKey{T}}\n\nA vector containing all GroupKey objects for a given GroupedDataFrame.\n\nSee keys(::GroupedDataFrame) for more information.\n\n\n\n\n\n","category":"type"},{"location":"lib/types/#DataFrames.SubDataFrame","page":"Types","title":"DataFrames.SubDataFrame","text":"SubDataFrame{<:AbstractDataFrame, <:AbstractIndex, <:AbstractVector{Int}} <: AbstractDataFrame\n\nA view of an AbstractDataFrame. It is returned by a call to the view function on an AbstractDataFrame if a collections of rows and columns are specified.\n\nA SubDataFrame is an AbstractDataFrame, so expect that most DataFrame functions should work. Such methods include describe, summary, nrow, size, by, stack, and join.\n\nIf the selection of columns in a parent data frame is passed as : (a colon) then SubDataFrame will always have all columns from the parent, even if they are added or removed after its creation.\n\nExamples\n\njulia> df = DataFrame(a = repeat([1, 2, 3, 4], outer=[2]),\n                      b = repeat([2, 1], outer=[4]),\n                      c = 1:8)\n8×3 DataFrame\n Row │ a      b      c\n     │ Int64  Int64  Int64\n─────┼─────────────────────\n   1 │     1      2      1\n   2 │     2      1      2\n   3 │     3      2      3\n   4 │     4      1      4\n   5 │     1      2      5\n   6 │     2      1      6\n   7 │     3      2      7\n   8 │     4      1      8\n\njulia> sdf1 = view(df, :, 2:3) # column subsetting\n8×2 SubDataFrame\n Row │ b      c\n     │ Int64  Int64\n─────┼──────────────\n   1 │     2      1\n   2 │     1      2\n   3 │     2      3\n   4 │     1      4\n   5 │     2      5\n   6 │     1      6\n   7 │     2      7\n   8 │     1      8\n\njulia> sdf2 = @view df[end:-1:1, [1, 3]]  # row and column subsetting\n8×2 SubDataFrame\n Row │ a      c\n     │ Int64  Int64\n─────┼──────────────\n   1 │     4      8\n   2 │     3      7\n   3 │     2      6\n   4 │     1      5\n   5 │     4      4\n   6 │     3      3\n   7 │     2      2\n   8 │     1      1\n\njulia> sdf3 = groupby(df, :a)[1]  # indexing a GroupedDataFrame returns a SubDataFrame\n2×3 SubDataFrame\n Row │ a      b      c\n     │ Int64  Int64  Int64\n─────┼─────────────────────\n   1 │     1      2      1\n   2 │     1      2      5\n\n\n\n\n\n","category":"type"},{"location":"lib/types/#DataFrames.DataFrameRows","page":"Types","title":"DataFrames.DataFrameRows","text":"DataFrameRows{D<:AbstractDataFrame} <: AbstractVector{DataFrameRow}\n\nIterator over rows of an AbstractDataFrame, with each row represented as a DataFrameRow.\n\nA value of this type is returned by the eachrow function.\n\n\n\n\n\n","category":"type"},{"location":"lib/types/#DataFrames.DataFrameColumns","page":"Types","title":"DataFrames.DataFrameColumns","text":"DataFrameColumns{<:AbstractDataFrame}\n\nA vector-like object that allows iteration over columns of an AbstractDataFrame.\n\nIndexing into DataFrameColumns objects using integer, Symbol or string returns the corresponding column (without copying). Indexing into DataFrameColumns objects using a multiple column selector returns a subsetted DataFrameColumns object with a new parent containing only the selected columns (without copying).\n\nDataFrameColumns supports most of the AbstractVector API. The key differences are that it is read-only and that the keys function returns a vector of Symbols (and not integers as for normal vectors).\n\nIn particular findnext, findprev, findfirst, findlast, and findall functions are supported, and in findnext and findprev functions it is allowed to pass an integer, string, or Symbol as a reference index.\n\n\n\n\n\n","category":"type"},{"location":"lib/types/#DataFrames.RepeatedVector","page":"Types","title":"DataFrames.RepeatedVector","text":"RepeatedVector{T} <: AbstractVector{T}\n\nAn AbstractVector that is a view into another AbstractVector with repeated elements\n\nNOTE: Not exported.\n\nConstructor\n\nRepeatedVector(parent::AbstractVector, inner::Int, outer::Int)\n\nArguments\n\nparent : the AbstractVector that's repeated\ninner : the numer of times each element is repeated\nouter : the numer of times the whole vector is repeated after expanded by inner\n\ninner and outer have the same meaning as similarly named arguments to repeat.\n\nExamples\n\nRepeatedVector([1, 2], 3, 1)   # [1, 1, 1, 2, 2, 2]\nRepeatedVector([1, 2], 1, 3)   # [1, 2, 1, 2, 1, 2]\nRepeatedVector([1, 2], 2, 2)   # [1, 2, 1, 2, 1, 2, 1, 2]\n\n\n\n\n\n","category":"type"},{"location":"lib/types/#DataFrames.StackedVector","page":"Types","title":"DataFrames.StackedVector","text":"StackedVector <: AbstractVector\n\nAn AbstractVector that is a linear, concatenated view into another set of AbstractVectors\n\nNOTE: Not exported.\n\nConstructor\n\nStackedVector(d::AbstractVector)\n\nArguments\n\nd... : one or more AbstractVectors\n\nExamples\n\nStackedVector(Any[[1, 2], [9, 10], [11, 12]])  # [1, 2, 9, 10, 11, 12]\n\n\n\n\n\n","category":"type"},{"location":"man/joins/#Database-Style-Joins","page":"Joins","title":"Database-Style Joins","text":"","category":"section"},{"location":"man/joins/","page":"Joins","title":"Joins","text":"We often need to combine two or more data sets together to provide a complete picture of the topic we are studying. For example, suppose that we have the following two data sets:","category":"page"},{"location":"man/joins/","page":"Joins","title":"Joins","text":"julia> using DataFrames\n\njulia> people = DataFrame(ID = [20, 40], Name = [\"John Doe\", \"Jane Doe\"])\n2×2 DataFrame\n Row │ ID     Name\n     │ Int64  String\n─────┼─────────────────\n   1 │    20  John Doe\n   2 │    40  Jane Doe\n\njulia> jobs = DataFrame(ID = [20, 40], Job = [\"Lawyer\", \"Doctor\"])\n2×2 DataFrame\n Row │ ID     Job\n     │ Int64  String\n─────┼───────────────\n   1 │    20  Lawyer\n   2 │    40  Doctor","category":"page"},{"location":"man/joins/","page":"Joins","title":"Joins","text":"We might want to work with a larger data set that contains both the names and jobs for each ID. We can do this using the innerjoin function:","category":"page"},{"location":"man/joins/","page":"Joins","title":"Joins","text":"julia> innerjoin(people, jobs, on = :ID)\n2×3 DataFrame\n Row │ ID     Name      Job\n     │ Int64  String    String\n─────┼─────────────────────────\n   1 │    20  John Doe  Lawyer\n   2 │    40  Jane Doe  Doctor","category":"page"},{"location":"man/joins/","page":"Joins","title":"Joins","text":"In relational database theory, this operation is generally referred to as a join. The columns used to determine which rows should be combined during a join are called keys.","category":"page"},{"location":"man/joins/","page":"Joins","title":"Joins","text":"The following functions are provided to perform seven kinds of joins:","category":"page"},{"location":"man/joins/","page":"Joins","title":"Joins","text":"innerjoin: the output contains rows for values of the key that exist in all passed data frames.\nleftjoin: the output contains rows for values of the key that exist in the first (left) argument,   whether or not that value exists in the second (right) argument.\nrightjoin: the output contains rows for values of the key that exist in the second (right) argument,   whether or not that value exists in the first (left) argument.\nouterjoin: the output contains rows for values of the key that exist in any of the passed data frames.\nsemijoin: Like an inner join, but output is restricted to columns from the first (left) argument.\nantijoin: The output contains rows for values of the key that exist in the first (left) but not the second (right) argument.   As with semijoin, output is restricted to columns from the first (left) argument.\ncrossjoin: The output is the cartesian product of rows from all passed data frames.","category":"page"},{"location":"man/joins/","page":"Joins","title":"Joins","text":"See the Wikipedia page on SQL joins for more information.","category":"page"},{"location":"man/joins/","page":"Joins","title":"Joins","text":"Here are examples of different kinds of join:","category":"page"},{"location":"man/joins/","page":"Joins","title":"Joins","text":"julia> jobs = DataFrame(ID = [20, 60], Job = [\"Lawyer\", \"Astronaut\"])\n2×2 DataFrame\n Row │ ID     Job\n     │ Int64  String\n─────┼──────────────────\n   1 │    20  Lawyer\n   2 │    60  Astronaut\n\njulia> innerjoin(people, jobs, on = :ID)\n1×3 DataFrame\n Row │ ID     Name      Job\n     │ Int64  String    String\n─────┼─────────────────────────\n   1 │    20  John Doe  Lawyer\n\njulia> leftjoin(people, jobs, on = :ID)\n2×3 DataFrame\n Row │ ID     Name      Job\n     │ Int64  String    String?\n─────┼──────────────────────────\n   1 │    20  John Doe  Lawyer\n   2 │    40  Jane Doe  missing\n\njulia> rightjoin(people, jobs, on = :ID)\n2×3 DataFrame\n Row │ ID     Name      Job\n     │ Int64  String?   String\n─────┼────────────────────────────\n   1 │    20  John Doe  Lawyer\n   2 │    60  missing   Astronaut\n\njulia> outerjoin(people, jobs, on = :ID)\n3×3 DataFrame\n Row │ ID     Name      Job\n     │ Int64  String?   String?\n─────┼────────────────────────────\n   1 │    20  John Doe  Lawyer\n   2 │    40  Jane Doe  missing\n   3 │    60  missing   Astronaut\n\njulia> semijoin(people, jobs, on = :ID)\n1×2 DataFrame\n Row │ ID     Name\n     │ Int64  String\n─────┼─────────────────\n   1 │    20  John Doe\n\njulia> antijoin(people, jobs, on = :ID)\n1×2 DataFrame\n Row │ ID     Name\n     │ Int64  String\n─────┼─────────────────\n   1 │    40  Jane Doe","category":"page"},{"location":"man/joins/","page":"Joins","title":"Joins","text":"Cross joins are the only kind of join that does not use a on key:","category":"page"},{"location":"man/joins/","page":"Joins","title":"Joins","text":"julia> crossjoin(people, jobs, makeunique = true)\n4×4 DataFrame\n Row │ ID     Name      ID_1   Job\n     │ Int64  String    Int64  String\n─────┼───────────────────────────────────\n   1 │    20  John Doe     20  Lawyer\n   2 │    20  John Doe     60  Astronaut\n   3 │    40  Jane Doe     20  Lawyer\n   4 │    40  Jane Doe     60  Astronaut","category":"page"},{"location":"man/joins/","page":"Joins","title":"Joins","text":"In order to join data frames on keys which have different names in the left and right tables, you may pass (left, right) tuples or left => right pairs as on argument:","category":"page"},{"location":"man/joins/","page":"Joins","title":"Joins","text":"julia> a = DataFrame(ID = [20, 40], Name = [\"John Doe\", \"Jane Doe\"])\n2×2 DataFrame\n Row │ ID     Name\n     │ Int64  String\n─────┼─────────────────\n   1 │    20  John Doe\n   2 │    40  Jane Doe\n\njulia> b = DataFrame(IDNew = [20, 40], Job = [\"Lawyer\", \"Doctor\"])\n2×2 DataFrame\n Row │ IDNew  Job\n     │ Int64  String\n─────┼───────────────\n   1 │    20  Lawyer\n   2 │    40  Doctor\n\njulia> innerjoin(a, b, on = :ID => :IDNew)\n2×3 DataFrame\n Row │ ID     Name      Job\n     │ Int64  String    String\n─────┼─────────────────────────\n   1 │    20  John Doe  Lawyer\n   2 │    40  Jane Doe  Doctor","category":"page"},{"location":"man/joins/","page":"Joins","title":"Joins","text":"Here is another example with multiple columns:","category":"page"},{"location":"man/joins/","page":"Joins","title":"Joins","text":"julia> a = DataFrame(City = [\"Amsterdam\", \"London\", \"London\", \"New York\", \"New York\"],\n                     Job = [\"Lawyer\", \"Lawyer\", \"Lawyer\", \"Doctor\", \"Doctor\"],\n                     Category = [1, 2, 3, 4, 5])\n5×3 DataFrame\n Row │ City       Job     Category\n     │ String     String  Int64\n─────┼─────────────────────────────\n   1 │ Amsterdam  Lawyer         1\n   2 │ London     Lawyer         2\n   3 │ London     Lawyer         3\n   4 │ New York   Doctor         4\n   5 │ New York   Doctor         5\n\njulia> b = DataFrame(Location = [\"Amsterdam\", \"London\", \"London\", \"New York\", \"New York\"],\n                     Work = [\"Lawyer\", \"Lawyer\", \"Lawyer\", \"Doctor\", \"Doctor\"],\n                     Name = [\"a\", \"b\", \"c\", \"d\", \"e\"])\n5×3 DataFrame\n Row │ Location   Work    Name\n     │ String     String  String\n─────┼───────────────────────────\n   1 │ Amsterdam  Lawyer  a\n   2 │ London     Lawyer  b\n   3 │ London     Lawyer  c\n   4 │ New York   Doctor  d\n   5 │ New York   Doctor  e\n\njulia> innerjoin(a, b, on = [:City => :Location, :Job => :Work])\n9×4 DataFrame\n Row │ City       Job     Category  Name\n     │ String     String  Int64     String\n─────┼─────────────────────────────────────\n   1 │ Amsterdam  Lawyer         1  a\n   2 │ London     Lawyer         2  b\n   3 │ London     Lawyer         3  b\n   4 │ London     Lawyer         2  c\n   5 │ London     Lawyer         3  c\n   6 │ New York   Doctor         4  d\n   7 │ New York   Doctor         5  d\n   8 │ New York   Doctor         4  e\n   9 │ New York   Doctor         5  e","category":"page"},{"location":"man/joins/","page":"Joins","title":"Joins","text":"Additionally, notice that in the last join rows 2 and 3 had the same values on on variables in both joined DataFrames. In such a situation innerjoin, outerjoin, leftjoin and rightjoin will produce all combinations of matching rows. In our example rows from 2 to 5 were created as a result. The same behavior can be observed for rows 4 and 5 in both joined DataFrames.","category":"page"},{"location":"man/joins/","page":"Joins","title":"Joins","text":"In order to check that columns passed as the on argument define unique keys (according to isequal) in each input data frame you can set the validate keyword argument to a two-element tuple or a pair of Bool values, with each element indicating whether to run check for the corresponding data frame. Here is an example for the join operation described above:","category":"page"},{"location":"man/joins/","page":"Joins","title":"Joins","text":"julia> innerjoin(a, b, on = [(:City => :Location), (:Job => :Work)], validate=(true, true))\nERROR: ArgumentError: Merge key(s) are not unique in both df1 and df2. df1 contains 2 duplicate keys: (City = \"London\", Job = \"Lawyer\") and (City = \"New York\", Job = \"Doctor\"). df2 contains 2 duplicate keys: (Location = \"London\", Work = \"Lawyer\") and (Location = \"New York\", Work = \"Doctor\").","category":"page"},{"location":"man/joins/","page":"Joins","title":"Joins","text":"Finally, using the source keyword argument you can add a column to the resulting data frame indicating whether the given row appeared only in the left, the right or both data frames. Here is an example:","category":"page"},{"location":"man/joins/","page":"Joins","title":"Joins","text":"julia> a = DataFrame(ID = [20, 40], Name = [\"John\", \"Jane\"])\n2×2 DataFrame\n Row │ ID     Name\n     │ Int64  String\n─────┼───────────────\n   1 │    20  John\n   2 │    40  Jane\n\njulia> b = DataFrame(ID = [20, 60], Job = [\"Lawyer\", \"Doctor\"])\n2×2 DataFrame\n Row │ ID     Job\n     │ Int64  String\n─────┼───────────────\n   1 │    20  Lawyer\n   2 │    60  Doctor\n\njulia> outerjoin(a, b, on=:ID, validate=(true, true), source=:source)\n3×4 DataFrame\n Row │ ID     Name     Job      source\n     │ Int64  String?  String?  String\n─────┼─────────────────────────────────────\n   1 │    20  John     Lawyer   both\n   2 │    40  Jane     missing  left_only\n   3 │    60  missing  Doctor   right_only","category":"page"},{"location":"man/joins/","page":"Joins","title":"Joins","text":"Note that this time we also used the validate keyword argument and it did not produce errors as the keys defined in both source data frames were unique.","category":"page"},{"location":"lib/functions/","page":"Functions","title":"Functions","text":"CurrentModule = DataFrames","category":"page"},{"location":"lib/functions/#Functions","page":"Functions","title":"Functions","text":"","category":"section"},{"location":"lib/functions/#Multi-threading-support","page":"Functions","title":"Multi-threading support","text":"","category":"section"},{"location":"lib/functions/","page":"Functions","title":"Functions","text":"Selected operations in DataFrames.jl automatically use multiple threads when available. It is task-based and implemented using the @spawn macro from Julia Base.","category":"page"},{"location":"lib/functions/","page":"Functions","title":"Functions","text":"This is a list of operations that currently make use of multi-threading:","category":"page"},{"location":"lib/functions/","page":"Functions","title":"Functions","text":"DataFrame constructor with copycols=true; also recursively all functions that call this constructor, e.g. copy.\ngetindex when multiple columns are selected.\ngroupby (both when hashing is required and when fast path using DataAPI.refpool is used).\njoin* functions for composing output data frame (but currently not for finding matching rows in joined data frames).\ncombine, select[!], and transform[!] on GroupedDataFrame when either of the conditions below is met:\nmultiple transformations are performed (each transformation is spawned in a separate task)\na transformation produces one row per group and the passed transformation is a custom function (i.e. not for standard reductions, which use optimized single-threaded methods).","category":"page"},{"location":"lib/functions/","page":"Functions","title":"Functions","text":"In general at least Julia 1.4 is required to ensure that multi-threading is used and the Julia process must be started with more than one thread. Some operations turn on multi-threading only if enough rows in the processed data frame are present (the exact threshold when multi-threading is enabled is considered to be undefined and might change in the future).","category":"page"},{"location":"lib/functions/","page":"Functions","title":"Functions","text":"Except for the list above, where multi-threading is used automatically, all functions provided by DataFrames.jl that update a data frame are not thread safe. This means that while they can be called from any thread, the caller is responsible for ensuring that a given DataFrame object is never modified by one thread while others are using it (either for reading or writing). Using the same DataFrame at the same time from different threads is safe as long as it is not modified.","category":"page"},{"location":"lib/functions/#Index","page":"Functions","title":"Index","text":"","category":"section"},{"location":"lib/functions/","page":"Functions","title":"Functions","text":"Pages = [\"functions.md\"]","category":"page"},{"location":"lib/functions/#Constructing-data-frames","page":"Functions","title":"Constructing data frames","text":"","category":"section"},{"location":"lib/functions/","page":"Functions","title":"Functions","text":"copy\nsimilar","category":"page"},{"location":"lib/functions/#Base.copy","page":"Functions","title":"Base.copy","text":"copy(df::DataFrame; copycols::Bool=true)\n\nCopy data frame df. If copycols=true (the default), return a new  DataFrame holding copies of column vectors in df. If copycols=false, return a new DataFrame sharing column vectors with df.\n\n\n\n\n\ncopy(dfr::DataFrameRow)\n\nConstruct a NamedTuple with the same contents as the DataFrameRow. This method returns a NamedTuple so that the returned object is not affected by changes to the parent data frame of which dfr is a view.\n\n\n\n\n\ncopy(key::GroupKey)\n\nConstruct a NamedTuple with the same contents as the GroupKey.\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Base.similar","page":"Functions","title":"Base.similar","text":"similar(df::AbstractDataFrame, rows::Integer=nrow(df))\n\nCreate a new DataFrame with the same column names and column element types as df. An optional second argument can be provided to request a number of rows that is different than the number of rows present in df.\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Summary-information","page":"Functions","title":"Summary information","text":"","category":"section"},{"location":"lib/functions/","page":"Functions","title":"Functions","text":"describe\nlength\nncol\nndims\nnrow\nrownumber\nshow\nsize","category":"page"},{"location":"lib/functions/#DataAPI.describe","page":"Functions","title":"DataAPI.describe","text":"describe(df::AbstractDataFrame; cols=:)\ndescribe(df::AbstractDataFrame, stats::Union{Symbol, Pair}...; cols=:)\n\nReturn descriptive statistics for a data frame as a new DataFrame where each row represents a variable and each column a summary statistic.\n\nArguments\n\ndf : the AbstractDataFrame\nstats::Union{Symbol, Pair}... : the summary statistics to report. Arguments can be:\nA symbol from the list :mean, :std, :min, :q25, :median, :q75, :max, :eltype, :nunique, :first, :last, and :nmissing. The default statistics used are :mean, :min, :median, :max, :nmissing, and :eltype.\n:all as the only Symbol argument to return all statistics.\nA function => name pair where name is a Symbol or string. This will create a column of summary statistics with the provided name.\ncols : a keyword argument allowing to select only a subset or transformation of columns from df to describe. Can be any column selector or transformation accepted by select.\n\nDetails\n\nFor Real columns, compute the mean, standard deviation, minimum, first quantile, median, third quantile, and maximum. If a column does not derive from Real, describe will attempt to calculate all statistics, using nothing as a fall-back in the case of an error.\n\nWhen stats contains :nunique, describe will report the number of unique values in a column. If a column's base type derives from Real, :nunique will return nothings.\n\nMissing values are filtered in the calculation of all statistics, however the column :nmissing will report the number of missing values of that variable.\n\nIf custom functions are provided, they are called repeatedly with the vector corresponding to each column as the only argument. For columns allowing for missing values, the vector is wrapped in a call to skipmissing: custom functions must therefore support such objects (and not only vectors), and cannot access missing values.\n\nExamples\n\njulia> df = DataFrame(i=1:10, x=0.1:0.1:1.0, y='a':'j');\n\njulia> describe(df)\n3×7 DataFrame\n Row │ variable  mean    min  median  max  nmissing  eltype\n     │ Symbol    Union…  Any  Union…  Any  Int64     DataType\n─────┼────────────────────────────────────────────────────────\n   1 │ i         5.5     1    5.5     10          0  Int64\n   2 │ x         0.55    0.1  0.55    1.0         0  Float64\n   3 │ y                 a            j           0  Char\n\njulia> describe(df, :min, :max)\n3×3 DataFrame\n Row │ variable  min  max\n     │ Symbol    Any  Any\n─────┼────────────────────\n   1 │ i         1    10\n   2 │ x         0.1  1.0\n   3 │ y         a    j\n\njulia> describe(df, :min, sum => :sum)\n3×3 DataFrame\n Row │ variable  min  sum\n     │ Symbol    Any  Union…\n─────┼───────────────────────\n   1 │ i         1    55\n   2 │ x         0.1  5.5\n   3 │ y         a\n\njulia> describe(df, :min, sum => :sum, cols=:x)\n1×3 DataFrame\n Row │ variable  min      sum\n     │ Symbol    Float64  Float64\n─────┼────────────────────────────\n   1 │ x             0.1      5.5\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Base.length","page":"Functions","title":"Base.length","text":"length(dfr::DataFrameRow)\n\nReturn the number of elements of dfr.\n\nSee also: size\n\nExamples\n\njulia> dfr = DataFrame(a=1:3, b='a':'c')[1, :]\nDataFrameRow\n Row │ a      b\n     │ Int64  Char\n─────┼─────────────\n   1 │     1  a\n\njulia> length(dfr)\n2\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#DataFrames.ncol","page":"Functions","title":"DataFrames.ncol","text":"nrow(df::AbstractDataFrame)\nncol(df::AbstractDataFrame)\n\nReturn the number of rows or columns in an AbstractDataFrame df.\n\nSee also size.\n\nExamples\n\njulia> df = DataFrame(i = 1:10, x = rand(10), y = rand([\"a\", \"b\", \"c\"], 10));\n\njulia> size(df)\n(10, 3)\n\njulia> nrow(df)\n10\n\njulia> ncol(df)\n3\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Base.ndims","page":"Functions","title":"Base.ndims","text":"ndims(::AbstractDataFrame)\nndims(::Type{<:AbstractDataFrame})\n\nReturn the number of dimensions of a data frame, which is always 2.\n\n\n\n\n\nndims(::DataFrameRow)\nndims(::Type{<:DataFrameRow})\n\nReturn the number of dimensions of a data frame row, which is always 1.\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#DataFrames.nrow","page":"Functions","title":"DataFrames.nrow","text":"nrow(df::AbstractDataFrame)\nncol(df::AbstractDataFrame)\n\nReturn the number of rows or columns in an AbstractDataFrame df.\n\nSee also size.\n\nExamples\n\njulia> df = DataFrame(i = 1:10, x = rand(10), y = rand([\"a\", \"b\", \"c\"], 10));\n\njulia> size(df)\n(10, 3)\n\njulia> nrow(df)\n10\n\njulia> ncol(df)\n3\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#DataFrames.rownumber","page":"Functions","title":"DataFrames.rownumber","text":"rownumber(dfr::DataFrameRow)\n\nReturn a row number in the AbstractDataFrame that dfr was created from.\n\nNote that this differs from the first element in the tuple returned by parentindices. The latter gives the row number in the parent(dfr), which is the source DataFrame where data that dfr gives access to is stored.\n\nExamples\n\njulia> df = DataFrame(reshape(1:12, 3, 4), :auto)\n3×4 DataFrame\n Row │ x1     x2     x3     x4\n     │ Int64  Int64  Int64  Int64\n─────┼────────────────────────────\n   1 │     1      4      7     10\n   2 │     2      5      8     11\n   3 │     3      6      9     12\n\njulia> dfr = df[2, :]\nDataFrameRow\n Row │ x1     x2     x3     x4\n     │ Int64  Int64  Int64  Int64\n─────┼────────────────────────────\n   2 │     2      5      8     11\n\njulia> rownumber(dfr)\n2\n\njulia> parentindices(dfr)\n(2, Base.OneTo(4))\n\njulia> parent(dfr)\n3×4 DataFrame\n Row │ x1     x2     x3     x4\n     │ Int64  Int64  Int64  Int64\n─────┼────────────────────────────\n   1 │     1      4      7     10\n   2 │     2      5      8     11\n   3 │     3      6      9     12\n\njulia> dfv = @view df[2:3, 1:3]\n2×3 SubDataFrame\n Row │ x1     x2     x3\n     │ Int64  Int64  Int64\n─────┼─────────────────────\n   1 │     2      5      8\n   2 │     3      6      9\n\njulia> dfrv = dfv[2, :]\nDataFrameRow\n Row │ x1     x2     x3\n     │ Int64  Int64  Int64\n─────┼─────────────────────\n   3 │     3      6      9\n\njulia> rownumber(dfrv)\n2\n\njulia> parentindices(dfrv)\n(3, 1:3)\n\njulia> parent(dfrv)\n3×4 DataFrame\n Row │ x1     x2     x3     x4\n     │ Int64  Int64  Int64  Int64\n─────┼────────────────────────────\n   1 │     1      4      7     10\n   2 │     2      5      8     11\n   3 │     3      6      9     12\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Base.show","page":"Functions","title":"Base.show","text":"show([io::IO, ]df::AbstractDataFrame;\n     allrows::Bool = !get(io, :limit, false),\n     allcols::Bool = !get(io, :limit, false),\n     allgroups::Bool = !get(io, :limit, false),\n     rowlabel::Symbol = :Row,\n     summary::Bool = true,\n     eltypes::Bool = true,\n     truncate::Int = 32,\n     kwargs...)\n\nRender a data frame to an I/O stream. The specific visual representation chosen depends on the width of the display.\n\nIf io is omitted, the result is printed to stdout, and allrows, allcols and allgroups default to false.\n\nArguments\n\nio::IO: The I/O stream to which df will be printed.\ndf::AbstractDataFrame: The data frame to print.\nallrows::Bool: Whether to print all rows, rather than a subset that fits the device height. By default this is the case only if io does not have the IOContext property limit set.\nallcols::Bool: Whether to print all columns, rather than a subset that fits the device width. By default this is the case only if io does not have the IOContext property limit set.\nallgroups::Bool: Whether to print all groups rather than the first and last, when df is a GroupedDataFrame. By default this is the case only if io does not have the IOContext property limit set.\nrowlabel::Symbol = :Row: The label to use for the column containing row numbers.\nsummary::Bool = true: Whether to print a brief string summary of the data frame.\neltypes::Bool = true: Whether to print the column types under column names.\ntruncate::Int = 32: the maximal display width the output can use before being truncated (in the textwidth sense, excluding …). If truncate is 0 or less, no truncation is applied.\nkwargs...: Any keyword argument supported by the function pretty_table of PrettyTables.jl can be passed here to customize the output.\n\nExamples\n\njulia> using DataFrames\n\njulia> df = DataFrame(A = 1:3, B = [\"x\", \"y\", \"z\"]);\n\njulia> show(df, show_row_number=false)\n3×2 DataFrame\n A      B\n Int64  String\n───────────────\n     1  x\n     2  y\n     3  z\n\n\n\n\n\nshow(io::IO, mime::MIME, df::AbstractDataFrame)\n\nRender a data frame to an I/O stream in MIME type mime.\n\nArguments\n\nio::IO: The I/O stream to which df will be printed.\nmime::MIME: supported MIME types are: \"text/plain\", \"text/html\", \"text/latex\", \"text/csv\", \"text/tab-separated-values\" (the last two MIME types do not support  showing #undef values)\ndf::AbstractDataFrame: The data frame to print.\n\nAdditionally selected MIME types support passing the following keyword arguments:\n\nMIME type \"text/plain\" accepts all listed keyword arguments and therir behavior is identical as for show(::IO, ::AbstractDataFrame)\nMIME type \"text/html\" accepts summary keyword argument which allows to choose whether to print a brief string summary of the data frame.\n\nExamples\n\njulia> show(stdout, MIME(\"text/latex\"), DataFrame(A = 1:3, B = [\"x\", \"y\", \"z\"]))\n\\begin{tabular}{r|cc}\n\t& A & B\\\\\n\t\\hline\n\t& Int64 & String\\\\\n\t\\hline\n\t1 & 1 & x \\\\\n\t2 & 2 & y \\\\\n\t3 & 3 & z \\\\\n\\end{tabular}\n14\n\njulia> show(stdout, MIME(\"text/csv\"), DataFrame(A = 1:3, B = [\"x\", \"y\", \"z\"]))\n\"A\",\"B\"\n1,\"x\"\n2,\"y\"\n3,\"z\"\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Base.size","page":"Functions","title":"Base.size","text":"size(df::AbstractDataFrame[, dim])\n\nReturn a tuple containing the number of rows and columns of df. Optionally a dimension dim can be specified, where 1 corresponds to rows and 2 corresponds to columns.\n\nSee also: nrow, ncol\n\nExamples\n\njulia> df = DataFrame(a=1:3, b='a':'c');\n\njulia> size(df)\n(3, 2)\n\njulia> size(df, 1)\n3\n\n\n\n\n\nsize(dfr::DataFrameRow[, dim])\n\nReturn a 1-tuple containing the number of elements of dfr. If an optional dimension dim is specified, it must be 1, and the number of elements is returned directly as a number.\n\nSee also: length\n\nExamples\n\njulia> dfr = DataFrame(a=1:3, b='a':'c')[1, :]\nDataFrameRow\n Row │ a      b\n     │ Int64  Char\n─────┼─────────────\n   1 │     1  a\n\njulia> size(dfr)\n(2,)\n\njulia> size(dfr, 1)\n2\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Working-with-column-names","page":"Functions","title":"Working with column names","text":"","category":"section"},{"location":"lib/functions/","page":"Functions","title":"Functions","text":"names\npropertynames\nrename\nrename!","category":"page"},{"location":"lib/functions/#Base.names","page":"Functions","title":"Base.names","text":"names(df::AbstractDataFrame)\nnames(df::AbstractDataFrame, cols)\n\nReturn a freshly allocated Vector{String} of names of columns contained in df.\n\nIf cols is passed then restrict returned column names to those matching the selector (this is useful in particular with regular expressions, Cols, Not, and Between). cols can be:\n\nany column selector (Symbol, string or integer; :, Cols, All, Between, Not, a regular expression, or a vector of Symbols, strings or integers)\na Type, in which case names of columns whose eltype is a subtype of T are returned\na Function predicate taking the column name as a string and returning true for columns that should be kept\n\nSee also propertynames which returns a Vector{Symbol}.\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Base.propertynames","page":"Functions","title":"Base.propertynames","text":"propertynames(df::AbstractDataFrame)\n\nReturn a freshly allocated Vector{Symbol} of names of columns contained in df.\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#DataFrames.rename","page":"Functions","title":"DataFrames.rename","text":"rename(df::AbstractDataFrame, vals::AbstractVector{Symbol};\n       makeunique::Bool=false)\nrename(df::AbstractDataFrame, vals::AbstractVector{<:AbstractString};\n       makeunique::Bool=false)\nrename(df::AbstractDataFrame, (from => to)::Pair...)\nrename(df::AbstractDataFrame, d::AbstractDict)\nrename(df::AbstractDataFrame, d::AbstractVector{<:Pair})\nrename(f::Function, df::AbstractDataFrame)\n\nCreate a new data frame that is a copy of df with changed column names. Each name is changed at most once. Permutation of names is allowed.\n\nArguments\n\ndf : the AbstractDataFrame; if it is a SubDataFrame then renaming is only allowed if it was created using : as a column selector.\nd : an AbstractDict or an AbstractVector of Pairs that maps the original names or column numbers to new names\nf : a function which for each column takes the old name as a String and returns the new name that gets converted to a Symbol\nvals : new column names as a vector of Symbols or AbstractStrings of the same length as the number of columns in df\nmakeunique : if false (the default), an error will be raised if duplicate names are found; if true, duplicate names will be suffixed with _i (i starting at 1 for the first duplicate).\n\nIf pairs are passed to rename (as positional arguments or in a dictionary or a vector) then:\n\nfrom value can be a Symbol, an AbstractString or an Integer;\nto value can be a Symbol or an AbstractString.\n\nMixing symbols and strings in to and from is not allowed.\n\nSee also: rename!\n\nExamples\n\njulia> df = DataFrame(i = 1, x = 2, y = 3)\n1×3 DataFrame\n Row │ i      x      y\n     │ Int64  Int64  Int64\n─────┼─────────────────────\n   1 │     1      2      3\n\njulia> rename(df, :i => :A, :x => :X)\n1×3 DataFrame\n Row │ A      X      y\n     │ Int64  Int64  Int64\n─────┼─────────────────────\n   1 │     1      2      3\n\njulia> rename(df, :x => :y, :y => :x)\n1×3 DataFrame\n Row │ i      y      x\n     │ Int64  Int64  Int64\n─────┼─────────────────────\n   1 │     1      2      3\n\njulia> rename(df, [1 => :A, 2 => :X])\n1×3 DataFrame\n Row │ A      X      y\n     │ Int64  Int64  Int64\n─────┼─────────────────────\n   1 │     1      2      3\n\njulia> rename(df, Dict(\"i\" => \"A\", \"x\" => \"X\"))\n1×3 DataFrame\n Row │ A      X      y\n     │ Int64  Int64  Int64\n─────┼─────────────────────\n   1 │     1      2      3\n\njulia> rename(uppercase, df)\n1×3 DataFrame\n Row │ I      X      Y\n     │ Int64  Int64  Int64\n─────┼─────────────────────\n   1 │     1      2      3\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#DataFrames.rename!","page":"Functions","title":"DataFrames.rename!","text":"rename!(df::AbstractDataFrame, vals::AbstractVector{Symbol};\n        makeunique::Bool=false)\nrename!(df::AbstractDataFrame, vals::AbstractVector{<:AbstractString};\n        makeunique::Bool=false)\nrename!(df::AbstractDataFrame, (from => to)::Pair...)\nrename!(df::AbstractDataFrame, d::AbstractDict)\nrename!(df::AbstractDataFrame, d::AbstractVector{<:Pair})\nrename!(f::Function, df::AbstractDataFrame)\n\nRename columns of df in-place. Each name is changed at most once. Permutation of names is allowed.\n\nArguments\n\ndf : the AbstractDataFrame\nd : an AbstractDict or an AbstractVector of Pairs that maps the original names or column numbers to new names\nf : a function which for each column takes the old name as a String and returns the new name that gets converted to a Symbol\nvals : new column names as a vector of Symbols or AbstractStrings of the same length as the number of columns in df\nmakeunique : if false (the default), an error will be raised if duplicate names are found; if true, duplicate names will be suffixed with _i (i starting at 1 for the first duplicate).\n\nIf pairs are passed to rename! (as positional arguments or in a dictionary or a vector) then:\n\nfrom value can be a Symbol, an AbstractString or an Integer;\nto value can be a Symbol or an AbstractString.\n\nMixing symbols and strings in to and from is not allowed.\n\nSee also: rename\n\nExamples\n\njulia> df = DataFrame(i = 1, x = 2, y = 3)\n1×3 DataFrame\n Row │ i      x      y\n     │ Int64  Int64  Int64\n─────┼─────────────────────\n   1 │     1      2      3\n\njulia> rename!(df, Dict(:i => \"A\", :x => \"X\"))\n1×3 DataFrame\n Row │ A      X      y\n     │ Int64  Int64  Int64\n─────┼─────────────────────\n   1 │     1      2      3\n\njulia> rename!(df, [:a, :b, :c])\n1×3 DataFrame\n Row │ a      b      c\n     │ Int64  Int64  Int64\n─────┼─────────────────────\n   1 │     1      2      3\n\njulia> rename!(df, [:a, :b, :a])\nERROR: ArgumentError: Duplicate variable names: :a. Pass makeunique=true to make them unique using a suffix automatically.\n\njulia> rename!(df, [:a, :b, :a], makeunique=true)\n1×3 DataFrame\n Row │ a      b      a_1\n     │ Int64  Int64  Int64\n─────┼─────────────────────\n   1 │     1      2      3\n\njulia> rename!(uppercase, df)\n1×3 DataFrame\n Row │ A      B      A_1\n     │ Int64  Int64  Int64\n─────┼─────────────────────\n   1 │     1      2      3\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Mutating-and-transforming-data-frames-and-grouped-data-frames","page":"Functions","title":"Mutating and transforming data frames and grouped data frames","text":"","category":"section"},{"location":"lib/functions/","page":"Functions","title":"Functions","text":"append!\ncombine\nflatten\nhcat\ninsertcols!\nmapcols\nmapcols!\npush!\nreduce\nrepeat\nrepeat!\nselect\nselect!\ntransform\ntransform!\nvcat","category":"page"},{"location":"lib/functions/#Base.append!","page":"Functions","title":"Base.append!","text":"append!(df::DataFrame, df2::AbstractDataFrame; cols::Symbol=:setequal,\n        promote::Bool=(cols in [:union, :subset]))\nappend!(df::DataFrame, table; cols::Symbol=:setequal,\n        promote::Bool=(cols in [:union, :subset]))\n\nAdd the rows of df2 to the end of df. If the second argument table is not an AbstractDataFrame then it is converted using DataFrame(table, copycols=false) before being appended.\n\nThe exact behavior of append! depends on the cols argument:\n\nIf cols == :setequal (this is the default) then df2 must contain exactly the same columns as df (but possibly in a different order).\nIf cols == :orderequal then df2 must contain the same columns in the same order (for AbstractDict this option requires that keys(row) matches propertynames(df) to allow for support of ordered dicts; however, if df2 is a Dict an error is thrown as it is an unordered collection).\nIf cols == :intersect then df2 may contain more columns than df, but all column names that are present in df must be present in df2 and only these are used.\nIf cols == :subset then append! behaves like for :intersect but if some column is missing in df2 then a missing value is pushed to df.\nIf cols == :union then append! adds columns missing in df that are present in df2, for columns present in df but missing in df2 a missing value is pushed.\n\nIf promote=true and element type of a column present in df does not allow the type of a pushed argument then a new column with a promoted element type allowing it is freshly allocated and stored in df. If promote=false an error is thrown.\n\nThe above rule has the following exceptions:\n\nIf df has no columns then copies of columns from df2 are added to it.\nIf df2 has no columns then calling append! leaves df unchanged.\n\nPlease note that append! must not be used on a DataFrame that contains columns that are aliases (equal when compared with ===).\n\nSee also\n\nUse push! to add individual rows to a data frame and vcat to vertically concatenate data frames.\n\nExamples\n\njulia> df1 = DataFrame(A=1:3, B=1:3)\n3×2 DataFrame\n Row │ A      B\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1      1\n   2 │     2      2\n   3 │     3      3\n\njulia> df2 = DataFrame(A=4.0:6.0, B=4:6)\n3×2 DataFrame\n Row │ A        B\n     │ Float64  Int64\n─────┼────────────────\n   1 │     4.0      4\n   2 │     5.0      5\n   3 │     6.0      6\n\njulia> append!(df1, df2);\n\njulia> df1\n6×2 DataFrame\n Row │ A      B\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1      1\n   2 │     2      2\n   3 │     3      3\n   4 │     4      4\n   5 │     5      5\n   6 │     6      6\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#DataFrames.combine","page":"Functions","title":"DataFrames.combine","text":"combine(df::AbstractDataFrame, args...; renamecols::Bool=true)\ncombine(f::Callable, df::AbstractDataFrame; renamecols::Bool=true)\ncombine(gd::GroupedDataFrame, args...;\n        keepkeys::Bool=true, ungroup::Bool=true, renamecols::Bool=true)\ncombine(f::Base.Callable, gd::GroupedDataFrame;\n        keepkeys::Bool=true, ungroup::Bool=true, renamecols::Bool=true)\n\nCreate a new data frame that contains columns from df or gd specified by args and return it. The result can have any number of rows that is determined by the values returned by passed transformations.\n\nBelow detailed common rules for all transformation functions supported by DataFrames.jl are explained and compared.\n\nAll these operations are supported both for AbstractDataFrame (when split and combine steps are skipped) and GroupedDataFrame. Technically, AbstractDataFrame is just considered as being grouped on no columns (meaning it has a single group, or zero groups if it is empty). The only difference is that in this case the keepkeys and ungroup keyword arguments (described below) are not supported and a data frame is always returned, as there are no split and combine steps in this case.\n\nIn order to perform operations by groups you first need to create a GroupedDataFrame object from your data frame using the groupby function that takes two arguments: (1) a data frame to be grouped, and (2) a set of columns to group by.\n\nOperations can then be applied on each group using one of the following functions:\n\ncombine: does not put restrictions on number of rows returned, the order of rows is specified by the order of groups in GroupedDataFrame; it is typically used to compute summary statistics by group;\nselect: return a data frame with the number and order of rows exactly the same as the source data frame, including only new calculated columns; select! is an in-place version of select;\ntransform: return a data frame with the number and order of rows exactly the same as the source data frame, including all columns from the source and new calculated columns; transform! is an in-place version of transform.\n\nAll these functions take a specification of one or more functions to apply to each subset of the DataFrame. This specification can be of the following forms:\n\nstandard column selectors (integers, Symbols, strings, vectors of integers, vectors of Symbols, vectors of strings, All, Cols, :, Between, Not and regular expressions)\na cols => function pair indicating that function should be called with positional arguments holding columns cols, which can be any valid column selector; in this case target column name is automatically generated and it is assumed that function returns a single value or a vector; the generated name is created by concatenating source column name and function name by default (see examples below).\na cols => function => target_cols form additionally explicitly specifying the target column or columns.\na col => target_cols pair, which renames the column col to target_cols, which must be single name (as a Symbol or a string), a vector of names or AsTable.\na nrow or nrow => target_cols form which efficiently computes the number of rows in a group; without target_cols the new column is called :nrow, otherwise it must be single name (as a Symbol or a string).\nvectors or matrices containing transformations specified by the Pair syntax described in points 2 to 5\na function which will be called with a SubDataFrame corresponding to each group; this form should be avoided due to its poor performance unless the number of groups is small or a very large number of columns are processed (in which case SubDataFrame avoids excessive compilation)\n\nNote! If the expression of the form x => y is passed then except for the special convenience form nrow => target_cols it is always interpreted as cols => function. In particular the following expression function => target_cols is not a valid transformation specification.\n\nAll functions have two types of signatures. One of them takes a GroupedDataFrame as the first argument and an arbitrary number of transformations described above as following arguments. The second type of signature is when a Function or a Type is passed as the first argument and a GroupedDataFrame as the second argument (similar to map).\n\nAs a special rule, with the cols => function and cols => function => target_cols syntaxes, if cols is wrapped in an AsTable object then a NamedTuple containing columns selected by cols is passed to function.\n\nWhat is allowed for function to return is determined by the target_cols value:\n\nIf both cols and target_cols are omitted (so only a function is passed), then returning a data frame, a matrix, a NamedTuple, or a DataFrameRow will produce multiple columns in the result. Returning any other value produces a single column.\nIf target_cols is a Symbol or a string then the function is assumed to return a single column. In this case returning a data frame, a matrix, a NamedTuple, or a DataFrameRow raises an error.\nIf target_cols is a vector of Symbols or strings or AsTable it is assumed that function returns multiple columns. If function returns one of AbstractDataFrame, NamedTuple, DataFrameRow, AbstractMatrix then rules described in point 1 above apply. If function returns an AbstractVector then each element of this vector must support the keys function, which must return a collection of Symbols, strings or integers; the return value of keys must be identical for all elements. Then as many columns are created as there are elements in the return value of the keys function. If target_cols is AsTable then their names are set to be equal to the key names except if keys returns integers, in which case they are prefixed by x (so the column names are e.g. x1, x2, ...). If target_cols is a vector of Symbols or strings then column names produced using the rules above are ignored and replaced by target_cols (the number of columns must be the same as the length of target_cols in this case). If fun returns a value of any other type then it is assumed that it is a table conforming to the Tables.jl API and the Tables.columntable function is called on it to get the resulting columns and their names. The names are retained when target_cols is AsTable and are replaced if target_cols is a vector of Symbols or strings.\n\nIn all of these cases, function can return either a single row or multiple rows. As a particular rule, values wrapped in a Ref or a 0-dimensional AbstractArray are unwrapped and then treated as a single row.\n\nselect/select! and transform/transform! always return a DataFrame with the same number and order of rows as the source (even if GroupedDataFrame had its groups reordered).\n\nFor combine, rows in the returned object appear in the order of groups in the GroupedDataFrame. The functions can return an arbitrary number of rows for each group, but the kind of returned object and the number and names of columns must be the same for all groups, except when a DataFrame() or NamedTuple() is returned, in which case a given group is skipped.\n\nIt is allowed to mix single values and vectors if multiple transformations are requested. In this case single value will be repeated to match the length of columns specified by returned vectors.\n\nTo apply function to each row instead of whole columns, it can be wrapped in a ByRow struct. cols can be any column indexing syntax, in which case function will be passed one argument for each of the columns specified by cols or a NamedTuple of them if specified columns are wrapped in AsTable. If ByRow is used it is allowed for cols to select an empty set of columns, in which case function is called for each row without any arguments and an empty NamedTuple is passed if empty set of columns is wrapped in AsTable.\n\nIf a collection of column names is passed then requesting duplicate column names in target data frame are accepted (e.g. select!(df, [:a], :, r\"a\") is allowed) and only the first occurrence is used. In particular a syntax to move column :col to the first position in the data frame is select!(df, :col, :). On the contrary, output column names of renaming, transformation and single column selection operations must be unique, so e.g. select!(df, :a, :a => :a) or select!(df, :a, :a => ByRow(sin) => :a) are not allowed.\n\nAs a general rule if copycols=true columns are copied and when copycols=false columns are reused if possible. Note, however, that including the same column several times in the data frame via renaming or transformations that return the same object without copying may create column aliases even if copycols=true. An example of such a situation is select!(df, :a, :a => :b, :a => identity => :c). As a special case in transform and transform! column renaming always copies columns to avoid storing aliased columns in the target data frame.\n\nIf df is a SubDataFrame and copycols=true then a DataFrame is returned and the same copying rules apply as for a DataFrame input: this means in particular that selected columns will be copied. If copycols=false, a SubDataFrame is returned without copying columns.\n\nIf a GroupedDataFrame is passed, a separate task is spawned for each specified transformation; each transformation then spawns as many tasks as Julia threads, and splits processing of groups across them (however, currently transformations with optimized implementations like sum and transformations that return multiple rows use a single task for all groups). This allows for parallel operation when Julia was started with more than one thread. Passed transformation functions should therefore not modify global variables (i.e. they should be pure), or use locks to control parallel accesses. In the future, parallelism may be extended to other cases, so this requirement also holds for DataFrame inputs.\n\nKeyword arguments\n\nrenamecols::Bool=true : whether in the cols => function form automatically generated column names should include the name of transformation functions or not.\nkeepkeys::Bool=true : whether grouping columns of gd should be kept in the returned data frame.\nungroup::Bool=true : whether the return value of the operation on gd should be a data frame or a GroupedDataFrame.\n\nExamples\n\njulia> df = DataFrame(a=1:3, b=4:6)\n3×2 DataFrame\n Row │ a      b\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1      4\n   2 │     2      5\n   3 │     3      6\n\njulia> combine(df, :a => sum, nrow, renamecols=false)\n1×2 DataFrame\n Row │ a      nrow\n     │ Int64  Int64\n─────┼──────────────\n   1 │     6      3\n\njulia> combine(df, :a => ByRow(sin) => :c, :b)\n3×2 DataFrame\n Row │ c         b\n     │ Float64   Int64\n─────┼─────────────────\n   1 │ 0.841471      4\n   2 │ 0.909297      5\n   3 │ 0.14112       6\n\njulia> combine(df, :, [:a, :b] => (a, b) -> a .+ b .- sum(b)/length(b))\n3×3 DataFrame\n Row │ a      b      a_b_function\n     │ Int64  Int64  Float64\n─────┼────────────────────────────\n   1 │     1      4           0.0\n   2 │     2      5           2.0\n   3 │     3      6           4.0\n\njulia> combine(df, names(df) .=> [minimum maximum])\n1×4 DataFrame\n Row │ a_minimum  b_minimum  a_maximum  b_maximum\n     │ Int64      Int64      Int64      Int64\n─────┼────────────────────────────────────────────\n   1 │         1          4          3          6\n\njulia> using Statistics\n\njulia> combine(df, AsTable(:) => ByRow(mean), renamecols=false)\n3×1 DataFrame\n Row │ a_b\n     │ Float64\n─────┼─────────\n   1 │     2.5\n   2 │     3.5\n   3 │     4.5\n\njulia> combine(first, df)\n1×2 DataFrame\n Row │ a      b\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1      4\n\njulia> df = DataFrame(a=1:3, b=4:6, c=7:9)\n3×3 DataFrame\n Row │ a      b      c\n     │ Int64  Int64  Int64\n─────┼─────────────────────\n   1 │     1      4      7\n   2 │     2      5      8\n   3 │     3      6      9\n\njulia> combine(df, AsTable(:) => ByRow(x -> (mean=mean(x), std=std(x))) => :stats,\n               AsTable(:) => ByRow(x -> (mean=mean(x), std=std(x))) => AsTable)\n3×3 DataFrame\n Row │ stats                    mean     std\n     │ NamedTup…                Float64  Float64\n─────┼───────────────────────────────────────────\n   1 │ (mean = 4.0, std = 3.0)      4.0      3.0\n   2 │ (mean = 5.0, std = 3.0)      5.0      3.0\n   3 │ (mean = 6.0, std = 3.0)      6.0      3.0\n\njulia> df = DataFrame(a = repeat([1, 2, 3, 4], outer=[2]),\n                      b = repeat([2, 1], outer=[4]),\n                      c = 1:8);\n\njulia> gd = groupby(df, :a);\n\njulia> combine(gd, :c => sum, nrow)\n4×3 DataFrame\n Row │ a      c_sum  nrow\n     │ Int64  Int64  Int64\n─────┼─────────────────────\n   1 │     1      6      2\n   2 │     2      8      2\n   3 │     3     10      2\n   4 │     4     12      2\n\njulia> combine(gd, :c => sum, nrow, ungroup=false)\nGroupedDataFrame with 4 groups based on key: a\nFirst Group (1 row): a = 1\n Row │ a      c_sum  nrow\n     │ Int64  Int64  Int64\n─────┼─────────────────────\n   1 │     1      6      2\n⋮\nLast Group (1 row): a = 4\n Row │ a      c_sum  nrow\n     │ Int64  Int64  Int64\n─────┼─────────────────────\n   1 │     4     12      2\n\njulia> combine(gd) do d # do syntax for the slower variant\n           sum(d.c)\n       end\n4×2 DataFrame\n Row │ a      x1\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1      6\n   2 │     2      8\n   3 │     3     10\n   4 │     4     12\n\njulia> combine(gd, :c => (x -> sum(log, x)) => :sum_log_c) # specifying a name for target column\n4×2 DataFrame\n Row │ a      sum_log_c\n     │ Int64  Float64\n─────┼──────────────────\n   1 │     1    1.60944\n   2 │     2    2.48491\n   3 │     3    3.04452\n   4 │     4    3.46574\n\njulia> combine(gd, [:b, :c] .=> sum) # passing a vector of pairs\n4×3 DataFrame\n Row │ a      b_sum  c_sum\n     │ Int64  Int64  Int64\n─────┼─────────────────────\n   1 │     1      4      6\n   2 │     2      2      8\n   3 │     3      4     10\n   4 │     4      2     12\n\njulia> combine(gd) do sdf # dropping group when DataFrame() is returned\n          sdf.c[1] != 1 ? sdf : DataFrame()\n       end\n6×3 DataFrame\n Row │ a      b      c\n     │ Int64  Int64  Int64\n─────┼─────────────────────\n   1 │     2      1      2\n   2 │     2      1      6\n   3 │     3      2      3\n   4 │     3      2      7\n   5 │     4      1      4\n   6 │     4      1      8\n\nauto-splatting, renaming and keepkeys\n\njulia> df = DataFrame(a = repeat([1, 2, 3, 4], outer=[2]),\n                      b = repeat([2, 1], outer=[4]),\n                      c = 1:8);\n\njulia> gd = groupby(df, :a);\n\njulia> combine(gd, :b => :b1, :c => :c1, [:b, :c] => +, keepkeys=false)\n8×3 DataFrame\n Row │ b1     c1     b_c_+\n     │ Int64  Int64  Int64\n─────┼─────────────────────\n   1 │     2      1      3\n   2 │     2      5      7\n   3 │     1      2      3\n   4 │     1      6      7\n   5 │     2      3      5\n   6 │     2      7      9\n   7 │     1      4      5\n   8 │     1      8      9\n\nbroadcasting and column expansion\n\njulia> df = DataFrame(a = repeat([1, 2, 3, 4], outer=[2]),\n                      b = repeat([2, 1], outer=[4]),\n                      c = 1:8);\n\njulia> gd = groupby(df, :a);\n\njulia> combine(gd, :b, AsTable([:b, :c]) => ByRow(extrema) => [:min, :max])\n8×4 DataFrame\n Row │ a      b      min    max\n     │ Int64  Int64  Int64  Int64\n─────┼────────────────────────────\n   1 │     1      2      1      2\n   2 │     1      2      2      5\n   3 │     2      1      1      2\n   4 │     2      1      1      6\n   5 │     3      2      2      3\n   6 │     3      2      2      7\n   7 │     4      1      1      4\n   8 │     4      1      1      8\n\njulia> combine(gd, [:b, :c] .=> Ref) # preventing vector from being spread across multiple rows\n4×3 DataFrame\n Row │ a      b_Ref      c_Ref\n     │ Int64  SubArray…  SubArray…\n─────┼─────────────────────────────\n   1 │     1  [2, 2]     [1, 5]\n   2 │     2  [1, 1]     [2, 6]\n   3 │     3  [2, 2]     [3, 7]\n   4 │     4  [1, 1]     [4, 8]\n\njulia> combine(gd, AsTable(Not(:a)) => Ref) # protecting result\n4×2 DataFrame\n Row │ a      b_c_Ref\n     │ Int64  NamedTup…\n─────┼─────────────────────────────────\n   1 │     1  (b = [2, 2], c = [1, 5])\n   2 │     2  (b = [1, 1], c = [2, 6])\n   3 │     3  (b = [2, 2], c = [3, 7])\n   4 │     4  (b = [1, 1], c = [4, 8])\n\njulia> combine(gd, :, AsTable(Not(:a)) => sum, renamecols=false)\n8×4 DataFrame\n Row │ a      b      c      b_c\n     │ Int64  Int64  Int64  Int64\n─────┼────────────────────────────\n   1 │     1      2      1      3\n   2 │     1      2      5      7\n   3 │     2      1      2      3\n   4 │     2      1      6      7\n   5 │     3      2      3      5\n   6 │     3      2      7      9\n   7 │     4      1      4      5\n   8 │     4      1      8      9\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#DataFrames.flatten","page":"Functions","title":"DataFrames.flatten","text":"flatten(df::AbstractDataFrame, cols)\n\nWhen columns cols of data frame df have iterable elements that define length (for example a Vector of Vectors), return a DataFrame where each element of each col in cols is flattened, meaning the column corresponding to col becomes a longer vector where the original entries are concatenated. Elements of row i of df in columns other than cols will be repeated according to the length of df[i, col]. These lengths must therefore be the same for each col in cols, or else an error is raised. Note that these elements are not copied, and thus if they are mutable changing them in the returned DataFrame will affect df.\n\ncols can be any column selector (Symbol, string or integer; :, Cols, All, Between, Not, a regular expression, or a vector of Symbols, strings or integers).\n\nExamples\n\njulia> df1 = DataFrame(a = [1, 2], b = [[1, 2], [3, 4]], c = [[5, 6], [7, 8]])\n2×3 DataFrame\n Row │ a      b       c\n     │ Int64  Array…  Array…\n─────┼───────────────────────\n   1 │     1  [1, 2]  [5, 6]\n   2 │     2  [3, 4]  [7, 8]\n\njulia> flatten(df1, :b)\n4×3 DataFrame\n Row │ a      b      c\n     │ Int64  Int64  Array…\n─────┼──────────────────────\n   1 │     1      1  [5, 6]\n   2 │     1      2  [5, 6]\n   3 │     2      3  [7, 8]\n   4 │     2      4  [7, 8]\n\njulia> flatten(df1, [:b, :c])\n4×3 DataFrame\n Row │ a      b      c\n     │ Int64  Int64  Int64\n─────┼─────────────────────\n   1 │     1      1      5\n   2 │     1      2      6\n   3 │     2      3      7\n   4 │     2      4      8\n\njulia> df2 = DataFrame(a = [1, 2], b = [(\"p\", \"q\"), (\"r\", \"s\")])\n2×2 DataFrame\n Row │ a      b\n     │ Int64  Tuple…\n─────┼───────────────────\n   1 │     1  (\"p\", \"q\")\n   2 │     2  (\"r\", \"s\")\n\njulia> flatten(df2, :b)\n4×2 DataFrame\n Row │ a      b\n     │ Int64  String\n─────┼───────────────\n   1 │     1  p\n   2 │     1  q\n   3 │     2  r\n   4 │     2  s\n\njulia> df3 = DataFrame(a = [1, 2], b = [[1, 2], [3, 4]], c = [[5, 6], [7]])\n2×3 DataFrame\n Row │ a      b       c\n     │ Int64  Array…  Array…\n─────┼───────────────────────\n   1 │     1  [1, 2]  [5, 6]\n   2 │     2  [3, 4]  [7]\n\njulia> flatten(df3, [:b, :c])\nERROR: ArgumentError: Lengths of iterables stored in columns :b and :c are not the same in row 2\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Base.hcat","page":"Functions","title":"Base.hcat","text":"hcat(df::AbstractDataFrame...;\n     makeunique::Bool=false, copycols::Bool=true)\n\nHorizontally concatenate data frames.\n\nIf makeunique=false (the default) column names of passed objects must be unique. If makeunique=true then duplicate column names will be suffixed with _i (i starting at 1 for the first duplicate).\n\nIf copycols=true (the default) then the DataFrame returned by hcat will contain copied columns from the source data frames. If copycols=false then it will contain columns as they are stored in the source (without copying). This option should be used with caution as mutating either the columns in sources or in the returned DataFrame might lead to the corruption of the other object.\n\nExample\n\njulia> df1 = DataFrame(A=1:3, B=1:3)\n3×2 DataFrame\n Row │ A      B\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1      1\n   2 │     2      2\n   3 │     3      3\n\njulia> df2 = DataFrame(A=4:6, B=4:6)\n3×2 DataFrame\n Row │ A      B\n     │ Int64  Int64\n─────┼──────────────\n   1 │     4      4\n   2 │     5      5\n   3 │     6      6\n\njulia> df3 = hcat(df1, df2, makeunique=true)\n3×4 DataFrame\n Row │ A      B      A_1    B_1\n     │ Int64  Int64  Int64  Int64\n─────┼────────────────────────────\n   1 │     1      1      4      4\n   2 │     2      2      5      5\n   3 │     3      3      6      6\n\njulia> df3.A === df1.A\nfalse\n\njulia> df3 = hcat(df1, df2, makeunique=true, copycols=false);\n\njulia> df3.A === df1.A\ntrue\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#DataFrames.insertcols!","page":"Functions","title":"DataFrames.insertcols!","text":"insertcols!(df::DataFrame[, col], (name=>val)::Pair...;\n            makeunique::Bool=false, copycols::Bool=true)\n\nInsert a column into a data frame in place. Return the updated DataFrame. If col is omitted it is set to ncol(df)+1 (the column is inserted as the last column).\n\nArguments\n\ndf : the DataFrame to which we want to add columns\ncol : a position at which we want to insert a column, passed as an integer or a column name (a string or a Symbol); the column selected with col and columns following it are shifted to the right in df after the operation\nname : the name of the new column\nval : an AbstractVector giving the contents of the new column or a value of any type other than AbstractArray which will be repeated to fill a new vector; As a particular rule a values stored in a Ref or a 0-dimensional AbstractArray are unwrapped and treated in the same way.\nmakeunique : Defines what to do if name already exists in df; if it is false an error will be thrown; if it is true a new unique name will be generated by adding a suffix\ncopycols : whether vectors passed as columns should be copied\n\nIf val is an AbstractRange then the result of collect(val) is inserted.\n\nExamples\n\njulia> df = DataFrame(a=1:3)\n3×1 DataFrame\n Row │ a\n     │ Int64\n─────┼───────\n   1 │     1\n   2 │     2\n   3 │     3\n\njulia> insertcols!(df, 1, :b => 'a':'c')\n3×2 DataFrame\n Row │ b     a\n     │ Char  Int64\n─────┼─────────────\n   1 │ a         1\n   2 │ b         2\n   3 │ c         3\n\njulia> insertcols!(df, 2, :c => 2:4, :c => 3:5, makeunique=true)\n3×4 DataFrame\n Row │ b     c      c_1    a\n     │ Char  Int64  Int64  Int64\n─────┼───────────────────────────\n   1 │ a         2      3      1\n   2 │ b         3      4      2\n   3 │ c         4      5      3\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#DataFrames.mapcols","page":"Functions","title":"DataFrames.mapcols","text":"mapcols(f::Union{Function, Type}, df::AbstractDataFrame)\n\nReturn a DataFrame where each column of df is transformed using function f. f must return AbstractVector objects all with the same length or scalars (all values other than AbstractVector are considered to be a scalar).\n\nNote that mapcols guarantees not to reuse the columns from df in the returned DataFrame. If f returns its argument then it gets copied before being stored.\n\nExamples\n\njulia> df = DataFrame(x=1:4, y=11:14)\n4×2 DataFrame\n Row │ x      y\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1     11\n   2 │     2     12\n   3 │     3     13\n   4 │     4     14\n\njulia> mapcols(x -> x.^2, df)\n4×2 DataFrame\n Row │ x      y\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1    121\n   2 │     4    144\n   3 │     9    169\n   4 │    16    196\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#DataFrames.mapcols!","page":"Functions","title":"DataFrames.mapcols!","text":"mapcols!(f::Union{Function, Type}, df::DataFrame)\n\nUpdate a DataFrame in-place where each column of df is transformed using function f. f must return AbstractVector objects all with the same length or scalars (all values other than AbstractVector are considered to be a scalar).\n\nNote that mapcols! reuses the columns from df if they are returned by f.\n\nExamples\n\njulia> df = DataFrame(x=1:4, y=11:14)\n4×2 DataFrame\n Row │ x      y\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1     11\n   2 │     2     12\n   3 │     3     13\n   4 │     4     14\n\njulia> mapcols!(x -> x.^2, df);\n\njulia> df\n4×2 DataFrame\n Row │ x      y\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1    121\n   2 │     4    144\n   3 │     9    169\n   4 │    16    196\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Base.push!","page":"Functions","title":"Base.push!","text":"push!(df::DataFrame, row::Union{Tuple, AbstractArray}; promote::Bool=false)\npush!(df::DataFrame, row::Union{DataFrameRow, NamedTuple, AbstractDict};\n      cols::Symbol=:setequal, promote::Bool=(cols in [:union, :subset]))\n\nAdd in-place one row at the end of df taking the values from row.\n\nColumn types of df are preserved, and new values are converted if necessary. An error is thrown if conversion fails.\n\nIf row is neither a DataFrameRow, NamedTuple nor AbstractDict then it must be a Tuple or an AbstractArray and columns are matched by order of appearance. In this case row must contain the same number of elements as the number of columns in df.\n\nIf row is a DataFrameRow, NamedTuple or AbstractDict then values in row are matched to columns in df based on names. The exact behavior depends on the cols argument value in the following way:\n\nIf cols == :setequal (this is the default) then row must contain exactly the same columns as df (but possibly in a different order).\nIf cols == :orderequal then row must contain the same columns in the same order (for AbstractDict this option requires that keys(row) matches propertynames(df) to allow for support of ordered dicts; however, if row is a Dict an error is thrown as it is an unordered collection).\nIf cols == :intersect then row may contain more columns than df, but all column names that are present in df must be present in row and only they are used to populate a new row in df.\nIf cols == :subset then push! behaves like for :intersect but if some column is missing in row then a missing value is pushed to df.\nIf cols == :union then columns missing in df that are present in row are added to df (using missing for existing rows) and a missing value is pushed to columns missing in row that are present in df.\n\nIf promote=true and element type of a column present in df does not allow the type of a pushed argument then a new column with a promoted element type allowing it is freshly allocated and stored in df. If promote=false an error is thrown.\n\nAs a special case, if df has no columns and row is a NamedTuple or DataFrameRow, columns are created for all values in row, using their names and order.\n\nPlease note that push! must not be used on a DataFrame that contains columns that are aliases (equal when compared with ===).\n\nExamples\n\njulia> df = DataFrame(A=1:3, B=1:3);\n\njulia> push!(df, (true, false))\n4×2 DataFrame\n Row │ A      B\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1      1\n   2 │     2      2\n   3 │     3      3\n   4 │     1      0\n\njulia> push!(df, df[1, :])\n5×2 DataFrame\n Row │ A      B\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1      1\n   2 │     2      2\n   3 │     3      3\n   4 │     1      0\n   5 │     1      1\n\njulia> push!(df, (C=\"something\", A=true, B=false), cols=:intersect)\n6×2 DataFrame\n Row │ A      B\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1      1\n   2 │     2      2\n   3 │     3      3\n   4 │     1      0\n   5 │     1      1\n   6 │     1      0\n\njulia> push!(df, Dict(:A=>1.0, :C=>1.0), cols=:union)\n7×3 DataFrame\n Row │ A        B        C\n     │ Float64  Int64?   Float64?\n─────┼─────────────────────────────\n   1 │     1.0        1  missing\n   2 │     2.0        2  missing\n   3 │     3.0        3  missing\n   4 │     1.0        0  missing\n   5 │     1.0        1  missing\n   6 │     1.0        0  missing\n   7 │     1.0  missing        1.0\n\njulia> push!(df, NamedTuple(), cols=:subset)\n8×3 DataFrame\n Row │ A          B        C\n     │ Float64?   Int64?   Float64?\n─────┼───────────────────────────────\n   1 │       1.0        1  missing\n   2 │       2.0        2  missing\n   3 │       3.0        3  missing\n   4 │       1.0        0  missing\n   5 │       1.0        1  missing\n   6 │       1.0        0  missing\n   7 │       1.0  missing        1.0\n   8 │ missing    missing  missing\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Base.reduce","page":"Functions","title":"Base.reduce","text":"reduce(::typeof(vcat),\n       dfs::Union{AbstractVector{<:AbstractDataFrame},\n                  Tuple{AbstractDataFrame, Vararg{AbstractDataFrame}}};\n       cols::Union{Symbol, AbstractVector{Symbol},\n                   AbstractVector{<:AbstractString}}=:setequal,\n       source::Union{Nothing, Symbol, AbstractString,\n                     Pair{<:Union{Symbol, AbstractString}, <:AbstractVector}}=nothing)\n\nEfficiently reduce the given vector or tuple of AbstractDataFrames with vcat.\n\nThe column order, names, and types of the resulting DataFrame, and the behavior of cols and source keyword arguments follow the rules specified for vcat of AbstractDataFrames.\n\nExample\n\njulia> df1 = DataFrame(A=1:3, B=1:3)\n3×2 DataFrame\n Row │ A      B\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1      1\n   2 │     2      2\n   3 │     3      3\n\njulia> df2 = DataFrame(A=4:6, B=4:6)\n3×2 DataFrame\n Row │ A      B\n     │ Int64  Int64\n─────┼──────────────\n   1 │     4      4\n   2 │     5      5\n   3 │     6      6\n\njulia> df3 = DataFrame(A=7:9, C=7:9)\n3×2 DataFrame\n Row │ A      C\n     │ Int64  Int64\n─────┼──────────────\n   1 │     7      7\n   2 │     8      8\n   3 │     9      9\n\njulia> reduce(vcat, (df1, df2))\n6×2 DataFrame\n Row │ A      B\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1      1\n   2 │     2      2\n   3 │     3      3\n   4 │     4      4\n   5 │     5      5\n   6 │     6      6\n\njulia> reduce(vcat, [df1, df2, df3], cols=:union, source=:source)\n9×4 DataFrame\n Row │ A      B        C        source\n     │ Int64  Int64?   Int64?   Int64\n─────┼─────────────────────────────────\n   1 │     1        1  missing       1\n   2 │     2        2  missing       1\n   3 │     3        3  missing       1\n   4 │     4        4  missing       2\n   5 │     5        5  missing       2\n   6 │     6        6  missing       2\n   7 │     7  missing        7       3\n   8 │     8  missing        8       3\n   9 │     9  missing        9       3\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Base.repeat","page":"Functions","title":"Base.repeat","text":"repeat(df::AbstractDataFrame; inner::Integer = 1, outer::Integer = 1)\n\nConstruct a data frame by repeating rows in df. inner specifies how many times each row is repeated, and outer specifies how many times the full set of rows is repeated.\n\nExample\n\njulia> df = DataFrame(a = 1:2, b = 3:4)\n2×2 DataFrame\n Row │ a      b\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1      3\n   2 │     2      4\n\njulia> repeat(df, inner = 2, outer = 3)\n12×2 DataFrame\n Row │ a      b\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1      3\n   2 │     1      3\n   3 │     2      4\n   4 │     2      4\n   5 │     1      3\n   6 │     1      3\n   7 │     2      4\n   8 │     2      4\n   9 │     1      3\n  10 │     1      3\n  11 │     2      4\n  12 │     2      4\n\n\n\n\n\nrepeat(df::AbstractDataFrame, count::Integer)\n\nConstruct a data frame by repeating each row in df the number of times specified by count.\n\nExample\n\njulia> df = DataFrame(a = 1:2, b = 3:4)\n2×2 DataFrame\n Row │ a      b\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1      3\n   2 │     2      4\n\njulia> repeat(df, 2)\n4×2 DataFrame\n Row │ a      b\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1      3\n   2 │     2      4\n   3 │     1      3\n   4 │     2      4\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#DataFrames.repeat!","page":"Functions","title":"DataFrames.repeat!","text":"repeat!(df::DataFrame; inner::Integer = 1, outer::Integer = 1)\n\nUpdate a data frame df in-place by repeating its rows. inner specifies how many times each row is repeated, and outer specifies how many times the full set of rows is repeated. Columns of df are freshly allocated.\n\nExample\n\njulia> df = DataFrame(a = 1:2, b = 3:4)\n2×2 DataFrame\n Row │ a      b\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1      3\n   2 │     2      4\n\njulia> repeat!(df, inner = 2, outer = 3);\n\njulia> df\n12×2 DataFrame\n Row │ a      b\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1      3\n   2 │     1      3\n   3 │     2      4\n   4 │     2      4\n   5 │     1      3\n   6 │     1      3\n   7 │     2      4\n   8 │     2      4\n   9 │     1      3\n  10 │     1      3\n  11 │     2      4\n  12 │     2      4\n\n\n\n\n\nrepeat!(df::DataFrame, count::Integer)\n\nUpdate a data frame df in-place by repeating its rows the number of times specified by count. Columns of df are freshly allocated.\n\nExample\n\njulia> df = DataFrame(a = 1:2, b = 3:4)\n2×2 DataFrame\n Row │ a      b\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1      3\n   2 │     2      4\n\njulia> repeat(df, 2)\n4×2 DataFrame\n Row │ a      b\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1      3\n   2 │     2      4\n   3 │     1      3\n   4 │     2      4\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#DataFrames.select","page":"Functions","title":"DataFrames.select","text":"select(df::AbstractDataFrame, args...; copycols::Bool=true, renamecols::Bool=true)\nselect(args::Callable, df::DataFrame; renamecols::Bool=true)\nselect(gd::GroupedDataFrame, args...; copycols::Bool=true, keepkeys::Bool=true,\n       ungroup::Bool=true, renamecols::Bool=true)\nselect(f::Base.Callable, gd::GroupedDataFrame; copycols::Bool=true,\n       keepkeys::Bool=true, ungroup::Bool=true, renamecols::Bool=true)\n\nCreate a new data frame that contains columns from df or gd specified by args and return it. The result is guaranteed to have the same number of rows as df, except when no columns are selected (in which case the result has zero rows).\n\nBelow detailed common rules for all transformation functions supported by DataFrames.jl are explained and compared.\n\nAll these operations are supported both for AbstractDataFrame (when split and combine steps are skipped) and GroupedDataFrame. Technically, AbstractDataFrame is just considered as being grouped on no columns (meaning it has a single group, or zero groups if it is empty). The only difference is that in this case the keepkeys and ungroup keyword arguments (described below) are not supported and a data frame is always returned, as there are no split and combine steps in this case.\n\nIn order to perform operations by groups you first need to create a GroupedDataFrame object from your data frame using the groupby function that takes two arguments: (1) a data frame to be grouped, and (2) a set of columns to group by.\n\nOperations can then be applied on each group using one of the following functions:\n\ncombine: does not put restrictions on number of rows returned, the order of rows is specified by the order of groups in GroupedDataFrame; it is typically used to compute summary statistics by group;\nselect: return a data frame with the number and order of rows exactly the same as the source data frame, including only new calculated columns; select! is an in-place version of select;\ntransform: return a data frame with the number and order of rows exactly the same as the source data frame, including all columns from the source and new calculated columns; transform! is an in-place version of transform.\n\nAll these functions take a specification of one or more functions to apply to each subset of the DataFrame. This specification can be of the following forms:\n\nstandard column selectors (integers, Symbols, strings, vectors of integers, vectors of Symbols, vectors of strings, All, Cols, :, Between, Not and regular expressions)\na cols => function pair indicating that function should be called with positional arguments holding columns cols, which can be any valid column selector; in this case target column name is automatically generated and it is assumed that function returns a single value or a vector; the generated name is created by concatenating source column name and function name by default (see examples below).\na cols => function => target_cols form additionally explicitly specifying the target column or columns.\na col => target_cols pair, which renames the column col to target_cols, which must be single name (as a Symbol or a string), a vector of names or AsTable.\na nrow or nrow => target_cols form which efficiently computes the number of rows in a group; without target_cols the new column is called :nrow, otherwise it must be single name (as a Symbol or a string).\nvectors or matrices containing transformations specified by the Pair syntax described in points 2 to 5\na function which will be called with a SubDataFrame corresponding to each group; this form should be avoided due to its poor performance unless the number of groups is small or a very large number of columns are processed (in which case SubDataFrame avoids excessive compilation)\n\nNote! If the expression of the form x => y is passed then except for the special convenience form nrow => target_cols it is always interpreted as cols => function. In particular the following expression function => target_cols is not a valid transformation specification.\n\nAll functions have two types of signatures. One of them takes a GroupedDataFrame as the first argument and an arbitrary number of transformations described above as following arguments. The second type of signature is when a Function or a Type is passed as the first argument and a GroupedDataFrame as the second argument (similar to map).\n\nAs a special rule, with the cols => function and cols => function => target_cols syntaxes, if cols is wrapped in an AsTable object then a NamedTuple containing columns selected by cols is passed to function.\n\nWhat is allowed for function to return is determined by the target_cols value:\n\nIf both cols and target_cols are omitted (so only a function is passed), then returning a data frame, a matrix, a NamedTuple, or a DataFrameRow will produce multiple columns in the result. Returning any other value produces a single column.\nIf target_cols is a Symbol or a string then the function is assumed to return a single column. In this case returning a data frame, a matrix, a NamedTuple, or a DataFrameRow raises an error.\nIf target_cols is a vector of Symbols or strings or AsTable it is assumed that function returns multiple columns. If function returns one of AbstractDataFrame, NamedTuple, DataFrameRow, AbstractMatrix then rules described in point 1 above apply. If function returns an AbstractVector then each element of this vector must support the keys function, which must return a collection of Symbols, strings or integers; the return value of keys must be identical for all elements. Then as many columns are created as there are elements in the return value of the keys function. If target_cols is AsTable then their names are set to be equal to the key names except if keys returns integers, in which case they are prefixed by x (so the column names are e.g. x1, x2, ...). If target_cols is a vector of Symbols or strings then column names produced using the rules above are ignored and replaced by target_cols (the number of columns must be the same as the length of target_cols in this case). If fun returns a value of any other type then it is assumed that it is a table conforming to the Tables.jl API and the Tables.columntable function is called on it to get the resulting columns and their names. The names are retained when target_cols is AsTable and are replaced if target_cols is a vector of Symbols or strings.\n\nIn all of these cases, function can return either a single row or multiple rows. As a particular rule, values wrapped in a Ref or a 0-dimensional AbstractArray are unwrapped and then treated as a single row.\n\nselect/select! and transform/transform! always return a DataFrame with the same number and order of rows as the source (even if GroupedDataFrame had its groups reordered).\n\nFor combine, rows in the returned object appear in the order of groups in the GroupedDataFrame. The functions can return an arbitrary number of rows for each group, but the kind of returned object and the number and names of columns must be the same for all groups, except when a DataFrame() or NamedTuple() is returned, in which case a given group is skipped.\n\nIt is allowed to mix single values and vectors if multiple transformations are requested. In this case single value will be repeated to match the length of columns specified by returned vectors.\n\nTo apply function to each row instead of whole columns, it can be wrapped in a ByRow struct. cols can be any column indexing syntax, in which case function will be passed one argument for each of the columns specified by cols or a NamedTuple of them if specified columns are wrapped in AsTable. If ByRow is used it is allowed for cols to select an empty set of columns, in which case function is called for each row without any arguments and an empty NamedTuple is passed if empty set of columns is wrapped in AsTable.\n\nIf a collection of column names is passed then requesting duplicate column names in target data frame are accepted (e.g. select!(df, [:a], :, r\"a\") is allowed) and only the first occurrence is used. In particular a syntax to move column :col to the first position in the data frame is select!(df, :col, :). On the contrary, output column names of renaming, transformation and single column selection operations must be unique, so e.g. select!(df, :a, :a => :a) or select!(df, :a, :a => ByRow(sin) => :a) are not allowed.\n\nAs a general rule if copycols=true columns are copied and when copycols=false columns are reused if possible. Note, however, that including the same column several times in the data frame via renaming or transformations that return the same object without copying may create column aliases even if copycols=true. An example of such a situation is select!(df, :a, :a => :b, :a => identity => :c). As a special case in transform and transform! column renaming always copies columns to avoid storing aliased columns in the target data frame.\n\nIf df is a SubDataFrame and copycols=true then a DataFrame is returned and the same copying rules apply as for a DataFrame input: this means in particular that selected columns will be copied. If copycols=false, a SubDataFrame is returned without copying columns.\n\nIf a GroupedDataFrame is passed, a separate task is spawned for each specified transformation; each transformation then spawns as many tasks as Julia threads, and splits processing of groups across them (however, currently transformations with optimized implementations like sum and transformations that return multiple rows use a single task for all groups). This allows for parallel operation when Julia was started with more than one thread. Passed transformation functions should therefore not modify global variables (i.e. they should be pure), or use locks to control parallel accesses. In the future, parallelism may be extended to other cases, so this requirement also holds for DataFrame inputs.\n\nKeyword arguments\n\ncopycols::Bool=true : whether columns of the source data frame should be copied if no transformation is applied to them.\nrenamecols::Bool=true : whether in the cols => function form automatically generated column names should include the name of transformation functions or not.\nkeepkeys::Bool=true : whether grouping columns of gd should be kept in the returned data frame.\nungroup::Bool=true : whether the return value of the operation on gd should be a data frame or a GroupedDataFrame.\n\nExamples\n\njulia> df = DataFrame(a=1:3, b=4:6)\n3×2 DataFrame\n Row │ a      b\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1      4\n   2 │     2      5\n   3 │     3      6\n\njulia> select(df, 2)\n3×1 DataFrame\n Row │ b\n     │ Int64\n─────┼───────\n   1 │     4\n   2 │     5\n   3 │     6\n\njulia> select(df, :a => ByRow(sin) => :c, :b)\n3×2 DataFrame\n Row │ c         b\n     │ Float64   Int64\n─────┼─────────────────\n   1 │ 0.841471      4\n   2 │ 0.909297      5\n   3 │ 0.14112       6\n\njulia> select(df, :, [:a, :b] => (a, b) -> a .+ b .- sum(b)/length(b))\n3×3 DataFrame\n Row │ a      b      a_b_function\n     │ Int64  Int64  Float64\n─────┼────────────────────────────\n   1 │     1      4           0.0\n   2 │     2      5           2.0\n   3 │     3      6           4.0\n\njulia> select(df, names(df) .=> [minimum maximum])\n3×4 DataFrame\n Row │ a_minimum  b_minimum  a_maximum  b_maximum\n     │ Int64      Int64      Int64      Int64\n─────┼────────────────────────────────────────────\n   1 │         1          4          3          6\n   2 │         1          4          3          6\n   3 │         1          4          3          6\n\njulia> using Statistics\n\njulia> select(df, AsTable(:) => ByRow(mean), renamecols=false)\n3×1 DataFrame\n Row │ a_b\n     │ Float64\n─────┼─────────\n   1 │     2.5\n   2 │     3.5\n   3 │     4.5\n\njulia> select(first, df)\n3×2 DataFrame\n Row │ a      b\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1      4\n   2 │     1      4\n   3 │     1      4\n\njulia> df = DataFrame(a=1:3, b=4:6, c=7:9)\n3×3 DataFrame\n Row │ a      b      c\n     │ Int64  Int64  Int64\n─────┼─────────────────────\n   1 │     1      4      7\n   2 │     2      5      8\n   3 │     3      6      9\n\njulia> select(df, AsTable(:) => ByRow(x -> (mean=mean(x), std=std(x))) => :stats,\n              AsTable(:) => ByRow(x -> (mean=mean(x), std=std(x))) => AsTable)\n3×3 DataFrame\n Row │ stats                    mean     std\n     │ NamedTup…                Float64  Float64\n─────┼───────────────────────────────────────────\n   1 │ (mean = 4.0, std = 3.0)      4.0      3.0\n   2 │ (mean = 5.0, std = 3.0)      5.0      3.0\n   3 │ (mean = 6.0, std = 3.0)      6.0      3.0\n\njulia> df = DataFrame(a = [1, 1, 1, 2, 2, 1, 1, 2],\n                      b = repeat([2, 1], outer=[4]),\n                      c = 1:8)\n8×3 DataFrame\n Row │ a      b      c\n     │ Int64  Int64  Int64\n─────┼─────────────────────\n   1 │     1      2      1\n   2 │     1      1      2\n   3 │     1      2      3\n   4 │     2      1      4\n   5 │     2      2      5\n   6 │     1      1      6\n   7 │     1      2      7\n   8 │     2      1      8\n\njulia> gd = groupby(df, :a)\nGroupedDataFrame with 2 groups based on key: a\nFirst Group (5 rows): a = 1\n Row │ a      b      c\n     │ Int64  Int64  Int64\n─────┼─────────────────────\n   1 │     1      2      1\n   2 │     1      1      2\n   3 │     1      2      3\n   4 │     1      1      6\n   5 │     1      2      7\n⋮\nLast Group (3 rows): a = 2\n Row │ a      b      c\n     │ Int64  Int64  Int64\n─────┼─────────────────────\n   1 │     2      1      4\n   2 │     2      2      5\n   3 │     2      1      8\n\nspecifying a name for target column\n\njulia> df = DataFrame(a = [1, 1, 1, 2, 2, 1, 1, 2],\n                      b = repeat([2, 1], outer=[4]),\n                      c = 1:8);\n\njulia> gd = groupby(df, :a);\n\njulia> select(gd, :c => (x -> sum(log, x)) => :sum_log_c)\n8×2 DataFrame\n Row │ a      sum_log_c\n     │ Int64  Float64\n─────┼──────────────────\n   1 │     1    5.52943\n   2 │     1    5.52943\n   3 │     1    5.52943\n   4 │     2    5.07517\n   5 │     2    5.07517\n   6 │     1    5.52943\n   7 │     1    5.52943\n   8 │     2    5.07517\n\njulia> select(gd, [:b, :c] .=> sum) # passing a vector of pairs\n8×3 DataFrame\n Row │ a      b_sum  c_sum\n     │ Int64  Int64  Int64\n─────┼─────────────────────\n   1 │     1      8     19\n   2 │     1      8     19\n   3 │     1      8     19\n   4 │     2      4     17\n   5 │     2      4     17\n   6 │     1      8     19\n   7 │     1      8     19\n   8 │     2      4     17\n\nmultiple arguments, renaming and keepkeys\n\njulia> df = DataFrame(a = [1, 1, 1, 2, 2, 1, 1, 2],\n                      b = repeat([2, 1], outer=[4]),\n                      c = 1:8);\n\njulia> gd = groupby(df, :a);\n\njulia> select(gd, :b => :b1, :c => :c1, [:b, :c] => +, keepkeys=false)\n8×3 DataFrame\n Row │ b1     c1     b_c_+\n     │ Int64  Int64  Int64\n─────┼─────────────────────\n   1 │     2      1      3\n   2 │     1      2      3\n   3 │     2      3      5\n   4 │     1      4      5\n   5 │     2      5      7\n   6 │     1      6      7\n   7 │     2      7      9\n   8 │     1      8      9\n\nbroadcasting and column expansion\n\njulia> df = DataFrame(a = [1, 1, 1, 2, 2, 1, 1, 2],\n                      b = repeat([2, 1], outer=[4]),\n                      c = 1:8);\n\njulia> gd = groupby(df, :a);\n\njulia> select(gd, :b, AsTable([:b, :c]) => ByRow(extrema) => [:min, :max])\n8×4 DataFrame\n Row │ a      b      min    max\n     │ Int64  Int64  Int64  Int64\n─────┼────────────────────────────\n   1 │     1      2      1      2\n   2 │     1      1      1      2\n   3 │     1      2      2      3\n   4 │     2      1      1      4\n   5 │     2      2      2      5\n   6 │     1      1      1      6\n   7 │     1      2      2      7\n   8 │     2      1      1      8\n\njulia> select(gd, :, AsTable(Not(:a)) => sum, renamecols=false)\n8×4 DataFrame\n Row │ a      b      c      b_c\n     │ Int64  Int64  Int64  Int64\n─────┼────────────────────────────\n   1 │     1      2      1      3\n   2 │     1      1      2      3\n   3 │     1      2      3      5\n   4 │     2      1      4      5\n   5 │     2      2      5      7\n   6 │     1      1      6      7\n   7 │     1      2      7      9\n   8 │     2      1      8      9\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#DataFrames.select!","page":"Functions","title":"DataFrames.select!","text":"select!(df::DataFrame, args...; renamecols::Bool=true)\nselect!(args::Base.Callable, df::DataFrame; renamecols::Bool=true)\nselect!(gd::GroupedDataFrame{DataFrame}, args...; ungroup::Bool=true, renamecols::Bool=true)\nselect!(f::Base.Callable, gd::GroupedDataFrame; ungroup::Bool=true, renamecols::Bool=true)\n\nMutate df or gd in place to retain only columns or transformations specified by args... and return it. The result is guaranteed to have the same number of rows as df or parent of gd, except when no columns are selected (in which case the result has zero rows).\n\nIf gd is passed then it is updated to reflect the new rows of its updated parent. If there are independent GroupedDataFrame objects constructed using the same parent data frame they might get corrupt.\n\nBelow detailed common rules for all transformation functions supported by DataFrames.jl are explained and compared.\n\nAll these operations are supported both for AbstractDataFrame (when split and combine steps are skipped) and GroupedDataFrame. Technically, AbstractDataFrame is just considered as being grouped on no columns (meaning it has a single group, or zero groups if it is empty). The only difference is that in this case the keepkeys and ungroup keyword arguments (described below) are not supported and a data frame is always returned, as there are no split and combine steps in this case.\n\nIn order to perform operations by groups you first need to create a GroupedDataFrame object from your data frame using the groupby function that takes two arguments: (1) a data frame to be grouped, and (2) a set of columns to group by.\n\nOperations can then be applied on each group using one of the following functions:\n\ncombine: does not put restrictions on number of rows returned, the order of rows is specified by the order of groups in GroupedDataFrame; it is typically used to compute summary statistics by group;\nselect: return a data frame with the number and order of rows exactly the same as the source data frame, including only new calculated columns; select! is an in-place version of select;\ntransform: return a data frame with the number and order of rows exactly the same as the source data frame, including all columns from the source and new calculated columns; transform! is an in-place version of transform.\n\nAll these functions take a specification of one or more functions to apply to each subset of the DataFrame. This specification can be of the following forms:\n\nstandard column selectors (integers, Symbols, strings, vectors of integers, vectors of Symbols, vectors of strings, All, Cols, :, Between, Not and regular expressions)\na cols => function pair indicating that function should be called with positional arguments holding columns cols, which can be any valid column selector; in this case target column name is automatically generated and it is assumed that function returns a single value or a vector; the generated name is created by concatenating source column name and function name by default (see examples below).\na cols => function => target_cols form additionally explicitly specifying the target column or columns.\na col => target_cols pair, which renames the column col to target_cols, which must be single name (as a Symbol or a string), a vector of names or AsTable.\na nrow or nrow => target_cols form which efficiently computes the number of rows in a group; without target_cols the new column is called :nrow, otherwise it must be single name (as a Symbol or a string).\nvectors or matrices containing transformations specified by the Pair syntax described in points 2 to 5\na function which will be called with a SubDataFrame corresponding to each group; this form should be avoided due to its poor performance unless the number of groups is small or a very large number of columns are processed (in which case SubDataFrame avoids excessive compilation)\n\nNote! If the expression of the form x => y is passed then except for the special convenience form nrow => target_cols it is always interpreted as cols => function. In particular the following expression function => target_cols is not a valid transformation specification.\n\nAll functions have two types of signatures. One of them takes a GroupedDataFrame as the first argument and an arbitrary number of transformations described above as following arguments. The second type of signature is when a Function or a Type is passed as the first argument and a GroupedDataFrame as the second argument (similar to map).\n\nAs a special rule, with the cols => function and cols => function => target_cols syntaxes, if cols is wrapped in an AsTable object then a NamedTuple containing columns selected by cols is passed to function.\n\nWhat is allowed for function to return is determined by the target_cols value:\n\nIf both cols and target_cols are omitted (so only a function is passed), then returning a data frame, a matrix, a NamedTuple, or a DataFrameRow will produce multiple columns in the result. Returning any other value produces a single column.\nIf target_cols is a Symbol or a string then the function is assumed to return a single column. In this case returning a data frame, a matrix, a NamedTuple, or a DataFrameRow raises an error.\nIf target_cols is a vector of Symbols or strings or AsTable it is assumed that function returns multiple columns. If function returns one of AbstractDataFrame, NamedTuple, DataFrameRow, AbstractMatrix then rules described in point 1 above apply. If function returns an AbstractVector then each element of this vector must support the keys function, which must return a collection of Symbols, strings or integers; the return value of keys must be identical for all elements. Then as many columns are created as there are elements in the return value of the keys function. If target_cols is AsTable then their names are set to be equal to the key names except if keys returns integers, in which case they are prefixed by x (so the column names are e.g. x1, x2, ...). If target_cols is a vector of Symbols or strings then column names produced using the rules above are ignored and replaced by target_cols (the number of columns must be the same as the length of target_cols in this case). If fun returns a value of any other type then it is assumed that it is a table conforming to the Tables.jl API and the Tables.columntable function is called on it to get the resulting columns and their names. The names are retained when target_cols is AsTable and are replaced if target_cols is a vector of Symbols or strings.\n\nIn all of these cases, function can return either a single row or multiple rows. As a particular rule, values wrapped in a Ref or a 0-dimensional AbstractArray are unwrapped and then treated as a single row.\n\nselect/select! and transform/transform! always return a DataFrame with the same number and order of rows as the source (even if GroupedDataFrame had its groups reordered).\n\nFor combine, rows in the returned object appear in the order of groups in the GroupedDataFrame. The functions can return an arbitrary number of rows for each group, but the kind of returned object and the number and names of columns must be the same for all groups, except when a DataFrame() or NamedTuple() is returned, in which case a given group is skipped.\n\nIt is allowed to mix single values and vectors if multiple transformations are requested. In this case single value will be repeated to match the length of columns specified by returned vectors.\n\nTo apply function to each row instead of whole columns, it can be wrapped in a ByRow struct. cols can be any column indexing syntax, in which case function will be passed one argument for each of the columns specified by cols or a NamedTuple of them if specified columns are wrapped in AsTable. If ByRow is used it is allowed for cols to select an empty set of columns, in which case function is called for each row without any arguments and an empty NamedTuple is passed if empty set of columns is wrapped in AsTable.\n\nIf a collection of column names is passed then requesting duplicate column names in target data frame are accepted (e.g. select!(df, [:a], :, r\"a\") is allowed) and only the first occurrence is used. In particular a syntax to move column :col to the first position in the data frame is select!(df, :col, :). On the contrary, output column names of renaming, transformation and single column selection operations must be unique, so e.g. select!(df, :a, :a => :a) or select!(df, :a, :a => ByRow(sin) => :a) are not allowed.\n\nAs a general rule if copycols=true columns are copied and when copycols=false columns are reused if possible. Note, however, that including the same column several times in the data frame via renaming or transformations that return the same object without copying may create column aliases even if copycols=true. An example of such a situation is select!(df, :a, :a => :b, :a => identity => :c). As a special case in transform and transform! column renaming always copies columns to avoid storing aliased columns in the target data frame.\n\nIf df is a SubDataFrame and copycols=true then a DataFrame is returned and the same copying rules apply as for a DataFrame input: this means in particular that selected columns will be copied. If copycols=false, a SubDataFrame is returned without copying columns.\n\nIf a GroupedDataFrame is passed, a separate task is spawned for each specified transformation; each transformation then spawns as many tasks as Julia threads, and splits processing of groups across them (however, currently transformations with optimized implementations like sum and transformations that return multiple rows use a single task for all groups). This allows for parallel operation when Julia was started with more than one thread. Passed transformation functions should therefore not modify global variables (i.e. they should be pure), or use locks to control parallel accesses. In the future, parallelism may be extended to other cases, so this requirement also holds for DataFrame inputs.\n\nKeyword arguments\n\nrenamecols::Bool=true : whether in the cols => function form automatically generated column names should include the name of transformation functions or not.\nungroup::Bool=true : whether the return value of the operation on gd should be a data frame or a GroupedDataFrame.\n\nSee select for examples.\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#DataFrames.transform","page":"Functions","title":"DataFrames.transform","text":"transform(df::AbstractDataFrame, args...; copycols::Bool=true, renamecols::Bool=true)\ntransform(f::Callable, df::DataFrame; renamecols::Bool=true)\ntransform(gd::GroupedDataFrame, args...; copycols::Bool=true,\n          keepkeys::Bool=true, ungroup::Bool=true, renamecols::Bool=true)\ntransform(f::Base.Callable, gd::GroupedDataFrame; copycols::Bool=true,\n          keepkeys::Bool=true, ungroup::Bool=true, renamecols::Bool=true)\n\nCreate a new data frame that contains columns from df or gd plus columns specified by args and return it. The result is guaranteed to have the same number of rows as df. Equivalent to select(df, :, args...) or select(gd, :, args...).\n\nBelow detailed common rules for all transformation functions supported by DataFrames.jl are explained and compared.\n\nAll these operations are supported both for AbstractDataFrame (when split and combine steps are skipped) and GroupedDataFrame. Technically, AbstractDataFrame is just considered as being grouped on no columns (meaning it has a single group, or zero groups if it is empty). The only difference is that in this case the keepkeys and ungroup keyword arguments (described below) are not supported and a data frame is always returned, as there are no split and combine steps in this case.\n\nIn order to perform operations by groups you first need to create a GroupedDataFrame object from your data frame using the groupby function that takes two arguments: (1) a data frame to be grouped, and (2) a set of columns to group by.\n\nOperations can then be applied on each group using one of the following functions:\n\ncombine: does not put restrictions on number of rows returned, the order of rows is specified by the order of groups in GroupedDataFrame; it is typically used to compute summary statistics by group;\nselect: return a data frame with the number and order of rows exactly the same as the source data frame, including only new calculated columns; select! is an in-place version of select;\ntransform: return a data frame with the number and order of rows exactly the same as the source data frame, including all columns from the source and new calculated columns; transform! is an in-place version of transform.\n\nAll these functions take a specification of one or more functions to apply to each subset of the DataFrame. This specification can be of the following forms:\n\nstandard column selectors (integers, Symbols, strings, vectors of integers, vectors of Symbols, vectors of strings, All, Cols, :, Between, Not and regular expressions)\na cols => function pair indicating that function should be called with positional arguments holding columns cols, which can be any valid column selector; in this case target column name is automatically generated and it is assumed that function returns a single value or a vector; the generated name is created by concatenating source column name and function name by default (see examples below).\na cols => function => target_cols form additionally explicitly specifying the target column or columns.\na col => target_cols pair, which renames the column col to target_cols, which must be single name (as a Symbol or a string), a vector of names or AsTable.\na nrow or nrow => target_cols form which efficiently computes the number of rows in a group; without target_cols the new column is called :nrow, otherwise it must be single name (as a Symbol or a string).\nvectors or matrices containing transformations specified by the Pair syntax described in points 2 to 5\na function which will be called with a SubDataFrame corresponding to each group; this form should be avoided due to its poor performance unless the number of groups is small or a very large number of columns are processed (in which case SubDataFrame avoids excessive compilation)\n\nNote! If the expression of the form x => y is passed then except for the special convenience form nrow => target_cols it is always interpreted as cols => function. In particular the following expression function => target_cols is not a valid transformation specification.\n\nAll functions have two types of signatures. One of them takes a GroupedDataFrame as the first argument and an arbitrary number of transformations described above as following arguments. The second type of signature is when a Function or a Type is passed as the first argument and a GroupedDataFrame as the second argument (similar to map).\n\nAs a special rule, with the cols => function and cols => function => target_cols syntaxes, if cols is wrapped in an AsTable object then a NamedTuple containing columns selected by cols is passed to function.\n\nWhat is allowed for function to return is determined by the target_cols value:\n\nIf both cols and target_cols are omitted (so only a function is passed), then returning a data frame, a matrix, a NamedTuple, or a DataFrameRow will produce multiple columns in the result. Returning any other value produces a single column.\nIf target_cols is a Symbol or a string then the function is assumed to return a single column. In this case returning a data frame, a matrix, a NamedTuple, or a DataFrameRow raises an error.\nIf target_cols is a vector of Symbols or strings or AsTable it is assumed that function returns multiple columns. If function returns one of AbstractDataFrame, NamedTuple, DataFrameRow, AbstractMatrix then rules described in point 1 above apply. If function returns an AbstractVector then each element of this vector must support the keys function, which must return a collection of Symbols, strings or integers; the return value of keys must be identical for all elements. Then as many columns are created as there are elements in the return value of the keys function. If target_cols is AsTable then their names are set to be equal to the key names except if keys returns integers, in which case they are prefixed by x (so the column names are e.g. x1, x2, ...). If target_cols is a vector of Symbols or strings then column names produced using the rules above are ignored and replaced by target_cols (the number of columns must be the same as the length of target_cols in this case). If fun returns a value of any other type then it is assumed that it is a table conforming to the Tables.jl API and the Tables.columntable function is called on it to get the resulting columns and their names. The names are retained when target_cols is AsTable and are replaced if target_cols is a vector of Symbols or strings.\n\nIn all of these cases, function can return either a single row or multiple rows. As a particular rule, values wrapped in a Ref or a 0-dimensional AbstractArray are unwrapped and then treated as a single row.\n\nselect/select! and transform/transform! always return a DataFrame with the same number and order of rows as the source (even if GroupedDataFrame had its groups reordered).\n\nFor combine, rows in the returned object appear in the order of groups in the GroupedDataFrame. The functions can return an arbitrary number of rows for each group, but the kind of returned object and the number and names of columns must be the same for all groups, except when a DataFrame() or NamedTuple() is returned, in which case a given group is skipped.\n\nIt is allowed to mix single values and vectors if multiple transformations are requested. In this case single value will be repeated to match the length of columns specified by returned vectors.\n\nTo apply function to each row instead of whole columns, it can be wrapped in a ByRow struct. cols can be any column indexing syntax, in which case function will be passed one argument for each of the columns specified by cols or a NamedTuple of them if specified columns are wrapped in AsTable. If ByRow is used it is allowed for cols to select an empty set of columns, in which case function is called for each row without any arguments and an empty NamedTuple is passed if empty set of columns is wrapped in AsTable.\n\nIf a collection of column names is passed then requesting duplicate column names in target data frame are accepted (e.g. select!(df, [:a], :, r\"a\") is allowed) and only the first occurrence is used. In particular a syntax to move column :col to the first position in the data frame is select!(df, :col, :). On the contrary, output column names of renaming, transformation and single column selection operations must be unique, so e.g. select!(df, :a, :a => :a) or select!(df, :a, :a => ByRow(sin) => :a) are not allowed.\n\nAs a general rule if copycols=true columns are copied and when copycols=false columns are reused if possible. Note, however, that including the same column several times in the data frame via renaming or transformations that return the same object without copying may create column aliases even if copycols=true. An example of such a situation is select!(df, :a, :a => :b, :a => identity => :c). As a special case in transform and transform! column renaming always copies columns to avoid storing aliased columns in the target data frame.\n\nIf df is a SubDataFrame and copycols=true then a DataFrame is returned and the same copying rules apply as for a DataFrame input: this means in particular that selected columns will be copied. If copycols=false, a SubDataFrame is returned without copying columns.\n\nIf a GroupedDataFrame is passed, a separate task is spawned for each specified transformation; each transformation then spawns as many tasks as Julia threads, and splits processing of groups across them (however, currently transformations with optimized implementations like sum and transformations that return multiple rows use a single task for all groups). This allows for parallel operation when Julia was started with more than one thread. Passed transformation functions should therefore not modify global variables (i.e. they should be pure), or use locks to control parallel accesses. In the future, parallelism may be extended to other cases, so this requirement also holds for DataFrame inputs.\n\nKeyword arguments\n\ncopycols::Bool=true : whether columns of the source data frame should be copied if no transformation is applied to them.\nrenamecols::Bool=true : whether in the cols => function form automatically generated column names should include the name of transformation functions or not.\nkeepkeys::Bool=true : whether grouping columns of gd should be kept in the returned data frame.\nungroup::Bool=true : whether the return value of the operation on gd should be a data frame or a GroupedDataFrame.\n\nNote that when the first argument is a GroupedDataFrame, keepkeys=false is needed to be able to return a different value for the grouping column:\n\njulia> gdf = groupby(DataFrame(x=1:2), :x)\nGroupedDataFrame with 2 groups based on key: x\nFirst Group (1 row): x = 1\n Row │ x\n     │ Int64\n─────┼───────\n   1 │     1\n⋮\nLast Group (1 row): x = 2\n Row │ x\n     │ Int64\n─────┼───────\n   1 │     2\n\njulia> transform(gdf, x -> (x=10,), keepkeys=false)\n2×1 DataFrame\n Row │ x\n     │ Int64\n─────┼───────\n   1 │    10\n   2 │    10\n\njulia> transform(gdf, x -> (x=10,), keepkeys=true)\nERROR: ArgumentError: column :x in returned data frame is not equal to grouping key :x\n\nSee select for more examples.\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#DataFrames.transform!","page":"Functions","title":"DataFrames.transform!","text":"transform!(df::DataFrame, args...; renamecols::Bool=true)\ntransform!(args::Callable, df::DataFrame; renamecols::Bool=true)\ntransform!(gd::GroupedDataFrame{DataFrame}, args...; ungroup::Bool=true, renamecols::Bool=true)\ntransform!(f::Base.Callable, gd::GroupedDataFrame; ungroup::Bool=true, renamecols::Bool=true)\n\nMutate df or gd in place to add columns specified by args... and return it. The result is guaranteed to have the same number of rows as df. Equivalent to select!(df, :, args...) or select!(gd, :, args...).\n\nBelow detailed common rules for all transformation functions supported by DataFrames.jl are explained and compared.\n\nAll these operations are supported both for AbstractDataFrame (when split and combine steps are skipped) and GroupedDataFrame. Technically, AbstractDataFrame is just considered as being grouped on no columns (meaning it has a single group, or zero groups if it is empty). The only difference is that in this case the keepkeys and ungroup keyword arguments (described below) are not supported and a data frame is always returned, as there are no split and combine steps in this case.\n\nIn order to perform operations by groups you first need to create a GroupedDataFrame object from your data frame using the groupby function that takes two arguments: (1) a data frame to be grouped, and (2) a set of columns to group by.\n\nOperations can then be applied on each group using one of the following functions:\n\ncombine: does not put restrictions on number of rows returned, the order of rows is specified by the order of groups in GroupedDataFrame; it is typically used to compute summary statistics by group;\nselect: return a data frame with the number and order of rows exactly the same as the source data frame, including only new calculated columns; select! is an in-place version of select;\ntransform: return a data frame with the number and order of rows exactly the same as the source data frame, including all columns from the source and new calculated columns; transform! is an in-place version of transform.\n\nAll these functions take a specification of one or more functions to apply to each subset of the DataFrame. This specification can be of the following forms:\n\nstandard column selectors (integers, Symbols, strings, vectors of integers, vectors of Symbols, vectors of strings, All, Cols, :, Between, Not and regular expressions)\na cols => function pair indicating that function should be called with positional arguments holding columns cols, which can be any valid column selector; in this case target column name is automatically generated and it is assumed that function returns a single value or a vector; the generated name is created by concatenating source column name and function name by default (see examples below).\na cols => function => target_cols form additionally explicitly specifying the target column or columns.\na col => target_cols pair, which renames the column col to target_cols, which must be single name (as a Symbol or a string), a vector of names or AsTable.\na nrow or nrow => target_cols form which efficiently computes the number of rows in a group; without target_cols the new column is called :nrow, otherwise it must be single name (as a Symbol or a string).\nvectors or matrices containing transformations specified by the Pair syntax described in points 2 to 5\na function which will be called with a SubDataFrame corresponding to each group; this form should be avoided due to its poor performance unless the number of groups is small or a very large number of columns are processed (in which case SubDataFrame avoids excessive compilation)\n\nNote! If the expression of the form x => y is passed then except for the special convenience form nrow => target_cols it is always interpreted as cols => function. In particular the following expression function => target_cols is not a valid transformation specification.\n\nAll functions have two types of signatures. One of them takes a GroupedDataFrame as the first argument and an arbitrary number of transformations described above as following arguments. The second type of signature is when a Function or a Type is passed as the first argument and a GroupedDataFrame as the second argument (similar to map).\n\nAs a special rule, with the cols => function and cols => function => target_cols syntaxes, if cols is wrapped in an AsTable object then a NamedTuple containing columns selected by cols is passed to function.\n\nWhat is allowed for function to return is determined by the target_cols value:\n\nIf both cols and target_cols are omitted (so only a function is passed), then returning a data frame, a matrix, a NamedTuple, or a DataFrameRow will produce multiple columns in the result. Returning any other value produces a single column.\nIf target_cols is a Symbol or a string then the function is assumed to return a single column. In this case returning a data frame, a matrix, a NamedTuple, or a DataFrameRow raises an error.\nIf target_cols is a vector of Symbols or strings or AsTable it is assumed that function returns multiple columns. If function returns one of AbstractDataFrame, NamedTuple, DataFrameRow, AbstractMatrix then rules described in point 1 above apply. If function returns an AbstractVector then each element of this vector must support the keys function, which must return a collection of Symbols, strings or integers; the return value of keys must be identical for all elements. Then as many columns are created as there are elements in the return value of the keys function. If target_cols is AsTable then their names are set to be equal to the key names except if keys returns integers, in which case they are prefixed by x (so the column names are e.g. x1, x2, ...). If target_cols is a vector of Symbols or strings then column names produced using the rules above are ignored and replaced by target_cols (the number of columns must be the same as the length of target_cols in this case). If fun returns a value of any other type then it is assumed that it is a table conforming to the Tables.jl API and the Tables.columntable function is called on it to get the resulting columns and their names. The names are retained when target_cols is AsTable and are replaced if target_cols is a vector of Symbols or strings.\n\nIn all of these cases, function can return either a single row or multiple rows. As a particular rule, values wrapped in a Ref or a 0-dimensional AbstractArray are unwrapped and then treated as a single row.\n\nselect/select! and transform/transform! always return a DataFrame with the same number and order of rows as the source (even if GroupedDataFrame had its groups reordered).\n\nFor combine, rows in the returned object appear in the order of groups in the GroupedDataFrame. The functions can return an arbitrary number of rows for each group, but the kind of returned object and the number and names of columns must be the same for all groups, except when a DataFrame() or NamedTuple() is returned, in which case a given group is skipped.\n\nIt is allowed to mix single values and vectors if multiple transformations are requested. In this case single value will be repeated to match the length of columns specified by returned vectors.\n\nTo apply function to each row instead of whole columns, it can be wrapped in a ByRow struct. cols can be any column indexing syntax, in which case function will be passed one argument for each of the columns specified by cols or a NamedTuple of them if specified columns are wrapped in AsTable. If ByRow is used it is allowed for cols to select an empty set of columns, in which case function is called for each row without any arguments and an empty NamedTuple is passed if empty set of columns is wrapped in AsTable.\n\nIf a collection of column names is passed then requesting duplicate column names in target data frame are accepted (e.g. select!(df, [:a], :, r\"a\") is allowed) and only the first occurrence is used. In particular a syntax to move column :col to the first position in the data frame is select!(df, :col, :). On the contrary, output column names of renaming, transformation and single column selection operations must be unique, so e.g. select!(df, :a, :a => :a) or select!(df, :a, :a => ByRow(sin) => :a) are not allowed.\n\nAs a general rule if copycols=true columns are copied and when copycols=false columns are reused if possible. Note, however, that including the same column several times in the data frame via renaming or transformations that return the same object without copying may create column aliases even if copycols=true. An example of such a situation is select!(df, :a, :a => :b, :a => identity => :c). As a special case in transform and transform! column renaming always copies columns to avoid storing aliased columns in the target data frame.\n\nIf df is a SubDataFrame and copycols=true then a DataFrame is returned and the same copying rules apply as for a DataFrame input: this means in particular that selected columns will be copied. If copycols=false, a SubDataFrame is returned without copying columns.\n\nIf a GroupedDataFrame is passed, a separate task is spawned for each specified transformation; each transformation then spawns as many tasks as Julia threads, and splits processing of groups across them (however, currently transformations with optimized implementations like sum and transformations that return multiple rows use a single task for all groups). This allows for parallel operation when Julia was started with more than one thread. Passed transformation functions should therefore not modify global variables (i.e. they should be pure), or use locks to control parallel accesses. In the future, parallelism may be extended to other cases, so this requirement also holds for DataFrame inputs.\n\nKeyword arguments\n\nrenamecols::Bool=true : whether in the cols => function form automatically generated column names should include the name of transformation functions or not.\nungroup::Bool=true : whether the return value of the operation on gd should be a data frame or a GroupedDataFrame.\n\nSee select for examples.\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Base.vcat","page":"Functions","title":"Base.vcat","text":"vcat(dfs::AbstractDataFrame...;\n     cols::Union{Symbol, AbstractVector{Symbol},\n                 AbstractVector{<:AbstractString}}=:setequal,\n     source::Union{Nothing, Symbol, AbstractString,\n                   Pair{<:Union{Symbol, AbstractString}, <:AbstractVector}}=nothing)\n\nVertically concatenate AbstractDataFrames.\n\nThe cols keyword argument determines the columns of the returned data frame:\n\n:setequal: require all data frames to have the same column names disregarding order. If they appear in different orders, the order of the first provided data frame is used.\n:orderequal: require all data frames to have the same column names and in the same order.\n:intersect: only the columns present in all provided data frames are kept. If the intersection is empty, an empty data frame is returned.\n:union: columns present in at least one of the provided data frames are kept. Columns not present in some data frames are filled with missing where necessary.\nA vector of Symbols or strings: only listed columns are kept. Columns not present in some data frames are filled with missing where necessary.\n\nThe source keyword argument, if not nothing (the default), specifies the additional column to be added in the last position in the resulting data frame that will identify the source data frame. It can be a Symbol or an AbstractString, in which case the identifier will be the number of the passed source data frame, or a Pair consisting of a Symbol or an AbstractString and of a vector specifying the data frame identifiers (which do not have to be unique). The name of the source column is not allowed to be present in any source data frame.\n\nThe order of columns is determined by the order they appear in the included data frames, searching through the header of the first data frame, then the second, etc.\n\nThe element types of columns are determined using promote_type, as with vcat for AbstractVectors.\n\nvcat ignores empty data frames, making it possible to initialize an empty data frame at the beginning of a loop and vcat onto it.\n\nExample\n\njulia> df1 = DataFrame(A=1:3, B=1:3)\n3×2 DataFrame\n Row │ A      B\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1      1\n   2 │     2      2\n   3 │     3      3\n\njulia> df2 = DataFrame(A=4:6, B=4:6)\n3×2 DataFrame\n Row │ A      B\n     │ Int64  Int64\n─────┼──────────────\n   1 │     4      4\n   2 │     5      5\n   3 │     6      6\n\njulia> df3 = DataFrame(A=7:9, C=7:9)\n3×2 DataFrame\n Row │ A      C\n     │ Int64  Int64\n─────┼──────────────\n   1 │     7      7\n   2 │     8      8\n   3 │     9      9\n\njulia> df4 = DataFrame()\n0×0 DataFrame\n\njulia> vcat(df1, df2)\n6×2 DataFrame\n Row │ A      B\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1      1\n   2 │     2      2\n   3 │     3      3\n   4 │     4      4\n   5 │     5      5\n   6 │     6      6\n\njulia> vcat(df1, df3, cols=:union)\n6×3 DataFrame\n Row │ A      B        C\n     │ Int64  Int64?   Int64?\n─────┼─────────────────────────\n   1 │     1        1  missing\n   2 │     2        2  missing\n   3 │     3        3  missing\n   4 │     7  missing        7\n   5 │     8  missing        8\n   6 │     9  missing        9\n\njulia> vcat(df1, df3, cols=:intersect)\n6×1 DataFrame\n Row │ A\n     │ Int64\n─────┼───────\n   1 │     1\n   2 │     2\n   3 │     3\n   4 │     7\n   5 │     8\n   6 │     9\n\njulia> vcat(df4, df1)\n3×2 DataFrame\n Row │ A      B\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1      1\n   2 │     2      2\n   3 │     3      3\n\njulia> vcat(df1, df2, df3, df4, cols=:union, source=\"source\")\n9×4 DataFrame\n Row │ A      B        C        source\n     │ Int64  Int64?   Int64?   Int64\n─────┼─────────────────────────────────\n   1 │     1        1  missing       1\n   2 │     2        2  missing       1\n   3 │     3        3  missing       1\n   4 │     4        4  missing       2\n   5 │     5        5  missing       2\n   6 │     6        6  missing       2\n   7 │     7  missing        7       3\n   8 │     8  missing        8       3\n   9 │     9  missing        9       3\n\njulia> vcat(df1, df2, df4, df3, cols=:union, source=:source => 'a':'d')\n9×4 DataFrame\n Row │ A      B        C        source\n     │ Int64  Int64?   Int64?   Char\n─────┼─────────────────────────────────\n   1 │     1        1  missing  a\n   2 │     2        2  missing  a\n   3 │     3        3  missing  a\n   4 │     4        4  missing  b\n   5 │     5        5  missing  b\n   6 │     6        6  missing  b\n   7 │     7  missing        7  d\n   8 │     8  missing        8  d\n   9 │     9  missing        9  d\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Reshaping-data-frames-between-tall-and-wide-formats","page":"Functions","title":"Reshaping data frames between tall and wide formats","text":"","category":"section"},{"location":"lib/functions/","page":"Functions","title":"Functions","text":"stack\nunstack\npermutedims","category":"page"},{"location":"lib/functions/#DataFrames.stack","page":"Functions","title":"DataFrames.stack","text":"stack(df::AbstractDataFrame[, measure_vars[, id_vars] ];\n      variable_name=:variable, value_name=:value,\n      view::Bool=false, variable_eltype::Type=String)\n\nStack a data frame df, i.e. convert it from wide to long format.\n\nReturn the long-format DataFrame with: columns for each of the id_vars, column value_name (:value by default) holding the values of the stacked columns (measure_vars), and column variable_name (:variable by default) a vector holding the name of the corresponding measure_vars variable.\n\nIf view=true then return a stacked view of a data frame (long format). The result is a view because the columns are special AbstractVectors that return views into the original data frame.\n\nArguments\n\ndf : the AbstractDataFrame to be stacked\nmeasure_vars : the columns to be stacked (the measurement variables), as a column selector (Symbol, string or integer; :, Cols, All, Between, Not, a regular expression, or a vector of Symbols, strings or integers). If neither measure_vars or id_vars are given, measure_vars defaults to all floating point columns.\nid_vars : the identifier columns that are repeated during stacking, as a column selector (Symbol, string or integer; :, Cols, All, Between, Not, a regular expression, or a vector of Symbols, strings or integers). Defaults to all variables that are not measure_vars\nvariable_name : the name (Symbol or string) of the new stacked column that shall hold the names of each of measure_vars\nvalue_name : the name (Symbol or string) of the new stacked column containing the values from each of measure_vars\nview : whether the stacked data frame should be a view rather than contain freshly allocated vectors.\nvariable_eltype : determines the element type of column variable_name. By default a PooledArray{String} is created. If variable_eltype=Symbol a PooledVector{Symbol} is created, and if variable_eltype=CategoricalValue{String} a CategoricalArray{String} is produced (call using CategoricalArrays first if needed) Passing any other type T will produce a PooledVector{T} column as long as it supports conversion from String. When view=true, a RepeatedVector{T} is produced.\n\nExamples\n\njulia> df = DataFrame(a = repeat(1:3, inner = 2),\n                             b = repeat(1:2, inner = 3),\n                             c = repeat(1:1, inner = 6),\n                             d = repeat(1:6, inner = 1),\n                             e = string.('a':'f'))\n6×5 DataFrame\n Row │ a      b      c      d      e\n     │ Int64  Int64  Int64  Int64  String\n─────┼────────────────────────────────────\n   1 │     1      1      1      1  a\n   2 │     1      1      1      2  b\n   3 │     2      1      1      3  c\n   4 │     2      2      1      4  d\n   5 │     3      2      1      5  e\n   6 │     3      2      1      6  f\n\njulia> stack(df, [:c, :d])\n12×5 DataFrame\n Row │ a      b      e       variable  value\n     │ Int64  Int64  String  String    Int64\n─────┼───────────────────────────────────────\n   1 │     1      1  a       c             1\n   2 │     1      1  b       c             1\n   3 │     2      1  c       c             1\n   4 │     2      2  d       c             1\n   5 │     3      2  e       c             1\n   6 │     3      2  f       c             1\n   7 │     1      1  a       d             1\n   8 │     1      1  b       d             2\n   9 │     2      1  c       d             3\n  10 │     2      2  d       d             4\n  11 │     3      2  e       d             5\n  12 │     3      2  f       d             6\n\njulia> stack(df, [:c, :d], [:a])\n12×3 DataFrame\n Row │ a      variable  value\n     │ Int64  String    Int64\n─────┼────────────────────────\n   1 │     1  c             1\n   2 │     1  c             1\n   3 │     2  c             1\n   4 │     2  c             1\n   5 │     3  c             1\n   6 │     3  c             1\n   7 │     1  d             1\n   8 │     1  d             2\n   9 │     2  d             3\n  10 │     2  d             4\n  11 │     3  d             5\n  12 │     3  d             6\n\njulia> stack(df, Not([:a, :b, :e]))\n12×5 DataFrame\n Row │ a      b      e       variable  value\n     │ Int64  Int64  String  String    Int64\n─────┼───────────────────────────────────────\n   1 │     1      1  a       c             1\n   2 │     1      1  b       c             1\n   3 │     2      1  c       c             1\n   4 │     2      2  d       c             1\n   5 │     3      2  e       c             1\n   6 │     3      2  f       c             1\n   7 │     1      1  a       d             1\n   8 │     1      1  b       d             2\n   9 │     2      1  c       d             3\n  10 │     2      2  d       d             4\n  11 │     3      2  e       d             5\n  12 │     3      2  f       d             6\n\njulia> stack(df, Not([:a, :b, :e]), variable_name=:somemeasure)\n12×5 DataFrame\n Row │ a      b      e       somemeasure  value\n     │ Int64  Int64  String  String       Int64\n─────┼──────────────────────────────────────────\n   1 │     1      1  a       c                1\n   2 │     1      1  b       c                1\n   3 │     2      1  c       c                1\n   4 │     2      2  d       c                1\n   5 │     3      2  e       c                1\n   6 │     3      2  f       c                1\n   7 │     1      1  a       d                1\n   8 │     1      1  b       d                2\n   9 │     2      1  c       d                3\n  10 │     2      2  d       d                4\n  11 │     3      2  e       d                5\n  12 │     3      2  f       d                6\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#DataFrames.unstack","page":"Functions","title":"DataFrames.unstack","text":"unstack(df::AbstractDataFrame, rowkeys, colkey, value; renamecols::Function=identity,\n        allowmissing::Bool=false, allowduplicates::Bool=false)\nunstack(df::AbstractDataFrame, colkey, value; renamecols::Function=identity,\n        allowmissing::Bool=false, allowduplicates::Bool=false)\nunstack(df::AbstractDataFrame; renamecols::Function=identity,\n        allowmissing::Bool=false, allowduplicates::Bool=false)\n\nUnstack data frame df, i.e. convert it from long to wide format.\n\nRow and column keys will be ordered in the order of their first appearance.\n\nPositional arguments\n\ndf : the AbstractDataFrame to be unstacked\nrowkeys : the columns with a unique key for each row, if not given, find a key by grouping on anything not a colkey or value. Can be any column selector (Symbol, string or integer; :, Cols, All, Between, Not, a regular expression, or a vector of Symbols, strings or integers).\ncolkey : the column (Symbol, string or integer) holding the column names in wide format, defaults to :variable\nvalue : the value column (Symbol, string or integer), defaults to :value\n\nKeyword arguments\n\nrenamecols: a function called on each unique value in colkey; it must return the name of the column to be created (typically as a string or a Symbol). Duplicates in resulting names when converted to Symbol are not allowed. By default no transformation is performed.\nallowmissing: if false (the default) then an error will be thrown if colkey contains missing values; if true then a column referring to missing value will be created.\nallowduplicates: if false (the default) then an error an error will be thrown if combination of rowkeys and colkey contains duplicate entries; if true then  then the last encountered value will be retained.\n\nExamples\n\njulia> wide = DataFrame(id = 1:6,\n                                a  = repeat(1:3, inner = 2),\n                                b  = repeat(1.0:2.0, inner = 3),\n                                c  = repeat(1.0:1.0, inner = 6),\n                                d  = repeat(1.0:3.0, inner = 2))\n6×5 DataFrame\n Row │ id     a      b        c        d\n     │ Int64  Int64  Float64  Float64  Float64\n─────┼─────────────────────────────────────────\n   1 │     1      1      1.0      1.0      1.0\n   2 │     2      1      1.0      1.0      1.0\n   3 │     3      2      1.0      1.0      2.0\n   4 │     4      2      2.0      1.0      2.0\n   5 │     5      3      2.0      1.0      3.0\n   6 │     6      3      2.0      1.0      3.0\n\njulia> long = stack(wide)\n18×4 DataFrame\n Row │ id     a      variable  value\n     │ Int64  Int64  String    Float64\n─────┼─────────────────────────────────\n   1 │     1      1  b             1.0\n   2 │     2      1  b             1.0\n   3 │     3      2  b             1.0\n   4 │     4      2  b             2.0\n   5 │     5      3  b             2.0\n   6 │     6      3  b             2.0\n   7 │     1      1  c             1.0\n   8 │     2      1  c             1.0\n  ⋮  │   ⋮      ⋮       ⋮         ⋮\n  12 │     6      3  c             1.0\n  13 │     1      1  d             1.0\n  14 │     2      1  d             1.0\n  15 │     3      2  d             2.0\n  16 │     4      2  d             2.0\n  17 │     5      3  d             3.0\n  18 │     6      3  d             3.0\n                         3 rows omitted\n\njulia> unstack(long)\n6×5 DataFrame\n Row │ id     a      b         c         d\n     │ Int64  Int64  Float64?  Float64?  Float64?\n─────┼────────────────────────────────────────────\n   1 │     1      1       1.0       1.0       1.0\n   2 │     2      1       1.0       1.0       1.0\n   3 │     3      2       1.0       1.0       2.0\n   4 │     4      2       2.0       1.0       2.0\n   5 │     5      3       2.0       1.0       3.0\n   6 │     6      3       2.0       1.0       3.0\n\njulia> unstack(long, :variable, :value)\n6×5 DataFrame\n Row │ id     a      b         c         d\n     │ Int64  Int64  Float64?  Float64?  Float64?\n─────┼────────────────────────────────────────────\n   1 │     1      1       1.0       1.0       1.0\n   2 │     2      1       1.0       1.0       1.0\n   3 │     3      2       1.0       1.0       2.0\n   4 │     4      2       2.0       1.0       2.0\n   5 │     5      3       2.0       1.0       3.0\n   6 │     6      3       2.0       1.0       3.0\n\njulia> unstack(long, :id, :variable, :value)\n6×4 DataFrame\n Row │ id     b         c         d\n     │ Int64  Float64?  Float64?  Float64?\n─────┼─────────────────────────────────────\n   1 │     1       1.0       1.0       1.0\n   2 │     2       1.0       1.0       1.0\n   3 │     3       1.0       1.0       2.0\n   4 │     4       2.0       1.0       2.0\n   5 │     5       2.0       1.0       3.0\n   6 │     6       2.0       1.0       3.0\n\njulia> unstack(long, [:id, :a], :variable, :value)\n6×5 DataFrame\n Row │ id     a      b         c         d\n     │ Int64  Int64  Float64?  Float64?  Float64?\n─────┼────────────────────────────────────────────\n   1 │     1      1       1.0       1.0       1.0\n   2 │     2      1       1.0       1.0       1.0\n   3 │     3      2       1.0       1.0       2.0\n   4 │     4      2       2.0       1.0       2.0\n   5 │     5      3       2.0       1.0       3.0\n   6 │     6      3       2.0       1.0       3.0\n\njulia> unstack(long, :id, :variable, :value, renamecols=x->Symbol(:_, x))\n6×4 DataFrame\n Row │ id     _b        _c        _d\n     │ Int64  Float64?  Float64?  Float64?\n─────┼─────────────────────────────────────\n   1 │     1       1.0       1.0       1.0\n   2 │     2       1.0       1.0       1.0\n   3 │     3       1.0       1.0       2.0\n   4 │     4       2.0       1.0       2.0\n   5 │     5       2.0       1.0       3.0\n   6 │     6       2.0       1.0       3.0\n\nNote that there are some differences between the widened results above.\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Base.permutedims","page":"Functions","title":"Base.permutedims","text":"permutedims(df::AbstractDataFrame, src_namescol::Union{Int, Symbol, AbstractString},\n            [dest_namescol::Union{Symbol, AbstractString}];\n            makeunique::Bool=false)\n\nTurn df on its side such that rows become columns and values in the column indexed by src_namescol become the names of new columns. In the resulting DataFrame, column names of df will become the first column with name specified by dest_namescol.\n\nArguments\n\ndf : the AbstractDataFrame\nsrc_namescol : the column that will become the new header. This column's element type must be AbstractString or Symbol.\ndest_namescol : the name of the first column in the returned DataFrame. Defaults to the same name as src_namescol.\nmakeunique : if false (the default), an error will be raised if duplicate names are found; if true, duplicate names will be suffixed with _i (i starting at 1 for the first duplicate).\n\nNote: The element types of columns in resulting DataFrame (other than the first column, which always has element type String) will depend on the element types of all input columns based on the result of promote_type. That is, if the source data frame contains Int and Float64 columns, resulting columns will have element type Float64. If the source has Int and String columns, resulting columns will have element type Any.\n\nExamples\n\njulia> df1 = DataFrame(a=[\"x\", \"y\"], b=[1.0, 2.0], c=[3, 4], d=[true, false])\n2×4 DataFrame\n Row │ a       b        c      d\n     │ String  Float64  Int64  Bool\n─────┼───────────────────────────────\n   1 │ x           1.0      3   true\n   2 │ y           2.0      4  false\n\njulia> permutedims(df1, 1) # note the column types\n3×3 DataFrame\n Row │ a       x        y\n     │ String  Float64  Float64\n─────┼──────────────────────────\n   1 │ b           1.0      2.0\n   2 │ c           3.0      4.0\n   3 │ d           1.0      0.0\n\njulia> df2 = DataFrame(a=[\"x\", \"y\"], b=[1, \"two\"], c=[3, 4], d=[true, false])\n2×4 DataFrame\n Row │ a       b    c      d\n     │ String  Any  Int64  Bool\n─────┼───────────────────────────\n   1 │ x       1        3   true\n   2 │ y       two      4  false\n\njulia> permutedims(df2, 1, \"different_name\")\n3×3 DataFrame\n Row │ different_name  x     y\n     │ String          Any   Any\n─────┼─────────────────────────────\n   1 │ b               1     two\n   2 │ c               3     4\n   3 │ d               true  false\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Sorting","page":"Functions","title":"Sorting","text":"","category":"section"},{"location":"lib/functions/","page":"Functions","title":"Functions","text":"issorted\norder\nsort\nsort!\nsortperm","category":"page"},{"location":"lib/functions/#Base.issorted","page":"Functions","title":"Base.issorted","text":"issorted(df::AbstractDataFrame, cols;\n         lt=isless, by=identity, rev::Bool=false, order::Ordering=Forward)\n\nTest whether data frame df sorted by column(s) cols.\n\ncols can be any column selector (Symbol, string or integer; :, Cols, All, Between, Not, a regular expression, or a vector of Symbols, strings or integers).\n\nIf rev is true, reverse sorting is performed. To enable reverse sorting only for some columns, pass order(c, rev=true) in cols, with c the corresponding column index (see example below). See other methods for a description of other keyword arguments.\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#DataFrames.order","page":"Functions","title":"DataFrames.order","text":"order(col::ColumnIndex; kwargs...)\n\nSpecify sorting order for a column col in a data frame. kwargs can be lt, by, rev, and order with values following the rules defined in sort!.\n\nSee also: sort!, sort\n\nExamples\n\njulia> df = DataFrame(x = [-3, -1, 0, 2, 4], y = 1:5)\n5×2 DataFrame\n Row │ x      y\n     │ Int64  Int64\n─────┼──────────────\n   1 │    -3      1\n   2 │    -1      2\n   3 │     0      3\n   4 │     2      4\n   5 │     4      5\n\njulia> sort(df, order(:x, rev=true))\n5×2 DataFrame\n Row │ x      y\n     │ Int64  Int64\n─────┼──────────────\n   1 │     4      5\n   2 │     2      4\n   3 │     0      3\n   4 │    -1      2\n   5 │    -3      1\n\njulia> sort(df, order(:x, by=abs))\n5×2 DataFrame\n Row │ x      y\n     │ Int64  Int64\n─────┼──────────────\n   1 │     0      3\n   2 │    -1      2\n   3 │     2      4\n   4 │    -3      1\n   5 │     4      5\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Base.sort","page":"Functions","title":"Base.sort","text":"sort(df::AbstractDataFrame, cols;\n     alg::Union{Algorithm, Nothing}=nothing, lt=isless, by=identity,\n     rev::Bool=false, order::Ordering=Forward, view::Bool=false)\n\nReturn a data frame containing the rows in df sorted by column(s) cols.\n\ncols can be any column selector (Symbol, string or integer; :, Cols, All, Between, Not, a regular expression, or a vector of Symbols, strings or integers).\n\nIf alg is nothing (the default), the most appropriate algorithm is chosen automatically among TimSort, MergeSort and RadixSort depending on the type of the sorting columns and on the number of rows in df. If rev is true, reverse sorting is performed. To enable reverse sorting only for some columns, pass order(c, rev=true) in cols, with c the corresponding column index (see example below).\n\nIf view=false a freshly allocated DataFrame is returned. If view=true then a SubDataFrame view into df is returned.\n\nSee sort! for a description of other keyword arguments.\n\nExamples\n\njulia> df = DataFrame(x = [3, 1, 2, 1], y = [\"b\", \"c\", \"a\", \"b\"])\n4×2 DataFrame\n Row │ x      y\n     │ Int64  String\n─────┼───────────────\n   1 │     3  b\n   2 │     1  c\n   3 │     2  a\n   4 │     1  b\n\njulia> sort(df, :x)\n4×2 DataFrame\n Row │ x      y\n     │ Int64  String\n─────┼───────────────\n   1 │     1  c\n   2 │     1  b\n   3 │     2  a\n   4 │     3  b\n\njulia> sort(df, [:x, :y])\n4×2 DataFrame\n Row │ x      y\n     │ Int64  String\n─────┼───────────────\n   1 │     1  b\n   2 │     1  c\n   3 │     2  a\n   4 │     3  b\n\njulia> sort(df, [:x, :y], rev=true)\n4×2 DataFrame\n Row │ x      y\n     │ Int64  String\n─────┼───────────────\n   1 │     3  b\n   2 │     2  a\n   3 │     1  c\n   4 │     1  b\n\njulia> sort(df, [:x, order(:y, rev=true)])\n4×2 DataFrame\n Row │ x      y\n     │ Int64  String\n─────┼───────────────\n   1 │     1  c\n   2 │     1  b\n   3 │     2  a\n   4 │     3  b\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Base.sort!","page":"Functions","title":"Base.sort!","text":"sort!(df::AbstractDataFrame, cols;\n      alg::Union{Algorithm, Nothing}=nothing, lt=isless, by=identity,\n      rev::Bool=false, order::Ordering=Forward)\n\nSort data frame df by column(s) cols.\n\ncols can be any column selector (Symbol, string or integer; :, Cols, All, Between, Not, a regular expression, or a vector of Symbols, strings or integers).\n\nIf alg is nothing (the default), the most appropriate algorithm is chosen automatically among TimSort, MergeSort and RadixSort depending on the type of the sorting columns and on the number of rows in df. If rev is true, reverse sorting is performed. To enable reverse sorting only for some columns, pass order(c, rev=true) in cols, with c the corresponding column index (see example below). See other methods for a description of other keyword arguments.\n\nExamples\n\njulia> df = DataFrame(x = [3, 1, 2, 1], y = [\"b\", \"c\", \"a\", \"b\"])\n4×2 DataFrame\n Row │ x      y\n     │ Int64  String\n─────┼───────────────\n   1 │     3  b\n   2 │     1  c\n   3 │     2  a\n   4 │     1  b\n\njulia> sort!(df, :x)\n4×2 DataFrame\n Row │ x      y\n     │ Int64  String\n─────┼───────────────\n   1 │     1  c\n   2 │     1  b\n   3 │     2  a\n   4 │     3  b\n\njulia> sort!(df, [:x, :y])\n4×2 DataFrame\n Row │ x      y\n     │ Int64  String\n─────┼───────────────\n   1 │     1  b\n   2 │     1  c\n   3 │     2  a\n   4 │     3  b\n\njulia> sort!(df, [:x, :y], rev=true)\n4×2 DataFrame\n Row │ x      y\n     │ Int64  String\n─────┼───────────────\n   1 │     3  b\n   2 │     2  a\n   3 │     1  c\n   4 │     1  b\n\njulia> sort!(df, [:x, order(:y, rev=true)])\n4×2 DataFrame\n Row │ x      y\n     │ Int64  String\n─────┼───────────────\n   1 │     1  c\n   2 │     1  b\n   3 │     2  a\n   4 │     3  b\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Base.sortperm","page":"Functions","title":"Base.sortperm","text":"sortperm(df::AbstractDataFrame, cols;\n         alg::Union{Algorithm, Nothing}=nothing, lt=isless, by=identity,\n         rev::Bool=false, order::Ordering=Forward)\n\nReturn a permutation vector of row indices of data frame df that puts them in sorted order according to column(s) cols.\n\ncols can be any column selector (Symbol, string or integer; :, Cols, All, Between, Not, a regular expression, or a vector of Symbols, strings or integers).\n\nIf alg is nothing (the default), the most appropriate algorithm is chosen automatically among TimSort, MergeSort and RadixSort depending on the type of the sorting columns and on the number of rows in df. If rev is true, reverse sorting is performed. To enable reverse sorting only for some columns, pass order(c, rev=true) in cols, with c the corresponding column index (see example below). See other methods for a description of other keyword arguments.\n\nExamples\n\njulia> df = DataFrame(x = [3, 1, 2, 1], y = [\"b\", \"c\", \"a\", \"b\"])\n4×2 DataFrame\n Row │ x      y\n     │ Int64  String\n─────┼───────────────\n   1 │     3  b\n   2 │     1  c\n   3 │     2  a\n   4 │     1  b\n\njulia> sortperm(df, :x)\n4-element Vector{Int64}:\n 2\n 4\n 3\n 1\n\njulia> sortperm(df, [:x, :y])\n4-element Vector{Int64}:\n 4\n 2\n 3\n 1\n\njulia> sortperm(df, [:x, :y], rev=true)\n4-element Vector{Int64}:\n 1\n 3\n 2\n 4\n\njulia> sortperm(df, [:x, order(:y, rev=true)])\n4-element Vector{Int64}:\n 2\n 4\n 3\n 1\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Joining","page":"Functions","title":"Joining","text":"","category":"section"},{"location":"lib/functions/","page":"Functions","title":"Functions","text":"antijoin\ncrossjoin\ninnerjoin\nleftjoin\nouterjoin\nrightjoin\nsemijoin","category":"page"},{"location":"lib/functions/#DataAPI.antijoin","page":"Functions","title":"DataAPI.antijoin","text":"antijoin(df1, df2; on, makeunique=false, validate=(false, false), matchmissing=:error)\n\nPerform an anti join of two data frame objects and return a DataFrame containing the result. An anti join returns the subset of rows of df1 that do not match with the keys in df2.\n\nThe order of rows in the result is undefined and may change in the future releases.\n\nArguments\n\ndf1, df2: the AbstractDataFrames to be joined\n\nKeyword Arguments\n\non : A column name to join df1 and df2 on. If the columns on which df1 and df2 will be joined have different names, then a left=>right pair can be passed. It is also allowed to perform a join on multiple columns, in which case a vector of column names or column name pairs can be passed (mixing names and pairs is allowed).\nmakeunique : if false (the default), an error will be raised if duplicate names are found in columns not joined on; if true, duplicate names will be suffixed with _i (i starting at 1 for the first duplicate).\nvalidate : whether to check that columns passed as the on argument  define unique keys in each input data frame (according to isequal).  Can be a tuple or a pair, with the first element indicating whether to  run check for df1 and the second element for df2.  By default no check is performed.\nmatchmissing : if equal to :error throw an error if missing is present in on columns; if equal to :equal then missing is allowed and missings are matched; if equal to :notequal then missings are dropped in df2 on columns; isequal is used for comparisons of rows for equality\n\nIt is not allowed to join on columns that contain NaN or -0.0 in real or imaginary part of the number. If you need to perform a join on such values use CategoricalArrays.jl and transform a column containing such values into a CategoricalVector.\n\nWhen merging on categorical columns that differ in the ordering of their levels, the ordering of the left data frame takes precedence over the ordering of the right data frame.\n\nSee also: innerjoin, leftjoin, rightjoin,           outerjoin, semijoin, crossjoin.\n\nExamples\n\njulia> name = DataFrame(ID = [1, 2, 3], Name = [\"John Doe\", \"Jane Doe\", \"Joe Blogs\"])\n3×2 DataFrame\n Row │ ID     Name\n     │ Int64  String\n─────┼──────────────────\n   1 │     1  John Doe\n   2 │     2  Jane Doe\n   3 │     3  Joe Blogs\n\njulia> job = DataFrame(ID = [1, 2, 4], Job = [\"Lawyer\", \"Doctor\", \"Farmer\"])\n3×2 DataFrame\n Row │ ID     Job\n     │ Int64  String\n─────┼───────────────\n   1 │     1  Lawyer\n   2 │     2  Doctor\n   3 │     4  Farmer\n\njulia> antijoin(name, job, on = :ID)\n1×2 DataFrame\n Row │ ID     Name\n     │ Int64  String\n─────┼──────────────────\n   1 │     3  Joe Blogs\n\njulia> job2 = DataFrame(identifier = [1, 2, 4], Job = [\"Lawyer\", \"Doctor\", \"Farmer\"])\n3×2 DataFrame\n Row │ identifier  Job\n     │ Int64       String\n─────┼────────────────────\n   1 │          1  Lawyer\n   2 │          2  Doctor\n   3 │          4  Farmer\n\njulia> antijoin(name, job2, on = :ID => :identifier)\n1×2 DataFrame\n Row │ ID     Name\n     │ Int64  String\n─────┼──────────────────\n   1 │     3  Joe Blogs\n\njulia> antijoin(name, job2, on = [:ID => :identifier])\n1×2 DataFrame\n Row │ ID     Name\n     │ Int64  String\n─────┼──────────────────\n   1 │     3  Joe Blogs\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#DataAPI.crossjoin","page":"Functions","title":"DataAPI.crossjoin","text":"crossjoin(df1, df2, dfs...; makeunique = false)\n\nPerform a cross join of two or more data frame objects and return a DataFrame containing the result. A cross join returns the cartesian product of rows from all passed data frames, where the first passed data frame is assigned to the dimension that changes the slowest and the last data frame is assigned to the dimension that changes the fastest.\n\nArguments\n\ndf1, df2, dfs... : the AbstractDataFrames to be joined\n\nKeyword Arguments\n\nmakeunique : if false (the default), an error will be raised if duplicate names are found in columns not joined on; if true, duplicate names will be suffixed with _i (i starting at 1 for the first duplicate).\n\nIf more than two data frames are passed, the join is performed recursively with left associativity.\n\nSee also: innerjoin, leftjoin, rightjoin,           outerjoin, semijoin, antijoin.\n\nExamples\n\njulia> df1 = DataFrame(X=1:3)\n3×1 DataFrame\n Row │ X\n     │ Int64\n─────┼───────\n   1 │     1\n   2 │     2\n   3 │     3\n\njulia> df2 = DataFrame(Y=[\"a\", \"b\"])\n2×1 DataFrame\n Row │ Y\n     │ String\n─────┼────────\n   1 │ a\n   2 │ b\n\njulia> crossjoin(df1, df2)\n6×2 DataFrame\n Row │ X      Y\n     │ Int64  String\n─────┼───────────────\n   1 │     1  a\n   2 │     1  b\n   3 │     2  a\n   4 │     2  b\n   5 │     3  a\n   6 │     3  b\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#DataAPI.innerjoin","page":"Functions","title":"DataAPI.innerjoin","text":"innerjoin(df1, df2; on, makeunique=false, validate=(false, false),\n          renamecols=(identity => identity), matchmissing=:error)\ninnerjoin(df1, df2, dfs...; on, makeunique=false,\n          validate=(false, false), matchmissing=:error)\n\nPerform an inner join of two or more data frame objects and return a DataFrame containing the result. An inner join includes rows with keys that match in all passed data frames.\n\nThe order of rows in the result is undefined and may change in the future releases.\n\nIn the returned data frame the type of the columns on which the data frames are joined is determined by the type of these columns in df1. This behavior may change in future releases.\n\nArguments\n\ndf1, df2, dfs...: the AbstractDataFrames to be joined\n\nKeyword Arguments\n\non : A column name to join df1 and df2 on. If the columns on which df1 and df2 will be joined have different names, then a left=>right pair can be passed. It is also allowed to perform a join on multiple columns, in which case a vector of column names or column name pairs can be passed (mixing names and pairs is allowed). If more than two data frames are joined then only a column name or a vector of column names are allowed. on is a required argument.\nmakeunique : if false (the default), an error will be raised if duplicate names are found in columns not joined on; if true, duplicate names will be suffixed with _i (i starting at 1 for the first duplicate).\nvalidate : whether to check that columns passed as the on argument define unique keys in each input data frame (according to isequal). Can be a tuple or a pair, with the first element indicating whether to run check for df1 and the second element for df2. By default no check is performed.\nrenamecols : a Pair specifying how columns of left and right data frames should be renamed in the resulting data frame. Each element of the pair can be a string or a Symbol can be passed in which case it is appended to the original column name; alternatively a function can be passed in which case it is applied to each column name, which is passed to it as a String. Note that renamecols does not affect on columns, whose names are always taken from the left data frame and left unchanged.\nmatchmissing : if equal to :error throw an error if missing is present in on columns; if equal to :equal then missing is allowed and missings are matched; if equal to :notequal then missings are dropped in df1 and df2 on columns; isequal is used for comparisons of rows for equality\n\nIt is not allowed to join on columns that contain NaN or -0.0 in real or imaginary part of the number. If you need to perform a join on such values use CategoricalArrays.jl and transform a column containing such values into a CategoricalVector.\n\nWhen merging on categorical columns that differ in the ordering of their levels, the ordering of the left data frame takes precedence over the ordering of the right data frame.\n\nIf more than two data frames are passed, the join is performed recursively with left associativity. In this case the validate keyword argument is applied recursively with left associativity.\n\nSee also: leftjoin, rightjoin, outerjoin,           semijoin, antijoin, crossjoin.\n\nExamples\n\njulia> name = DataFrame(ID = [1, 2, 3], Name = [\"John Doe\", \"Jane Doe\", \"Joe Blogs\"])\n3×2 DataFrame\n Row │ ID     Name\n     │ Int64  String\n─────┼──────────────────\n   1 │     1  John Doe\n   2 │     2  Jane Doe\n   3 │     3  Joe Blogs\n\njulia> job = DataFrame(ID = [1, 2, 4], Job = [\"Lawyer\", \"Doctor\", \"Farmer\"])\n3×2 DataFrame\n Row │ ID     Job\n     │ Int64  String\n─────┼───────────────\n   1 │     1  Lawyer\n   2 │     2  Doctor\n   3 │     4  Farmer\n\njulia> innerjoin(name, job, on = :ID)\n2×3 DataFrame\n Row │ ID     Name      Job\n     │ Int64  String    String\n─────┼─────────────────────────\n   1 │     1  John Doe  Lawyer\n   2 │     2  Jane Doe  Doctor\n\njulia> job2 = DataFrame(identifier = [1, 2, 4], Job = [\"Lawyer\", \"Doctor\", \"Farmer\"])\n3×2 DataFrame\n Row │ identifier  Job\n     │ Int64       String\n─────┼────────────────────\n   1 │          1  Lawyer\n   2 │          2  Doctor\n   3 │          4  Farmer\n\njulia> innerjoin(name, job2, on = :ID => :identifier, renamecols = \"_left\" => \"_right\")\n2×3 DataFrame\n Row │ ID     Name_left  Job_right\n     │ Int64  String     String\n─────┼─────────────────────────────\n   1 │     1  John Doe   Lawyer\n   2 │     2  Jane Doe   Doctor\n\njulia> innerjoin(name, job2, on = [:ID => :identifier], renamecols = uppercase => lowercase)\n2×3 DataFrame\n Row │ ID     NAME      job\n     │ Int64  String    String\n─────┼─────────────────────────\n   1 │     1  John Doe  Lawyer\n   2 │     2  Jane Doe  Doctor\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#DataAPI.leftjoin","page":"Functions","title":"DataAPI.leftjoin","text":"leftjoin(df1, df2; on, makeunique=false, source=nothing, validate=(false, false),\n         renamecols=(identity => identity), matchmissing=:error)\n\nPerform a left join of two data frame objects and return a DataFrame containing the result. A left join includes all rows from df1.\n\nThe order of rows in the result is undefined and may change in the future releases.\n\nIn the returned data frame the type of the columns on which the data frames are joined is determined by the type of these columns in df1. This behavior may change in future releases.\n\nArguments\n\ndf1, df2: the AbstractDataFrames to be joined\n\nKeyword Arguments\n\non : A column name to join df1 and df2 on. If the columns on which df1 and df2 will be joined have different names, then a left=>right pair can be passed. It is also allowed to perform a join on multiple columns, in which case a vector of column names or column name pairs can be passed (mixing names and pairs is allowed).\nmakeunique : if false (the default), an error will be raised if duplicate names are found in columns not joined on; if true, duplicate names will be suffixed with _i (i starting at 1 for the first duplicate).\nsource : Default: nothing. If a Symbol or string, adds indicator column with the given name, for whether a row appeared in only df1 (\"left_only\"), only df2 (\"right_only\") or in both (\"both\"). If the name is already in use, the column name will be modified if makeunique=true.\nvalidate : whether to check that columns passed as the on argument define unique keys in each input data frame (according to isequal). Can be a tuple or a pair, with the first element indicating whether to run check for df1 and the second element for df2. By default no check is performed.\nrenamecols : a Pair specifying how columns of left and right data frames should be renamed in the resulting data frame. Each element of the pair can be a string or a Symbol can be passed in which case it is appended to the original column name; alternatively a function can be passed in which case it is applied to each column name, which is passed to it as a String. Note that renamecols does not affect on columns, whose names are always taken from the left data frame and left unchanged.\nmatchmissing : if equal to :error throw an error if missing is present in on columns; if equal to :equal then missing is allowed and missings are matched; if equal to :notequal then missings are dropped in df2 on columns; isequal is used for comparisons of rows for equality\n\nAll columns of the returned data table will support missing values.\n\nIt is not allowed to join on columns that contain NaN or -0.0 in real or imaginary part of the number. If you need to perform a join on such values use CategoricalArrays.jl and transform a column containing such values into a CategoricalVector.\n\nWhen merging on categorical columns that differ in the ordering of their levels, the ordering of the left data frame takes precedence over the ordering of the right data frame.\n\nSee also: innerjoin, rightjoin, outerjoin,           semijoin, antijoin, crossjoin.\n\nExamples\n\njulia> name = DataFrame(ID = [1, 2, 3], Name = [\"John Doe\", \"Jane Doe\", \"Joe Blogs\"])\n3×2 DataFrame\n Row │ ID     Name\n     │ Int64  String\n─────┼──────────────────\n   1 │     1  John Doe\n   2 │     2  Jane Doe\n   3 │     3  Joe Blogs\n\njulia> job = DataFrame(ID = [1, 2, 4], Job = [\"Lawyer\", \"Doctor\", \"Farmer\"])\n3×2 DataFrame\n Row │ ID     Job\n     │ Int64  String\n─────┼───────────────\n   1 │     1  Lawyer\n   2 │     2  Doctor\n   3 │     4  Farmer\n\njulia> leftjoin(name, job, on = :ID)\n3×3 DataFrame\n Row │ ID     Name       Job\n     │ Int64  String     String?\n─────┼───────────────────────────\n   1 │     1  John Doe   Lawyer\n   2 │     2  Jane Doe   Doctor\n   3 │     3  Joe Blogs  missing\n\njulia> job2 = DataFrame(identifier = [1, 2, 4], Job = [\"Lawyer\", \"Doctor\", \"Farmer\"])\n3×2 DataFrame\n Row │ identifier  Job\n     │ Int64       String\n─────┼────────────────────\n   1 │          1  Lawyer\n   2 │          2  Doctor\n   3 │          4  Farmer\n\njulia> leftjoin(name, job2, on = :ID => :identifier, renamecols = \"_left\" => \"_right\")\n3×3 DataFrame\n Row │ ID     Name_left  Job_right\n     │ Int64  String     String?\n─────┼─────────────────────────────\n   1 │     1  John Doe   Lawyer\n   2 │     2  Jane Doe   Doctor\n   3 │     3  Joe Blogs  missing\n\njulia> leftjoin(name, job2, on = [:ID => :identifier], renamecols = uppercase => lowercase)\n3×3 DataFrame\n Row │ ID     NAME       job\n     │ Int64  String     String?\n─────┼───────────────────────────\n   1 │     1  John Doe   Lawyer\n   2 │     2  Jane Doe   Doctor\n   3 │     3  Joe Blogs  missing\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#DataAPI.outerjoin","page":"Functions","title":"DataAPI.outerjoin","text":"outerjoin(df1, df2; on, makeunique=false, source=nothing, validate=(false, false),\n          renamecols=(identity => identity), matchmissing=:error)\nouterjoin(df1, df2, dfs...; on, makeunique = false,\n          validate = (false, false), matchmissing=:error)\n\nPerform an outer join of two or more data frame objects and return a DataFrame containing the result. An outer join includes rows with keys that appear in any of the passed data frames.\n\nThe order of rows in the result is undefined and may change in the future releases.\n\nIn the returned data frame the type of the columns on which the data frames are joined is determined by the element type of these columns both df1 and df2. This behavior may change in future releases.\n\nArguments\n\ndf1, df2, dfs... : the AbstractDataFrames to be joined\n\nKeyword Arguments\n\non : A column name to join df1 and df2 on. If the columns on which df1 and df2 will be joined have different names, then a left=>right pair can be passed. It is also allowed to perform a join on multiple columns, in which case a vector of column names or column name pairs can be passed (mixing names and pairs is allowed). If more than two data frames are joined then only a column name or a vector of column names are allowed. on is a required argument.\nmakeunique : if false (the default), an error will be raised if duplicate names are found in columns not joined on; if true, duplicate names will be suffixed with _i (i starting at 1 for the first duplicate).\nsource : Default: nothing. If a Symbol or string, adds indicator column with the given name for whether a row appeared in only df1 (\"left_only\"), only df2 (\"right_only\") or in both (\"both\"). If the name is already in use, the column name will be modified if makeunique=true. This argument is only supported when joining exactly two data frames.\nvalidate : whether to check that columns passed as the on argument define unique keys in each input data frame (according to isequal). Can be a tuple or a pair, with the first element indicating whether to run check for df1 and the second element for df2. By default no check is performed.\nrenamecols : a Pair specifying how columns of left and right data frames should be renamed in the resulting data frame. Each element of the pair can be a string or a Symbol can be passed in which case it is appended to the original column name; alternatively a function can be passed in which case it is applied to each column name, which is passed to it as a String. Note that renamecols does not affect on columns, whose names are always taken from the left data frame and left unchanged.\nmatchmissing : if equal to :error throw an error if missing is present in on columns; if equal to :equal then missing is allowed and missings are matched; isequal is used for comparisons of rows for equality\n\nAll columns of the returned data table will support missing values.\n\nIt is not allowed to join on columns that contain NaN or -0.0 in real or imaginary part of the number. If you need to perform a join on such values use CategoricalArrays.jl and transform a column containing such values into a CategoricalVector.\n\nWhen merging on categorical columns that differ in the ordering of their levels, the ordering of the left data frame takes precedence over the ordering of the right data frame.\n\nIf more than two data frames are passed, the join is performed recursively with left associativity. In this case the indicator keyword argument is not supported and validate keyword argument is applied recursively with left associativity.\n\nSee also: innerjoin, leftjoin, rightjoin,           semijoin, antijoin, crossjoin.\n\nExamples\n\njulia> name = DataFrame(ID = [1, 2, 3], Name = [\"John Doe\", \"Jane Doe\", \"Joe Blogs\"])\n3×2 DataFrame\n Row │ ID     Name\n     │ Int64  String\n─────┼──────────────────\n   1 │     1  John Doe\n   2 │     2  Jane Doe\n   3 │     3  Joe Blogs\n\njulia> job = DataFrame(ID = [1, 2, 4], Job = [\"Lawyer\", \"Doctor\", \"Farmer\"])\n3×2 DataFrame\n Row │ ID     Job\n     │ Int64  String\n─────┼───────────────\n   1 │     1  Lawyer\n   2 │     2  Doctor\n   3 │     4  Farmer\n\njulia> outerjoin(name, job, on = :ID)\n4×3 DataFrame\n Row │ ID     Name       Job\n     │ Int64  String?    String?\n─────┼───────────────────────────\n   1 │     1  John Doe   Lawyer\n   2 │     2  Jane Doe   Doctor\n   3 │     3  Joe Blogs  missing\n   4 │     4  missing    Farmer\n\njulia> job2 = DataFrame(identifier = [1, 2, 4], Job = [\"Lawyer\", \"Doctor\", \"Farmer\"])\n3×2 DataFrame\n Row │ identifier  Job\n     │ Int64       String\n─────┼────────────────────\n   1 │          1  Lawyer\n   2 │          2  Doctor\n   3 │          4  Farmer\n\njulia> rightjoin(name, job2, on = :ID => :identifier, renamecols = \"_left\" => \"_right\")\n3×3 DataFrame\n Row │ ID     Name_left  Job_right\n     │ Int64  String?    String\n─────┼─────────────────────────────\n   1 │     1  John Doe   Lawyer\n   2 │     2  Jane Doe   Doctor\n   3 │     4  missing    Farmer\n\njulia> rightjoin(name, job2, on = [:ID => :identifier], renamecols = uppercase => lowercase)\n3×3 DataFrame\n Row │ ID     NAME      job\n     │ Int64  String?   String\n─────┼─────────────────────────\n   1 │     1  John Doe  Lawyer\n   2 │     2  Jane Doe  Doctor\n   3 │     4  missing   Farmer\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#DataAPI.rightjoin","page":"Functions","title":"DataAPI.rightjoin","text":"rightjoin(df1, df2; on, makeunique=false, source=nothing,\n          validate=(false, false), renamecols=(identity => identity),\n          matchmissing=:error)\n\nPerform a right join on two data frame objects and return a DataFrame containing the result. A right join includes all rows from df2.\n\nThe order of rows in the result is undefined and may change in the future releases.\n\nIn the returned data frame the type of the columns on which the data frames are joined is determined by the type of these columns in df2. This behavior may change in future releases.\n\nArguments\n\ndf1, df2: the AbstractDataFrames to be joined\n\nKeyword Arguments\n\non : A column name to join df1 and df2 on. If the columns on which df1 and df2 will be joined have different names, then a left=>right pair can be passed. It is also allowed to perform a join on multiple columns, in which case a vector of column names or column name pairs can be passed (mixing names and pairs is allowed).\nmakeunique : if false (the default), an error will be raised if duplicate names are found in columns not joined on; if true, duplicate names will be suffixed with _i (i starting at 1 for the first duplicate).\nsource : Default: nothing. If a Symbol or string, adds indicator column with the given name for whether a row appeared in only df1 (\"left_only\"), only df2 (\"right_only\") or in both (\"both\"). If the name is already in use, the column name will be modified if makeunique=true.\nvalidate : whether to check that columns passed as the on argument define unique keys in each input data frame (according to isequal). Can be a tuple or a pair, with the first element indicating whether to run check for df1 and the second element for df2. By default no check is performed.\nrenamecols : a Pair specifying how columns of left and right data frames should be renamed in the resulting data frame. Each element of the pair can be a string or a Symbol can be passed in which case it is appended to the original column name; alternatively a function can be passed in which case it is applied to each column name, which is passed to it as a String. Note that renamecols does not affect on columns, whose names are always taken from the left data frame and left unchanged.\nmatchmissing : if equal to :error throw an error if missing is present in on columns; if equal to :equal then missing is allowed and missings are matched; if equal to :notequal then missings are dropped in df1 on columns; isequal is used for comparisons of rows for equality\n\nAll columns of the returned data table will support missing values.\n\nIt is not allowed to join on columns that contain NaN or -0.0 in real or imaginary part of the number. If you need to perform a join on such values use CategoricalArrays.jl and transform a column containing such values into a CategoricalVector.\n\nWhen merging on categorical columns that differ in the ordering of their levels, the ordering of the left data frame takes precedence over the ordering of the right data frame.\n\nSee also: innerjoin, leftjoin, outerjoin,           semijoin, antijoin, crossjoin.\n\nExamples\n\njulia> name = DataFrame(ID = [1, 2, 3], Name = [\"John Doe\", \"Jane Doe\", \"Joe Blogs\"])\n3×2 DataFrame\n Row │ ID     Name\n     │ Int64  String\n─────┼──────────────────\n   1 │     1  John Doe\n   2 │     2  Jane Doe\n   3 │     3  Joe Blogs\n\njulia> job = DataFrame(ID = [1, 2, 4], Job = [\"Lawyer\", \"Doctor\", \"Farmer\"])\n3×2 DataFrame\n Row │ ID     Job\n     │ Int64  String\n─────┼───────────────\n   1 │     1  Lawyer\n   2 │     2  Doctor\n   3 │     4  Farmer\n\njulia> rightjoin(name, job, on = :ID)\n3×3 DataFrame\n Row │ ID     Name      Job\n     │ Int64  String?   String\n─────┼─────────────────────────\n   1 │     1  John Doe  Lawyer\n   2 │     2  Jane Doe  Doctor\n   3 │     4  missing   Farmer\n\njulia> job2 = DataFrame(identifier = [1, 2, 4], Job = [\"Lawyer\", \"Doctor\", \"Farmer\"])\n3×2 DataFrame\n Row │ identifier  Job\n     │ Int64       String\n─────┼────────────────────\n   1 │          1  Lawyer\n   2 │          2  Doctor\n   3 │          4  Farmer\n\njulia> rightjoin(name, job2, on = :ID => :identifier, renamecols = \"_left\" => \"_right\")\n3×3 DataFrame\n Row │ ID     Name_left  Job_right\n     │ Int64  String?    String\n─────┼─────────────────────────────\n   1 │     1  John Doe   Lawyer\n   2 │     2  Jane Doe   Doctor\n   3 │     4  missing    Farmer\n\njulia> rightjoin(name, job2, on = [:ID => :identifier], renamecols = uppercase => lowercase)\n3×3 DataFrame\n Row │ ID     NAME      job\n     │ Int64  String?   String\n─────┼─────────────────────────\n   1 │     1  John Doe  Lawyer\n   2 │     2  Jane Doe  Doctor\n   3 │     4  missing   Farmer\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#DataAPI.semijoin","page":"Functions","title":"DataAPI.semijoin","text":"semijoin(df1, df2; on, makeunique=false, validate=(false, false), matchmissing=:error)\n\nPerform a semi join of two data frame objects and return a DataFrame containing the result. A semi join returns the subset of rows of df1 that match with the keys in df2.\n\nThe order of rows in the result is undefined and may change in the future releases.\n\nArguments\n\ndf1, df2: the AbstractDataFrames to be joined\n\nKeyword Arguments\n\non : A column name to join df1 and df2 on. If the columns on which df1 and df2 will be joined have different names, then a left=>right pair can be passed. It is also allowed to perform a join on multiple columns, in which case a vector of column names or column name pairs can be passed (mixing names and pairs is allowed).\nmakeunique : if false (the default), an error will be raised if duplicate names are found in columns not joined on; if true, duplicate names will be suffixed with _i (i starting at 1 for the first duplicate).\nindicator : Default: nothing. If a Symbol or string, adds categorical indicator  column with the given name for whether a row appeared in only df1 (\"left_only\"),  only df2 (\"right_only\") or in both (\"both\"). If the name is already in use,  the column name will be modified if makeunique=true.\nvalidate : whether to check that columns passed as the on argument  define unique keys in each input data frame (according to isequal).  Can be a tuple or a pair, with the first element indicating whether to  run check for df1 and the second element for df2.  By default no check is performed.\nmatchmissing : if equal to :error throw an error if missing is present in on columns; if equal to :equal then missing is allowed and missings are matched; if equal to :notequal then missings are dropped in df2 on columns; isequal is used for comparisons of rows for equality\n\nIt is not allowed to join on columns that contain NaN or -0.0 in real or imaginary part of the number. If you need to perform a join on such values use CategoricalArrays.jl and transform a column containing such values into a CategoricalVector.\n\nWhen merging on categorical columns that differ in the ordering of their levels, the ordering of the left data frame takes precedence over the ordering of the right data frame.\n\nSee also: innerjoin, leftjoin, rightjoin,           outerjoin, antijoin, crossjoin.\n\nExamples\n\njulia> name = DataFrame(ID = [1, 2, 3], Name = [\"John Doe\", \"Jane Doe\", \"Joe Blogs\"])\n3×2 DataFrame\n Row │ ID     Name\n     │ Int64  String\n─────┼──────────────────\n   1 │     1  John Doe\n   2 │     2  Jane Doe\n   3 │     3  Joe Blogs\n\njulia> job = DataFrame(ID = [1, 2, 4], Job = [\"Lawyer\", \"Doctor\", \"Farmer\"])\n3×2 DataFrame\n Row │ ID     Job\n     │ Int64  String\n─────┼───────────────\n   1 │     1  Lawyer\n   2 │     2  Doctor\n   3 │     4  Farmer\n\njulia> semijoin(name, job, on = :ID)\n2×2 DataFrame\n Row │ ID     Name\n     │ Int64  String\n─────┼─────────────────\n   1 │     1  John Doe\n   2 │     2  Jane Doe\n\njulia> job2 = DataFrame(identifier = [1, 2, 4], Job = [\"Lawyer\", \"Doctor\", \"Farmer\"])\n3×2 DataFrame\n Row │ identifier  Job\n     │ Int64       String\n─────┼────────────────────\n   1 │          1  Lawyer\n   2 │          2  Doctor\n   3 │          4  Farmer\n\njulia> semijoin(name, job2, on = :ID => :identifier)\n2×2 DataFrame\n Row │ ID     Name\n     │ Int64  String\n─────┼─────────────────\n   1 │     1  John Doe\n   2 │     2  Jane Doe\n\njulia> semijoin(name, job2, on = [:ID => :identifier])\n2×2 DataFrame\n Row │ ID     Name\n     │ Int64  String\n─────┼─────────────────\n   1 │     1  John Doe\n   2 │     2  Jane Doe\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Grouping","page":"Functions","title":"Grouping","text":"","category":"section"},{"location":"lib/functions/","page":"Functions","title":"Functions","text":"get\ngroupby\ngroupcols\ngroupindices\nkeys\nparent\nvaluecols","category":"page"},{"location":"lib/functions/#Base.get","page":"Functions","title":"Base.get","text":"get(gd::GroupedDataFrame, key, default)\n\nGet a group based on the values of the grouping columns.\n\nkey may be a GroupKey, NamedTuple or Tuple of grouping column values (in the same order as the cols argument to groupby). It may also be an AbstractDict, in which case the order of the arguments does not matter.\n\nExamples\n\njulia> df = DataFrame(a = repeat([:foo, :bar, :baz], outer=[2]),\n                      b = repeat([2, 1], outer=[3]),\n                      c = 1:6);\n\njulia> gd = groupby(df, :a)\nGroupedDataFrame with 3 groups based on key: a\nFirst Group (2 rows): a = :foo\n Row │ a       b      c\n     │ Symbol  Int64  Int64\n─────┼──────────────────────\n   1 │ foo         2      1\n   2 │ foo         1      4\n⋮\nLast Group (2 rows): a = :baz\n Row │ a       b      c\n     │ Symbol  Int64  Int64\n─────┼──────────────────────\n   1 │ baz         2      3\n   2 │ baz         1      6\n\njulia> get(gd, (a=:bar,), nothing)\n2×3 SubDataFrame\n Row │ a       b      c\n     │ Symbol  Int64  Int64\n─────┼──────────────────────\n   1 │ bar         1      2\n   2 │ bar         2      5\n\njulia> get(gd, (:baz,), nothing)\n2×3 SubDataFrame\n Row │ a       b      c\n     │ Symbol  Int64  Int64\n─────┼──────────────────────\n   1 │ baz         2      3\n   2 │ baz         1      6\n\njulia> get(gd, (:qux,), nothing)\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#DataFrames.groupby","page":"Functions","title":"DataFrames.groupby","text":"groupby(d::AbstractDataFrame, cols;\n        sort::Union{Bool, Nothing}=nothing,\n        skipmissing::Bool=false)\n\nReturn a GroupedDataFrame representing a view of an AbstractDataFrame split into row groups.\n\nArguments\n\ndf : an AbstractDataFrame to split\ncols : data frame columns to group by. Can be any column selector (Symbol, string or integer; :, Cols, All, Between, Not, a regular expression, or a vector of Symbols, strings or integers).\nsort : if sort=true sort groups according to the values of the grouping columns cols; if sort=false groups are created in order of their appereance in df if sort=nothing (the default) then the fastest available grouping algorithm is picked and in consequence the order of groups in the result is undefined and may change in future releases; below a description of the current implementation is provided.\nskipmissing : whether to skip groups with missing values in one of the grouping columns cols\n\nDetails\n\nAn iterator over a GroupedDataFrame returns a SubDataFrame view for each grouping into df. Within each group, the order of rows in df is preserved.\n\ncols can be any valid data frame indexing expression. In particular if it is an empty vector then a single-group GroupedDataFrame is created.\n\nA GroupedDataFrame also supports indexing by groups, select, transform, and combine (which applies a function to each group and combines the result into a data frame).\n\nGroupedDataFrame also supports the dictionary interface. The keys are GroupKey objects returned by keys(::GroupedDataFrame), which can also be used to get the values of the grouping columns for each group. Tuples and NamedTuples containing the values of the grouping columns (in the same order as the cols argument) are also accepted as indices. Finally, an AbstractDict can be used to index into a grouped data frame where the keys are column names of the data frame. The order of the keys does not matter in this case.\n\nIn the current implementation if sort=nothing groups are ordered following the order of appearance of values in the grouping columns, except when all grouping columns provide non-nothing DataAPI.refpool, in which case the order of groups follows the order of values returned by DataAPI.refpool. As a particular application of this rule if all cols are CategoricalVectors then groups are always sorted. Integer columns with a narrow range also use this this optimization, so to the order of groups when grouping on integer columns is undefined. A column is considered to be an integer column when deciding on the grouping algorithm choice if its eltype is a subtype of Union{Missing, Real}, all its elements are either missing or pass isinteger test, and none of them is equal to -0.0.\n\nSee also\n\ncombine, select, select!, transform, transform!\n\nExamples\n\njulia> df = DataFrame(a = repeat([1, 2, 3, 4], outer=[2]),\n                      b = repeat([2, 1], outer=[4]),\n                      c = 1:8);\n\njulia> gd = groupby(df, :a)\nGroupedDataFrame with 4 groups based on key: a\nFirst Group (2 rows): a = 1\n Row │ a      b      c\n     │ Int64  Int64  Int64\n─────┼─────────────────────\n   1 │     1      2      1\n   2 │     1      2      5\n⋮\nLast Group (2 rows): a = 4\n Row │ a      b      c\n     │ Int64  Int64  Int64\n─────┼─────────────────────\n   1 │     4      1      4\n   2 │     4      1      8\n\njulia> gd[1]\n2×3 SubDataFrame\n Row │ a      b      c\n     │ Int64  Int64  Int64\n─────┼─────────────────────\n   1 │     1      2      1\n   2 │     1      2      5\n\njulia> last(gd)\n2×3 SubDataFrame\n Row │ a      b      c\n     │ Int64  Int64  Int64\n─────┼─────────────────────\n   1 │     4      1      4\n   2 │     4      1      8\n\njulia> gd[(a=3,)]\n2×3 SubDataFrame\n Row │ a      b      c\n     │ Int64  Int64  Int64\n─────┼─────────────────────\n   1 │     3      2      3\n   2 │     3      2      7\n\njulia> gd[Dict(\"a\" => 3)]\n2×3 SubDataFrame\n Row │ a      b      c\n     │ Int64  Int64  Int64\n─────┼─────────────────────\n   1 │     3      2      3\n   2 │     3      2      7\n\njulia> gd[(3,)]\n2×3 SubDataFrame\n Row │ a      b      c\n     │ Int64  Int64  Int64\n─────┼─────────────────────\n   1 │     3      2      3\n   2 │     3      2      7\n\njulia> k = first(keys(gd))\nGroupKey: (a = 1,)\n\njulia> gd[k]\n2×3 SubDataFrame\n Row │ a      b      c\n     │ Int64  Int64  Int64\n─────┼─────────────────────\n   1 │     1      2      1\n   2 │     1      2      5\n\njulia> for g in gd\n           println(g)\n       end\n2×3 SubDataFrame\n Row │ a      b      c\n     │ Int64  Int64  Int64\n─────┼─────────────────────\n   1 │     1      2      1\n   2 │     1      2      5\n2×3 SubDataFrame\n Row │ a      b      c\n     │ Int64  Int64  Int64\n─────┼─────────────────────\n   1 │     2      1      2\n   2 │     2      1      6\n2×3 SubDataFrame\n Row │ a      b      c\n     │ Int64  Int64  Int64\n─────┼─────────────────────\n   1 │     3      2      3\n   2 │     3      2      7\n2×3 SubDataFrame\n Row │ a      b      c\n     │ Int64  Int64  Int64\n─────┼─────────────────────\n   1 │     4      1      4\n   2 │     4      1      8\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#DataFrames.groupcols","page":"Functions","title":"DataFrames.groupcols","text":"groupcols(gd::GroupedDataFrame)\n\nReturn a vector of Symbol column names in parent(gd) used for grouping.\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#DataFrames.groupindices","page":"Functions","title":"DataFrames.groupindices","text":"groupindices(gd::GroupedDataFrame)\n\nReturn a vector of group indices for each row of parent(gd).\n\nRows appearing in group gd[i] are attributed index i. Rows not present in any group are attributed missing (this can happen if skipmissing=true was passed when creating gd, or if gd is a subset from a larger GroupedDataFrame).\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Base.keys","page":"Functions","title":"Base.keys","text":"keys(gd::GroupedDataFrame)\n\nGet the set of keys for each group of the GroupedDataFrame gd as a GroupKeys object. Each key is a GroupKey, which behaves like a NamedTuple holding the values of the grouping columns for a given group. Unlike the equivalent Tuple, NamedTuple, and AbstractDict, these keys can be used to index into gd efficiently. The ordering of the keys is identical to the ordering of the groups of gd under iteration and integer indexing.\n\nExamples\n\njulia> df = DataFrame(a = repeat([:foo, :bar, :baz], outer=[4]),\n                      b = repeat([2, 1], outer=[6]),\n                      c = 1:12);\n\njulia> gd = groupby(df, [:a, :b])\nGroupedDataFrame with 6 groups based on keys: a, b\nFirst Group (2 rows): a = :foo, b = 2\n Row │ a       b      c\n     │ Symbol  Int64  Int64\n─────┼──────────────────────\n   1 │ foo         2      1\n   2 │ foo         2      7\n⋮\nLast Group (2 rows): a = :baz, b = 1\n Row │ a       b      c\n     │ Symbol  Int64  Int64\n─────┼──────────────────────\n   1 │ baz         1      6\n   2 │ baz         1     12\n\njulia> keys(gd)\n6-element DataFrames.GroupKeys{GroupedDataFrame{DataFrame}}:\n GroupKey: (a = :foo, b = 2)\n GroupKey: (a = :bar, b = 1)\n GroupKey: (a = :baz, b = 2)\n GroupKey: (a = :foo, b = 1)\n GroupKey: (a = :bar, b = 2)\n GroupKey: (a = :baz, b = 1)\n\njulia> k = keys(gd)[1]\nGroupKey: (a = :foo, b = 2)\n\njulia> keys(k)\n2-element Vector{Symbol}:\n :a\n :b\n\njulia> values(k)  # Same as Tuple(k)\n(:foo, 2)\n\njulia> NamedTuple(k)\n(a = :foo, b = 2)\n\njulia> k.a\n:foo\n\njulia> k[:a]\n:foo\n\njulia> k[1]\n:foo\n\nKeys can be used as indices to retrieve the corresponding group from their GroupedDataFrame:\n\njulia> gd[k]\n2×3 SubDataFrame\n Row │ a       b      c\n     │ Symbol  Int64  Int64\n─────┼──────────────────────\n   1 │ foo         2      1\n   2 │ foo         2      7\n\njulia> gd[keys(gd)[1]] == gd[1]\ntrue\n\n\n\n\n\nkeys(dfc::DataFrameColumns)\n\nGet a vector of column names of dfc as Symbols.\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Base.parent","page":"Functions","title":"Base.parent","text":"parent(gd::GroupedDataFrame)\n\nReturn the parent data frame of gd.\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#DataFrames.valuecols","page":"Functions","title":"DataFrames.valuecols","text":"valuecols(gd::GroupedDataFrame)\n\nReturn a vector of Symbol column names in parent(gd) not used for grouping.\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Filtering-rows","page":"Functions","title":"Filtering rows","text":"","category":"section"},{"location":"lib/functions/","page":"Functions","title":"Functions","text":"delete!\nempty\nempty!\nfilter\nfilter!\nfirst\nlast\nonly\nnonunique\nsubset\nsubset!\nunique\nunique!","category":"page"},{"location":"lib/functions/#Base.delete!","page":"Functions","title":"Base.delete!","text":"delete!(df::DataFrame, inds)\n\nDelete rows specified by inds from a DataFrame df in place and return it.\n\nInternally deleteat! is called for all columns so inds must be: a vector of sorted and unique integers, a boolean vector, an integer, or Not.\n\nExamples\n\njulia> df = DataFrame(a=1:3, b=4:6)\n3×2 DataFrame\n Row │ a      b\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1      4\n   2 │     2      5\n   3 │     3      6\n\njulia> delete!(df, 2)\n2×2 DataFrame\n Row │ a      b\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1      4\n   2 │     3      6\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Base.empty","page":"Functions","title":"Base.empty","text":"empty(df::AbstractDataFrame)\n\nCreate a new DataFrame with the same column names and column element types as df but with zero rows.\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Base.empty!","page":"Functions","title":"Base.empty!","text":"empty!(df::DataFrame)\n\nRemove all rows from df, making each of its columns empty.\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Base.filter","page":"Functions","title":"Base.filter","text":"filter(fun, df::AbstractDataFrame; view::Bool=false)\nfilter(cols => fun, df::AbstractDataFrame; view::Bool=false)\n\nReturn a data frame containing only rows from df for which fun returns true.\n\nIf cols is not specified then the predicate fun is passed DataFrameRows.\n\nIf cols is specified then the predicate fun is passed elements of the corresponding columns as separate positional arguments, unless cols is an AsTable selector, in which case a NamedTuple of these arguments is passed. cols can be any column selector (Symbol, string or integer; :, Cols, All, Between, Not, a regular expression, or a vector of Symbols, strings or integers), and column duplicates are allowed if a vector of Symbols, strings, or integers is passed.\n\nIf view=false a freshly allocated DataFrame is returned. If view=true then a SubDataFrame view into df is returned.\n\nPassing cols leads to a more efficient execution of the operation for large data frames.\n\nSee also: filter!\n\nExamples\n\njulia> df = DataFrame(x = [3, 1, 2, 1], y = [\"b\", \"c\", \"a\", \"b\"])\n4×2 DataFrame\n Row │ x      y\n     │ Int64  String\n─────┼───────────────\n   1 │     3  b\n   2 │     1  c\n   3 │     2  a\n   4 │     1  b\n\njulia> filter(row -> row.x > 1, df)\n2×2 DataFrame\n Row │ x      y\n     │ Int64  String\n─────┼───────────────\n   1 │     3  b\n   2 │     2  a\n\njulia> filter(:x => x -> x > 1, df)\n2×2 DataFrame\n Row │ x      y\n     │ Int64  String\n─────┼───────────────\n   1 │     3  b\n   2 │     2  a\n\njulia> filter([:x, :y] => (x, y) -> x == 1 || y == \"b\", df)\n3×2 DataFrame\n Row │ x      y\n     │ Int64  String\n─────┼───────────────\n   1 │     3  b\n   2 │     1  c\n   3 │     1  b\n\njulia> filter(AsTable(:) => nt -> nt.x == 1 || nt.y == \"b\", df)\n3×2 DataFrame\n Row │ x      y\n     │ Int64  String\n─────┼───────────────\n   1 │     3  b\n   2 │     1  c\n   3 │     1  b\n\n\n\n\n\nfilter(fun, gdf::GroupedDataFrame)\nfilter(cols => fun, gdf::GroupedDataFrame)\n\nReturn a new GroupedDataFrame containing only groups for which fun returns true.\n\nIf cols is not specified then the predicate fun is called with a SubDataFrame for each group.\n\nIf cols is specified then the predicate fun is called for each group with views of the corresponding columns as separate positional arguments, unless cols is an AsTable selector, in which case a NamedTuple of these arguments is passed. cols can be any column selector (Symbol, string or integer; :, Cols, All, Between, Not, a regular expression, or a vector of Symbols, strings or integers), and column duplicates are allowed if a vector of Symbols, strings, or integers is passed.\n\nExamples\n\njulia> df = DataFrame(g=[1, 2], x=['a', 'b']);\n\njulia> gd = groupby(df, :g)\nGroupedDataFrame with 2 groups based on key: g\nFirst Group (1 row): g = 1\n Row │ g      x\n     │ Int64  Char\n─────┼─────────────\n   1 │     1  a\n⋮\nLast Group (1 row): g = 2\n Row │ g      x\n     │ Int64  Char\n─────┼─────────────\n   1 │     2  b\n\njulia> filter(x -> x.x[1] == 'a', gd)\nGroupedDataFrame with 1 group based on key: g\nFirst Group (1 row): g = 1\n Row │ g      x\n     │ Int64  Char\n─────┼─────────────\n   1 │     1  a\n\njulia> filter(:x => x -> x[1] == 'a', gd)\nGroupedDataFrame with 1 group based on key: g\nFirst Group (1 row): g = 1\n Row │ g      x\n     │ Int64  Char\n─────┼─────────────\n   1 │     1  a\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Base.filter!","page":"Functions","title":"Base.filter!","text":"filter!(fun, df::AbstractDataFrame)\nfilter!(cols => fun, df::AbstractDataFrame)\n\nRemove rows from data frame df for which fun returns false.\n\nIf cols is not specified then the predicate fun is passed DataFrameRows.\n\nIf cols is specified then the predicate fun is passed elements of the corresponding columns as separate positional arguments, unless cols is an AsTable selector, in which case a NamedTuple of these arguments is passed. cols can be any column selector (Symbol, string or integer; :, Cols, All, Between, Not, a regular expression, or a vector of Symbols, strings or integers), and column duplicates are allowed if a vector of Symbols, strings, or integers is passed.\n\nPassing cols leads to a more efficient execution of the operation for large data frames.\n\nSee also: filter\n\nExamples\n\njulia> df = DataFrame(x = [3, 1, 2, 1], y = [\"b\", \"c\", \"a\", \"b\"])\n4×2 DataFrame\n Row │ x      y\n     │ Int64  String\n─────┼───────────────\n   1 │     3  b\n   2 │     1  c\n   3 │     2  a\n   4 │     1  b\n\njulia> filter!(row -> row.x > 1, df)\n2×2 DataFrame\n Row │ x      y\n     │ Int64  String\n─────┼───────────────\n   1 │     3  b\n   2 │     2  a\n\njulia> filter!(:x => x -> x == 3, df)\n1×2 DataFrame\n Row │ x      y\n     │ Int64  String\n─────┼───────────────\n   1 │     3  b\n\njulia> df = DataFrame(x = [3, 1, 2, 1], y = [\"b\", \"c\", \"a\", \"b\"]);\n\njulia> filter!([:x, :y] => (x, y) -> x == 1 || y == \"b\", df)\n3×2 DataFrame\n Row │ x      y\n     │ Int64  String\n─────┼───────────────\n   1 │     3  b\n   2 │     1  c\n   3 │     1  b\n\njulia> df = DataFrame(x = [3, 1, 2, 1], y = [\"b\", \"c\", \"a\", \"b\"]);\n\njulia> filter!(AsTable(:) => nt -> nt.x == 1 || nt.y == \"b\", df)\n3×2 DataFrame\n Row │ x      y\n     │ Int64  String\n─────┼───────────────\n   1 │     3  b\n   2 │     1  c\n   3 │     1  b\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Base.first","page":"Functions","title":"Base.first","text":"first(df::AbstractDataFrame)\n\nGet the first row of df as a DataFrameRow.\n\n\n\n\n\nfirst(df::AbstractDataFrame, n::Integer)\n\nGet a data frame with the n first rows of df.\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Base.last","page":"Functions","title":"Base.last","text":"last(df::AbstractDataFrame)\n\nGet the last row of df as a DataFrameRow.\n\n\n\n\n\nlast(df::AbstractDataFrame, n::Integer)\n\nGet a data frame with the n last rows of df.\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Base.Iterators.only","page":"Functions","title":"Base.Iterators.only","text":"only(df::AbstractDataFrame)\n\nIf df has a single row return it as a DataFrameRow; otherwise throw ArgumentError.\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#DataFrames.nonunique","page":"Functions","title":"DataFrames.nonunique","text":"nonunique(df::AbstractDataFrame)\nnonunique(df::AbstractDataFrame, cols)\n\nReturn a Vector{Bool} in which true entries indicate duplicate rows. A row is a duplicate if there exists a prior row with all columns containing equal values (according to isequal).\n\nSee also unique and unique!.\n\nArguments\n\ndf : AbstractDataFrame\ncols : a selector specifying the column(s) or their transformations to compare. Can be any column selector or transformation accepted by select.\n\nExamples\n\njulia> df = DataFrame(i = 1:4, x = [1, 2, 1, 2])\n4×2 DataFrame\n Row │ i      x\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1      1\n   2 │     2      2\n   3 │     3      1\n   4 │     4      2\n\njulia> df = vcat(df, df)\n8×2 DataFrame\n Row │ i      x\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1      1\n   2 │     2      2\n   3 │     3      1\n   4 │     4      2\n   5 │     1      1\n   6 │     2      2\n   7 │     3      1\n   8 │     4      2\n\njulia> nonunique(df)\n8-element Vector{Bool}:\n 0\n 0\n 0\n 0\n 1\n 1\n 1\n 1\n\njulia> nonunique(df, 2)\n8-element Vector{Bool}:\n 0\n 0\n 1\n 1\n 1\n 1\n 1\n 1\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#DataFrames.subset","page":"Functions","title":"DataFrames.subset","text":"subset(df::AbstractDataFrame, args...; skipmissing::Bool=false, view::Bool=false)\nsubset(gdf::GroupedDataFrame, args...; skipmissing::Bool=false, view::Bool=false,\n       ungroup::Bool=true)\n\nReturn a copy of data frame df or parent of gdf containing only rows for which all values produced by transformation(s) args for a given row are true. All transformations must produce vectors containing true or false (and optionally missing if skipmissing=true).\n\nEach argument passed in args can be either a single column selector or a source_columns => function transformation specifier following the rules described for select.\n\nNote that as opposed to filter the subset function works on whole columns (and selects rows within groups for GroupedDataFrame rather than whole groups) and must return a vector.\n\nIf skipmissing=false (the default) args are required to produce vectors containing only Bool values. If skipmissing=true, additionally missing is allowed and it is treated as false (i.e. rows for which one of the conditions returns missing are skipped).\n\nIf view=true a SubDataFrame view  is returned instead of a DataFrame.\n\nIf ungroup=false the resulting data frame is re-grouped based on the same grouping columns as gdf and a GroupedDataFrame is returned.\n\nIf a GroupedDataFrame is passed then it must include all groups present in the parent data frame, like in select!.\n\nSee also: subset!, filter, select\n\nExamples\n\njulia> df = DataFrame(id=1:4, x=[true, false, true, false],\n                      y=[true, true, false, false],\n                      z=[true, true, missing, missing], v=[1, 2, 11, 12])\n4×5 DataFrame\n Row │ id     x      y      z        v\n     │ Int64  Bool   Bool   Bool?    Int64\n─────┼─────────────────────────────────────\n   1 │     1   true   true     true      1\n   2 │     2  false   true     true      2\n   3 │     3   true  false  missing     11\n   4 │     4  false  false  missing     12\n\njulia> subset(df, :x)\n2×5 DataFrame\n Row │ id     x     y      z        v\n     │ Int64  Bool  Bool   Bool?    Int64\n─────┼────────────────────────────────────\n   1 │     1  true   true     true      1\n   2 │     3  true  false  missing     11\n\njulia> subset(df, :v => x -> x .> 3)\n2×5 DataFrame\n Row │ id     x      y      z        v\n     │ Int64  Bool   Bool   Bool?    Int64\n─────┼─────────────────────────────────────\n   1 │     3   true  false  missing     11\n   2 │     4  false  false  missing     12\n\njulia> subset(df, :x, :y => ByRow(!))\n1×5 DataFrame\n Row │ id     x     y      z        v\n     │ Int64  Bool  Bool   Bool?    Int64\n─────┼────────────────────────────────────\n   1 │     3  true  false  missing     11\n\njulia> subset(df, :x, :z, skipmissing=true)\n1×5 DataFrame\n Row │ id     x     y     z      v\n     │ Int64  Bool  Bool  Bool?  Int64\n─────┼─────────────────────────────────\n   1 │     1  true  true   true      1\n\njulia> subset(df, :x, :z)\nERROR: ArgumentError: missing was returned in condition number 2 but only true or false are allowed; pass skipmissing=true to skip missing values\n\njulia> subset(groupby(df, :y), :v => x -> x .> minimum(x))\n2×5 DataFrame\n Row │ id     x      y      z        v\n     │ Int64  Bool   Bool   Bool?    Int64\n─────┼─────────────────────────────────────\n   1 │     2  false   true     true      2\n   2 │     4  false  false  missing     12\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#DataFrames.subset!","page":"Functions","title":"DataFrames.subset!","text":"subset!(df::AbstractDataFrame, args...; skipmissing::Bool=false)\nsubset!(gdf::GroupedDataFrame{DataFrame}, args..., skipmissing::Bool=false,\n        ungroup::Bool=true)\n\nUpdate data frame df or the parent of gdf in place to contain only rows for which all values produced by transformation(s) args for a given row is true. All transformations must produce vectors containing true or false (and optionally missing if skipmissing=true).\n\nEach argument passed in args can be either a single column selector or a source_columns => function transformation specifier following the rules described for select.\n\nNote that as opposed to filter! the subset! function works on whole columns (and selects rows within groups for GroupedDataFrame rather than whole groups) and must return a vector.\n\nIf skipmissing=false (the default) args are required to produce vectors containing only Bool values. If skipmissing=true, additionally missing is allowed and it is treated as false (i.e. rows for which one of the conditions returns missing are skipped).\n\nIf ungroup=false the resulting data frame is re-grouped based on the same grouping columns as gdf and a GroupedDataFrame is returned.\n\nIf GroupedDataFrame is subsetted then it must include all groups present in the parent data frame, like in select!. In this case the passed GroupedDataFrame is updated to have correct groups after its parent is updated.\n\nSee also: subset, filter!, select!\n\nExamples\n\njulia> df = DataFrame(id=1:4, x=[true, false, true, false], y=[true, true, false, false])\n4×3 DataFrame\n Row │ id     x      y\n     │ Int64  Bool   Bool\n─────┼─────────────────────\n   1 │     1   true   true\n   2 │     2  false   true\n   3 │     3   true  false\n   4 │     4  false  false\n\njulia> subset!(df, :x, :y => ByRow(!));\n\njulia> df\n1×3 DataFrame\n Row │ id     x     y\n     │ Int64  Bool  Bool\n─────┼────────────────────\n   1 │     3  true  false\n\njulia> df = DataFrame(id=1:4, y=[true, true, false, false], v=[1, 2, 11, 12]);\n\njulia> subset!(groupby(df, :y), :v => x -> x .> minimum(x));\n\njulia> df\n2×3 DataFrame\n Row │ id     y      v\n     │ Int64  Bool   Int64\n─────┼─────────────────────\n   1 │     2   true      2\n   2 │     4  false     12\n\njulia> df = DataFrame(id=1:4, x=[true, false, true, false],\n                      z=[true, true, missing, missing], v=1:4)\n4×4 DataFrame\n Row │ id     x      z        v\n     │ Int64  Bool   Bool?    Int64\n─────┼──────────────────────────────\n   1 │     1   true     true      1\n   2 │     2  false     true      2\n   3 │     3   true  missing      3\n   4 │     4  false  missing      4\n\njulia> subset!(df, :x, :z)\nERROR: ArgumentError: missing was returned in condition number 2 but only true or false are allowed; pass skipmissing=true to skip missing values\n\njulia> subset!(df, :x, :z, skipmissing=true);\n\njulia> df\n1×4 DataFrame\n Row │ id     x     z      v\n     │ Int64  Bool  Bool?  Int64\n─────┼───────────────────────────\n   1 │     1  true   true      1\n\njulia> df = DataFrame(id=1:4, x=[true, false, true, false], y=[true, true, false, false],\n                      z=[true, true, missing, missing], v=[1, 2, 11, 12]);\n\njulia> subset!(groupby(df, :y), :v => x -> x .> minimum(x));\n\njulia> df\n2×5 DataFrame\n Row │ id     x      y      z        v\n     │ Int64  Bool   Bool   Bool?    Int64\n─────┼─────────────────────────────────────\n   1 │     2  false   true     true      2\n   2 │     4  false  false  missing     12\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Base.unique","page":"Functions","title":"Base.unique","text":"unique(df::AbstractDataFrame; view::Bool=false)\nunique(df::AbstractDataFrame, cols; view::Bool=false)\nunique!(df::AbstractDataFrame)\nunique!(df::AbstractDataFrame, cols)\n\nReturn a data frame containing only the first occurrence of unique rows in df. When cols is specified, the returned DataFrame contains complete rows, retaining in each case the first occurrence of a given combination of values in selected columns or their transformations. cols can be any column selector or transformation accepted by select.\n\nFor unique, if view=false a freshly allocated DataFrame is returned, and if view=true then a SubDataFrame view into df is returned.\n\nunique! updates df in-place and does not support the view keyword argument.\n\nSee also nonunique.\n\nArguments\n\ndf : the AbstractDataFrame\ncols :  column indicator (Symbol, Int, Vector{Symbol}, Regex, etc.)\n\nspecifying the column(s) to compare.\n\nExamples\n\njulia> df = DataFrame(i = 1:4, x = [1, 2, 1, 2])\n4×2 DataFrame\n Row │ i      x\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1      1\n   2 │     2      2\n   3 │     3      1\n   4 │     4      2\n\njulia> df = vcat(df, df)\n8×2 DataFrame\n Row │ i      x\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1      1\n   2 │     2      2\n   3 │     3      1\n   4 │     4      2\n   5 │     1      1\n   6 │     2      2\n   7 │     3      1\n   8 │     4      2\n\njulia> unique(df)   # doesn't modify df\n4×2 DataFrame\n Row │ i      x\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1      1\n   2 │     2      2\n   3 │     3      1\n   4 │     4      2\n\njulia> unique(df, 2)\n2×2 DataFrame\n Row │ i      x\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1      1\n   2 │     2      2\n\njulia> unique!(df)  # modifies df\n4×2 DataFrame\n Row │ i      x\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1      1\n   2 │     2      2\n   3 │     3      1\n   4 │     4      2\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Base.unique!","page":"Functions","title":"Base.unique!","text":"unique(df::AbstractDataFrame; view::Bool=false)\nunique(df::AbstractDataFrame, cols; view::Bool=false)\nunique!(df::AbstractDataFrame)\nunique!(df::AbstractDataFrame, cols)\n\nReturn a data frame containing only the first occurrence of unique rows in df. When cols is specified, the returned DataFrame contains complete rows, retaining in each case the first occurrence of a given combination of values in selected columns or their transformations. cols can be any column selector or transformation accepted by select.\n\nFor unique, if view=false a freshly allocated DataFrame is returned, and if view=true then a SubDataFrame view into df is returned.\n\nunique! updates df in-place and does not support the view keyword argument.\n\nSee also nonunique.\n\nArguments\n\ndf : the AbstractDataFrame\ncols :  column indicator (Symbol, Int, Vector{Symbol}, Regex, etc.)\n\nspecifying the column(s) to compare.\n\nExamples\n\njulia> df = DataFrame(i = 1:4, x = [1, 2, 1, 2])\n4×2 DataFrame\n Row │ i      x\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1      1\n   2 │     2      2\n   3 │     3      1\n   4 │     4      2\n\njulia> df = vcat(df, df)\n8×2 DataFrame\n Row │ i      x\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1      1\n   2 │     2      2\n   3 │     3      1\n   4 │     4      2\n   5 │     1      1\n   6 │     2      2\n   7 │     3      1\n   8 │     4      2\n\njulia> unique(df)   # doesn't modify df\n4×2 DataFrame\n Row │ i      x\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1      1\n   2 │     2      2\n   3 │     3      1\n   4 │     4      2\n\njulia> unique(df, 2)\n2×2 DataFrame\n Row │ i      x\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1      1\n   2 │     2      2\n\njulia> unique!(df)  # modifies df\n4×2 DataFrame\n Row │ i      x\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1      1\n   2 │     2      2\n   3 │     3      1\n   4 │     4      2\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Working-with-missing-values","page":"Functions","title":"Working with missing values","text":"","category":"section"},{"location":"lib/functions/","page":"Functions","title":"Functions","text":"allowmissing\nallowmissing!\ncompletecases\ndisallowmissing\ndisallowmissing!\ndropmissing\ndropmissing!","category":"page"},{"location":"lib/functions/#Missings.allowmissing","page":"Functions","title":"Missings.allowmissing","text":"allowmissing(df::AbstractDataFrame, cols=:)\n\nReturn a copy of data frame df with columns cols converted to element type Union{T, Missing} from T to allow support for missing values.\n\ncols can be any column selector (Symbol, string or integer; :, Cols, All, Between, Not, a regular expression, or a vector of Symbols, strings or integers).\n\nIf cols is omitted all columns in the data frame are converted.\n\nExamples\n\njulia> df = DataFrame(a=[1, 2])\n2×1 DataFrame\n Row │ a\n     │ Int64\n─────┼───────\n   1 │     1\n   2 │     2\n\njulia> allowmissing(df)\n2×1 DataFrame\n Row │ a\n     │ Int64?\n─────┼────────\n   1 │      1\n   2 │      2\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#DataFrames.allowmissing!","page":"Functions","title":"DataFrames.allowmissing!","text":"allowmissing!(df::DataFrame, cols=:)\n\nConvert columns cols of data frame df from element type T to Union{T, Missing} to support missing values.\n\ncols can be any column selector (Symbol, string or integer; :, Cols, All, Between, Not, a regular expression, or a vector of Symbols, strings or integers).\n\nIf cols is omitted all columns in the data frame are converted.\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#DataFrames.completecases","page":"Functions","title":"DataFrames.completecases","text":"completecases(df::AbstractDataFrame, cols=:)\n\nReturn a Boolean vector with true entries indicating rows without missing values (complete cases) in data frame df.\n\nIf cols is provided, only missing values in the corresponding columns areconsidered. cols can be any column selector (Symbol, string or integer; :, Cols, All, Between, Not, a regular expression, or a vector of Symbols, strings or integers).\n\nSee also: dropmissing and dropmissing!. Use findall(completecases(df)) to get the indices of the rows.\n\nExamples\n\njulia> df = DataFrame(i = 1:5,\n                            x = [missing, 4, missing, 2, 1],\n                            y = [missing, missing, \"c\", \"d\", \"e\"])\n5×3 DataFrame\n Row │ i      x        y\n     │ Int64  Int64?   String?\n─────┼─────────────────────────\n   1 │     1  missing  missing\n   2 │     2        4  missing\n   3 │     3  missing  c\n   4 │     4        2  d\n   5 │     5        1  e\n\njulia> completecases(df)\n5-element BitVector:\n 0\n 0\n 0\n 1\n 1\n\njulia> completecases(df, :x)\n5-element BitVector:\n 0\n 1\n 0\n 1\n 1\n\njulia> completecases(df, [:x, :y])\n5-element BitVector:\n 0\n 0\n 0\n 1\n 1\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Missings.disallowmissing","page":"Functions","title":"Missings.disallowmissing","text":"disallowmissing(df::AbstractDataFrame, cols=:; error::Bool=true)\n\nReturn a copy of data frame df with columns cols converted from element type Union{T, Missing} to T to drop support for missing values.\n\ncols can be any column selector (Symbol, string or integer; :, Cols, All, Between, Not, a regular expression, or a vector of Symbols, strings or integers).\n\nIf cols is omitted all columns in the data frame are converted.\n\nIf error=false then columns containing a missing value will be skipped instead of throwing an error.\n\nExamples\n\njulia> df = DataFrame(a=Union{Int, Missing}[1, 2])\n2×1 DataFrame\n Row │ a\n     │ Int64?\n─────┼────────\n   1 │      1\n   2 │      2\n\njulia> disallowmissing(df)\n2×1 DataFrame\n Row │ a\n     │ Int64\n─────┼───────\n   1 │     1\n   2 │     2\n\njulia> df = DataFrame(a=[1, missing])\n2×1 DataFrame\n Row │ a\n     │ Int64?\n─────┼─────────\n   1 │       1\n   2 │ missing\n\njulia> disallowmissing(df, error=false)\n2×1 DataFrame\n Row │ a\n     │ Int64?\n─────┼─────────\n   1 │       1\n   2 │ missing\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#DataFrames.disallowmissing!","page":"Functions","title":"DataFrames.disallowmissing!","text":"disallowmissing!(df::DataFrame, cols=:; error::Bool=true)\n\nConvert columns cols of data frame df from element type Union{T, Missing} to T to drop support for missing values.\n\ncols can be any column selector (Symbol, string or integer; :, Cols, All, Between, Not, a regular expression, or a vector of Symbols, strings or integers).\n\nIf cols is omitted all columns in the data frame are converted.\n\nIf error=false then columns containing a missing value will be skipped instead of throwing an error.\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#DataFrames.dropmissing","page":"Functions","title":"DataFrames.dropmissing","text":"dropmissing(df::AbstractDataFrame, cols=:; view::Bool=false, disallowmissing::Bool=!view)\n\nReturn a data frame excluding rows with missing values in df.\n\nIf cols is provided, only missing values in the corresponding columns are considered. cols can be any column selector (Symbol, string or integer; :, Cols, All, Between, Not, a regular expression, or a vector of Symbols, strings or integers).\n\nIf view=false a freshly allocated DataFrame is returned. If view=true then a SubDataFrame view into df is returned. In this case disallowmissing must be false.\n\nIf disallowmissing is true (the default when view is false) then columns specified in cols will be converted so as not to allow for missing values using disallowmissing!.\n\nSee also: completecases and dropmissing!.\n\nExamples\n\njulia> df = DataFrame(i = 1:5,\n                      x = [missing, 4, missing, 2, 1],\n                      y = [missing, missing, \"c\", \"d\", \"e\"])\n5×3 DataFrame\n Row │ i      x        y\n     │ Int64  Int64?   String?\n─────┼─────────────────────────\n   1 │     1  missing  missing\n   2 │     2        4  missing\n   3 │     3  missing  c\n   4 │     4        2  d\n   5 │     5        1  e\n\njulia> dropmissing(df)\n2×3 DataFrame\n Row │ i      x      y\n     │ Int64  Int64  String\n─────┼──────────────────────\n   1 │     4      2  d\n   2 │     5      1  e\n\njulia> dropmissing(df, disallowmissing=false)\n2×3 DataFrame\n Row │ i      x       y\n     │ Int64  Int64?  String?\n─────┼────────────────────────\n   1 │     4       2  d\n   2 │     5       1  e\n\njulia> dropmissing(df, :x)\n3×3 DataFrame\n Row │ i      x      y\n     │ Int64  Int64  String?\n─────┼───────────────────────\n   1 │     2      4  missing\n   2 │     4      2  d\n   3 │     5      1  e\n\njulia> dropmissing(df, [:x, :y])\n2×3 DataFrame\n Row │ i      x      y\n     │ Int64  Int64  String\n─────┼──────────────────────\n   1 │     4      2  d\n   2 │     5      1  e\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#DataFrames.dropmissing!","page":"Functions","title":"DataFrames.dropmissing!","text":"dropmissing!(df::AbstractDataFrame, cols=:; disallowmissing::Bool=true)\n\nRemove rows with missing values from data frame df and return it.\n\nIf cols is provided, only missing values in the corresponding columns are considered. cols can be any column selector (Symbol, string or integer; :, Cols, All, Between, Not, a regular expression, or a vector of Symbols, strings or integers).\n\nIf disallowmissing is true (the default) then the cols columns will get converted using disallowmissing!.\n\nSee also: dropmissing and completecases.\n\njulia> df = DataFrame(i = 1:5,\n                      x = [missing, 4, missing, 2, 1],\n                      y = [missing, missing, \"c\", \"d\", \"e\"])\n5×3 DataFrame\n Row │ i      x        y\n     │ Int64  Int64?   String?\n─────┼─────────────────────────\n   1 │     1  missing  missing\n   2 │     2        4  missing\n   3 │     3  missing  c\n   4 │     4        2  d\n   5 │     5        1  e\n\njulia> dropmissing!(copy(df))\n2×3 DataFrame\n Row │ i      x      y\n     │ Int64  Int64  String\n─────┼──────────────────────\n   1 │     4      2  d\n   2 │     5      1  e\n\njulia> dropmissing!(copy(df), disallowmissing=false)\n2×3 DataFrame\n Row │ i      x       y\n     │ Int64  Int64?  String?\n─────┼────────────────────────\n   1 │     4       2  d\n   2 │     5       1  e\n\njulia> dropmissing!(copy(df), :x)\n3×3 DataFrame\n Row │ i      x      y\n     │ Int64  Int64  String?\n─────┼───────────────────────\n   1 │     2      4  missing\n   2 │     4      2  d\n   3 │     5      1  e\n\njulia> dropmissing!(df, [:x, :y])\n2×3 DataFrame\n Row │ i      x      y\n     │ Int64  Int64  String\n─────┼──────────────────────\n   1 │     4      2  d\n   2 │     5      1  e\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Iteration","page":"Functions","title":"Iteration","text":"","category":"section"},{"location":"lib/functions/","page":"Functions","title":"Functions","text":"eachcol\neachrow\nvalues\npairs","category":"page"},{"location":"lib/functions/#Base.eachcol","page":"Functions","title":"Base.eachcol","text":"eachcol(df::AbstractDataFrame)\n\nReturn a DataFrameColumns object that is a vector-like that allows iterating an AbstractDataFrame column by column.\n\nIndexing into DataFrameColumns objects using integer, Symbol or string returns the corresponding column (without copying). Indexing into DataFrameColumns objects using a multiple column selector returns a subsetted DataFrameColumns object with a new parent containing only the selected columns (without copying).\n\nDataFrameColumns supports most of the AbstractVector API. The key differences are that it is read-only and that the keys function returns a vector of Symbols (and not integers as for normal vectors).\n\nIn particular findnext, findprev, findfirst, findlast, and findall functions are supported, and in findnext and findprev functions it is allowed to pass an integer, string, or Symbol as a reference index.\n\nExamples\n\njulia> df = DataFrame(x=1:4, y=11:14)\n4×2 DataFrame\n Row │ x      y\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1     11\n   2 │     2     12\n   3 │     3     13\n   4 │     4     14\n\njulia> eachcol(df)\n4×2 DataFrameColumns\n Row │ x      y\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1     11\n   2 │     2     12\n   3 │     3     13\n   4 │     4     14\n\njulia> collect(eachcol(df))\n2-element Vector{AbstractVector{T} where T}:\n [1, 2, 3, 4]\n [11, 12, 13, 14]\n\njulia> map(eachcol(df)) do col\n           maximum(col) - minimum(col)\n       end\n2-element Vector{Int64}:\n 3\n 3\n\njulia> sum.(eachcol(df))\n2-element Vector{Int64}:\n 10\n 50\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Base.eachrow","page":"Functions","title":"Base.eachrow","text":"eachrow(df::AbstractDataFrame)\n\nReturn a DataFrameRows that iterates a data frame row by row, with each row represented as a DataFrameRow.\n\nBecause DataFrameRows have an eltype of Any, use copy(dfr::DataFrameRow) to obtain a named tuple, which supports iteration and property access like a DataFrameRow, but also passes information on the eltypes of the columns of df.\n\nExamples\n\njulia> df = DataFrame(x=1:4, y=11:14)\n4×2 DataFrame\n Row │ x      y\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1     11\n   2 │     2     12\n   3 │     3     13\n   4 │     4     14\n\njulia> eachrow(df)\n4×2 DataFrameRows\n Row │ x      y\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1     11\n   2 │     2     12\n   3 │     3     13\n   4 │     4     14\n\njulia> copy.(eachrow(df))\n4-element Vector{NamedTuple{(:x, :y), Tuple{Int64, Int64}}}:\n (x = 1, y = 11)\n (x = 2, y = 12)\n (x = 3, y = 13)\n (x = 4, y = 14)\n\njulia> eachrow(view(df, [4, 3], [2, 1]))\n2×2 DataFrameRows\n Row │ y      x\n     │ Int64  Int64\n─────┼──────────────\n   1 │    14      4\n   2 │    13      3\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Base.values","page":"Functions","title":"Base.values","text":"values(dfc::DataFrameColumns)\n\nGet a vector of columns from dfc.\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Base.pairs","page":"Functions","title":"Base.pairs","text":"pairs(dfc::DataFrameColumns)\n\nReturn an iterator of pairs associating the name of each column of dfc with the corresponding column vector, i.e. name => col where name is the column name of the column col.\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Equality","page":"Functions","title":"Equality","text":"","category":"section"},{"location":"lib/functions/","page":"Functions","title":"Functions","text":"isapprox","category":"page"},{"location":"lib/functions/#Base.isapprox","page":"Functions","title":"Base.isapprox","text":"isapprox(df1::AbstractDataFrame, df2::AbstractDataFrame;\n         rtol::Real=atol>0 ? 0 : √eps, atol::Real=0,\n         nans::Bool=false, norm::Function=norm)\n\nInexact equality comparison. df1 and df2 must have the same size and column names. Return  true if isapprox with given keyword arguments applied to all pairs of columns stored in df1 and df2 returns true.\n\n\n\n\n\n","category":"function"},{"location":"man/split_apply_combine/#The-Split-Apply-Combine-Strategy","page":"Split-apply-combine","title":"The Split-Apply-Combine Strategy","text":"","category":"section"},{"location":"man/split_apply_combine/","page":"Split-apply-combine","title":"Split-apply-combine","text":"Many data analysis tasks involve three steps:","category":"page"},{"location":"man/split_apply_combine/","page":"Split-apply-combine","title":"Split-apply-combine","text":"splitting a data set into groups,\napplying some functions to each of the groups,\ncombining the results.","category":"page"},{"location":"man/split_apply_combine/","page":"Split-apply-combine","title":"Split-apply-combine","text":"Note that any of the steps 1 and 3 of this general procedure can be dropped, in which case we just transform a data frame without grouping it and later combining the result.","category":"page"},{"location":"man/split_apply_combine/","page":"Split-apply-combine","title":"Split-apply-combine","text":"A standardized framework for handling this sort of computation is described in the paper \"The Split-Apply-Combine Strategy for Data Analysis\", written by Hadley Wickham.","category":"page"},{"location":"man/split_apply_combine/","page":"Split-apply-combine","title":"Split-apply-combine","text":"The DataFrames package supports the split-apply-combine strategy through the groupby function that creates a GroupedDataFrame, followed by combine, select/select! or transform/transform!.","category":"page"},{"location":"man/split_apply_combine/","page":"Split-apply-combine","title":"Split-apply-combine","text":"All operations described in this section of the manual are supported both for AbstractDataFrame (when split and combine steps are skipped) and GroupedDataFrame. Technically, AbstractDataFrame is just considered as being grouped on no columns (meaning it has a single group, or zero groups if it is empty). The only difference is that in this case the keepkeys and ungroup keyword arguments (described below) are not supported and a data frame is always returned, as there are no split and combine steps in this case.","category":"page"},{"location":"man/split_apply_combine/","page":"Split-apply-combine","title":"Split-apply-combine","text":"In order to perform operations by groups you first need to create a GroupedDataFrame object from your data frame using the groupby function that takes two arguments: (1) a data frame to be grouped, and (2) a set of columns to group by.","category":"page"},{"location":"man/split_apply_combine/","page":"Split-apply-combine","title":"Split-apply-combine","text":"Operations can then be applied on each group using one of the following functions:","category":"page"},{"location":"man/split_apply_combine/","page":"Split-apply-combine","title":"Split-apply-combine","text":"combine: does not put restrictions on number of rows returned, the order of rows is specified by the order of groups in GroupedDataFrame; it is typically used to compute summary statistics by group;\nselect: return a data frame with the number and order of rows exactly the same as the source data frame, including only new calculated columns; select! is an in-place version of select;\ntransform: return a data frame with the number and order of rows exactly the same as the source data frame, including all columns from the source and new calculated columns; transform! is an in-place version of transform.","category":"page"},{"location":"man/split_apply_combine/","page":"Split-apply-combine","title":"Split-apply-combine","text":"All these functions take a specification of one or more functions to apply to each subset of the DataFrame. This specification can be of the following forms:","category":"page"},{"location":"man/split_apply_combine/","page":"Split-apply-combine","title":"Split-apply-combine","text":"standard column selectors (integers, Symbols, strings, vectors of integers, vectors of Symbols, vectors of strings, All, Cols, :, Between, Not and regular expressions)\na cols => function pair indicating that function should be called with positional arguments holding columns cols, which can be any valid column selector; in this case target column name is automatically generated and it is assumed that function returns a single value or a vector; the generated name is created by concatenating source column name and function name by default (see examples below).\na cols => function => target_cols form additionally explicitly specifying the target column or columns.\na col => target_cols pair, which renames the column col to target_cols, which must be single name (as a Symbol or a string), a vector of names or AsTable.\na nrow or nrow => target_cols form which efficiently computes the number of rows in a group; without target_cols the new column is called :nrow, otherwise it must be single name (as a Symbol or a string).\nvectors or matrices containing transformations specified by the Pair syntax described in points 2 to 5\na function which will be called with a SubDataFrame corresponding to each group; this form should be avoided due to its poor performance unless the number of groups is small or a very large number of columns are processed (in which case SubDataFrame avoids excessive compilation)","category":"page"},{"location":"man/split_apply_combine/","page":"Split-apply-combine","title":"Split-apply-combine","text":"Note! If the expression of the form x => y is passed then except for the special convenience form nrow => target_cols it is always interpreted as cols => function. In particular the following expression function => target_cols is not a valid transformation specification.","category":"page"},{"location":"man/split_apply_combine/","page":"Split-apply-combine","title":"Split-apply-combine","text":"All functions have two types of signatures. One of them takes a GroupedDataFrame as the first argument and an arbitrary number of transformations described above as following arguments. The second type of signature is when a Function or a Type is passed as the first argument and a GroupedDataFrame as the second argument (similar to map).","category":"page"},{"location":"man/split_apply_combine/","page":"Split-apply-combine","title":"Split-apply-combine","text":"As a special rule, with the cols => function and cols => function => target_cols syntaxes, if cols is wrapped in an AsTable object then a NamedTuple containing columns selected by cols is passed to function.","category":"page"},{"location":"man/split_apply_combine/","page":"Split-apply-combine","title":"Split-apply-combine","text":"What is allowed for function to return is determined by the target_cols value:","category":"page"},{"location":"man/split_apply_combine/","page":"Split-apply-combine","title":"Split-apply-combine","text":"If both cols and target_cols are omitted (so only a function is passed), then returning a data frame, a matrix, a NamedTuple, or a DataFrameRow will produce multiple columns in the result. Returning any other value produces a single column.\nIf target_cols is a Symbol or a string then the function is assumed to return a single column. In this case returning a data frame, a matrix, a NamedTuple, or a DataFrameRow raises an error.\nIf target_cols is a vector of Symbols or strings or AsTable it is assumed that function returns multiple columns. If function returns one of AbstractDataFrame, NamedTuple, DataFrameRow, AbstractMatrix then rules described in point 1 above apply. If function returns an AbstractVector then each element of this vector must support the keys function, which must return a collection of Symbols, strings or integers; the return value of keys must be identical for all elements. Then as many columns are created as there are elements in the return value of the keys function. If target_cols is AsTable then their names are set to be equal to the key names except if keys returns integers, in which case they are prefixed by x (so the column names are e.g. x1, x2, ...). If target_cols is a vector of Symbols or strings then column names produced using the rules above are ignored and replaced by target_cols (the number of columns must be the same as the length of target_cols in this case). If fun returns a value of any other type then it is assumed that it is a table conforming to the Tables.jl API and the Tables.columntable function is called on it to get the resulting columns and their names. The names are retained when target_cols is AsTable and are replaced if target_cols is a vector of Symbols or strings.","category":"page"},{"location":"man/split_apply_combine/","page":"Split-apply-combine","title":"Split-apply-combine","text":"In all of these cases, function can return either a single row or multiple rows. As a particular rule, values wrapped in a Ref or a 0-dimensional AbstractArray are unwrapped and then treated as a single row.","category":"page"},{"location":"man/split_apply_combine/","page":"Split-apply-combine","title":"Split-apply-combine","text":"select/select! and transform/transform! always return a DataFrame with the same number and order of rows as the source (even if GroupedDataFrame had its groups reordered).","category":"page"},{"location":"man/split_apply_combine/","page":"Split-apply-combine","title":"Split-apply-combine","text":"For combine, rows in the returned object appear in the order of groups in the GroupedDataFrame. The functions can return an arbitrary number of rows for each group, but the kind of returned object and the number and names of columns must be the same for all groups, except when a DataFrame() or NamedTuple() is returned, in which case a given group is skipped.","category":"page"},{"location":"man/split_apply_combine/","page":"Split-apply-combine","title":"Split-apply-combine","text":"It is allowed to mix single values and vectors if multiple transformations are requested. In this case single value will be repeated to match the length of columns specified by returned vectors.","category":"page"},{"location":"man/split_apply_combine/","page":"Split-apply-combine","title":"Split-apply-combine","text":"A separate task is spawned for each specified transformation; each transformation then spawns as many tasks as Julia threads, and splits processing of groups across them (however, currently transformations with optimized implementations like sum and transformations that return multiple rows use a single task for all groups). This allows for parallel operation when Julia was started with more than one thread. Passed transformation functions should therefore not modify global variables (i.e. they should be pure), or use locks to control parallel accesses.","category":"page"},{"location":"man/split_apply_combine/","page":"Split-apply-combine","title":"Split-apply-combine","text":"To apply function to each row instead of whole columns, it can be wrapped in a ByRow struct. cols can be any column indexing syntax, in which case function will be passed one argument for each of the columns specified by cols or a NamedTuple of them if specified columns are wrapped in AsTable. If ByRow is used it is allowed for cols to select an empty set of columns, in which case function is called for each row without any arguments and an empty NamedTuple is passed if empty set of columns is wrapped in AsTable.","category":"page"},{"location":"man/split_apply_combine/","page":"Split-apply-combine","title":"Split-apply-combine","text":"The following keyword arguments are supported by the transformation functions (not all keyword arguments are supported in all cases; in general they are allowed in situations when they are meaningful, see the documentation of the specific functions for details):","category":"page"},{"location":"man/split_apply_combine/","page":"Split-apply-combine","title":"Split-apply-combine","text":"keepkeys : whether grouping columns should be kept in the returned data frame.\nungroup : whether the return value of the operation should be a data frame or a GroupedDataFrame.\ncopycols : whether columns of the source data frame should be copied if no transformation is applied to them.\nrenamecols : whether in the cols => function form automatically generated column names should include the name of transformation functions or not.","category":"page"},{"location":"man/split_apply_combine/","page":"Split-apply-combine","title":"Split-apply-combine","text":"We show several examples of these functions applied to the iris dataset below:","category":"page"},{"location":"man/split_apply_combine/","page":"Split-apply-combine","title":"Split-apply-combine","text":"julia> using DataFrames, CSV, Statistics\n\njulia> iris = CSV.read((joinpath(dirname(pathof(DataFrames)),\n                                 \"..\", \"docs\", \"src\", \"assets\", \"iris.csv\")),\n                       DataFrame)\n150×5 DataFrame\n Row │ SepalLength  SepalWidth  PetalLength  PetalWidth  Species\n     │ Float64      Float64     Float64      Float64     String\n─────┼──────────────────────────────────────────────────────────────────\n   1 │         5.1         3.5          1.4         0.2  Iris-setosa\n   2 │         4.9         3.0          1.4         0.2  Iris-setosa\n   3 │         4.7         3.2          1.3         0.2  Iris-setosa\n   4 │         4.6         3.1          1.5         0.2  Iris-setosa\n   5 │         5.0         3.6          1.4         0.2  Iris-setosa\n   6 │         5.4         3.9          1.7         0.4  Iris-setosa\n   7 │         4.6         3.4          1.4         0.3  Iris-setosa\n   8 │         5.0         3.4          1.5         0.2  Iris-setosa\n  ⋮  │      ⋮           ⋮            ⋮           ⋮             ⋮\n 144 │         6.8         3.2          5.9         2.3  Iris-virginica\n 145 │         6.7         3.3          5.7         2.5  Iris-virginica\n 146 │         6.7         3.0          5.2         2.3  Iris-virginica\n 147 │         6.3         2.5          5.0         1.9  Iris-virginica\n 148 │         6.5         3.0          5.2         2.0  Iris-virginica\n 149 │         6.2         3.4          5.4         2.3  Iris-virginica\n 150 │         5.9         3.0          5.1         1.8  Iris-virginica\n                                                        135 rows omitted\n\njulia> gdf = groupby(iris, :Species)\nGroupedDataFrame with 3 groups based on key: Species\nFirst Group (50 rows): Species = \"Iris-setosa\"\n Row │ SepalLength  SepalWidth  PetalLength  PetalWidth  Species\n     │ Float64      Float64     Float64      Float64     String\n─────┼───────────────────────────────────────────────────────────────\n   1 │         5.1         3.5          1.4         0.2  Iris-setosa\n   2 │         4.9         3.0          1.4         0.2  Iris-setosa\n   3 │         4.7         3.2          1.3         0.2  Iris-setosa\n   4 │         4.6         3.1          1.5         0.2  Iris-setosa\n   5 │         5.0         3.6          1.4         0.2  Iris-setosa\n   6 │         5.4         3.9          1.7         0.4  Iris-setosa\n   7 │         4.6         3.4          1.4         0.3  Iris-setosa\n   8 │         5.0         3.4          1.5         0.2  Iris-setosa\n  ⋮  │      ⋮           ⋮            ⋮           ⋮            ⋮\n  43 │         4.4         3.2          1.3         0.2  Iris-setosa\n  44 │         5.0         3.5          1.6         0.6  Iris-setosa\n  45 │         5.1         3.8          1.9         0.4  Iris-setosa\n  46 │         4.8         3.0          1.4         0.3  Iris-setosa\n  47 │         5.1         3.8          1.6         0.2  Iris-setosa\n  48 │         4.6         3.2          1.4         0.2  Iris-setosa\n  49 │         5.3         3.7          1.5         0.2  Iris-setosa\n  50 │         5.0         3.3          1.4         0.2  Iris-setosa\n                                                      34 rows omitted\n⋮\nLast Group (50 rows): Species = \"Iris-virginica\"\n Row │ SepalLength  SepalWidth  PetalLength  PetalWidth  Species\n     │ Float64      Float64     Float64      Float64     String\n─────┼──────────────────────────────────────────────────────────────────\n   1 │         6.3         3.3          6.0         2.5  Iris-virginica\n   2 │         5.8         2.7          5.1         1.9  Iris-virginica\n   3 │         7.1         3.0          5.9         2.1  Iris-virginica\n   4 │         6.3         2.9          5.6         1.8  Iris-virginica\n   5 │         6.5         3.0          5.8         2.2  Iris-virginica\n   6 │         7.6         3.0          6.6         2.1  Iris-virginica\n   7 │         4.9         2.5          4.5         1.7  Iris-virginica\n   8 │         7.3         2.9          6.3         1.8  Iris-virginica\n  ⋮  │      ⋮           ⋮            ⋮           ⋮             ⋮\n  43 │         5.8         2.7          5.1         1.9  Iris-virginica\n  44 │         6.8         3.2          5.9         2.3  Iris-virginica\n  45 │         6.7         3.3          5.7         2.5  Iris-virginica\n  46 │         6.7         3.0          5.2         2.3  Iris-virginica\n  47 │         6.3         2.5          5.0         1.9  Iris-virginica\n  48 │         6.5         3.0          5.2         2.0  Iris-virginica\n  49 │         6.2         3.4          5.4         2.3  Iris-virginica\n  50 │         5.9         3.0          5.1         1.8  Iris-virginica\n                                                         34 rows omitted\n\njulia> combine(gdf, :PetalLength => mean)\n3×2 DataFrame\n Row │ Species          PetalLength_mean\n     │ String           Float64\n─────┼───────────────────────────────────\n   1 │ Iris-setosa                 1.464\n   2 │ Iris-versicolor             4.26\n   3 │ Iris-virginica              5.552\n\njulia> combine(gdf, nrow)\n3×2 DataFrame\n Row │ Species          nrow\n     │ String           Int64\n─────┼────────────────────────\n   1 │ Iris-setosa         50\n   2 │ Iris-versicolor     50\n   3 │ Iris-virginica      50\n\njulia> combine(gdf, nrow, :PetalLength => mean => :mean)\n3×3 DataFrame\n Row │ Species          nrow   mean\n     │ String           Int64  Float64\n─────┼─────────────────────────────────\n   1 │ Iris-setosa         50    1.464\n   2 │ Iris-versicolor     50    4.26\n   3 │ Iris-virginica      50    5.552\n\njulia> combine(gdf, [:PetalLength, :SepalLength] => ((p, s) -> (a=mean(p)/mean(s), b=sum(p))) =>\n               AsTable) # multiple columns are passed as arguments\n3×3 DataFrame\n Row │ Species          a         b\n     │ String           Float64   Float64\n─────┼────────────────────────────────────\n   1 │ Iris-setosa      0.292449     73.2\n   2 │ Iris-versicolor  0.717655    213.0\n   3 │ Iris-virginica   0.842744    277.6\n\njulia> combine(gdf,\n               AsTable([:PetalLength, :SepalLength]) =>\n               x -> std(x.PetalLength) / std(x.SepalLength)) # passing a NamedTuple\n3×2 DataFrame\n Row │ Species          PetalLength_SepalLength_function\n     │ String           Float64\n─────┼───────────────────────────────────────────────────\n   1 │ Iris-setosa                              0.492245\n   2 │ Iris-versicolor                          0.910378\n   3 │ Iris-virginica                           0.867923\n\njulia> combine(x -> std(x.PetalLength) / std(x.SepalLength), gdf) # passing a SubDataFrame\n3×2 DataFrame\n Row │ Species          x1\n     │ String           Float64\n─────┼───────────────────────────\n   1 │ Iris-setosa      0.492245\n   2 │ Iris-versicolor  0.910378\n   3 │ Iris-virginica   0.867923\n\njulia> combine(gdf, 1:2 => cor, nrow)\n3×3 DataFrame\n Row │ Species          SepalLength_SepalWidth_cor  nrow\n     │ String           Float64                     Int64\n─────┼────────────────────────────────────────────────────\n   1 │ Iris-setosa                        0.74678      50\n   2 │ Iris-versicolor                    0.525911     50\n   3 │ Iris-virginica                     0.457228     50\n\njulia> combine(gdf, :PetalLength => (x -> [extrema(x)]) => [:min, :max])\n3×3 DataFrame\n Row │ Species          min      max\n     │ String           Float64  Float64\n─────┼───────────────────────────────────\n   1 │ Iris-setosa          1.0      1.9\n   2 │ Iris-versicolor      3.0      5.1\n   3 │ Iris-virginica       4.5      6.9","category":"page"},{"location":"man/split_apply_combine/","page":"Split-apply-combine","title":"Split-apply-combine","text":"Contrary to combine, the select and transform functions always return a data frame with the same number and order of rows as the source. In the example below the return values in columns :SepalLength_SepalWidth_cor and :nrow are broadcasted to match the number of elements in each group:","category":"page"},{"location":"man/split_apply_combine/","page":"Split-apply-combine","title":"Split-apply-combine","text":"julia> select(gdf, 1:2 => cor)\n150×2 DataFrame\n Row │ Species         SepalLength_SepalWidth_cor\n     │ String          Float64\n─────┼────────────────────────────────────────────\n   1 │ Iris-setosa                       0.74678\n   2 │ Iris-setosa                       0.74678\n   3 │ Iris-setosa                       0.74678\n   4 │ Iris-setosa                       0.74678\n  ⋮  │       ⋮                     ⋮\n 148 │ Iris-virginica                    0.457228\n 149 │ Iris-virginica                    0.457228\n 150 │ Iris-virginica                    0.457228\n                                  143 rows omitted\n\njulia> transform(gdf, :Species => x -> chop.(x, head=5, tail=0))\n150×6 DataFrame\n Row │ SepalLength  SepalWidth  PetalLength  PetalWidth  Species         Species_function\n     │ Float64      Float64     Float64      Float64     String          SubString…\n─────┼────────────────────────────────────────────────────────────────────────────────────\n   1 │         5.1         3.5          1.4         0.2  Iris-setosa     setosa\n   2 │         4.9         3.0          1.4         0.2  Iris-setosa     setosa\n   3 │         4.7         3.2          1.3         0.2  Iris-setosa     setosa\n   4 │         4.6         3.1          1.5         0.2  Iris-setosa     setosa\n  ⋮  │      ⋮           ⋮            ⋮           ⋮             ⋮                ⋮\n 148 │         6.5         3.0          5.2         2.0  Iris-virginica  virginica\n 149 │         6.2         3.4          5.4         2.3  Iris-virginica  virginica\n 150 │         5.9         3.0          5.1         1.8  Iris-virginica  virginica\n                                                                          143 rows omitted","category":"page"},{"location":"man/split_apply_combine/","page":"Split-apply-combine","title":"Split-apply-combine","text":"All functions also support the do block form. However, as noted above, this form is slow and should therefore be avoided when performance matters.","category":"page"},{"location":"man/split_apply_combine/","page":"Split-apply-combine","title":"Split-apply-combine","text":"julia> combine(gdf) do df\n           (m = mean(df.PetalLength), s² = var(df.PetalLength))\n       end\n3×3 DataFrame\n Row │ Species          m        s²\n     │ String           Float64  Float64\n─────┼─────────────────────────────────────\n   1 │ Iris-setosa        1.464  0.0301061\n   2 │ Iris-versicolor    4.26   0.220816\n   3 │ Iris-virginica     5.552  0.304588","category":"page"},{"location":"man/split_apply_combine/","page":"Split-apply-combine","title":"Split-apply-combine","text":"If you only want to split the data set into subsets, use the groupby function:","category":"page"},{"location":"man/split_apply_combine/","page":"Split-apply-combine","title":"Split-apply-combine","text":"julia> for subdf in groupby(iris, :Species)\n           println(size(subdf, 1))\n       end\n50\n50\n50","category":"page"},{"location":"man/split_apply_combine/","page":"Split-apply-combine","title":"Split-apply-combine","text":"To also get the values of the grouping columns along with each group, use the pairs function:","category":"page"},{"location":"man/split_apply_combine/","page":"Split-apply-combine","title":"Split-apply-combine","text":"julia> for (key, subdf) in pairs(groupby(iris, :Species))\n           println(\"Number of data points for $(key.Species): $(nrow(subdf))\")\n       end\nNumber of data points for Iris-setosa: 50\nNumber of data points for Iris-versicolor: 50\nNumber of data points for Iris-virginica: 50","category":"page"},{"location":"man/split_apply_combine/","page":"Split-apply-combine","title":"Split-apply-combine","text":"The value of key in the previous example is a DataFrames.GroupKey object, which can be used in a similar fashion to a NamedTuple.","category":"page"},{"location":"man/split_apply_combine/","page":"Split-apply-combine","title":"Split-apply-combine","text":"Grouping a data frame using the groupby function can be seen as adding a lookup key to it. Such lookups can be performed efficiently by indexing the resulting GroupedDataFrame with a Tuple or NamedTuple:","category":"page"},{"location":"man/split_apply_combine/","page":"Split-apply-combine","title":"Split-apply-combine","text":"julia> df = DataFrame(g = repeat(1:1000, inner=5), x = 1:5000)\n5000×2 DataFrame\n  Row │ g      x\n      │ Int64  Int64\n──────┼──────────────\n    1 │     1      1\n    2 │     1      2\n    3 │     1      3\n    4 │     1      4\n    5 │     1      5\n    6 │     2      6\n    7 │     2      7\n    8 │     2      8\n  ⋮   │   ⋮      ⋮\n 4994 │   999   4994\n 4995 │   999   4995\n 4996 │  1000   4996\n 4997 │  1000   4997\n 4998 │  1000   4998\n 4999 │  1000   4999\n 5000 │  1000   5000\n    4985 rows omitted\n\njulia> gdf = groupby(df, :g)\nGroupedDataFrame with 1000 groups based on key: g\nFirst Group (5 rows): g = 1\n Row │ g      x\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1      1\n   2 │     1      2\n   3 │     1      3\n   4 │     1      4\n   5 │     1      5\n⋮\nLast Group (5 rows): g = 1000\n Row │ g      x\n     │ Int64  Int64\n─────┼──────────────\n   1 │  1000   4996\n   2 │  1000   4997\n   3 │  1000   4998\n   4 │  1000   4999\n   5 │  1000   5000\n\njulia> gdf[(g=500,)]\n5×2 SubDataFrame\n Row │ g      x\n     │ Int64  Int64\n─────┼──────────────\n   1 │   500   2496\n   2 │   500   2497\n   3 │   500   2498\n   4 │   500   2499\n   5 │   500   2500\n\njulia> gdf[[(500,), (501,)]]\nGroupedDataFrame with 2 groups based on key: g\nFirst Group (5 rows): g = 500\n Row │ g      x\n     │ Int64  Int64\n─────┼──────────────\n   1 │   500   2496\n   2 │   500   2497\n   3 │   500   2498\n   4 │   500   2499\n   5 │   500   2500\n⋮\nLast Group (5 rows): g = 501\n Row │ g      x\n     │ Int64  Int64\n─────┼──────────────\n   1 │   501   2501\n   2 │   501   2502\n   3 │   501   2503\n   4 │   501   2504\n   5 │   501   2505","category":"page"},{"location":"man/split_apply_combine/","page":"Split-apply-combine","title":"Split-apply-combine","text":"In order to apply a function to each non-grouping column of a GroupedDataFrame you can write:","category":"page"},{"location":"man/split_apply_combine/","page":"Split-apply-combine","title":"Split-apply-combine","text":"julia> gd = groupby(iris, :Species)\nGroupedDataFrame with 3 groups based on key: Species\nFirst Group (50 rows): Species = \"Iris-setosa\"\n Row │ SepalLength  SepalWidth  PetalLength  PetalWidth  Species\n     │ Float64      Float64     Float64      Float64     String\n─────┼───────────────────────────────────────────────────────────────\n   1 │         5.1         3.5          1.4         0.2  Iris-setosa\n   2 │         4.9         3.0          1.4         0.2  Iris-setosa\n   3 │         4.7         3.2          1.3         0.2  Iris-setosa\n   4 │         4.6         3.1          1.5         0.2  Iris-setosa\n   5 │         5.0         3.6          1.4         0.2  Iris-setosa\n   6 │         5.4         3.9          1.7         0.4  Iris-setosa\n   7 │         4.6         3.4          1.4         0.3  Iris-setosa\n   8 │         5.0         3.4          1.5         0.2  Iris-setosa\n  ⋮  │      ⋮           ⋮            ⋮           ⋮            ⋮\n  43 │         4.4         3.2          1.3         0.2  Iris-setosa\n  44 │         5.0         3.5          1.6         0.6  Iris-setosa\n  45 │         5.1         3.8          1.9         0.4  Iris-setosa\n  46 │         4.8         3.0          1.4         0.3  Iris-setosa\n  47 │         5.1         3.8          1.6         0.2  Iris-setosa\n  48 │         4.6         3.2          1.4         0.2  Iris-setosa\n  49 │         5.3         3.7          1.5         0.2  Iris-setosa\n  50 │         5.0         3.3          1.4         0.2  Iris-setosa\n                                                      34 rows omitted\n⋮\nLast Group (50 rows): Species = \"Iris-virginica\"\n Row │ SepalLength  SepalWidth  PetalLength  PetalWidth  Species\n     │ Float64      Float64     Float64      Float64     String\n─────┼──────────────────────────────────────────────────────────────────\n   1 │         6.3         3.3          6.0         2.5  Iris-virginica\n   2 │         5.8         2.7          5.1         1.9  Iris-virginica\n   3 │         7.1         3.0          5.9         2.1  Iris-virginica\n   4 │         6.3         2.9          5.6         1.8  Iris-virginica\n   5 │         6.5         3.0          5.8         2.2  Iris-virginica\n   6 │         7.6         3.0          6.6         2.1  Iris-virginica\n   7 │         4.9         2.5          4.5         1.7  Iris-virginica\n   8 │         7.3         2.9          6.3         1.8  Iris-virginica\n  ⋮  │      ⋮           ⋮            ⋮           ⋮             ⋮\n  43 │         5.8         2.7          5.1         1.9  Iris-virginica\n  44 │         6.8         3.2          5.9         2.3  Iris-virginica\n  45 │         6.7         3.3          5.7         2.5  Iris-virginica\n  46 │         6.7         3.0          5.2         2.3  Iris-virginica\n  47 │         6.3         2.5          5.0         1.9  Iris-virginica\n  48 │         6.5         3.0          5.2         2.0  Iris-virginica\n  49 │         6.2         3.4          5.4         2.3  Iris-virginica\n  50 │         5.9         3.0          5.1         1.8  Iris-virginica\n                                                         34 rows omitted\n\njulia> combine(gd, valuecols(gd) .=> mean)\n3×5 DataFrame\n Row │ Species          SepalLength_mean  SepalWidth_mean  PetalLength_mean  P ⋯\n     │ String           Float64           Float64          Float64           F ⋯\n─────┼──────────────────────────────────────────────────────────────────────────\n   1 │ Iris-setosa                 5.006            3.418             1.464    ⋯\n   2 │ Iris-versicolor             5.936            2.77              4.26\n   3 │ Iris-virginica              6.588            2.974             5.552\n                                                                1 column omitted","category":"page"},{"location":"man/split_apply_combine/","page":"Split-apply-combine","title":"Split-apply-combine","text":"Note that GroupedDataFrame is a view: therefore grouping columns of its parent data frame must not be mutated, and rows must not be added nor removed from it. If the number or rows of the parent changes then an error is thrown when a child GroupedDataFrame is used:","category":"page"},{"location":"man/split_apply_combine/","page":"Split-apply-combine","title":"Split-apply-combine","text":"julia> df = DataFrame(id=1:2)\n2×1 DataFrame\n Row │ id\n     │ Int64\n─────┼───────\n   1 │     1\n   2 │     2\n\njulia> gd = groupby(df, :id)\nGroupedDataFrame with 2 groups based on key: id\nFirst Group (1 row): id = 1\n Row │ id\n     │ Int64\n─────┼───────\n   1 │     1\n⋮\nLast Group (1 row): id = 2\n Row │ id\n     │ Int64\n─────┼───────\n   1 │     2\n\njulia> push!(df, [3])\n3×1 DataFrame\n Row │ id\n     │ Int64\n─────┼───────\n   1 │     1\n   2 │     2\n   3 │     3\n\njulia> gd[1]\nERROR: AssertionError: The current number of rows in the parent data frame is 3 and it does not match the number of rows it contained when GroupedDataFrame was created which was 2. The number of rows in the parent data frame has likely been changed unintentionally (e.g. using subset!, filter!, delete!, push!, or append! functions).","category":"page"},{"location":"man/split_apply_combine/","page":"Split-apply-combine","title":"Split-apply-combine","text":"Sometimes it is useful to append rows to the source data frame of a GroupedDataFrame, without affecting the rows used for grouping. In such a scenario you can create the grouped data frame using a view of the parent data frame to avoid the error:","category":"page"},{"location":"man/split_apply_combine/","page":"Split-apply-combine","title":"Split-apply-combine","text":"julia> df = DataFrame(id=1:2)\n2×1 DataFrame\n Row │ id\n     │ Int64\n─────┼───────\n   1 │     1\n   2 │     2\n\njulia> gd = groupby(view(df, :, :), :id)\nGroupedDataFrame with 2 groups based on key: id\nFirst Group (1 row): id = 1\n Row │ id\n     │ Int64\n─────┼───────\n   1 │     1\n⋮\nLast Group (1 row): id = 2\n Row │ id\n     │ Int64\n─────┼───────\n   1 │     2\n\njulia> push!(df, [3])\n3×1 DataFrame\n Row │ id\n     │ Int64\n─────┼───────\n   1 │     1\n   2 │     2\n   3 │     3\n\njulia> gd[1]\n1×1 SubDataFrame\n Row │ id\n     │ Int64\n─────┼───────\n   1 │     1","category":"page"},{"location":"man/getting_started/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"man/getting_started/#Installation","page":"Getting Started","title":"Installation","text":"","category":"section"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"The DataFrames package is available through the Julia package system and can be installed using the following commands:","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"using Pkg\nPkg.add(\"DataFrames\")","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"Throughout the rest of this tutorial, we will assume that you have installed the DataFrames package and have already typed using DataFrames to bring all of the relevant variables into your current namespace.","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"note: Note\nBy default Jupyter Notebook will limit the number of rows and columns when displaying a data frame to roughly fit the screen size (like in the REPL).You can override this behavior by changing the values of the ENV[\"COLUMNS\"] and ENV[\"LINES\"] variables to hold the maximum width and height of output in characters respectively.Alternatively, you may want to set the maximum number of data frame rows to print to 100 and the maximum output width in characters to 1000 for every Julia session using some Jupyter kernel file (numbers 100 and 1000 are only examples and can be adjusted). In such case add a \"COLUMNS\": \"1000\", \"LINES\": \"100\" entry to the \"env\" variable in this Jupyter kernel file. See here for information about location and specification of Jupyter kernels.","category":"page"},{"location":"man/getting_started/#The-DataFrame-Type","page":"Getting Started","title":"The DataFrame Type","text":"","category":"section"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"Objects of the DataFrame type represent a data table as a series of vectors, each corresponding to a column or variable. The simplest way of constructing a DataFrame is to pass column vectors using keyword arguments or pairs:","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"julia> using DataFrames\n\njulia> df = DataFrame(A = 1:4, B = [\"M\", \"F\", \"F\", \"M\"])\n4×2 DataFrame\n Row │ A      B\n     │ Int64  String\n─────┼───────────────\n   1 │     1  M\n   2 │     2  F\n   3 │     3  F\n   4 │     4  M","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"Columns can be directly (i.e. without copying) accessed via df.col, df.\"col\", df[!, :col] or df[!, \"col\"]. The two latter syntaxes are more flexible as they allow passing a variable holding the name of the column, and not only a literal name. Note that column names can be either symbols (written as :col, :var\"col\" or Symbol(\"col\")) or strings (written as \"col\"). Note that in the forms df.\"col\" and :var\"col\" variable interpolation into a string using $ does not work. Columns can also be accessed using an integer index specifying their position.","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"Since df[!, :col] does not make a copy, changing the elements of the column vector returned by this syntax will affect the values stored in the original df. To get a copy of the column use df[:, :col]: changing the vector returned by this syntax does not change df.","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"julia> df.A\n4-element Vector{Int64}:\n 1\n 2\n 3\n 4\n\njulia> df.\"A\"\n4-element Vector{Int64}:\n 1\n 2\n 3\n 4\n\njulia> df.A === df[!, :A]\ntrue\n\njulia> df.A === df[:, :A]\nfalse\n\njulia> df.A == df[:, :A]\ntrue\n\njulia> df.A === df[!, \"A\"]\ntrue\n\njulia> df.A === df[:, \"A\"]\nfalse\n\njulia> df.A == df[:, \"A\"]\ntrue\n\njulia> df.A === df[!, 1]\ntrue\n\njulia> df.A === df[:, 1]\nfalse\n\njulia> df.A == df[:, 1]\ntrue\n\njulia> firstcolumn = :A\n:A\n\njulia> df[!, firstcolumn] === df.A\ntrue\n\njulia> df[:, firstcolumn] === df.A\nfalse\n\njulia> df[:, firstcolumn] == df.A\ntrue","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"Column names can be obtained as strings using the names function:","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"julia> names(df)\n2-element Vector{String}:\n \"A\"\n \"B\"","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"To get column names as Symbols use the propertynames function:","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"julia> propertynames(df)\n2-element Vector{Symbol}:\n :A\n :B","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"note: Note\nDataFrames.jl allows to use Symbols (like :A) and strings (like \"A\") for all column indexing operations for convenience. However, using Symbols is slightly faster and should generally be preferred, if not generating them via string manipulation.","category":"page"},{"location":"man/getting_started/#Constructing-Column-by-Column","page":"Getting Started","title":"Constructing Column by Column","text":"","category":"section"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"It is also possible to start with an empty DataFrame and add columns to it one by one:","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"julia> df = DataFrame()\n0×0 DataFrame\n\njulia> df.A = 1:8\n1:8\n\njulia> df.B = [\"M\", \"F\", \"F\", \"M\", \"F\", \"M\", \"M\", \"F\"]\n8-element Vector{String}:\n \"M\"\n \"F\"\n \"F\"\n \"M\"\n \"F\"\n \"M\"\n \"M\"\n \"F\"\n\njulia> df\n8×2 DataFrame\n Row │ A      B\n     │ Int64  String\n─────┼───────────────\n   1 │     1  M\n   2 │     2  F\n   3 │     3  F\n   4 │     4  M\n   5 │     5  F\n   6 │     6  M\n   7 │     7  M\n   8 │     8  F","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"The DataFrame we build in this way has 8 rows and 2 columns. This can be checked using the size function:","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"julia> size(df, 1)\n8\n\njulia> size(df, 2)\n2\n\njulia> size(df)\n(8, 2)\n","category":"page"},{"location":"man/getting_started/#Constructing-Row-by-Row","page":"Getting Started","title":"Constructing Row by Row","text":"","category":"section"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"It is also possible to fill a DataFrame row by row. Let us construct an empty data frame with two columns (note that the first column can only contain integers and the second one can only contain strings):","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"julia> df = DataFrame(A = Int[], B = String[])\n0×2 DataFrame","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"Rows can then be added as tuples or vectors, where the order of elements matches that of columns:","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"julia> push!(df, (1, \"M\"))\n1×2 DataFrame\n Row │ A      B\n     │ Int64  String\n─────┼───────────────\n   1 │     1  M\n\njulia> push!(df, [2, \"N\"])\n2×2 DataFrame\n Row │ A      B\n     │ Int64  String\n─────┼───────────────\n   1 │     1  M\n   2 │     2  N","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"Rows can also be added as Dicts, where the dictionary keys match the column names:","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"julia> push!(df, Dict(:B => \"F\", :A => 3))\n3×2 DataFrame\n Row │ A      B\n     │ Int64  String\n─────┼───────────────\n   1 │     1  M\n   2 │     2  N\n   3 │     3  F","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"Note that constructing a DataFrame row by row is significantly less performant than constructing it all at once, or column by column. For many use-cases this will not matter, but for very large DataFrames  this may be a consideration.","category":"page"},{"location":"man/getting_started/#Constructing-from-another-table-type","page":"Getting Started","title":"Constructing from another table type","text":"","category":"section"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"DataFrames supports the Tables.jl interface for interacting with tabular data. This means that a DataFrame can be used as a \"source\" to any package that expects a Tables.jl interface input, (file format packages, data manipulation packages, etc.). A DataFrame can also be a sink for any Tables.jl interface input. Some example uses are:","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"df = DataFrame(a=[1, 2, 3], b=[:a, :b, :c])\n\n# write DataFrame out to CSV file\nCSV.write(\"dataframe.csv\", df)\n\n# store DataFrame in an SQLite database table\nSQLite.load!(df, db, \"dataframe_table\")\n\n# transform a DataFrame through Query.jl package\ndf = df |> @map({a=_.a + 1, _.b}) |> DataFrame","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"A particular common case of a collection that supports the Tables.jl interface is a vector of NamedTuples:","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"julia> v = [(a=1, b=2), (a=3, b=4)]\n2-element Vector{NamedTuple{(:a, :b), Tuple{Int64, Int64}}}:\n (a = 1, b = 2)\n (a = 3, b = 4)\n\njulia> df = DataFrame(v)\n2×2 DataFrame\n Row │ a      b\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1      2\n   2 │     3      4","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"You can also easily convert a data frame back to a vector of NamedTuples:","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"julia> using Tables\n\njulia> Tables.rowtable(df)\n2-element Vector{NamedTuple{(:a, :b), Tuple{Int64, Int64}}}:\n (a = 1, b = 2)\n (a = 3, b = 4)","category":"page"},{"location":"man/missing/#Missing-Data","page":"Missing Data","title":"Missing Data","text":"","category":"section"},{"location":"man/missing/","page":"Missing Data","title":"Missing Data","text":"In Julia, missing values in data are represented using the special object missing, which is the single instance of the type Missing.","category":"page"},{"location":"man/missing/","page":"Missing Data","title":"Missing Data","text":"julia> missing\nmissing\n\njulia> typeof(missing)\nMissing\n","category":"page"},{"location":"man/missing/","page":"Missing Data","title":"Missing Data","text":"The Missing type lets users create Vectors and DataFrame columns with missing values. Here we create a vector with a missing value and the element-type of the returned vector is Union{Missing, Int64}.","category":"page"},{"location":"man/missing/","page":"Missing Data","title":"Missing Data","text":"julia> x = [1, 2, missing]\n3-element Vector{Union{Missing, Int64}}:\n 1\n 2\n  missing\n\njulia> eltype(x)\nUnion{Missing, Int64}\n\njulia> Union{Missing, Int}\nUnion{Missing, Int64}\n\njulia> eltype(x) == Union{Missing, Int}\ntrue\n","category":"page"},{"location":"man/missing/","page":"Missing Data","title":"Missing Data","text":"missing values can be excluded when performing operations by using skipmissing, which returns a memory-efficient iterator.","category":"page"},{"location":"man/missing/","page":"Missing Data","title":"Missing Data","text":"julia> skipmissing(x)\nskipmissing(Union{Missing, Int64}[1, 2, missing])\n","category":"page"},{"location":"man/missing/","page":"Missing Data","title":"Missing Data","text":"The output of skipmissing can be passed directly into functions as an argument. For example, we can find the sum of all non-missing values or collect the non-missing values into a new missing-free vector.","category":"page"},{"location":"man/missing/","page":"Missing Data","title":"Missing Data","text":"julia> sum(skipmissing(x))\n3\n\njulia> collect(skipmissing(x))\n2-element Vector{Int64}:\n 1\n 2\n","category":"page"},{"location":"man/missing/","page":"Missing Data","title":"Missing Data","text":"The function coalesce can be used to replace missing values with another value (note the dot, indicating that the replacement should be applied to all entries in x):","category":"page"},{"location":"man/missing/","page":"Missing Data","title":"Missing Data","text":"julia> coalesce.(x, 0)\n3-element Vector{Int64}:\n 1\n 2\n 0\n","category":"page"},{"location":"man/missing/","page":"Missing Data","title":"Missing Data","text":"The functions dropmissing and dropmissing! can be used to remove the rows containing missing values from a DataFrame and either create a new DataFrame or mutate the original in-place respectively.","category":"page"},{"location":"man/missing/","page":"Missing Data","title":"Missing Data","text":"julia> using DataFrames\n\njulia> df = DataFrame(i = 1:5,\n                      x = [missing, 4, missing, 2, 1],\n                      y = [missing, missing, \"c\", \"d\", \"e\"])\n5×3 DataFrame\n Row │ i      x        y\n     │ Int64  Int64?   String?\n─────┼─────────────────────────\n   1 │     1  missing  missing\n   2 │     2        4  missing\n   3 │     3  missing  c\n   4 │     4        2  d\n   5 │     5        1  e\n\njulia> dropmissing(df)\n2×3 DataFrame\n Row │ i      x      y\n     │ Int64  Int64  String\n─────┼──────────────────────\n   1 │     4      2  d\n   2 │     5      1  e","category":"page"},{"location":"man/missing/","page":"Missing Data","title":"Missing Data","text":"One can specify the column(s) in which to search for rows containing missing values to be removed.","category":"page"},{"location":"man/missing/","page":"Missing Data","title":"Missing Data","text":"julia> dropmissing(df, :x)\n3×3 DataFrame\n Row │ i      x      y\n     │ Int64  Int64  String?\n─────┼───────────────────────\n   1 │     2      4  missing\n   2 │     4      2  d\n   3 │     5      1  e","category":"page"},{"location":"man/missing/","page":"Missing Data","title":"Missing Data","text":"By default the dropmissing and dropmissing! functions keep the Union{T, Missing} element type in columns selected for row removal. To remove the Missing part, if present, set the disallowmissing option to true (it will become the default behavior in the future).","category":"page"},{"location":"man/missing/","page":"Missing Data","title":"Missing Data","text":"julia> dropmissing(df, disallowmissing=true)\n2×3 DataFrame\n Row │ i      x      y\n     │ Int64  Int64  String\n─────┼──────────────────────\n   1 │     4      2  d\n   2 │     5      1  e","category":"page"},{"location":"man/missing/","page":"Missing Data","title":"Missing Data","text":"The Missings.jl package provides a few convenience functions to work with missing values.","category":"page"},{"location":"man/missing/","page":"Missing Data","title":"Missing Data","text":"The function Missings.replace returns an iterator which replaces missing elements with another value:","category":"page"},{"location":"man/missing/","page":"Missing Data","title":"Missing Data","text":"julia> using Missings\n\njulia> Missings.replace(x, 1)\nMissings.EachReplaceMissing{Vector{Union{Missing, Int64}}, Int64}(Union{Missing, Int64}[1, 2, missing], 1)\n\njulia> collect(Missings.replace(x, 1))\n3-element Vector{Int64}:\n 1\n 2\n 1\n\njulia> collect(Missings.replace(x, 1)) == coalesce.(x, 1)\ntrue\n","category":"page"},{"location":"man/missing/","page":"Missing Data","title":"Missing Data","text":"The function nonmissingtype returns the element-type T in Union{T, Missing}.","category":"page"},{"location":"man/missing/","page":"Missing Data","title":"Missing Data","text":"julia> eltype(x)\nUnion{Missing, Int64}\n\njulia> nonmissingtype(eltype(x))\nInt64\n","category":"page"},{"location":"man/missing/","page":"Missing Data","title":"Missing Data","text":"The missings function constructs Vectors and Arrays supporting missing values, using the optional first argument to specify the element-type.","category":"page"},{"location":"man/missing/","page":"Missing Data","title":"Missing Data","text":"julia> missings(1)\n1-element Vector{Missing}:\n missing\n\njulia> missings(3)\n3-element Vector{Missing}:\n missing\n missing\n missing\n\njulia> missings(1, 3)\n1×3 Matrix{Missing}:\n missing  missing  missing\n\njulia> missings(Int, 1, 3)\n1×3 Matrix{Union{Missing, Int64}}:\n missing  missing  missing\n","category":"page"},{"location":"man/missing/","page":"Missing Data","title":"Missing Data","text":"See the Julia manual for more information about missing values.","category":"page"},{"location":"#DataFrames.jl","page":"Introduction","title":"DataFrames.jl","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Welcome to the DataFrames.jl documentation!","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"This resource aims to teach you everything you need to know to get up and running with tabular data manipulation using the DataFrames.jl package.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"For more illustrations of DataFrames.jl usage, in particular in conjunction with other packages you can check-out the following resources (they are kept up to date with the released version of DataFrames.jl):","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Data Wrangling with DataFrames.jl Cheat Sheet\nDataFrames Tutorial using Jupyter Notebooks\nJulia Academy DataFrames.jl tutorial\nJuliaCon 2019, JuliaCon 2020, JuliaCon 2021, PyData Global 2020, and ODSC Europe 2021 tutorials\nDataFrames.jl showcase","category":"page"},{"location":"#What-is-DataFrames.jl?","page":"Introduction","title":"What is DataFrames.jl?","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"DataFrames.jl provides a set of tools for working with tabular data in Julia. Its design and functionality are similar to those of pandas (in Python) and data.frame, data.table and dplyr (in R), making it  a great general purpose data science tool, especially for those  coming to Julia from R or Python.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"DataFrames.jl plays a central role in the Julia Data ecosystem, and has tight integrations with a range of different libraries. DataFrames.jl isn't the only tool for working with tabular data in Julia – as noted below, there are some other great libraries for certain use-cases – but it provides great data wrangling functionality through a familiar interface.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"To understand the toolchain in more detail, have a look at the tutorials in this manual. New users can start with the First Steps with DataFrames.jl section.","category":"page"},{"location":"#DataFrames.jl-and-the-Julia-Data-Ecosystem","page":"Introduction","title":"DataFrames.jl and the Julia Data Ecosystem","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The Julia data ecosystem can be a difficult space for new users to navigate, in part because the Julia ecosystem tends to distribute functionality across different libraries more than some other languages. Because many people coming to DataFrames.jl are just starting to explore the Julia data ecosystem, below is a list of well-supported libraries that provide different data science tools, along with a few notes about what makes each library special, and how well integrated they are with DataFrames.jl.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Statistics\nStatsKit.jl: A convenience meta-package which loads a set of essential packages for statistics, including those mentioned below in this section and DataFrames.jl itself.\nStatistics: The Julia standard library comes with a wide range of statistics functionality, but to gain access to these functions you must call using Statistics.\nLinearAlgebra: Like Statistics, many linear algebra features (factorizations, inversions, etc.) live in a library you have to load to use.\nSparseArrays are also in the standard library but must be loaded to be used.\nFreqTables.jl: Create frequency tables / cross-tabulations. Tightly integrated with DataFrames.jl.\nHypothesisTests.jl: A range of hypothesis testing tools.\nGLM.jl: Tools for estimating linear and generalized linear models. Tightly integrated with DataFrames.jl.\nStatsModels.jl: For converting heterogeneous DataFrame into homogenous matrices for use with linear algebra libraries or machine learning applications that don't directly support DataFrames. Will do things like convert categorical variables into indicators/one-hot-encodings, create interaction terms, etc.\nMultivariateStats.jl: linear regression, ridge regression, PCA, component analyses tools. Not well integrated with DataFrames.jl, but easily used in combination with StatsModels.\nMachine Learning\nMLJ.jl: if you're more of an applied user, there is a single package the pulls from all these different libraries and provides a single, scikit-learn inspired API: MLJ.jl. MLJ.jl provides a common interface for a wide range of machine learning algorithms.\nScikitLearn.jl: A Julia wrapper around the full Python scikit-learn machine learning library. Not well integrated with DataFrames.jl, but can be combined using StatsModels.jl.\nAutoMLPipeline: A package that makes it trivial to create complex ML pipeline structures using simple expressions. It leverages on the built-in macro programming features of Julia to symbolically process, manipulate pipeline expressions, and makes it easy to discover optimal structures for machine learning regression and classification.\nDeep learning: KNet.jl and Flux.jl.\nPlotting\nPlots.jl: Powerful, modern plotting library with a syntax akin to that of matplotlib (in Python) or plot (in R). StatsPlots.jl provides Plots.jl with recipes for many standard statistical plots.\nGadfly.jl: High-level plotting library with a \"grammar of graphics\" syntax akin to that of ggplot (in R).\nVegaLite.jl: High-level plotting library that uses a different \"grammar of graphics\" syntax and has an emphasis on interactive graphics.\nData Wrangling:\nImpute.jl: various methods for handling missing data in vectors, matrices and tables.\nDataFramesMeta.jl: A range of convenience functions for DataFrames.jl that augment select and transform to provide a user experience similar to that provided by dplyr in R.\nQuery.jl: Query.jl provides a single framework for data wrangling that works with a range of libraries, including DataFrames.jl, other tabular data libraries (more on those below), and even non-tabular data. Provides many convenience functions analogous to those in dplyr in R or LINQ.\nYou can find more on both of these packages in the Data manipulation frameworks section of this manual.\nAnd More!\nLightGraphs.jl: A pure-Julia, high performance network analysis library. Edgelists in DataFrames can be easily converted into graphs using the GraphDataFrameBridge.jl package.\nIO:\nDataFrames.jl work well with a range of formats, including CSVs (using CSV.jl), Apache Arrow (using Arrow.jl) Stata, SPSS, and SAS files (using StatFiles.jl), and reading and writing parquet files (using Parquet.jl).","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"While not all of these libraries are tightly integrated with DataFrames.jl, because DataFrames are essentially collections of aligned Julia vectors, so it is easy to (a) pull out a vector for use with a non-DataFrames-integrated library, or (b) convert your table into a homogenously-typed matrix using the Matrix constructor or StatsModels.jl.","category":"page"},{"location":"#Other-Julia-Tabular-Libraries","page":"Introduction","title":"Other Julia Tabular Libraries","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"DataFrames.jl is a great general purpose tool for data manipulation and wrangling, but it's not ideal for all applications. For users with more specialized needs, consider using:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"TypedTables.jl: Type-stable heterogeneous tables. Useful for improved performance when the structure of your table is relatively stable and does not feature thousands of columns.\nJuliaDB.jl: For users working with data that is too large to fit in memory, we suggest JuliaDB.jl, which offers better performance for large datasets, and can handle out-of-core data manipulations (Python users can think of JuliaDB.jl as the Julia version of dask).","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Note that most tabular data libraries in the Julia ecosystem (including DataFrames.jl) support a common interface (defined in the Tables.jl package). As a result, some libraries are capable or working with a range of tabular data structures, making it easy to move between tabular libraries as your needs change. A user of Query.jl, for example, can use the same code to manipulate data in a DataFrame, a Table (defined by TypedTables.jl), or a JuliaDB table.","category":"page"},{"location":"#Questions?","page":"Introduction","title":"Questions?","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"If there is something you expect DataFrames to be capable of, but cannot figure out how to do, please reach out with questions in Domains/Data on Discourse. Additionally you might want to listen to an introduction to DataFrames.jl on JuliaAcademy.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Please report bugs by opening an issue.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"You can follow the source links throughout the documentation to jump right to the source files on GitHub to make pull requests for improving the documentation and function capabilities.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Please review DataFrames contributing guidelines before submitting your first PR!","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Information on specific versions can be found on the Release page.","category":"page"},{"location":"#Package-Manual","page":"Introduction","title":"Package Manual","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Pages = [\"man/basics.md\",\n         \"man/getting_started.md\",\n         \"man/joins.md\",\n         \"man/split_apply_combine.md\",\n         \"man/reshaping_and_pivoting.md\",\n         \"man/sorting.md\",\n         \"man/categorical.md\",\n         \"man/missing.md\",\n         \"man/comparisons.md\",\n         \"man/querying_frameworks.md\"]\nDepth = 2","category":"page"},{"location":"#API","page":"Introduction","title":"API","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Only exported (i.e. available for use without DataFrames. qualifier after loading the DataFrames.jl package with using DataFrames) types and functions are considered a part of the public API of the DataFrames.jl package. In general all such objects are documented in this manual (in case some documentation is missing please kindly report an issue here).","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"All types and functions that are part of public API are guaranteed to go through a deprecation period before being changed or removed.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Please be warned that while Julia allows you to access internal functions or types of DataFrames.jl these can change without warning between versions of DataFrames.jl. In particular it is not safe to directly access fields of types that are a part of public API of the DataFrames.jl package using e.g. the getfield function. Whenever some operation on fields of defined types is considered allowed an appropriate exported function should be used instead.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Pages = [\"lib/types.md\", \"lib/functions.md\", \"lib/indexing.md\"]\nDepth = 2","category":"page"},{"location":"#Index","page":"Introduction","title":"Index","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Pages = [\"lib/types.md\", \"lib/functions.md\"]","category":"page"},{"location":"assets/README/#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"assets/README/","page":"Introduction","title":"Introduction","text":"In this folder we store the following data sets:","category":"page"},{"location":"assets/README/","page":"Introduction","title":"Introduction","text":"german_credit.csv\niris.csv","category":"page"},{"location":"assets/README/#German-Credit-data-set","page":"Introduction","title":"German Credit data set","text":"","category":"section"},{"location":"assets/README/#License:","page":"Introduction","title":"License:","text":"","category":"section"},{"location":"assets/README/","page":"Introduction","title":"Introduction","text":"https://opendatacommons.org/licenses/dbcl/1-0/","category":"page"},{"location":"assets/README/#Source:","page":"Introduction","title":"Source:","text":"","category":"section"},{"location":"assets/README/","page":"Introduction","title":"Introduction","text":"https://archive.ics.uci.edu/ml/datasets/statlog+(german+credit+data) Professor Dr. Hans Hofmann Institut für Statistik und Ökonometrie Universität Hamburg FB Wirtschaftswissenschaften Von-Melle-Park 5 2000 Hamburg 13","category":"page"},{"location":"assets/README/","page":"Introduction","title":"Introduction","text":"The original data is from UCI, and the file stored here is from Kaggle","category":"page"},{"location":"assets/README/#Iris-data-set","page":"Introduction","title":"Iris data set","text":"","category":"section"},{"location":"assets/README/#License","page":"Introduction","title":"License","text":"","category":"section"},{"location":"assets/README/","page":"Introduction","title":"Introduction","text":"https://creativecommons.org/publicdomain/zero/1.0/","category":"page"},{"location":"assets/README/#Source:-2","page":"Introduction","title":"Source:","text":"","category":"section"},{"location":"assets/README/","page":"Introduction","title":"Introduction","text":"https://archive.ics.uci.edu/ml/datasets/Iris Creator: R.A. Fisher","category":"page"}]
}
