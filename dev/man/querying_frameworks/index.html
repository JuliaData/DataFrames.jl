<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Data manipulation frameworks · DataFrames.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link rel="canonical" href="https://juliadata.github.io/DataFrames.jl/stable/man/querying_frameworks/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="DataFrames.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">DataFrames.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><a class="tocitem" href="../basics/">First Steps with DataFrames.jl</a></li><li><span class="tocitem">User Guide</span><ul><li><a class="tocitem" href="../getting_started/">Getting Started</a></li><li><a class="tocitem" href="../working_with_dataframes/">Working with DataFrames</a></li><li><a class="tocitem" href="../importing_and_exporting/">Importing and Exporting Data (I/O)</a></li><li><a class="tocitem" href="../joins/">Joins</a></li><li><a class="tocitem" href="../split_apply_combine/">Split-apply-combine</a></li><li><a class="tocitem" href="../reshaping_and_pivoting/">Reshaping</a></li><li><a class="tocitem" href="../sorting/">Sorting</a></li><li><a class="tocitem" href="../categorical/">Categorical Data</a></li><li><a class="tocitem" href="../missing/">Missing Data</a></li><li class="is-active"><a class="tocitem" href>Data manipulation frameworks</a><ul class="internal"><li><a class="tocitem" href="#DataFramesMeta.jl"><span>DataFramesMeta.jl</span></a></li><li><a class="tocitem" href="#DataFrameMacros.jl"><span>DataFrameMacros.jl</span></a></li><li><a class="tocitem" href="#Query.jl"><span>Query.jl</span></a></li></ul></li><li><a class="tocitem" href="../comparisons/">Comparison with Python/R/Stata</a></li></ul></li><li><span class="tocitem">API</span><ul><li><a class="tocitem" href="../../lib/types/">Types</a></li><li><a class="tocitem" href="../../lib/functions/">Functions</a></li><li><a class="tocitem" href="../../lib/indexing/">Indexing</a></li><li><a class="tocitem" href="../../lib/metadata/">Metadata</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">User Guide</a></li><li class="is-active"><a href>Data manipulation frameworks</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Data manipulation frameworks</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaData/DataFrames.jl/blob/main/docs/src/man/querying_frameworks.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Data-manipulation-frameworks"><a class="docs-heading-anchor" href="#Data-manipulation-frameworks">Data manipulation frameworks</a><a id="Data-manipulation-frameworks-1"></a><a class="docs-heading-anchor-permalink" href="#Data-manipulation-frameworks" title="Permalink"></a></h1><p>Three frameworks provide convenience methods to manipulate <code>DataFrame</code>s: DataFramesMeta.jl, DataFrameMacros.jl and Query.jl. They implement a functionality similar to <a href="https://dplyr.tidyverse.org/">dplyr</a> or <a href="https://en.wikipedia.org/wiki/Language_Integrated_Query">LINQ</a>.</p><h2 id="DataFramesMeta.jl"><a class="docs-heading-anchor" href="#DataFramesMeta.jl">DataFramesMeta.jl</a><a id="DataFramesMeta.jl-1"></a><a class="docs-heading-anchor-permalink" href="#DataFramesMeta.jl" title="Permalink"></a></h2><p>The <a href="https://github.com/JuliaStats/DataFramesMeta.jl">DataFramesMeta.jl</a> package provides a convenient yet fast macro-based interface to work with <code>DataFrame</code>s. The instructions below are for version 0.10.0 of DataFramesMeta.jl.</p><p>First install the DataFramesMeta.jl package:</p><pre><code class="language-julia hljs">using Pkg
Pkg.add(&quot;DataFramesMeta&quot;)</code></pre><p>The major benefit of the package is it provides a more convenient syntax for the transformation functions <code>transform</code>, <code>select</code>, and <code>combine</code>  via the macros <code>@transform</code>, <code>@select</code>, <code>@combine</code>, and more.</p><p>DataFramesMeta.jl also reexports the <code>@chain</code> macro from  <a href="https://github.com/jkrumbiegel/Chain.jl">Chain.jl</a>, allowing users to pipe the output of one transformation as an input to another, as with  <code>|&gt;</code> and <code>%&gt;%</code> in R. </p><p>Below we present several selected examples of usage of the package.</p><p>First we subset rows of the source data frame using a logical condition and select its two columns, renaming one of them:</p><pre><code class="language-julia-repl hljs">julia&gt; using DataFramesMeta

julia&gt; df = DataFrame(name=[&quot;John&quot;, &quot;Sally&quot;, &quot;Roger&quot;],
                      age=[54.0, 34.0, 79.0],
                      children=[0, 2, 4])
3×3 DataFrame
 Row │ name    age      children
     │ String  Float64  Int64
─────┼───────────────────────────
   1 │ John       54.0         0
   2 │ Sally      34.0         2
   3 │ Roger      79.0         4

julia&gt; @chain df begin
           @rsubset :age &gt; 40 
           @select(:number_of_children = :children, :name)
       end
2×2 DataFrame
 Row │ number_of_children  name
     │ Int64               String
─────┼────────────────────────────
   1 │                  0  John
   2 │                  4  Roger</code></pre><p>In the following examples we show that DataFramesMeta.jl also supports the split-apply-combine pattern:</p><pre><code class="language-julia-repl hljs">julia&gt; df = DataFrame(key=repeat(1:3, 4), value=1:12)
12×2 DataFrame
 Row │ key    value
     │ Int64  Int64
─────┼──────────────
   1 │     1      1
   2 │     2      2
   3 │     3      3
   4 │     1      4
   5 │     2      5
   6 │     3      6
   7 │     1      7
   8 │     2      8
   9 │     3      9
  10 │     1     10
  11 │     2     11
  12 │     3     12

julia&gt; @chain df begin
           @rsubset :value &gt; 3 
           @by(:key, :min = minimum(:value), :max = maximum(:value))
           @select(:key, :range = :max - :min)
        end
3×2 DataFrame
 Row │ key    range
     │ Int64  Int64
─────┼──────────────
   1 │     1      6
   2 │     2      6
   3 │     3      6

julia&gt; @chain df begin
           groupby(:key)
           @transform :value0 = :value .- minimum(:value)
       end
12×3 DataFrame
 Row │ key    value  value0
     │ Int64  Int64  Int64
─────┼──────────────────────
   1 │     1      1       0
   2 │     2      2       0
   3 │     3      3       0
   4 │     1      4       3
   5 │     2      5       3
   6 │     3      6       3
   7 │     1      7       6
   8 │     2      8       6
   9 │     3      9       6
  10 │     1     10       9
  11 │     2     11       9
  12 │     3     12       9</code></pre><p>You can find more details about how this package can be used on the <a href="https://github.com/JuliaData/DataFramesMeta.jl">DataFramesMeta.jl GitHub page</a>.</p><h2 id="DataFrameMacros.jl"><a class="docs-heading-anchor" href="#DataFrameMacros.jl">DataFrameMacros.jl</a><a id="DataFrameMacros.jl-1"></a><a class="docs-heading-anchor-permalink" href="#DataFrameMacros.jl" title="Permalink"></a></h2><p><a href="https://github.com/jkrumbiegel/DataFrameMacros.jl">DataFrameMacros.jl</a> is an alternative to DataFramesMeta.jl with an additional focus on convenient solutions for the transformation of multiple columns at once. The instructions below are for version 0.3 of DataFrameMacros.jl.</p><p>First, install the DataFrameMacros.jl package:</p><pre><code class="language-julia hljs">using Pkg
Pkg.add(&quot;DataFrameMacros&quot;)</code></pre><p>In DataFrameMacros.jl, all but the <code>@combine</code> macro are row-wise by default. There is also a <code>@groupby</code> which allows creating grouping columns on the fly using the same syntax as <code>@transform</code>, for grouping by new columns without writing them out twice.</p><p>In the example below, you can also see some of DataFrameMacros.jl&#39;s multi-column features, where <code>mean</code> is applied to both age columns at once by selecting them with the <code>r&quot;age&quot;</code> regex. The new column names are then derived using the <code>&quot;{}&quot;</code> shortcut which splices the transformed column names into a string.</p><pre><code class="language-julia-repl hljs">julia&gt; using DataFrames, DataFrameMacros, Chain, Statistics

julia&gt; df = DataFrame(name=[&quot;John&quot;, &quot;Sally&quot;, &quot;Roger&quot;],
                      age=[54.0, 34.0, 79.0],
                      children=[0, 2, 4])
3×3 DataFrame
 Row │ name    age      children 
     │ String  Float64  Int64    
─────┼───────────────────────────
   1 │ John       54.0         0
   2 │ Sally      34.0         2
   3 │ Roger      79.0         4

julia&gt; @chain df begin
           @transform :age_months = :age * 12
           @groupby :has_child = :children &gt; 0
           @combine &quot;mean_{}&quot; = mean({r&quot;age&quot;})
       end
2×3 DataFrame
 Row │ has_child  mean_age  mean_age_months 
     │ Bool       Float64   Float64         
─────┼──────────────────────────────────────
   1 │     false      54.0            648.0
   2 │      true      56.5            678.0</code></pre><p>There&#39;s also the capability to reference a group of multiple columns as a single unit, for example to run aggregations over them, with the <code>{{ }}</code> syntax. In the following example, the first quarter is compared to the maximum of the other three:</p><pre><code class="language-julia-repl hljs">julia&gt; df = DataFrame(q1 = [12.0, 0.4, 42.7],
                      q2 = [6.4, 2.3, 40.9],
                      q3 = [9.5, 0.2, 13.6],
                      q4 = [6.3, 5.4, 39.3])
3×4 DataFrame
 Row │ q1       q2       q3       q4      
     │ Float64  Float64  Float64  Float64 
─────┼────────────────────────────────────
   1 │    12.0      6.4      9.5      6.3
   2 │     0.4      2.3      0.2      5.4
   3 │    42.7     40.9     13.6     39.3

julia&gt; @transform df :q1_best = :q1 &gt; maximum({{Not(:q1)}})
3×5 DataFrame
 Row │ q1       q2       q3       q4       q1_best 
     │ Float64  Float64  Float64  Float64  Bool    
─────┼─────────────────────────────────────────────
   1 │    12.0      6.4      9.5      6.3     true
   2 │     0.4      2.3      0.2      5.4    false
   3 │    42.7     40.9     13.6     39.3     true</code></pre><h2 id="Query.jl"><a class="docs-heading-anchor" href="#Query.jl">Query.jl</a><a id="Query.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Query.jl" title="Permalink"></a></h2><p>The <a href="https://github.com/queryverse/Query.jl">Query.jl</a> package provides advanced data manipulation capabilities for <code>DataFrame</code>s (and many other data structures). This section provides a short introduction to the package, the <a href="http://www.queryverse.org/Query.jl/stable/">Query.jl documentation</a> has a more comprehensive documentation of the package. The instructions here are for version 1.0.0 of Query.jl.</p><p>To get started, install the Query.jl package:</p><pre><code class="language-julia hljs">using Pkg
Pkg.add(&quot;Query&quot;)</code></pre><p>A query is started with the <code>@from</code> macro and consists of a series of query commands. Query.jl provides commands that can filter, project, join, flatten and group data from a <code>DataFrame</code>. A query can return an iterator, or one can materialize the results of a query into a variety of data structures, including a new <code>DataFrame</code>.</p><p>A simple example of a query looks like this:</p><pre><code class="language-julia-repl hljs">julia&gt; using DataFrames, Query

julia&gt; df = DataFrame(name=[&quot;John&quot;, &quot;Sally&quot;, &quot;Roger&quot;],
                      age=[54.0, 34.0, 79.0],
                      children=[0, 2, 4])
3×3 DataFrame
 Row │ name    age      children
     │ String  Float64  Int64
─────┼───────────────────────────
   1 │ John       54.0         0
   2 │ Sally      34.0         2
   3 │ Roger      79.0         4

julia&gt; q1 = @from i in df begin
            @where i.age &gt; 40
            @select {number_of_children=i.children, i.name}
            @collect DataFrame
       end
2×2 DataFrame
 Row │ number_of_children  name
     │ Int64               String
─────┼────────────────────────────
   1 │                  0  John
   2 │                  4  Roger</code></pre><p>The query starts with the <code>@from</code> macro. The first argument <code>i</code> is the name of the range variable that will be used to refer to an individual row in later query commands. The next argument <code>df</code> is the data source that one wants to query. The <code>@where</code> command in this query will filter the source data by applying the filter condition <code>i.age &gt; 40</code>. This filters out any rows in which the <code>age</code> column is not larger than 40. The <code>@select</code> command then projects the columns of the source data onto a new column structure. The example here applies three specific modifications: 1) it only keeps a subset of the columns in the source <code>DataFrame</code>, i.e. the <code>age</code> column will not be part of the transformed data; 2) it changes the order of the two columns that are selected; and 3) it renames one of the columns that is selected from <code>children</code> to <code>number_of_children</code>. The example query uses the <code>{}</code> syntax to achieve this. A <code>{}</code> in a Query.jl expression instantiates a new <a href="https://github.com/blackrock/NamedTuples.jl">NamedTuple</a>, i.e. it is a shortcut for writing <code>@NT(number_of_children=&gt;i.children, name=&gt;i.name)</code>. The <code>@collect</code> statement determines the data structure that the query returns. In this example the results are returned as a <code>DataFrame</code>.</p><p>A query without a <code>@collect</code> statement returns a standard julia iterator that can be used with any normal julia language construct that can deal with iterators. The following code returns a julia iterator for the query results:</p><pre><code class="language-julia-repl hljs">julia&gt; q2 = @from i in df begin
                   @where i.age &gt; 40
                   @select {number_of_children=i.children, i.name}
              end; # suppress printing the iterator type
</code></pre><p>One can loop over the results using a standard julia <code>for</code> statement:</p><pre><code class="language-julia-repl hljs">julia&gt; total_children = 0
0

julia&gt; for i in q2
           global total_children += i.number_of_children
       end

julia&gt; total_children
4
</code></pre><p>Or one can use a comprehension to extract the name of a subset of rows:</p><pre><code class="language-julia-repl hljs">julia&gt; y = [i.name for i in q2 if i.number_of_children &gt; 0]
1-element Vector{String}:
 &quot;Roger&quot;
</code></pre><p>The last example (extracting only the name and applying a second filter) could of course be completely expressed as a query expression:</p><pre><code class="language-julia-repl hljs">julia&gt; q3 = @from i in df begin
            @where i.age &gt; 40 &amp;&amp; i.children &gt; 0
            @select i.name
            @collect
       end
1-element Vector{String}:
 &quot;Roger&quot;
</code></pre><p>A query that ends with a <code>@collect</code> statement without a specific type will materialize the query results into an array. Note also the difference in the <code>@select</code> statement: The previous queries all used the <code>{}</code> syntax in the <code>@select</code> statement to project results into a tabular format. The last query instead just selects a single value from each row in the <code>@select</code> statement.</p><p>These examples only scratch the surface of what one can do with <a href="https://github.com/queryverse/Query.jl">Query.jl</a>, and the interested reader is referred to the <a href="http://www.queryverse.org/Query.jl/stable/">Query.jl documentation</a> for more information.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../missing/">« Missing Data</a><a class="docs-footer-nextpage" href="../comparisons/">Comparison with Python/R/Stata »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Friday 2 December 2022 10:39">Friday 2 December 2022</span>. Using Julia version 1.8.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
