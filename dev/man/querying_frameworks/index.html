<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Data manipulation frameworks · DataFrames.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link rel="canonical" href="https://juliadata.github.io/DataFrames.jl/stable/man/querying_frameworks/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="DataFrames.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">DataFrames.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><a class="tocitem" href="../basics/">First Steps with DataFrames.jl</a></li><li><span class="tocitem">User Guide</span><ul><li><a class="tocitem" href="../getting_started/">Getting Started</a></li><li><a class="tocitem" href="../working_with_dataframes/">Working with DataFrames</a></li><li><a class="tocitem" href="../importing_and_exporting/">Importing and Exporting Data (I/O)</a></li><li><a class="tocitem" href="../joins/">Joins</a></li><li><a class="tocitem" href="../split_apply_combine/">Split-apply-combine</a></li><li><a class="tocitem" href="../reshaping_and_pivoting/">Reshaping</a></li><li><a class="tocitem" href="../sorting/">Sorting</a></li><li><a class="tocitem" href="../categorical/">Categorical Data</a></li><li><a class="tocitem" href="../missing/">Missing Data</a></li><li class="is-active"><a class="tocitem" href>Data manipulation frameworks</a><ul class="internal"><li><a class="tocitem" href="#DataFramesMeta.jl"><span>DataFramesMeta.jl</span></a></li><li><a class="tocitem" href="#Query.jl"><span>Query.jl</span></a></li></ul></li><li><a class="tocitem" href="../comparisons/">Comparison with Python/R/Stata</a></li></ul></li><li><span class="tocitem">API</span><ul><li><a class="tocitem" href="../../lib/types/">Types</a></li><li><a class="tocitem" href="../../lib/functions/">Functions</a></li><li><a class="tocitem" href="../../lib/indexing/">Indexing</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">User Guide</a></li><li class="is-active"><a href>Data manipulation frameworks</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Data manipulation frameworks</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaData/DataFrames.jl/blob/main/docs/src/man/querying_frameworks.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Data-manipulation-frameworks"><a class="docs-heading-anchor" href="#Data-manipulation-frameworks">Data manipulation frameworks</a><a id="Data-manipulation-frameworks-1"></a><a class="docs-heading-anchor-permalink" href="#Data-manipulation-frameworks" title="Permalink"></a></h1><p>Two popular frameworks provide convenience methods to manipulate <code>DataFrame</code>s: DataFramesMeta.jl and Query.jl. They implement a functionality similar to <a href="https://dplyr.tidyverse.org/">dplyr</a> or <a href="https://en.wikipedia.org/wiki/Language_Integrated_Query">LINQ</a>.</p><h2 id="DataFramesMeta.jl"><a class="docs-heading-anchor" href="#DataFramesMeta.jl">DataFramesMeta.jl</a><a id="DataFramesMeta.jl-1"></a><a class="docs-heading-anchor-permalink" href="#DataFramesMeta.jl" title="Permalink"></a></h2><p>The <a href="https://github.com/JuliaStats/DataFramesMeta.jl">DataFramesMeta.jl</a> package provides a convenient yet fast macro-based interface to work with <code>DataFrame</code>s. The instructions below are for version 0.6.0 of DataFramesMeta.jl.</p><p>First install the DataFramesMeta.jl package:</p><pre><code class="language-julia hljs">using Pkg
Pkg.add(&quot;DataFramesMeta&quot;)</code></pre><p>The major benefit of the package is that it allows you to refer to columns of a <code>DataFrame</code> as <code>Symbol</code>s. Therefore instead of writing <code>verylongdataframename.variable</code> you can simply write <code>:variable</code> in expressions. Additionally you can chain a sequence of transformations of a <code>DataFrame</code> using the <code>@linq</code> macro.</p><p>When a DataFramesMeta.jl macro such as <code>@select</code>, <code>@transform</code>, <code>@by</code>, <code>@combine</code>,  <code>@where</code>, or <code>@orderby</code> is called inside a <code>@linq</code> block, you can omit the <code>@</code>. Therefore <code>transform</code> inside <code>@linq</code> is not the same as <code>transform</code> outside of a <code>@linq</code> block. </p><p>Here is a minimal example of usage of the package. Observe that we refer to names of columns using only their names and that chaining is performed using the <code>@linq</code> macro and the <code>|&gt;</code> operator:</p><pre><code class="language-julia-repl hljs">julia&gt; using DataFramesMeta

julia&gt; df = DataFrame(name=[&quot;John&quot;, &quot;Sally&quot;, &quot;Roger&quot;],
                      age=[54.0, 34.0, 79.0],
                      children=[0, 2, 4])
3×3 DataFrame
 Row │ name    age      children
     │ String  Float64  Int64
─────┼───────────────────────────
   1 │ John       54.0         0
   2 │ Sally      34.0         2
   3 │ Roger      79.0         4

julia&gt; @linq df |&gt;
           where(:age .&gt; 40) |&gt;
           select(number_of_children=:children, :name)
2×2 DataFrame
 Row │ number_of_children  name
     │ Int64               String
─────┼────────────────────────────
   1 │                  0  John
   2 │                  4  Roger</code></pre><p>In the following examples we show that DataFramesMeta.jl also supports the split-apply-combine pattern:</p><pre><code class="language-julia-repl hljs">julia&gt; df = DataFrame(key=repeat(1:3, 4), value=1:12)
12×2 DataFrame
 Row │ key    value
     │ Int64  Int64
─────┼──────────────
   1 │     1      1
   2 │     2      2
   3 │     3      3
   4 │     1      4
   5 │     2      5
   6 │     3      6
   7 │     1      7
   8 │     2      8
   9 │     3      9
  10 │     1     10
  11 │     2     11
  12 │     3     12

julia&gt; @linq df |&gt;
           where(:value .&gt; 3) |&gt;
           by(:key, min=minimum(:value), max=maximum(:value)) |&gt;
           select(:key, range=:max - :min)
3×2 DataFrame
 Row │ key    range
     │ Int64  Int64
─────┼──────────────
   1 │     1      6
   2 │     2      6
   3 │     3      6

julia&gt; @linq df |&gt;
           groupby(:key) |&gt;
           transform(value0 = :value .- minimum(:value))
12×3 DataFrame
 Row │ key    value  value0
     │ Int64  Int64  Int64
─────┼──────────────────────
   1 │     1      1       0
   2 │     2      2       0
   3 │     3      3       0
   4 │     1      4       3
   5 │     2      5       3
   6 │     3      6       3
   7 │     1      7       6
   8 │     2      8       6
   9 │     3      9       6
  10 │     1     10       9
  11 │     2     11       9
  12 │     3     12       9</code></pre><p>You can find more details about how this package can be used on the <a href="https://github.com/JuliaData/DataFramesMeta.jl">DataFramesMeta.jl GitHub page</a>.</p><h2 id="Query.jl"><a class="docs-heading-anchor" href="#Query.jl">Query.jl</a><a id="Query.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Query.jl" title="Permalink"></a></h2><p>The <a href="https://github.com/queryverse/Query.jl">Query.jl</a> package provides advanced data manipulation capabilities for <code>DataFrame</code>s (and many other data structures). This section provides a short introduction to the package, the <a href="http://www.queryverse.org/Query.jl/stable/">Query.jl documentation</a> has a more comprehensive documentation of the package. The instructions here are for version 1.0.0 of Query.jl.</p><p>To get started, install the Query.jl package:</p><pre><code class="language-julia hljs">using Pkg
Pkg.add(&quot;Query&quot;)</code></pre><p>A query is started with the <code>@from</code> macro and consists of a series of query commands. Query.jl provides commands that can filter, project, join, flatten and group data from a <code>DataFrame</code>. A query can return an iterator, or one can materialize the results of a query into a variety of data structures, including a new <code>DataFrame</code>.</p><p>A simple example of a query looks like this:</p><pre><code class="language-julia-repl hljs">julia&gt; using DataFrames, Query

julia&gt; df = DataFrame(name=[&quot;John&quot;, &quot;Sally&quot;, &quot;Roger&quot;],
                      age=[54.0, 34.0, 79.0],
                      children=[0, 2, 4])
3×3 DataFrame
 Row │ name    age      children
     │ String  Float64  Int64
─────┼───────────────────────────
   1 │ John       54.0         0
   2 │ Sally      34.0         2
   3 │ Roger      79.0         4

julia&gt; q1 = @from i in df begin
            @where i.age &gt; 40
            @select {number_of_children=i.children, i.name}
            @collect DataFrame
       end
2×2 DataFrame
 Row │ number_of_children  name
     │ Int64               String
─────┼────────────────────────────
   1 │                  0  John
   2 │                  4  Roger</code></pre><p>The query starts with the <code>@from</code> macro. The first argument <code>i</code> is the name of the range variable that will be used to refer to an individual row in later query commands. The next argument <code>df</code> is the data source that one wants to query. The <code>@where</code> command in this query will filter the source data by applying the filter condition <code>i.age &gt; 40</code>. This filters out any rows in which the <code>age</code> column is not larger than 40. The <code>@select</code> command then projects the columns of the source data onto a new column structure. The example here applies three specific modifications: 1) it only keeps a subset of the columns in the source <code>DataFrame</code>, i.e. the <code>age</code> column will not be part of the transformed data; 2) it changes the order of the two columns that are selected; and 3) it renames one of the columns that is selected from <code>children</code> to <code>number_of_children</code>. The example query uses the <code>{}</code> syntax to achieve this. A <code>{}</code> in a Query.jl expression instantiates a new <a href="https://github.com/blackrock/NamedTuples.jl">NamedTuple</a>, i.e. it is a shortcut for writing <code>@NT(number_of_children=&gt;i.children, name=&gt;i.name)</code>. The <code>@collect</code> statement determines the data structure that the query returns. In this example the results are returned as a <code>DataFrame</code>.</p><p>A query without a <code>@collect</code> statement returns a standard julia iterator that can be used with any normal julia language construct that can deal with iterators. The following code returns a julia iterator for the query results:</p><pre><code class="language-julia-repl hljs">julia&gt; q2 = @from i in df begin
                   @where i.age &gt; 40
                   @select {number_of_children=i.children, i.name}
              end; # suppress printing the iterator type
</code></pre><p>One can loop over the results using a standard julia <code>for</code> statement:</p><pre><code class="language-julia-repl hljs">julia&gt; total_children = 0
0

julia&gt; for i in q2
           global total_children += i.number_of_children
       end

julia&gt; total_children
4
</code></pre><p>Or one can use a comprehension to extract the name of a subset of rows:</p><pre><code class="language-julia-repl hljs">julia&gt; y = [i.name for i in q2 if i.number_of_children &gt; 0]
1-element Vector{String}:
 &quot;Roger&quot;
</code></pre><p>The last example (extracting only the name and applying a second filter) could of course be completely expressed as a query expression:</p><pre><code class="language-julia-repl hljs">julia&gt; q3 = @from i in df begin
            @where i.age &gt; 40 &amp;&amp; i.children &gt; 0
            @select i.name
            @collect
       end
1-element Vector{String}:
 &quot;Roger&quot;
</code></pre><p>A query that ends with a <code>@collect</code> statement without a specific type will materialize the query results into an array. Note also the difference in the <code>@select</code> statement: The previous queries all used the <code>{}</code> syntax in the <code>@select</code> statement to project results into a tabular format. The last query instead just selects a single value from each row in the <code>@select</code> statement.</p><p>These examples only scratch the surface of what one can do with <a href="https://github.com/queryverse/Query.jl">Query.jl</a>, and the interested reader is referred to the <a href="http://www.queryverse.org/Query.jl/stable/">Query.jl documentation</a> for more information.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../missing/">« Missing Data</a><a class="docs-footer-nextpage" href="../comparisons/">Comparison with Python/R/Stata »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.5 on <span class="colophon-date" title="Thursday 2 September 2021 09:10">Thursday 2 September 2021</span>. Using Julia version 1.6.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
