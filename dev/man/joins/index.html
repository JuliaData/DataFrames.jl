<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Joins · DataFrames.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link rel="canonical" href="https://juliadata.github.io/DataFrames.jl/stable/man/joins/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="DataFrames.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">DataFrames.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><a class="tocitem" href="../basics/">First Steps with DataFrames.jl</a></li><li><span class="tocitem">User Guide</span><ul><li><a class="tocitem" href="../getting_started/">Getting Started</a></li><li><a class="tocitem" href="../working_with_dataframes/">Working with DataFrames</a></li><li><a class="tocitem" href="../importing_and_exporting/">Importing and Exporting Data (I/O)</a></li><li class="is-active"><a class="tocitem" href>Joins</a><ul class="internal"><li><a class="tocitem" href="#Introduction-to-joins"><span>Introduction to joins</span></a></li><li><a class="tocitem" href="#Key-value-comparisons-and-floating-point-values"><span>Key value comparisons and floating point values</span></a></li><li><a class="tocitem" href="#Joining-on-key-columns-with-different-names"><span>Joining on key columns with different names</span></a></li><li><a class="tocitem" href="#Handling-of-duplicate-keys-and-tracking-source-data-frame"><span>Handling of duplicate keys and tracking source data frame</span></a></li><li><a class="tocitem" href="#Renaming-joined-columns"><span>Renaming joined columns</span></a></li><li><a class="tocitem" href="#Matching-missing-values-in-joins"><span>Matching missing values in joins</span></a></li><li><a class="tocitem" href="#Specifying-row-order-in-the-join-result"><span>Specifying row order in the join result</span></a></li><li><a class="tocitem" href="#In-place-left-join"><span>In-place left join</span></a></li></ul></li><li><a class="tocitem" href="../split_apply_combine/">Split-apply-combine</a></li><li><a class="tocitem" href="../reshaping_and_pivoting/">Reshaping</a></li><li><a class="tocitem" href="../sorting/">Sorting</a></li><li><a class="tocitem" href="../categorical/">Categorical Data</a></li><li><a class="tocitem" href="../missing/">Missing Data</a></li><li><a class="tocitem" href="../querying_frameworks/">Data manipulation frameworks</a></li><li><a class="tocitem" href="../comparisons/">Comparison with Python/R/Stata</a></li></ul></li><li><span class="tocitem">API</span><ul><li><a class="tocitem" href="../../lib/types/">Types</a></li><li><a class="tocitem" href="../../lib/functions/">Functions</a></li><li><a class="tocitem" href="../../lib/indexing/">Indexing</a></li><li><a class="tocitem" href="../../lib/metadata/">Metadata</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">User Guide</a></li><li class="is-active"><a href>Joins</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Joins</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaData/DataFrames.jl/blob/main/docs/src/man/joins.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Database-Style-Joins"><a class="docs-heading-anchor" href="#Database-Style-Joins">Database-Style Joins</a><a id="Database-Style-Joins-1"></a><a class="docs-heading-anchor-permalink" href="#Database-Style-Joins" title="Permalink"></a></h1><h2 id="Introduction-to-joins"><a class="docs-heading-anchor" href="#Introduction-to-joins">Introduction to joins</a><a id="Introduction-to-joins-1"></a><a class="docs-heading-anchor-permalink" href="#Introduction-to-joins" title="Permalink"></a></h2><p>We often need to combine two or more data sets together to provide a complete picture of the topic we are studying. For example, suppose that we have the following two data sets:</p><pre><code class="language-julia-repl hljs">julia&gt; using DataFrames

julia&gt; people = DataFrame(ID=[20, 40], Name=[&quot;John Doe&quot;, &quot;Jane Doe&quot;])
2×2 DataFrame
 Row │ ID     Name
     │ Int64  String
─────┼─────────────────
   1 │    20  John Doe
   2 │    40  Jane Doe

julia&gt; jobs = DataFrame(ID=[20, 40], Job=[&quot;Lawyer&quot;, &quot;Doctor&quot;])
2×2 DataFrame
 Row │ ID     Job
     │ Int64  String
─────┼───────────────
   1 │    20  Lawyer
   2 │    40  Doctor</code></pre><p>We might want to work with a larger data set that contains both the names and jobs for each ID. We can do this using the <code>innerjoin</code> function:</p><pre><code class="language-julia-repl hljs">julia&gt; innerjoin(people, jobs, on = :ID)
2×3 DataFrame
 Row │ ID     Name      Job
     │ Int64  String    String
─────┼─────────────────────────
   1 │    20  John Doe  Lawyer
   2 │    40  Jane Doe  Doctor</code></pre><p>In relational database theory, this operation is generally referred to as a join. The columns used to determine which rows should be combined during a join are called keys.</p><p>The following functions are provided to perform seven kinds of joins:</p><ul><li><code>innerjoin</code>: the output contains rows for values of the key that exist in all passed data frames.</li><li><code>leftjoin</code>: the output contains rows for values of the key that exist in the first (left) argument, whether or not that value exists in the second (right) argument.</li><li><code>rightjoin</code>: the output contains rows for values of the key that exist in the second (right) argument, whether or not that value exists in the first (left) argument.</li><li><code>outerjoin</code>: the output contains rows for values of the key that exist in any of the passed data frames.</li><li><code>semijoin</code>: Like an inner join, but output is restricted to columns from the first (left) argument.</li><li><code>antijoin</code>: The output contains rows for values of the key that exist in the first (left) but not the second (right) argument. As with <code>semijoin</code>, output is restricted to columns from the first (left) argument.</li><li><code>crossjoin</code>: The output is the cartesian product of rows from all passed data frames.</li></ul><p>See <a href="https://en.wikipedia.org/wiki/Join_(SQL)">the Wikipedia page on SQL joins</a> for more information.</p><p>Here are examples of different kinds of join:</p><pre><code class="language-julia-repl hljs">julia&gt; jobs = DataFrame(ID=[20, 60], Job=[&quot;Lawyer&quot;, &quot;Astronaut&quot;])
2×2 DataFrame
 Row │ ID     Job
     │ Int64  String
─────┼──────────────────
   1 │    20  Lawyer
   2 │    60  Astronaut

julia&gt; innerjoin(people, jobs, on = :ID)
1×3 DataFrame
 Row │ ID     Name      Job
     │ Int64  String    String
─────┼─────────────────────────
   1 │    20  John Doe  Lawyer

julia&gt; leftjoin(people, jobs, on = :ID)
2×3 DataFrame
 Row │ ID     Name      Job
     │ Int64  String    String?
─────┼──────────────────────────
   1 │    20  John Doe  Lawyer
   2 │    40  Jane Doe  missing

julia&gt; rightjoin(people, jobs, on = :ID)
2×3 DataFrame
 Row │ ID     Name      Job
     │ Int64  String?   String
─────┼────────────────────────────
   1 │    20  John Doe  Lawyer
   2 │    60  missing   Astronaut

julia&gt; outerjoin(people, jobs, on = :ID)
3×3 DataFrame
 Row │ ID     Name      Job
     │ Int64  String?   String?
─────┼────────────────────────────
   1 │    20  John Doe  Lawyer
   2 │    40  Jane Doe  missing
   3 │    60  missing   Astronaut

julia&gt; semijoin(people, jobs, on = :ID)
1×2 DataFrame
 Row │ ID     Name
     │ Int64  String
─────┼─────────────────
   1 │    20  John Doe

julia&gt; antijoin(people, jobs, on = :ID)
1×2 DataFrame
 Row │ ID     Name
     │ Int64  String
─────┼─────────────────
   1 │    40  Jane Doe</code></pre><p>Cross joins are the only kind of join that does not use a <code>on</code> key:</p><pre><code class="language-julia-repl hljs">julia&gt; crossjoin(people, jobs, makeunique = true)
4×4 DataFrame
 Row │ ID     Name      ID_1   Job
     │ Int64  String    Int64  String
─────┼───────────────────────────────────
   1 │    20  John Doe     20  Lawyer
   2 │    20  John Doe     60  Astronaut
   3 │    40  Jane Doe     20  Lawyer
   4 │    40  Jane Doe     60  Astronaut</code></pre><h2 id="Key-value-comparisons-and-floating-point-values"><a class="docs-heading-anchor" href="#Key-value-comparisons-and-floating-point-values">Key value comparisons and floating point values</a><a id="Key-value-comparisons-and-floating-point-values-1"></a><a class="docs-heading-anchor-permalink" href="#Key-value-comparisons-and-floating-point-values" title="Permalink"></a></h2><p>Key values from the two or more data frames are compared using the <code>isequal</code> function. This is consistent with the <code>Set</code> and <code>Dict</code> types in Julia Base.</p><p>It is not recommended to use floating point numbers as keys: floating point comparisons can be surprising and unpredictable. If you do use floating point keys, note that by default an error is raised when keys include <code>-0.0</code> (negative zero) or <code>NaN</code> values. Here is an example:</p><pre><code class="language-julia-repl hljs">julia&gt; innerjoin(DataFrame(id=[-0.0]), DataFrame(id=[0.0]), on=:id)
ERROR: ArgumentError: Currently for numeric values `NaN` and `-0.0` in their real or imaginary components are not allowed. Such value was found in column :id in left data frame. Use CategoricalArrays.jl to wrap these values in a CategoricalVector to perform the requested join.</code></pre><p>This can be overridden by wrapping the key values in a <a href="../categorical/#man-categorical">categorical</a> vector.</p><h2 id="Joining-on-key-columns-with-different-names"><a class="docs-heading-anchor" href="#Joining-on-key-columns-with-different-names">Joining on key columns with different names</a><a id="Joining-on-key-columns-with-different-names-1"></a><a class="docs-heading-anchor-permalink" href="#Joining-on-key-columns-with-different-names" title="Permalink"></a></h2><p>In order to join data frames on keys which have different names in the left and right tables, you may pass <code>left =&gt; right</code> pairs as <code>on</code> argument:</p><pre><code class="language-julia-repl hljs">julia&gt; a = DataFrame(ID=[20, 40], Name=[&quot;John Doe&quot;, &quot;Jane Doe&quot;])
2×2 DataFrame
 Row │ ID     Name
     │ Int64  String
─────┼─────────────────
   1 │    20  John Doe
   2 │    40  Jane Doe

julia&gt; b = DataFrame(IDNew=[20, 40], Job=[&quot;Lawyer&quot;, &quot;Doctor&quot;])
2×2 DataFrame
 Row │ IDNew  Job
     │ Int64  String
─────┼───────────────
   1 │    20  Lawyer
   2 │    40  Doctor

julia&gt; innerjoin(a, b, on = :ID =&gt; :IDNew)
2×3 DataFrame
 Row │ ID     Name      Job
     │ Int64  String    String
─────┼─────────────────────────
   1 │    20  John Doe  Lawyer
   2 │    40  Jane Doe  Doctor</code></pre><p>Here is another example with multiple columns:</p><pre><code class="language-julia-repl hljs">julia&gt; a = DataFrame(City=[&quot;Amsterdam&quot;, &quot;London&quot;, &quot;London&quot;, &quot;New York&quot;, &quot;New York&quot;],
                     Job=[&quot;Lawyer&quot;, &quot;Lawyer&quot;, &quot;Lawyer&quot;, &quot;Doctor&quot;, &quot;Doctor&quot;],
                     Category=[1, 2, 3, 4, 5])
5×3 DataFrame
 Row │ City       Job     Category
     │ String     String  Int64
─────┼─────────────────────────────
   1 │ Amsterdam  Lawyer         1
   2 │ London     Lawyer         2
   3 │ London     Lawyer         3
   4 │ New York   Doctor         4
   5 │ New York   Doctor         5

julia&gt; b = DataFrame(Location=[&quot;Amsterdam&quot;, &quot;London&quot;, &quot;London&quot;, &quot;New York&quot;, &quot;New York&quot;],
                     Work=[&quot;Lawyer&quot;, &quot;Lawyer&quot;, &quot;Lawyer&quot;, &quot;Doctor&quot;, &quot;Doctor&quot;],
                     Name=[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;])
5×3 DataFrame
 Row │ Location   Work    Name
     │ String     String  String
─────┼───────────────────────────
   1 │ Amsterdam  Lawyer  a
   2 │ London     Lawyer  b
   3 │ London     Lawyer  c
   4 │ New York   Doctor  d
   5 │ New York   Doctor  e

julia&gt; innerjoin(a, b, on = [:City =&gt; :Location, :Job =&gt; :Work])
9×4 DataFrame
 Row │ City       Job     Category  Name
     │ String     String  Int64     String
─────┼─────────────────────────────────────
   1 │ Amsterdam  Lawyer         1  a
   2 │ London     Lawyer         2  b
   3 │ London     Lawyer         3  b
   4 │ London     Lawyer         2  c
   5 │ London     Lawyer         3  c
   6 │ New York   Doctor         4  d
   7 │ New York   Doctor         5  d
   8 │ New York   Doctor         4  e
   9 │ New York   Doctor         5  e</code></pre><h2 id="Handling-of-duplicate-keys-and-tracking-source-data-frame"><a class="docs-heading-anchor" href="#Handling-of-duplicate-keys-and-tracking-source-data-frame">Handling of duplicate keys and tracking source data frame</a><a id="Handling-of-duplicate-keys-and-tracking-source-data-frame-1"></a><a class="docs-heading-anchor-permalink" href="#Handling-of-duplicate-keys-and-tracking-source-data-frame" title="Permalink"></a></h2><p>Additionally, notice that in the last join rows 2 and 3 had the same values on <code>on</code> variables in both joined <code>DataFrame</code>s. In such a situation <code>innerjoin</code>, <code>outerjoin</code>, <code>leftjoin</code> and <code>rightjoin</code> will produce all combinations of matching rows. In our example rows from 2 to 5 were created as a result. The same behavior can be observed for rows 4 and 5 in both joined <code>DataFrame</code>s.</p><p>In order to check that columns passed as the <code>on</code> argument define unique keys (according to <code>isequal</code>) in each input data frame you can set the <code>validate</code> keyword argument to a two-element tuple or a pair of <code>Bool</code> values, with each element indicating whether to run check for the corresponding data frame. Here is an example for the join operation described above:</p><pre><code class="language-julia-repl hljs">julia&gt; innerjoin(a, b, on = [(:City =&gt; :Location), (:Job =&gt; :Work)], validate=(true, true))
ERROR: ArgumentError: Merge key(s) are not unique in both df1 and df2. df1 contains 2 duplicate keys: (City = &quot;London&quot;, Job = &quot;Lawyer&quot;) and (City = &quot;New York&quot;, Job = &quot;Doctor&quot;). df2 contains 2 duplicate keys: (Location = &quot;London&quot;, Work = &quot;Lawyer&quot;) and (Location = &quot;New York&quot;, Work = &quot;Doctor&quot;).</code></pre><p>Finally, using the <code>source</code> keyword argument you can add a column to the resulting data frame indicating whether the given row appeared only in the left, the right or both data frames. Here is an example:</p><pre><code class="language-julia-repl hljs">julia&gt; a = DataFrame(ID=[20, 40], Name=[&quot;John&quot;, &quot;Jane&quot;])
2×2 DataFrame
 Row │ ID     Name
     │ Int64  String
─────┼───────────────
   1 │    20  John
   2 │    40  Jane

julia&gt; b = DataFrame(ID=[20, 60], Job=[&quot;Lawyer&quot;, &quot;Doctor&quot;])
2×2 DataFrame
 Row │ ID     Job
     │ Int64  String
─────┼───────────────
   1 │    20  Lawyer
   2 │    60  Doctor

julia&gt; outerjoin(a, b, on=:ID, validate=(true, true), source=:source)
3×4 DataFrame
 Row │ ID     Name     Job      source
     │ Int64  String?  String?  String
─────┼─────────────────────────────────────
   1 │    20  John     Lawyer   both
   2 │    40  Jane     missing  left_only
   3 │    60  missing  Doctor   right_only</code></pre><p>Note that this time we also used the <code>validate</code> keyword argument and it did not produce errors as the keys defined in both source data frames were unique.</p><h2 id="Renaming-joined-columns"><a class="docs-heading-anchor" href="#Renaming-joined-columns">Renaming joined columns</a><a id="Renaming-joined-columns-1"></a><a class="docs-heading-anchor-permalink" href="#Renaming-joined-columns" title="Permalink"></a></h2><p>Often you want to keep track of the source data frame. This feature is supported with the <code>renamecols</code> keyword argument:</p><pre><code class="language-julia-repl hljs">julia&gt; innerjoin(a, b, on=:ID, renamecols = &quot;_left&quot; =&gt; &quot;_right&quot;)
1×3 DataFrame
 Row │ ID     Name_left  Job_right
     │ Int64  String     String
─────┼─────────────────────────────
   1 │    20  John       Lawyer</code></pre><p>In the above example we added the <code>&quot;_left&quot;</code> suffix to the non-key columns from the left table and the <code>&quot;_right&quot;</code> suffix to the non-key columns from the right table.</p><p>Alternatively it is allowed to pass a function transforming column names:</p><pre><code class="language-julia-repl hljs">julia&gt; innerjoin(a, b, on=:ID, renamecols = lowercase =&gt; uppercase)
1×3 DataFrame
 Row │ ID     name    JOB
     │ Int64  String  String
─────┼───────────────────────
   1 │    20  John    Lawyer
</code></pre><h2 id="Matching-missing-values-in-joins"><a class="docs-heading-anchor" href="#Matching-missing-values-in-joins">Matching missing values in joins</a><a id="Matching-missing-values-in-joins-1"></a><a class="docs-heading-anchor-permalink" href="#Matching-missing-values-in-joins" title="Permalink"></a></h2><p>By default when you try to to perform a join on a key that has <code>missing</code> values you get an error:</p><pre><code class="language-julia-repl hljs">julia&gt; df1 = DataFrame(id=[1, missing, 3], a=1:3)
3×2 DataFrame
 Row │ id       a
     │ Int64?   Int64
─────┼────────────────
   1 │       1      1
   2 │ missing      2
   3 │       3      3

julia&gt; df2 = DataFrame(id=[1, 2, missing], b=1:3)
3×2 DataFrame
 Row │ id       b
     │ Int64?   Int64
─────┼────────────────
   1 │       1      1
   2 │       2      2
   3 │ missing      3

julia&gt; innerjoin(df1, df2, on=:id)
ERROR: ArgumentError: Missing values in key columns are not allowed when matchmissing == :error. `missing` found in column :id in left data frame.</code></pre><p>If you would prefer <code>missing</code> values to be treated as equal pass the <code>matchmissing=:equal</code> keyword argument:</p><pre><code class="language-julia-repl hljs">julia&gt; innerjoin(df1, df2, on=:id, matchmissing=:equal)
2×3 DataFrame
 Row │ id       a      b
     │ Int64?   Int64  Int64
─────┼───────────────────────
   1 │       1      1      1
   2 │ missing      2      3</code></pre><p>Alternatively you might want to drop all rows with <code>missing</code> values. In this case pass <code>matchmissing=:notequal</code>:</p><pre><code class="language-julia-repl hljs">julia&gt; innerjoin(df1, df2, on=:id, matchmissing=:notequal)
1×3 DataFrame
 Row │ id      a      b
     │ Int64?  Int64  Int64
─────┼──────────────────────
   1 │      1      1      1</code></pre><h2 id="Specifying-row-order-in-the-join-result"><a class="docs-heading-anchor" href="#Specifying-row-order-in-the-join-result">Specifying row order in the join result</a><a id="Specifying-row-order-in-the-join-result-1"></a><a class="docs-heading-anchor-permalink" href="#Specifying-row-order-in-the-join-result" title="Permalink"></a></h2><p>By default the order of rows produced by the join operation is undefined:</p><pre><code class="language-julia-repl hljs">julia&gt; df_left = DataFrame(id=[1, 2, 4, 5], left=1:4)
4×2 DataFrame
 Row │ id     left
     │ Int64  Int64
─────┼──────────────
   1 │     1      1
   2 │     2      2
   3 │     4      3
   4 │     5      4

julia&gt; df_right = DataFrame(id=[2, 1, 3, 6, 7], right=1:5)
5×2 DataFrame
 Row │ id     right
     │ Int64  Int64
─────┼──────────────
   1 │     2      1
   2 │     1      2
   3 │     3      3
   4 │     6      4
   5 │     7      5

julia&gt; outerjoin(df_left, df_right, on=:id)
7×3 DataFrame
 Row │ id     left     right
     │ Int64  Int64?   Int64?
─────┼─────────────────────────
   1 │     2        2        1
   2 │     1        1        2
   3 │     4        3  missing
   4 │     5        4  missing
   5 │     3  missing        3
   6 │     6  missing        4
   7 │     7  missing        5</code></pre><p>If you would like the result to keep the row order of the left table pass the <code>order=:left</code> keyword argument:</p><pre><code class="language-julia-repl hljs">julia&gt; outerjoin(df_left, df_right, on=:id, order=:left)
7×3 DataFrame
 Row │ id     left     right
     │ Int64  Int64?   Int64?
─────┼─────────────────────────
   1 │     1        1        2
   2 │     2        2        1
   3 │     4        3  missing
   4 │     5        4  missing
   5 │     3  missing        3
   6 │     6  missing        4
   7 │     7  missing        5</code></pre><p>Note that in this case keys missing from the left table are put after the keys present in it.</p><p>Similarly <code>order=:right</code> keeps the order of the right table (and puts keys not present in it at the end):</p><pre><code class="language-julia-repl hljs">julia&gt; outerjoin(df_left, df_right, on=:id, order=:right)
7×3 DataFrame
 Row │ id     left     right
     │ Int64  Int64?   Int64?
─────┼─────────────────────────
   1 │     2        2        1
   2 │     1        1        2
   3 │     3  missing        3
   4 │     6  missing        4
   5 │     7  missing        5
   6 │     4        3  missing
   7 │     5        4  missing</code></pre><h2 id="In-place-left-join"><a class="docs-heading-anchor" href="#In-place-left-join">In-place left join</a><a id="In-place-left-join-1"></a><a class="docs-heading-anchor-permalink" href="#In-place-left-join" title="Permalink"></a></h2><p>A common operation is adding data from a reference table to some main table. It is possible to perform such an in-place update using the <code>leftjoin!</code> function. In this case the left table is updated in place with matching rows from the right table.</p><pre><code class="language-julia-repl hljs">julia&gt; main = DataFrame(id=1:4, main=1:4)
4×2 DataFrame
 Row │ id     main
     │ Int64  Int64
─────┼──────────────
   1 │     1      1
   2 │     2      2
   3 │     3      3
   4 │     4      4

julia&gt; leftjoin!(main, DataFrame(id=[2, 4], info=[&quot;a&quot;, &quot;b&quot;]), on=:id);

julia&gt; main
4×3 DataFrame
 Row │ id     main   info
     │ Int64  Int64  String?
─────┼───────────────────────
   1 │     1      1  missing
   2 │     2      2  a
   3 │     3      3  missing
   4 │     4      4  b</code></pre><p>Note that in this case the order and number of rows in the left table is not changed. Therefore, in particular, it is not allowed to have duplicate keys in the right table:</p><pre><code class="nohighlight hljs">julia&gt; leftjoin!(main, DataFrame(id=[2, 2], info_bad=[&quot;a&quot;, &quot;b&quot;]), on=:id)
ERROR: ArgumentError: duplicate rows found in right table</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../importing_and_exporting/">« Importing and Exporting Data (I/O)</a><a class="docs-footer-nextpage" href="../split_apply_combine/">Split-apply-combine »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Saturday 21 October 2023 17:37">Saturday 21 October 2023</span>. Using Julia version 1.9.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
