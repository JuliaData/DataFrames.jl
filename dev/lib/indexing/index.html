<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Indexing · DataFrames.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link rel="canonical" href="https://juliadata.github.io/DataFrames.jl/stable/lib/indexing/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="DataFrames.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">DataFrames.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><span class="tocitem">User Guide</span><ul><li><a class="tocitem" href="../../man/getting_started/">Getting Started</a></li><li><a class="tocitem" href="../../man/working_with_dataframes/">Working with DataFrames</a></li><li><a class="tocitem" href="../../man/importing_and_exporting/">Importing and Exporting Data (I/O)</a></li><li><a class="tocitem" href="../../man/joins/">Joins</a></li><li><a class="tocitem" href="../../man/split_apply_combine/">Split-apply-combine</a></li><li><a class="tocitem" href="../../man/reshaping_and_pivoting/">Reshaping</a></li><li><a class="tocitem" href="../../man/sorting/">Sorting</a></li><li><a class="tocitem" href="../../man/categorical/">Categorical Data</a></li><li><a class="tocitem" href="../../man/missing/">Missing Data</a></li><li><a class="tocitem" href="../../man/querying_frameworks/">Data manipulation frameworks</a></li><li><a class="tocitem" href="../../man/comparisons/">Comparison with Python/R/Stata</a></li></ul></li><li><span class="tocitem">API</span><ul><li><a class="tocitem" href="../types/">Types</a></li><li><a class="tocitem" href="../functions/">Functions</a></li><li class="is-active"><a class="tocitem" href>Indexing</a><ul class="internal"><li><a class="tocitem" href="#General-rules"><span>General rules</span></a></li><li><a class="tocitem" href="#getindex-and-view"><span><code>getindex</code> and <code>view</code></span></a></li><li><a class="tocitem" href="#setindex!"><span><code>setindex!</code></span></a></li><li><a class="tocitem" href="#Broadcasting"><span>Broadcasting</span></a></li><li><a class="tocitem" href="#Indexing-GroupedDataFrames"><span>Indexing <code>GroupedDataFrame</code>s</span></a></li><li class="toplevel"><a class="tocitem" href="#Common-API-for-types-defined-in-DataFrames.jl"><span>Common API for types defined in DataFrames.jl</span></a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">API</a></li><li class="is-active"><a href>Indexing</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Indexing</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaData/DataFrames.jl/blob/main/docs/src/lib/indexing.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Indexing"><a class="docs-heading-anchor" href="#Indexing">Indexing</a><a id="Indexing-1"></a><a class="docs-heading-anchor-permalink" href="#Indexing" title="Permalink"></a></h1><ul></ul><h2 id="General-rules"><a class="docs-heading-anchor" href="#General-rules">General rules</a><a id="General-rules-1"></a><a class="docs-heading-anchor-permalink" href="#General-rules" title="Permalink"></a></h2><p>The following rules explain target functionality of how <code>getindex</code>, <code>setindex!</code>, <code>view</code>, and broadcasting are intended to work with <code>DataFrame</code>, <code>SubDataFrame</code> and <code>DataFrameRow</code> objects.</p><p>The rules for a valid type of index into a column are the following:</p><ul><li>a value, later denoted as <code>col</code>:<ul><li>a <code>Symbol</code>;</li><li>an <code>AbstractString</code>;</li><li>an <code>Integer</code> that is not <code>Bool</code>;</li></ul></li><li>a vector, later denoted as <code>cols</code>:<ul><li>a vector of <code>Symbol</code> (does not have to be a subtype of <code>AbstractVector{Symbol}</code>);</li><li>a vector of <code>AbstractString</code> (does not have to be a subtype of <code>AbstractVector{&lt;:AbstractString}</code>);</li><li>a vector of <code>Integer</code> other than <code>Bool</code> (does not have to be a subtype of <code>AbstractVector{&lt;:Integer}</code>);</li><li>a vector of <code>Bool</code> that has to be a subtype of <code>AbstractVector{Bool}</code>;</li><li>a regular expression, which gets expanded to a vector of matching column names;</li><li>a <code>Not</code> expression (see <a href="https://github.com/mbauman/InvertedIndices.jl">InvertedIndices.jl</a>);</li><li>an <code>Cols</code>, <code>All</code> or <code>Between</code> expression (see <a href="https://github.com/JuliaData/DataAPI.jl">DataAPI.jl</a>);</li><li>a colon literal <code>:</code>.</li></ul></li></ul><p>The rules for a valid type of index into a row are the following:</p><ul><li>a value, later denoted as <code>row</code>:<ul><li>an <code>Integer</code> that is not <code>Bool</code>;</li></ul></li><li>a vector, later denoted as <code>rows</code>:<ul><li>a vector of <code>Integer</code> other than <code>Bool</code> (does not have to be a subtype of <code>AbstractVector{&lt;:Integer}</code>);</li><li>a vector of <code>Bool</code> that has to be a subtype of <code>AbstractVector{Bool}</code>;</li><li>a <code>Not</code> expression;</li><li>a colon literal <code>:</code>;</li></ul></li><li>an exclamation mark <code>!</code>.</li></ul><p>Additionally it is allowed to index into an <code>AbstractDataFrame</code> using a two-dimensional <code>CartesianIndex</code>.</p><p>In the descriptions below <code>df</code> represents a <code>DataFrame</code>, <code>sdf</code> is a <code>SubDataFrame</code> and <code>dfr</code> is a <code>DataFrameRow</code>.</p><p><code>:</code> always expands to <code>axes(df, 1)</code> or <code>axes(sdf, 1)</code>.</p><p><code>df.col</code> works like <code>df[!, col]</code> and <code>sdf.col</code> works like <code>sdf[!, col]</code> in all cases except that <code>df.col .= v</code> and <code>sdf.col .= v</code> perform in-place broadcasting if <code>col</code> is present in <code>df</code>/<code>sdf</code> and is a valid identifier.</p><h2 id="getindex-and-view"><a class="docs-heading-anchor" href="#getindex-and-view"><code>getindex</code> and <code>view</code></a><a id="getindex-and-view-1"></a><a class="docs-heading-anchor-permalink" href="#getindex-and-view" title="Permalink"></a></h2><p>The following list specifies the behavior of <code>getindex</code> and <code>view</code> operations depending on argument types.</p><p>In particular a description explicitly mentions that the data is <em>copied</em> or <em>reused without copying</em>.</p><p>For performance reasons, accessing, via <code>getindex</code> or <code>view</code>, a single <code>row</code> and multiple <code>cols</code> of a <code>DataFrame</code>, a <code>SubDataFrame</code> or a <code>DataFrameRow</code> always returns a <code>DataFrameRow</code> (which is a view type).</p><p><code>getindex</code> on <code>DataFrame</code>:</p><ul><li><code>df[row, col]</code> -&gt; the value contained in row <code>row</code> of column <code>col</code>, the same as <code>df[!, col][row]</code>;</li><li><code>df[CartesianIndex(row, col)]</code> -&gt; the same as <code>df[row, col]</code>;</li><li><code>df[row, cols]</code> -&gt; a <code>DataFrameRow</code> with parent <code>df</code>;</li><li><code>df[rows, col]</code> -&gt; a copy of the vector <code>df[!, col]</code> with only the entries corresponding to <code>rows</code> selected,                    the same as <code>df[!, col][rows]</code>;</li><li><code>df[rows, cols]</code> -&gt; a <code>DataFrame</code> containing copies of columns <code>cols</code> with only the entries corresponding to <code>rows</code> selected;</li><li><code>df[!, col]</code> -&gt; the vector contained in column <code>col</code> returned without copying; the same as <code>df.col</code> if <code>col</code> is a valid identifier.</li><li><code>df[!, cols]</code> -&gt; create a new <code>DataFrame</code> with columns <code>cols</code> without copying of columns;                  the same as <code>select(df, cols, copycols=false)</code>.</li></ul><p><code>view</code> on <code>DataFrame</code>:</p><ul><li><code>@view df[row, col]</code> -&gt; a <code>0</code>-dimensional view into <code>df[!, col]</code> in row <code>row</code>, the same as <code>view(df[!, col], row)</code>;</li><li><code>@view df[CartesianIndex(row, col)]</code> -&gt; the same as <code>@view df[row, col]</code>;</li><li><code>@view df[row, cols]</code> -&gt; the same as <code>df[row, cols]</code>;</li><li><code>@view df[rows, col]</code> -&gt; a view into <code>df[!, col]</code> with <code>rows</code> selected, the same as <code>view(df[!, col], rows)</code>;</li><li><code>@view df[rows, cols]</code> -&gt; a <code>SubDataFrame</code> with <code>rows</code> selected with parent <code>df</code>;</li><li><code>@view df[!, col]</code> -&gt; a view into <code>df[!, col]</code>  with all rows.</li><li><code>@view df[!, cols]</code> -&gt; the same as <code>@view df[:, cols]</code>.</li></ul><p><code>getindex</code> on <code>SubDataFrame</code>:</p><ul><li><code>sdf[row, col]</code> -&gt; a value contained in row <code>row</code> of column <code>col</code>;</li><li><code>sdf[CartesianIndex(row, col)]</code> -&gt; the same as <code>sdf[row, col]</code>;</li><li><code>sdf[row, cols]</code> -&gt; a <code>DataFrameRow</code> with parent <code>parent(sdf)</code>;</li><li><code>sdf[rows, col]</code> -&gt; a copy of <code>sdf[!, col]</code> with only rows <code>rows</code> selected, the same as <code>sdf[!, col][rows]</code>;</li><li><code>sdf[rows, cols]</code> -&gt; a <code>DataFrame</code> containing columns <code>cols</code> and <code>sdf[rows, col]</code> as a vector for each <code>col</code> in <code>cols</code>;</li><li><code>sdf[!, col]</code> -&gt; a view of entries corresponding to <code>sdf</code> in the vector <code>parent(sdf)[!, col]</code>;                  the same as <code>sdf.col</code> if <code>col</code> is a valid identifier.</li><li><code>sdf[!, cols]</code> -&gt; create a new <code>SubDataFrame</code> with columns <code>cols</code>, the same parent as <code>sdf</code>, and the same rows selected;                   the same as <code>select(sdf, cols, copycols=false)</code>.</li></ul><p><code>view</code> on <code>SubDataFrame</code>:</p><ul><li><code>@view sdf[row, col]</code> -&gt; a <code>0</code>-dimensional view into <code>df[!, col]</code> at row <code>row</code>, the same as <code>view(sdf[!, col], row)</code>;</li><li><code>@view sdf[CartesianIndex(row, col)]</code> -&gt; the same as <code>@view sdf[row, col]</code>;</li><li><code>@view sdf[row, cols]</code> -&gt; a <code>DataFrameRow</code> with parent <code>parent(sdf)</code>;</li><li><code>@view sdf[rows, col]</code> -&gt; a view into <code>sdf[!, col]</code> vector with <code>rows</code> selected, the same as <code>view(sdf[!, col], rows)</code>;</li><li><code>@view sdf[rows, cols]</code> -&gt; a <code>SubDataFrame</code> with parent <code>parent(sdf)</code>;</li><li><code>@view sdf[!, col]</code> -&gt; a view into <code>sdf[!, col]</code> vector with all rows.</li><li><code>@view sdf[!, cols]</code> -&gt; the same as <code>@view sdf[:, cols]</code>.</li></ul><p><code>getindex</code> on <code>DataFrameRow</code>:</p><ul><li><code>dfr[col]</code> -&gt; the value contained in column <code>col</code> of <code>dfr</code>; the same as <code>dfr.col</code> if <code>col</code> is a valid identifier;</li><li><code>dfr[cols]</code> -&gt; a <code>DataFrameRow</code> with parent <code>parent(dfr)</code>;</li></ul><p><code>view</code> on <code>DataFrameRow</code>:</p><ul><li><code>@view dfr[col]</code> -&gt; a <code>0</code>-dimensional view into <code>parent(dfr)[DataFrames.row(dfr), col]</code>;</li><li><code>@view dfr[cols]</code> -&gt; a <code>DataFrameRow</code> with parent <code>parent(dfr)</code>;</li></ul><p>Note that views created with columns selector set to <code>:</code> change their columns&#39; count if columns are added/removed/renamed in the parent; if column selector is other than <code>:</code> then view points to selected columns by their number at the moment of creation of the view.</p><h2 id="setindex!"><a class="docs-heading-anchor" href="#setindex!"><code>setindex!</code></a><a id="setindex!-1"></a><a class="docs-heading-anchor-permalink" href="#setindex!" title="Permalink"></a></h2><p>The following list specifies the behavior of <code>setindex!</code> operations depending on argument types.</p><p>In particular a description explicitly mentions if the assignment is <em>in-place</em>.</p><p>Note that if a <code>setindex!</code> operation throws an error the target data frame may be partially changed so it is unsafe to use it afterwards (the column length correctness will be preserved).</p><p><code>setindex!</code> on <code>DataFrame</code>:</p><ul><li><code>df[row, col] = v</code> -&gt; set value of <code>col</code> in row <code>row</code> to <code>v</code> in-place;</li><li><code>df[CartesianIndex(row, col)] = v</code> -&gt; the same as <code>df[row, col] = v</code>;</li><li><code>df[row, cols] = v</code> -&gt; set row <code>row</code> of columns <code>cols</code> in-place; the same as <code>dfr = df[row, cols]; dfr[:] = v</code>;</li><li><code>df[rows, col] = v</code> -&gt; set rows <code>rows</code> of column <code>col</code> in-place; <code>v</code> must be an <code>AbstractVector</code>;                        if <code>rows</code> is <code>:</code> and <code>col</code> is a <code>Symbol</code> or <code>AbstractString</code>                        that is not present in <code>df</code> then a new column in <code>df</code> is created and holds a <code>copy</code> of <code>v</code>; equivalent to <code>df.col = copy(v)</code> if <code>col</code> is a valid identifier;</li><li><code>df[rows, cols] = v</code> -&gt; set rows <code>rows</code> of columns <code>cols</code> in-place; <code>v</code> must be an <code>AbstractMatrix</code> or an <code>AbstractDataFrame</code>                     (in this case column names must match);</li><li><code>df[!, col] = v</code> -&gt; replaces <code>col</code> with <code>v</code> without copying                     (with the exception that if <code>v</code> is an <code>AbstractRange</code> it gets converted to a <code>Vector</code>);                     also if <code>col</code> is a <code>Symbol</code> or <code>AbstractString</code> that is not present in <code>df</code> then                     a new column in <code>df</code> is created and holds <code>v</code>;                     equivalent to <code>df.col = v</code> if <code>col</code> is a valid identifier;                     this is allowed if <code>ncol(df) == 0 || length(v) == nrow(df)</code>;</li><li><code>df[!, cols] = v</code> -&gt; replaces existing columns <code>cols</code> in data frame <code>df</code> with copying;                      <code>v</code> must be an <code>AbstractMatrix</code> or an <code>AbstractDataFrame</code>                      (in the latter case column names must match);</li></ul><p><code>setindex!</code> on <code>SubDataFrame</code>:</p><ul><li><code>sdf[row, col] = v</code> -&gt; set value of <code>col</code> in row <code>row</code> to <code>v</code> in-place;</li><li><code>sdf[CartesianIndex(row, col)] = v</code> -&gt; the same as <code>sdf[row, col] = v</code>;</li><li><code>sdf[row, cols] = v</code> -&gt; the same as <code>dfr = df[row, cols]; dfr[:] = v</code> in-place;</li><li><code>sdf[rows, col] = v</code> -&gt; set rows <code>rows</code> of column <code>col</code>, in-place; <code>v</code> must be an abstract vector;</li><li><code>sdf[rows, cols] = v</code> -&gt; set rows <code>rows</code> of columns <code>cols</code> in-place;                          <code>v</code> can be an <code>AbstractMatrix</code> or <code>v</code> can be <code>AbstractDataFrame</code> when column names must match;</li></ul><p>Note that <code>sdf[!, col] = v</code>, <code>sdf[!, cols] = v</code> and <code>sdf.col = v</code> are not allowed as <code>sdf</code> can be only modified in-place.</p><p><code>setindex!</code> on <code>DataFrameRow</code>:</p><ul><li><code>dfr[col] = v</code> -&gt; set value of <code>col</code> in row <code>row</code> to <code>v</code> in-place;                   equivalent to <code>dfr.col = v</code> if <code>col</code> is a valid identifier;</li><li><code>dfr[cols] = v</code> -&gt; set values of entries in columns <code>cols</code> in <code>dfr</code> by elements of <code>v</code> in place;                    <code>v</code> can be:                    1) a <code>Tuple</code> or an <code>AbstractArray</code>,                       in which cases it must have a number of elements equal to <code>length(dfr)</code>,                    2) an <code>AbstractDict</code>, in which case column names must match,                    3) a <code>NamedTuple</code> or <code>DataFrameRow</code>, in which case column names and order must match;</li></ul><h2 id="Broadcasting"><a class="docs-heading-anchor" href="#Broadcasting">Broadcasting</a><a id="Broadcasting-1"></a><a class="docs-heading-anchor-permalink" href="#Broadcasting" title="Permalink"></a></h2><p>The following broadcasting rules apply to <code>AbstractDataFrame</code> objects:</p><ul><li><code>AbstractDataFrame</code> behaves in broadcasting like a two-dimensional collection compatible with matrices.</li><li>If an <code>AbstractDataFrame</code> takes part in broadcasting then a <code>DataFrame</code> is always produced as a result. In this case the requested broadcasting operation produces an object with exactly two dimensions. An exception is when an <code>AbstractDataFrame</code> is used only as a source of broadcast assignment into an object of dimensionality higher than two.</li><li>If multiple <code>AbstractDataFrame</code> objects take part in broadcasting then they have to have identical column names.</li></ul><p>Note that if broadcasting assignment operation throws an error the target data frame may be partially changed so it is unsafe to use it afterwards (the column length correctness will be preserved).</p><p>Broadcasting <code>DataFrameRow</code> is currently not allowed (which is consistent with <code>NamedTuple</code>).</p><p>It is possible to assign a value to <code>AbstractDataFrame</code> and <code>DataFrameRow</code> objects using the <code>.=</code> operator. In such an operation <code>AbstractDataFrame</code> is considered as two-dimensional and <code>DataFrameRow</code> as single-dimensional.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The rule above means that, similar to single-dimensional objects in Base (e.g. vectors), <code>DataFrameRow</code> is considered to be column-oriented.</p></div></div><p>Additional rules:</p><ul><li>in the <code>df[CartesianIndex(row, col)] .= v</code>, <code>df[row, col] .= v</code> syntaxes <code>v</code> is broadcasted into the contents of <code>df[row, col]</code> (this is consistent with Julia Base);</li><li>in the <code>df[row, cols] .= v</code> syntaxes the assignment to <code>df</code> is performed in-place;</li><li>in the <code>df[rows, col] .= v</code> and <code>df[rows, cols] .= v</code> syntaxes the assignment to <code>df</code> is performed in-place; if <code>rows</code> is <code>:</code> and <code>col</code> is <code>Symbol</code> or <code>AbstractString</code> and it is missing from <code>df</code> then a new column is allocated and added; the length of the column is always the value of <code>nrow(df)</code> before the assignment takes place;</li><li>in the <code>df[!, col] .= v</code> syntax column <code>col</code> is replaced by a freshly allocated vector; if <code>col</code> is <code>Symbol</code> or <code>AbstractString</code> and it is missing from <code>df</code> then a new column is allocated added; the length of the column is always the value of <code>nrow(df)</code> before the assignment takes place;</li><li>the <code>df[!, cols] .= v</code> syntax replaces existing columns <code>cols</code> in data frame <code>df</code> with freshly allocated vectors;</li><li><code>df.col .= v</code> syntax currently performs in-place assignment to an existing vector <code>df.col</code>; this behavior is deprecated and a new column will be allocated in the future. Starting from Julia 1.7 if <code>:col</code> is not present in <code>df</code> then a new column will be created in <code>df</code>.</li><li>in the <code>sdf[CartesianIndex(row, col)] .= v</code>, <code>sdf[row, col] .= v</code> and <code>sdf[row, cols] .= v</code> syntaxes the assignment to <code>sdf</code> is performed in-place;</li><li>in the <code>sdf[rows, col] .= v</code> and <code>sdf[rows, cols] .= v</code> syntaxes the assignment to <code>sdf</code> is performed in-place;</li><li><code>sdf.col .= v</code> syntax is performs an in-place assignment to an existing vector <code>sdf.col</code> and is deprecated; in the future this operation will not be allowed.</li><li><code>dfr.col .= v</code> syntax is allowed and performs in-place assignment to a value extracted by <code>dfr.col</code>.</li></ul><p>Note that <code>sdf[!, col] .= v</code> and <code>sdf[!, cols] .= v</code> syntaxes are not allowed as <code>sdf</code> can be only modified in-place.</p><p>If column indexing using <code>Symbol</code> or <code>AbstractString</code> names in <code>cols</code> is performed, the order of columns in the operation is specified by the order of names.</p><h2 id="Indexing-GroupedDataFrames"><a class="docs-heading-anchor" href="#Indexing-GroupedDataFrames">Indexing <code>GroupedDataFrame</code>s</a><a id="Indexing-GroupedDataFrames-1"></a><a class="docs-heading-anchor-permalink" href="#Indexing-GroupedDataFrames" title="Permalink"></a></h2><p>A <a href="../types/#DataFrames.GroupedDataFrame"><code>GroupedDataFrame</code></a> can behave as either an <code>AbstractVector</code> or <code>AbstractDict</code> depending on the type of index used. Integers (or arrays of them) trigger vector-like indexing while <code>Tuples</code>s and <code>NamedTuple</code>s trigger dictionary-like indexing. An intermediate between the two is the <a href="../types/#DataFrames.GroupKey"><code>GroupKey</code></a> type returned by <a href="../functions/#Base.keys"><code>keys(::GroupedDataFrame)</code></a>, which behaves similarly to a <code>NamedTuple</code> but has performance on par with integer indexing.</p><p>The elements of a <code>GroupedDataFrame</code> are <a href="../types/#DataFrames.SubDataFrame"><code>SubDataFrame</code></a>s of its parent.</p><ul><li><code>gd[i::Integer]</code> -&gt; Get the <code>i</code>th group.</li><li><code>gd[key::NamedTuple]</code> -&gt; Get the group corresponding to the given values of the grouping columns. The fields of the <code>NamedTuple</code> must match the grouping columns columns passed to <a href="../functions/#DataFrames.groupby"><code>groupby</code></a> (including order).</li><li><code>gd[key::Tuple]</code> -&gt; Same as previous, but omitting the names on <code>key</code>.</li><li><code>get(gd, key::Union{Tuple, NamedTuple}, default)</code> -&gt; Get group for key <code>key</code>, returning <code>default</code> if it does not exist.</li><li><code>gd[key::GroupKey]</code> -&gt; Get the group corresponding to the <a href="../types/#DataFrames.GroupKey"><code>GroupKey</code></a> <code>key</code> (one of the elements of the vector returned by <a href="../functions/#Base.keys"><code>keys(::GroupedDataFrame)</code></a>). This should be nearly as fast as integer indexing.</li><li><code>gd[a::AbstractVector]</code> -&gt; Select multiple groups and return them in a new <code>GroupedDataFrame</code> object. Groups may be selected by integer position using an array of <code>Integer</code>s or <code>Bool</code>s, similar to a standard array. Alternatively the array may contain keys of any of the types supported for dictionary-like indexing (<code>GroupKey</code>, <code>Tuple</code>, or <code>NamedTuple</code>). Selected groups must be unique, and different types of indices cannot be mixed.</li><li><code>gd[n::Not]</code> -&gt; Any of the above types wrapped in <code>Not</code>. The result  will be a new <code>GroupedDataFrame</code> containing all groups in <code>gd</code> <em>not</em> selected  by the wrapped index.</li></ul><h1 id="Common-API-for-types-defined-in-DataFrames.jl"><a class="docs-heading-anchor" href="#Common-API-for-types-defined-in-DataFrames.jl">Common API for types defined in DataFrames.jl</a><a id="Common-API-for-types-defined-in-DataFrames.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Common-API-for-types-defined-in-DataFrames.jl" title="Permalink"></a></h1><p>This table presents return value types of calling <code>names</code>, <code>propertynames</code>, <code>keys</code>, <code>length</code> and <code>ndims</code> on types exposed to the user by DataFrames.jl:</p><table><tr><th style="text-align: right">Type</th><th style="text-align: right"><code>names</code></th><th style="text-align: right"><code>propertynames</code></th><th style="text-align: right"><code>keys</code></th><th style="text-align: right"><code>length</code></th><th style="text-align: right"><code>ndims</code></th></tr><tr><td style="text-align: right"><code>AbstractDataFrame</code></td><td style="text-align: right"><code>Vector{String}</code></td><td style="text-align: right"><code>Vector{Symbol}</code></td><td style="text-align: right">undefined</td><td style="text-align: right">undefined</td><td style="text-align: right"><code>2</code></td></tr><tr><td style="text-align: right"><code>DataFrameRow</code></td><td style="text-align: right"><code>Vector{String}</code></td><td style="text-align: right"><code>Vector{Symbol}</code></td><td style="text-align: right"><code>Vector{Symbol}</code></td><td style="text-align: right"><code>Int</code></td><td style="text-align: right"><code>1</code></td></tr><tr><td style="text-align: right"><code>DataFrameRows</code></td><td style="text-align: right"><code>Vector{String}</code></td><td style="text-align: right"><code>Vector{Symbol}</code></td><td style="text-align: right">vector of <code>Int</code></td><td style="text-align: right"><code>Int</code></td><td style="text-align: right"><code>1</code></td></tr><tr><td style="text-align: right"><code>DataFrameColumns</code></td><td style="text-align: right"><code>Vector{String}</code></td><td style="text-align: right"><code>Vector{Symbol}</code></td><td style="text-align: right"><code>Vector{Symbol}</code></td><td style="text-align: right"><code>Int</code></td><td style="text-align: right"><code>1</code></td></tr><tr><td style="text-align: right"><code>GroupedDataFrame</code></td><td style="text-align: right"><code>Vector{String}</code></td><td style="text-align: right">tuple of fields</td><td style="text-align: right"><code>GroupKeys</code></td><td style="text-align: right"><code>Int</code></td><td style="text-align: right"><code>1</code></td></tr><tr><td style="text-align: right"><code>GroupKeys</code></td><td style="text-align: right">undefined</td><td style="text-align: right">tuple of fields</td><td style="text-align: right">vector of <code>Int</code></td><td style="text-align: right"><code>Int</code></td><td style="text-align: right"><code>1</code></td></tr><tr><td style="text-align: right"><code>GroupKey</code></td><td style="text-align: right"><code>Vector{String}</code></td><td style="text-align: right"><code>Vector{Symbol}</code></td><td style="text-align: right"><code>Vector{Symbol}</code></td><td style="text-align: right"><code>Int</code></td><td style="text-align: right"><code>1</code></td></tr></table><p>Additionally the above types <code>T</code> (i.e. <code>AbstractDataFrame</code>, <code>DataFrameRow</code>, <code>DataFrameRows</code>, <code>DataFrameColumns</code>, <code>GroupedDataFrame</code>, <code>GroupKeys</code>, <code>GroupKey</code>) the following methods are defined:</p><ul><li><code>size(::T)</code> returning a <code>Tuple</code> of <code>Int</code>.</li><li><code>size(::T, ::Integer)</code> returning an <code>Int</code>.</li><li><code>axes(::T)</code> returning a <code>Tuple</code> of <code>Int</code> vectors.</li><li><code>axes(::T, ::Integer)</code> returning an <code>Int</code> vector for a valid dimension (except  <code>DataFrameRows</code> and <code>GroupKeys</code> for which <code>Base.OneTo(1)</code> is also returned for  a dimension higher than a valid one because they are <code>AbstractVector</code>).</li><li><code>firstindex(::T)</code> returning <code>1</code> (except <code>AbstractDataFrame</code> for which it is undefined).</li><li><code>firstindex(::T, ::Integer)</code> returning <code>1</code> for a valid dimension (except <code>DataFrameRows</code>  and <code>GroupKeys</code> for which <code>1</code> is also returned for a dimension higher than a valid one  because they are <code>AbstractVector</code>).</li><li><code>lastindex(::T)</code> returning <code>Int</code> (except <code>AbstractDataFrame</code> for which it is undefined).</li><li><code>lastindex(::T, ::Integer)</code> returning <code>Int</code> for a valid dimension  (except <code>DataFrameRows</code>  and <code>GroupKeys</code> for which <code>1</code> is also returned for a dimension higher than a valid one  because they are <code>AbstractVector</code>).</li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../functions/">« Functions</a><a class="docs-footer-nextpage" href="../internals/">Internals »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Monday 28 June 2021 11:47">Monday 28 June 2021</span>. Using Julia version 1.6.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
