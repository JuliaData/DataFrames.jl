<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Indexing · DataFrames.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link rel="canonical" href="https://juliadata.github.io/DataFrames.jl/stable/lib/indexing/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><script src="../../../copy.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="DataFrames.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">DataFrames.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><a class="tocitem" href="../../man/basics/">First Steps with DataFrames.jl</a></li><li><span class="tocitem">User Guide</span><ul><li><a class="tocitem" href="../../man/getting_started/">Getting Started</a></li><li><a class="tocitem" href="../../man/working_with_dataframes/">Working with DataFrames</a></li><li><a class="tocitem" href="../../man/importing_and_exporting/">Importing and Exporting Data (I/O)</a></li><li><a class="tocitem" href="../../man/joins/">Joins</a></li><li><a class="tocitem" href="../../man/split_apply_combine/">Split-apply-combine</a></li><li><a class="tocitem" href="../../man/reshaping_and_pivoting/">Reshaping</a></li><li><a class="tocitem" href="../../man/sorting/">Sorting</a></li><li><a class="tocitem" href="../../man/categorical/">Categorical Data</a></li><li><a class="tocitem" href="../../man/missing/">Missing Data</a></li><li><a class="tocitem" href="../../man/querying_frameworks/">Data manipulation frameworks</a></li><li><a class="tocitem" href="../../man/comparisons/">Comparison with Python/R/Stata</a></li></ul></li><li><span class="tocitem">API</span><ul><li><a class="tocitem" href="../types/">Types</a></li><li><a class="tocitem" href="../functions/">Functions</a></li><li class="is-active"><a class="tocitem" href>Indexing</a><ul class="internal"><li><a class="tocitem" href="#General-rules"><span>General rules</span></a></li><li><a class="tocitem" href="#getindex-and-view"><span><code>getindex</code> and <code>view</code></span></a></li><li><a class="tocitem" href="#setindex!"><span><code>setindex!</code></span></a></li><li><a class="tocitem" href="#Broadcasting"><span>Broadcasting</span></a></li><li><a class="tocitem" href="#Indexing-GroupedDataFrames"><span>Indexing <code>GroupedDataFrame</code>s</span></a></li><li class="toplevel"><a class="tocitem" href="#Common-API-for-types-defined-in-DataFrames.jl"><span>Common API for types defined in DataFrames.jl</span></a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">API</a></li><li class="is-active"><a href>Indexing</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Indexing</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaData/DataFrames.jl/blob/main/docs/src/lib/indexing.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Indexing"><a class="docs-heading-anchor" href="#Indexing">Indexing</a><a id="Indexing-1"></a><a class="docs-heading-anchor-permalink" href="#Indexing" title="Permalink"></a></h1><ul></ul><h2 id="General-rules"><a class="docs-heading-anchor" href="#General-rules">General rules</a><a id="General-rules-1"></a><a class="docs-heading-anchor-permalink" href="#General-rules" title="Permalink"></a></h2><p>The following rules explain target functionality of how <code>getindex</code>, <code>setindex!</code>, <code>view</code>, and broadcasting are intended to work with <code>DataFrame</code>, <code>SubDataFrame</code> and <code>DataFrameRow</code> objects.</p><p>The following values are a valid column index:</p><ul><li>a scalar, later denoted as <code>col</code>:<ul><li>a <code>Symbol</code>;</li><li>an <code>AbstractString</code>;</li><li>an <code>Integer</code> that is not <code>Bool</code>;</li></ul></li><li>a vector, later denoted as <code>cols</code>:<ul><li>a vector of <code>Symbol</code> (does not have to be a subtype of <code>AbstractVector{Symbol}</code>);</li><li>a vector of <code>AbstractString</code> (does not have to be a subtype of <code>AbstractVector{&lt;:AbstractString}</code>);</li><li>a vector of <code>Integer</code> that are not <code>Bool</code> (does not have to be a subtype of <code>AbstractVector{&lt;:Integer}</code>);</li><li>a vector of <code>Bool</code> (must be a subtype of <code>AbstractVector{Bool}</code>);</li><li>a <a href="https://docs.julialang.org/en/v1/manual/strings/#Regular-Expressions">regular expression</a> (will be expanded to a vector of matching column names);</li><li>a <code>Not</code> expression (see <a href="https://github.com/JuliaData/InvertedIndices.jl">InvertedIndices.jl</a>); <code>Not(idx)</code> selects all indices not in the passed <code>idx</code>;</li><li>a <code>Cols</code> expression (see <a href="https://github.com/JuliaData/DataAPI.jl">DataAPI.jl</a>); <code>Cols(idxs...)</code> selects the union of the selections in <code>idxs</code>; in particular <code>Cols()</code> selects no columns and <code>Cols(:)</code> selects all columns; a special rule is <code>Cols(predicate)</code>, where <code>predicate</code> is a predicate function; in this case the columns whose names passed to <code>predicate</code> as strings return <code>true</code> are selected.</li><li>a <code>Between</code> expression (see <a href="https://github.com/JuliaData/DataAPI.jl">DataAPI.jl</a>); <code>Between(first, last)</code> selects the columns between <code>first</code> and <code>last</code> inclusively;</li><li>an <code>All</code> expression (see <a href="https://github.com/JuliaData/DataAPI.jl">DataAPI.jl</a>); <code>All()</code> selects all columns, equivalent to <code>:</code>;</li><li>a literal colon <code>:</code> (selects all columns).</li></ul></li></ul><p>The following values are a valid row index:</p><ul><li>a scalar, later denoted as <code>row</code>:<ul><li>an <code>Integer</code> that is not <code>Bool</code>;</li></ul></li><li>a vector, later denoted as <code>rows</code>:<ul><li>a vector of <code>Integer</code> that are not <code>Bool</code> (does not have to be a subtype of <code>AbstractVector{&lt;:Integer}</code>);</li><li>a vector of <code>Bool</code> (must be a subtype of <code>AbstractVector{Bool}</code>);</li><li>a <code>Not</code> expression (see <a href="https://github.com/JuliaData/InvertedIndices.jl">InvertedIndices.jl</a>);</li><li>a literal colon <code>:</code> (selects all rows with copying);</li><li>a literal exclamation mark <code>!</code> (selects all rows without copying).</li></ul></li></ul><p>Additionally it is allowed to index into an <code>AbstractDataFrame</code> using a two-dimensional <code>CartesianIndex</code>.</p><p>In the descriptions below <code>df</code> represents a <code>DataFrame</code>, <code>sdf</code> is a <code>SubDataFrame</code> and <code>dfr</code> is a <code>DataFrameRow</code>.</p><p><code>:</code> always expands to <code>axes(df, 1)</code> or <code>axes(sdf, 1)</code>.</p><p><code>df.col</code> works like <code>df[!, col]</code> and <code>sdf.col</code> works like <code>sdf[!, col]</code> in all cases except that <code>df.col .= v</code> and <code>sdf.col .= v</code> perform in-place broadcasting if <code>col</code> is present in <code>df</code>/<code>sdf</code> and is a valid identifier (this inconsistency is deprecated and in DataFrames.jl 1.4 release under Julia 1.7 and later both syntaxes will be always consistent).</p><h2 id="getindex-and-view"><a class="docs-heading-anchor" href="#getindex-and-view"><code>getindex</code> and <code>view</code></a><a id="getindex-and-view-1"></a><a class="docs-heading-anchor-permalink" href="#getindex-and-view" title="Permalink"></a></h2><p>The following list specifies the behavior of <code>getindex</code> and <code>view</code> operations depending on argument types.</p><p>In particular a description explicitly mentions that the data is <em>copied</em> or <em>reused without copying</em>.</p><p>For performance reasons, accessing, via <code>getindex</code> or <code>view</code>, a single <code>row</code> and multiple <code>cols</code> of a <code>DataFrame</code>, a <code>SubDataFrame</code> or a <code>DataFrameRow</code> always returns a <code>DataFrameRow</code> (which is a view type).</p><p><code>getindex</code> on <code>DataFrame</code>:</p><ul><li><code>df[row, col]</code> -&gt; the value contained in row <code>row</code> of column <code>col</code>, the same as <code>df[!, col][row]</code>;</li><li><code>df[CartesianIndex(row, col)]</code> -&gt; the same as <code>df[row, col]</code>;</li><li><code>df[row, cols]</code> -&gt; a <code>DataFrameRow</code> with parent <code>df</code>;</li><li><code>df[rows, col]</code> -&gt; a copy of the vector <code>df[!, col]</code> with only the entries                    corresponding to <code>rows</code> selected, the same as <code>df[!, col][rows]</code>;</li><li><code>df[rows, cols]</code> -&gt; a <code>DataFrame</code> containing copies of columns <code>cols</code> with                     only the entries corresponding to <code>rows</code> selected;</li><li><code>df[!, col]</code> -&gt; the vector contained in column <code>col</code> returned without copying;                 the same as <code>df.col</code> if <code>col</code> is a valid identifier.</li><li><code>df[!, cols]</code> -&gt; create a new <code>DataFrame</code> with columns <code>cols</code> without copying                  of columns; the same as <code>select(df, cols, copycols=false)</code>.</li></ul><p><code>view</code> on <code>DataFrame</code>:</p><ul><li><code>@view df[row, col]</code> -&gt; a <code>0</code>-dimensional view into <code>df[!, col]</code> in row <code>row</code>,                         the same as <code>view(df[!, col], row)</code>;</li><li><code>@view df[CartesianIndex(row, col)]</code> -&gt; the same as <code>@view df[row, col]</code>;</li><li><code>@view df[row, cols]</code> -&gt; the same as <code>df[row, cols]</code>;</li><li><code>@view df[rows, col]</code> -&gt; a view into <code>df[!, col]</code> with <code>rows</code> selected, the                          same as <code>view(df[!, col], rows)</code>;</li><li><code>@view df[rows, cols]</code> -&gt; a <code>SubDataFrame</code> with <code>rows</code> selected with parent <code>df</code>;</li><li><code>@view df[!, col]</code> -&gt; a view into <code>df[!, col]</code>  with all rows.</li><li><code>@view df[!, cols]</code> -&gt; the same as <code>@view df[:, cols]</code>.</li></ul><p><code>getindex</code> on <code>SubDataFrame</code>:</p><ul><li><code>sdf[row, col]</code> -&gt; a value contained in row <code>row</code> of column <code>col</code>;</li><li><code>sdf[CartesianIndex(row, col)]</code> -&gt; the same as <code>sdf[row, col]</code>;</li><li><code>sdf[row, cols]</code> -&gt; a <code>DataFrameRow</code> with parent <code>parent(sdf)</code>;</li><li><code>sdf[rows, col]</code> -&gt; a copy of <code>sdf[!, col]</code> with only rows <code>rows</code> selected,                     the same as <code>sdf[!, col][rows]</code>;</li><li><code>sdf[rows, cols]</code> -&gt; a <code>DataFrame</code> containing columns <code>cols</code> and <code>sdf[rows, col]</code> as a vector for each <code>col</code> in <code>cols</code>;</li><li><code>sdf[!, col]</code> -&gt; a view of entries corresponding to <code>sdf</code> in the vector                  <code>parent(sdf)[!, col]</code>; the same as <code>sdf.col</code> if <code>col</code> is a                  valid identifier.</li><li><code>sdf[!, cols]</code> -&gt; create a new <code>SubDataFrame</code> with columns <code>cols</code>, the same                   parent as <code>sdf</code>, and the same rows selected; the same as                   <code>select(sdf, cols, copycols=false)</code>.</li></ul><p><code>view</code> on <code>SubDataFrame</code>:</p><ul><li><code>@view sdf[row, col]</code> -&gt; a <code>0</code>-dimensional view into <code>df[!, col]</code> at row                          <code>row</code>, the same as <code>view(sdf[!, col], row)</code>;</li><li><code>@view sdf[CartesianIndex(row, col)]</code> -&gt; the same as <code>@view sdf[row, col]</code>;</li><li><code>@view sdf[row, cols]</code> -&gt; a <code>DataFrameRow</code> with parent <code>parent(sdf)</code>;</li><li><code>@view sdf[rows, col]</code> -&gt; a view into <code>sdf[!, col]</code> vector with <code>rows</code>                           selected, the same as <code>view(sdf[!, col], rows)</code>;</li><li><code>@view sdf[rows, cols]</code> -&gt; a <code>SubDataFrame</code> with parent <code>parent(sdf)</code>;</li><li><code>@view sdf[!, col]</code> -&gt; a view into <code>sdf[!, col]</code> vector with all rows.</li><li><code>@view sdf[!, cols]</code> -&gt; the same as <code>@view sdf[:, cols]</code>.</li></ul><p><code>getindex</code> on <code>DataFrameRow</code>:</p><ul><li><code>dfr[col]</code> -&gt; the value contained in column <code>col</code> of <code>dfr</code>; the same as               <code>dfr.col</code> if <code>col</code> is a valid identifier;</li><li><code>dfr[cols]</code> -&gt; a <code>DataFrameRow</code> with parent <code>parent(dfr)</code>;</li></ul><p><code>view</code> on <code>DataFrameRow</code>:</p><ul><li><code>@view dfr[col]</code> -&gt; a <code>0</code>-dimensional view into                     <code>parent(dfr)[DataFrames.row(dfr), col]</code>;</li><li><code>@view dfr[cols]</code> -&gt; a <code>DataFrameRow</code> with parent <code>parent(dfr)</code>;</li></ul><p>Note that views created with columns selector set to <code>:</code> change their columns&#39; count if columns are added/removed/renamed in the parent; if column selector is other than <code>:</code> then view points to selected columns by their number at the moment of creation of the view.</p><h2 id="setindex!"><a class="docs-heading-anchor" href="#setindex!"><code>setindex!</code></a><a id="setindex!-1"></a><a class="docs-heading-anchor-permalink" href="#setindex!" title="Permalink"></a></h2><p>The following list specifies the behavior of <code>setindex!</code> operations depending on argument types.</p><p>In particular a description explicitly mentions if the assignment is <em>in-place</em>.</p><p>Note that if a <code>setindex!</code> operation throws an error the target data frame may be partially changed so it is unsafe to use it afterwards (the column length correctness will be preserved).</p><p><code>setindex!</code> on <code>DataFrame</code>:</p><ul><li><code>df[row, col] = v</code> -&gt; set value of <code>col</code> in row <code>row</code> to <code>v</code> in-place;</li><li><code>df[CartesianIndex(row, col)] = v</code> -&gt; the same as <code>df[row, col] = v</code>;</li><li><code>df[row, cols] = v</code> -&gt; set row <code>row</code> of columns <code>cols</code> in-place; the same as                        <code>dfr = df[row, cols]; dfr[:] = v</code>;</li><li><code>df[rows, col] = v</code> -&gt; set rows <code>rows</code> of column <code>col</code> in-place; <code>v</code> must be                        an <code>AbstractVector</code>; if <code>rows</code> is <code>:</code> and <code>col</code> is a                        <code>Symbol</code> or <code>AbstractString</code> that is not present in                        <code>df</code> then a new column in <code>df</code> is created and holds a                        <code>copy</code> of <code>v</code>; equivalent to <code>df.col = copy(v)</code> if                        <code>col</code> is a valid identifier;</li><li><code>df[rows, cols] = v</code> -&gt; set rows <code>rows</code> of columns <code>cols</code> in-place; <code>v</code> must                         be an <code>AbstractMatrix</code> or an <code>AbstractDataFrame</code> (in                         this case column names must match);</li><li><code>df[!, col] = v</code> -&gt; replaces <code>col</code> with <code>v</code> without copying (with the                     exception that if <code>v</code> is an <code>AbstractRange</code> it gets                     converted to a <code>Vector</code>); also if <code>col</code> is a <code>Symbol</code> or                     <code>AbstractString</code> that is not present in <code>df</code> then a new                     column in <code>df</code> is created and holds <code>v</code>; equivalent to                     <code>df.col = v</code> if <code>col</code> is a valid identifier; this is                     allowed if <code>ncol(df) == 0 || length(v) == nrow(df)</code>;</li><li><code>df[!, cols] = v</code> -&gt; replaces existing columns <code>cols</code> in data frame <code>df</code> with                      copying; <code>v</code> must be an <code>AbstractMatrix</code> or an                      <code>AbstractDataFrame</code> (in the latter case column names must                      match);</li></ul><p><code>setindex!</code> on <code>SubDataFrame</code>:</p><ul><li><code>sdf[row, col] = v</code> -&gt; set value of <code>col</code> in row <code>row</code> to <code>v</code> in-place;</li><li><code>sdf[CartesianIndex(row, col)] = v</code> -&gt; the same as <code>sdf[row, col] = v</code>;</li><li><code>sdf[row, cols] = v</code> -&gt; the same as <code>dfr = df[row, cols]; dfr[:] = v</code> in-place;</li><li><code>sdf[rows, col] = v</code> -&gt; set rows <code>rows</code> of column <code>col</code>, in-place; <code>v</code> must be                         an abstract vector;</li><li><code>sdf[rows, cols] = v</code> -&gt; set rows <code>rows</code> of columns <code>cols</code> in-place; <code>v</code> can                          be an <code>AbstractMatrix</code> or <code>v</code> can be                          <code>AbstractDataFrame</code> in which case column names must                          match;</li><li><code>sdf[!, col] = v</code> -&gt; replaces <code>col</code> with <code>v</code> with copying; if <code>col</code> is present                      in <code>sdf</code> then filtered-out rows in newly created vector                      are filled with values already present in that column and                      <code>promote_type</code> is used to determine the <code>eltype</code> of the                      new column; if <code>col</code> is not present in <code>sdf</code> then the                      operation is only allowed if <code>sdf</code> was created with <code>:</code>                      as column selector, in which case filtered-out rows are                      filled with <code>missing</code>; equivalent to <code>sdf.col = v</code> if                      <code>col</code> is a valid identifier; operation is allowed if                      <code>length(v) == nrow(sdf)</code>;</li><li><code>sdf[!, cols] = v</code> -&gt; replaces existing columns <code>cols</code> in data frame <code>sdf</code>                       with copying; <code>v</code> must be an <code>AbstractMatrix</code> or an                       <code>AbstractDataFrame</code> (in the latter case column names                       must match); filtered-out rows in newly created vectors                       are filled with values already present in respective                       columns and <code>promote_type</code> is used to determine the                       <code>eltype</code> of the new columns;</li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The rules above mean that <code>sdf[:, col] = v</code> is an in-place operation if <code>col</code> is present in <code>sdf</code>, therefore it will be fast in general. On the other hand using <code>sdf[!, col] = v</code> or <code>sdf.col = v</code> will always allocate a new vector, which is more expensive computationally.</p></div></div><p><code>setindex!</code> on <code>DataFrameRow</code>:</p><ul><li><code>dfr[col] = v</code> -&gt; set value of <code>col</code> in row <code>row</code> to <code>v</code> in-place;                   equivalent to <code>dfr.col = v</code> if <code>col</code> is a valid identifier;</li><li><code>dfr[cols] = v</code> -&gt; set values of entries in columns <code>cols</code> in <code>dfr</code> by                    elements of <code>v</code> in place; <code>v</code> can be: 1) a <code>Tuple</code> or an                    <code>AbstractArray</code>, in which cases it must have a number of                    elements equal to <code>length(dfr)</code>, 2) an <code>AbstractDict</code>, in                    which case column names must match, 3) a <code>NamedTuple</code> or                    <code>DataFrameRow</code>, in which case column names and order must                    match;</li></ul><h2 id="Broadcasting"><a class="docs-heading-anchor" href="#Broadcasting">Broadcasting</a><a id="Broadcasting-1"></a><a class="docs-heading-anchor-permalink" href="#Broadcasting" title="Permalink"></a></h2><p>The following broadcasting rules apply to <code>AbstractDataFrame</code> objects:</p><ul><li><code>AbstractDataFrame</code> behaves in broadcasting like a two-dimensional collection compatible with matrices.</li><li>If an <code>AbstractDataFrame</code> takes part in broadcasting then a <code>DataFrame</code> is always produced as a result. In this case the requested broadcasting operation produces an object with exactly two dimensions. An exception is when an <code>AbstractDataFrame</code> is used only as a source of broadcast assignment into an object of dimensionality higher than two.</li><li>If multiple <code>AbstractDataFrame</code> objects take part in broadcasting then they have to have identical column names.</li></ul><p>Note that if broadcasting assignment operation throws an error the target data frame may be partially changed so it is unsafe to use it afterwards (the column length correctness will be preserved).</p><p>Broadcasting <code>DataFrameRow</code> is currently not allowed (which is consistent with <code>NamedTuple</code>).</p><p>It is possible to assign a value to <code>AbstractDataFrame</code> and <code>DataFrameRow</code> objects using the <code>.=</code> operator. In such an operation <code>AbstractDataFrame</code> is considered as two-dimensional and <code>DataFrameRow</code> as single-dimensional.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The rule above means that, similar to single-dimensional objects in Base (e.g. vectors), <code>DataFrameRow</code> is considered to be column-oriented.</p></div></div><p>Additional rules:</p><ul><li>in the <code>df[CartesianIndex(row, col)] .= v</code>, <code>df[row, col] .= v</code> syntaxes <code>v</code> is broadcasted into the contents of <code>df[row, col]</code> (this is consistent with Julia Base);</li><li>in the <code>df[row, cols] .= v</code> syntaxes the assignment to <code>df</code> is performed in-place;</li><li>in the <code>df[rows, col] .= v</code> and <code>df[rows, cols] .= v</code> syntaxes the assignment to <code>df</code> is performed in-place; if <code>rows</code> is <code>:</code> and <code>col</code> is <code>Symbol</code> or <code>AbstractString</code> and it is missing from <code>df</code> then a new column is allocated and added; the length of the column is always the value of <code>nrow(df)</code> before the assignment takes place;</li><li>in the <code>df[!, col] .= v</code> syntax column <code>col</code> is replaced by a freshly allocated vector; if <code>col</code> is <code>Symbol</code> or <code>AbstractString</code> and it is missing from <code>df</code> then a new column is allocated added; the length of the column is always the value of <code>nrow(df)</code> before the assignment takes place;</li><li>the <code>df[!, cols] .= v</code> syntax replaces existing columns <code>cols</code> in data frame <code>df</code> with freshly allocated vectors;</li><li><code>df.col .= v</code> syntax currently performs in-place assignment to an existing vector <code>df.col</code>; this behavior is deprecated and a new column will be allocated in the future. Starting from Julia 1.7 if <code>:col</code> is not present in <code>df</code> then a new column will be created in <code>df</code>.</li><li>in the <code>sdf[CartesianIndex(row, col)] .= v</code>, <code>sdf[row, col] .= v</code> and <code>sdf[row, cols] .= v</code> syntaxes the assignment to <code>sdf</code> is performed in-place;</li><li>in the <code>sdf[rows, col] .= v</code> and <code>sdf[rows, cols] .= v</code> syntaxes the assignment to <code>sdf</code> is performed in-place; if <code>rows</code> is <code>:</code> and <code>col</code> is a <code>Symbol</code> or <code>AbstractString</code> referring to a column missing from <code>sdf</code> and <code>sdf</code> was created with <code>:</code> as column selector then a new column is allocated and added; the filtered-out rows are filled with <code>missing</code>;</li><li>in the <code>sdf[!, col] .= v</code> syntax column <code>col</code> is replaced by a freshly allocated vector; the filtered-out rows are filled with values already present in <code>col</code>; if <code>col</code> is a <code>Symbol</code> or <code>AbstractString</code> referring to a column missing from <code>sdf</code> and was <code>sdf</code> created with <code>:</code> as column selector then a new column is allocated and added; in this case the filtered-out rows are filled with <code>missing</code>;</li><li>the <code>sdf[!, cols] .= v</code> syntax replaces existing columns <code>cols</code> in data frame <code>sdf</code> with freshly allocated vectors; the filtered-out rows are filled with values already present in <code>cols</code>;</li><li><code>sdf.col .= v</code> syntax currently performs in-place assignment to an existing vector <code>sdf.col</code>; this behavior is deprecated and a new column will be allocated in the future. Starting from Julia 1.7 if <code>:col</code> is not present in <code>sdf</code> then a new column will be created in <code>sdf</code> if <code>sdf</code> was created with <code>:</code> as a column selector.</li><li><code>dfr.col .= v</code> syntax is allowed and performs in-place assignment to a value extracted by <code>dfr.col</code>.</li></ul><p>Note that <code>sdf[!, col] .= v</code> and <code>sdf[!, cols] .= v</code> syntaxes are not allowed as <code>sdf</code> can be only modified in-place.</p><p>If column indexing using <code>Symbol</code> or <code>AbstractString</code> names in <code>cols</code> is performed, the order of columns in the operation is specified by the order of names.</p><h2 id="Indexing-GroupedDataFrames"><a class="docs-heading-anchor" href="#Indexing-GroupedDataFrames">Indexing <code>GroupedDataFrame</code>s</a><a id="Indexing-GroupedDataFrames-1"></a><a class="docs-heading-anchor-permalink" href="#Indexing-GroupedDataFrames" title="Permalink"></a></h2><p>A <a href="../types/#DataFrames.GroupedDataFrame"><code>GroupedDataFrame</code></a> can behave as either an <code>AbstractVector</code> or <code>AbstractDict</code> depending on the type of index used. Integers (or arrays of them) trigger vector-like indexing while <code>Tuples</code>s and <code>NamedTuple</code>s trigger dictionary-like indexing. An intermediate between the two is the <a href="../types/#DataFrames.GroupKey"><code>GroupKey</code></a> type returned by <a href="../functions/#Base.keys"><code>keys(::GroupedDataFrame)</code></a>, which behaves similarly to a <code>NamedTuple</code> but has performance on par with integer indexing.</p><p>The elements of a <code>GroupedDataFrame</code> are <a href="../types/#DataFrames.SubDataFrame"><code>SubDataFrame</code></a>s of its parent.</p><ul><li><code>gd[i::Integer]</code> -&gt; Get the <code>i</code>th group.</li><li><code>gd[key::NamedTuple]</code> -&gt; Get the group corresponding to the given values of the grouping columns. The fields of the <code>NamedTuple</code> must match the grouping columns columns passed to <a href="../functions/#DataFrames.groupby"><code>groupby</code></a> (including order).</li><li><code>gd[key::Tuple]</code> -&gt; Same as previous, but omitting the names on <code>key</code>.</li><li><code>get(gd, key::Union{Tuple, NamedTuple}, default)</code> -&gt; Get group for key <code>key</code>, returning <code>default</code> if it does not exist.</li><li><code>gd[key::GroupKey]</code> -&gt; Get the group corresponding to the <a href="../types/#DataFrames.GroupKey"><code>GroupKey</code></a> <code>key</code> (one of the elements of the vector returned by <a href="../functions/#Base.keys"><code>keys(::GroupedDataFrame)</code></a>). This should be nearly as fast as integer indexing.</li><li><code>gd[a::AbstractVector]</code> -&gt; Select multiple groups and return them in a new <code>GroupedDataFrame</code> object. Groups may be selected by integer position using an array of <code>Integer</code>s or <code>Bool</code>s, similar to a standard array. Alternatively the array may contain keys of any of the types supported for dictionary-like indexing (<code>GroupKey</code>, <code>Tuple</code>, or <code>NamedTuple</code>). Selected groups must be unique, and different types of indices cannot be mixed.</li><li><code>gd[n::Not]</code> -&gt; Any of the above types wrapped in <code>Not</code>. The result will be a  new <code>GroupedDataFrame</code> containing all groups in <code>gd</code> <em>not</em> selected by the  wrapped index.</li></ul><h1 id="Common-API-for-types-defined-in-DataFrames.jl"><a class="docs-heading-anchor" href="#Common-API-for-types-defined-in-DataFrames.jl">Common API for types defined in DataFrames.jl</a><a id="Common-API-for-types-defined-in-DataFrames.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Common-API-for-types-defined-in-DataFrames.jl" title="Permalink"></a></h1><p>This table presents return value types of calling <code>names</code>, <code>propertynames</code>, <code>keys</code>, <code>length</code> and <code>ndims</code> on types exposed to the user by DataFrames.jl:</p><table><tr><th style="text-align: right">Type</th><th style="text-align: right"><code>names</code></th><th style="text-align: right"><code>propertynames</code></th><th style="text-align: right"><code>keys</code></th><th style="text-align: right"><code>length</code></th><th style="text-align: right"><code>ndims</code></th></tr><tr><td style="text-align: right"><code>AbstractDataFrame</code></td><td style="text-align: right"><code>Vector{String}</code></td><td style="text-align: right"><code>Vector{Symbol}</code></td><td style="text-align: right">undefined</td><td style="text-align: right">undefined</td><td style="text-align: right"><code>2</code></td></tr><tr><td style="text-align: right"><code>DataFrameRow</code></td><td style="text-align: right"><code>Vector{String}</code></td><td style="text-align: right"><code>Vector{Symbol}</code></td><td style="text-align: right"><code>Vector{Symbol}</code></td><td style="text-align: right"><code>Int</code></td><td style="text-align: right"><code>1</code></td></tr><tr><td style="text-align: right"><code>DataFrameRows</code></td><td style="text-align: right"><code>Vector{String}</code></td><td style="text-align: right"><code>Vector{Symbol}</code></td><td style="text-align: right">vector of <code>Int</code></td><td style="text-align: right"><code>Int</code></td><td style="text-align: right"><code>1</code></td></tr><tr><td style="text-align: right"><code>DataFrameColumns</code></td><td style="text-align: right"><code>Vector{String}</code></td><td style="text-align: right"><code>Vector{Symbol}</code></td><td style="text-align: right"><code>Vector{Symbol}</code></td><td style="text-align: right"><code>Int</code></td><td style="text-align: right"><code>1</code></td></tr><tr><td style="text-align: right"><code>GroupedDataFrame</code></td><td style="text-align: right"><code>Vector{String}</code></td><td style="text-align: right">tuple of fields</td><td style="text-align: right"><code>GroupKeys</code></td><td style="text-align: right"><code>Int</code></td><td style="text-align: right"><code>1</code></td></tr><tr><td style="text-align: right"><code>GroupKeys</code></td><td style="text-align: right">undefined</td><td style="text-align: right">tuple of fields</td><td style="text-align: right">vector of <code>Int</code></td><td style="text-align: right"><code>Int</code></td><td style="text-align: right"><code>1</code></td></tr><tr><td style="text-align: right"><code>GroupKey</code></td><td style="text-align: right"><code>Vector{String}</code></td><td style="text-align: right"><code>Vector{Symbol}</code></td><td style="text-align: right"><code>Vector{Symbol}</code></td><td style="text-align: right"><code>Int</code></td><td style="text-align: right"><code>1</code></td></tr></table><p>Additionally the above types <code>T</code> (i.e. <code>AbstractDataFrame</code>, <code>DataFrameRow</code>, <code>DataFrameRows</code>, <code>DataFrameColumns</code>, <code>GroupedDataFrame</code>, <code>GroupKeys</code>, <code>GroupKey</code>) the following methods are defined:</p><ul><li><code>size(::T)</code> returning a <code>Tuple</code> of <code>Int</code>.</li><li><code>size(::T, ::Integer)</code> returning an <code>Int</code>.</li><li><code>axes(::T)</code> returning a <code>Tuple</code> of <code>Int</code> vectors.</li><li><code>axes(::T, ::Integer)</code> returning an <code>Int</code> vector for a valid dimension (except  <code>DataFrameRows</code> and <code>GroupKeys</code> for which <code>Base.OneTo(1)</code> is also returned  for a dimension higher than a valid one because they are <code>AbstractVector</code>).</li><li><code>firstindex(::T)</code> returning <code>1</code> (except <code>AbstractDataFrame</code> for which it is undefined).</li><li><code>firstindex(::T, ::Integer)</code> returning <code>1</code> for a valid dimension (except  <code>DataFrameRows</code> and <code>GroupKeys</code> for which <code>1</code> is also returned for a  dimension higher than a valid one because they are <code>AbstractVector</code>).</li><li><code>lastindex(::T)</code> returning <code>Int</code> (except <code>AbstractDataFrame</code> for which it is undefined).</li><li><code>lastindex(::T, ::Integer)</code> returning <code>Int</code> for a valid dimension  (except  <code>DataFrameRows</code> and <code>GroupKeys</code> for which <code>1</code> is also returned for a  dimension higher than a valid one because they are <code>AbstractVector</code>).</li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../functions/">« Functions</a><a class="docs-footer-nextpage" href="../internals/">Internals »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.12 on <span class="colophon-date" title="Sunday 23 January 2022 13:51">Sunday 23 January 2022</span>. Using Julia version 1.7.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
