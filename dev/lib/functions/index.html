<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Functions · DataFrames.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="DataFrames.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">DataFrames.jl</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><span class="tocitem">User Guide</span><ul><li><a class="tocitem" href="../../man/getting_started/">Getting Started</a></li><li><a class="tocitem" href="../../man/joins/">Joins</a></li><li><a class="tocitem" href="../../man/split_apply_combine/">Split-apply-combine</a></li><li><a class="tocitem" href="../../man/reshaping_and_pivoting/">Reshaping</a></li><li><a class="tocitem" href="../../man/sorting/">Sorting</a></li><li><a class="tocitem" href="../../man/categorical/">Categorical Data</a></li><li><a class="tocitem" href="../../man/missing/">Missing Data</a></li><li><a class="tocitem" href="../../man/querying_frameworks/">Data manipulation frameworks</a></li><li><a class="tocitem" href="../../man/comparisons/">Comparison with Stata/R</a></li></ul></li><li><span class="tocitem">API</span><ul><li><a class="tocitem" href="../types/">Types</a></li><li class="is-active"><a class="tocitem" href>Functions</a><ul class="internal"><li><a class="tocitem" href="#Constructing-data-frames"><span>Constructing data frames</span></a></li><li><a class="tocitem" href="#Summary-information"><span>Summary information</span></a></li><li><a class="tocitem" href="#Working-with-column-names"><span>Working with column names</span></a></li><li><a class="tocitem" href="#Mutating-and-transforming-data-frames-and-grouped-data-frames"><span>Mutating and transforming data frames and grouped data frames</span></a></li><li><a class="tocitem" href="#Reshaping-data-frames-between-tall-and-wide-formats"><span>Reshaping data frames between tall and wide formats</span></a></li><li><a class="tocitem" href="#Sorting"><span>Sorting</span></a></li><li><a class="tocitem" href="#Joining"><span>Joining</span></a></li><li><a class="tocitem" href="#Grouping"><span>Grouping</span></a></li><li><a class="tocitem" href="#Filtering-rows"><span>Filtering rows</span></a></li><li><a class="tocitem" href="#Working-with-missing-values"><span>Working with missing values</span></a></li><li><a class="tocitem" href="#Iteration"><span>Iteration</span></a></li><li><a class="tocitem" href="#Equality"><span>Equality</span></a></li></ul></li><li><a class="tocitem" href="../indexing/">Indexing</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">API</a></li><li class="is-active"><a href>Functions</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Functions</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaData/DataFrames.jl/blob/master/docs/src/lib/functions.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Functions"><a class="docs-heading-anchor" href="#Functions">Functions</a><a id="Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Functions" title="Permalink"></a></h1><ul><li><a href="#Base.append!"><code>Base.append!</code></a></li><li><a href="#Base.copy"><code>Base.copy</code></a></li><li><a href="#Base.delete!"><code>Base.delete!</code></a></li><li><a href="#Base.empty"><code>Base.empty</code></a></li><li><a href="#Base.empty!"><code>Base.empty!</code></a></li><li><a href="#Base.filter"><code>Base.filter</code></a></li><li><a href="#Base.filter!"><code>Base.filter!</code></a></li><li><a href="#Base.first"><code>Base.first</code></a></li><li><a href="#Base.get"><code>Base.get</code></a></li><li><a href="#Base.hcat"><code>Base.hcat</code></a></li><li><a href="#Base.isapprox"><code>Base.isapprox</code></a></li><li><a href="#Base.issorted"><code>Base.issorted</code></a></li><li><a href="#Base.keys"><code>Base.keys</code></a></li><li><a href="#Base.last"><code>Base.last</code></a></li><li><a href="#Base.length"><code>Base.length</code></a></li><li><a href="#Base.names"><code>Base.names</code></a></li><li><a href="#Base.ndims"><code>Base.ndims</code></a></li><li><a href="#Base.pairs"><code>Base.pairs</code></a></li><li><a href="#Base.parent"><code>Base.parent</code></a></li><li><a href="#Base.propertynames"><code>Base.propertynames</code></a></li><li><a href="#Base.push!"><code>Base.push!</code></a></li><li><a href="#Base.repeat"><code>Base.repeat</code></a></li><li><a href="#Base.show"><code>Base.show</code></a></li><li><a href="#Base.similar"><code>Base.similar</code></a></li><li><a href="#Base.size"><code>Base.size</code></a></li><li><a href="#Base.sort"><code>Base.sort</code></a></li><li><a href="#Base.sort!"><code>Base.sort!</code></a></li><li><a href="#Base.sortperm"><code>Base.sortperm</code></a></li><li><a href="#Base.unique"><code>Base.unique</code></a></li><li><a href="#Base.unique!"><code>Base.unique!</code></a></li><li><a href="#Base.values"><code>Base.values</code></a></li><li><a href="#Base.vcat"><code>Base.vcat</code></a></li><li><a href="#Compat.eachcol"><code>Compat.eachcol</code></a></li><li><a href="#Compat.eachrow"><code>Compat.eachrow</code></a></li><li><a href="#DataAPI.describe"><code>DataAPI.describe</code></a></li><li><a href="#DataFrames.allowmissing!"><code>DataFrames.allowmissing!</code></a></li><li><a href="#DataFrames.antijoin"><code>DataFrames.antijoin</code></a></li><li><a href="#DataFrames.combine"><code>DataFrames.combine</code></a></li><li><a href="#DataFrames.completecases"><code>DataFrames.completecases</code></a></li><li><a href="#DataFrames.crossjoin"><code>DataFrames.crossjoin</code></a></li><li><a href="#DataFrames.disallowmissing!"><code>DataFrames.disallowmissing!</code></a></li><li><a href="#DataFrames.dropmissing"><code>DataFrames.dropmissing</code></a></li><li><a href="#DataFrames.dropmissing!"><code>DataFrames.dropmissing!</code></a></li><li><a href="#DataFrames.flatten"><code>DataFrames.flatten</code></a></li><li><a href="#DataFrames.groupby"><code>DataFrames.groupby</code></a></li><li><a href="#DataFrames.groupcols"><code>DataFrames.groupcols</code></a></li><li><a href="#DataFrames.groupindices"><code>DataFrames.groupindices</code></a></li><li><a href="#DataFrames.innerjoin"><code>DataFrames.innerjoin</code></a></li><li><a href="#DataFrames.insertcols!"><code>DataFrames.insertcols!</code></a></li><li><a href="#DataFrames.leftjoin"><code>DataFrames.leftjoin</code></a></li><li><a href="#DataFrames.mapcols"><code>DataFrames.mapcols</code></a></li><li><a href="#DataFrames.mapcols!"><code>DataFrames.mapcols!</code></a></li><li><a href="#DataFrames.ncol"><code>DataFrames.ncol</code></a></li><li><a href="#DataFrames.nonunique"><code>DataFrames.nonunique</code></a></li><li><a href="#DataFrames.nrow"><code>DataFrames.nrow</code></a></li><li><a href="#DataFrames.order"><code>DataFrames.order</code></a></li><li><a href="#DataFrames.outerjoin"><code>DataFrames.outerjoin</code></a></li><li><a href="#DataFrames.rename"><code>DataFrames.rename</code></a></li><li><a href="#DataFrames.rename!"><code>DataFrames.rename!</code></a></li><li><a href="#DataFrames.repeat!"><code>DataFrames.repeat!</code></a></li><li><a href="#DataFrames.rightjoin"><code>DataFrames.rightjoin</code></a></li><li><a href="#DataFrames.rownumber"><code>DataFrames.rownumber</code></a></li><li><a href="#DataFrames.select"><code>DataFrames.select</code></a></li><li><a href="#DataFrames.select!"><code>DataFrames.select!</code></a></li><li><a href="#DataFrames.semijoin"><code>DataFrames.semijoin</code></a></li><li><a href="#DataFrames.stack"><code>DataFrames.stack</code></a></li><li><a href="#DataFrames.transform"><code>DataFrames.transform</code></a></li><li><a href="#DataFrames.transform!"><code>DataFrames.transform!</code></a></li><li><a href="#DataFrames.unstack"><code>DataFrames.unstack</code></a></li><li><a href="#DataFrames.valuecols"><code>DataFrames.valuecols</code></a></li><li><a href="#Missings.allowmissing"><code>Missings.allowmissing</code></a></li><li><a href="#Missings.disallowmissing"><code>Missings.disallowmissing</code></a></li></ul><h2 id="Constructing-data-frames"><a class="docs-heading-anchor" href="#Constructing-data-frames">Constructing data frames</a><a id="Constructing-data-frames-1"></a><a class="docs-heading-anchor-permalink" href="#Constructing-data-frames" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Base.copy" href="#Base.copy"><code>Base.copy</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">copy(df::DataFrame; copycols::Bool=true)</code></pre><p>Copy data frame <code>df</code>. If <code>copycols=true</code> (the default), return a new  <code>DataFrame</code> holding copies of column vectors in <code>df</code>. If <code>copycols=false</code>, return a new <code>DataFrame</code> sharing column vectors with <code>df</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/6b0feaadd019c5ee36010ab956b5fee7b67681d5/src/dataframe/dataframe.jl#L777-L784">source</a></section><section><div><pre><code class="language-none">copy(dfr::DataFrameRow)</code></pre><p>Construct a <code>NamedTuple</code> with the same contents as the <a href="../types/#DataFrames.DataFrameRow"><code>DataFrameRow</code></a>. This method returns a <code>NamedTuple</code> so that the returned object is not affected by changes to the parent data frame of which <code>dfr</code> is a view.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/6b0feaadd019c5ee36010ab956b5fee7b67681d5/src/dataframerow/dataframerow.jl#L417-L424">source</a></section><section><div><pre><code class="language-none">copy(key::GroupKey)</code></pre><p>Construct a <code>NamedTuple</code> with the same contents as the <a href="../types/#DataFrames.GroupKey"><code>GroupKey</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/6b0feaadd019c5ee36010ab956b5fee7b67681d5/src/groupeddataframe/groupeddataframe.jl#L313-L317">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.similar" href="#Base.similar"><code>Base.similar</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">similar(df::AbstractDataFrame, rows::Integer=nrow(df))</code></pre><p>Create a new <code>DataFrame</code> with the same column names and column element types as <code>df</code>. An optional second argument can be provided to request a number of rows that is different than the number of rows present in <code>df</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/6b0feaadd019c5ee36010ab956b5fee7b67681d5/src/abstractdataframe/abstractdataframe.jl#L362-L368">source</a></section></article><h2 id="Summary-information"><a class="docs-heading-anchor" href="#Summary-information">Summary information</a><a id="Summary-information-1"></a><a class="docs-heading-anchor-permalink" href="#Summary-information" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="DataAPI.describe" href="#DataAPI.describe"><code>DataAPI.describe</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">describe(df::AbstractDataFrame; cols=:)
describe(df::AbstractDataFrame, stats::Union{Symbol, Pair}...; cols=:)</code></pre><p>Return descriptive statistics for a data frame as a new <code>DataFrame</code> where each row represents a variable and each column a summary statistic.</p><p><strong>Arguments</strong></p><ul><li><code>df</code> : the <code>AbstractDataFrame</code></li><li><code>stats::Union{Symbol, Pair}...</code> : the summary statistics to report. Arguments can be:<ul><li>A symbol from the list <code>:mean</code>, <code>:std</code>, <code>:min</code>, <code>:q25</code>, <code>:median</code>, <code>:q75</code>, <code>:max</code>, <code>:eltype</code>, <code>:nunique</code>, <code>:first</code>, <code>:last</code>, and <code>:nmissing</code>. The default statistics used are <code>:mean</code>, <code>:min</code>, <code>:median</code>, <code>:max</code>, <code>:nmissing</code>, and <code>:eltype</code>.</li><li><code>:all</code> as the only <code>Symbol</code> argument to return all statistics.</li><li>A <code>name =&gt; function</code> pair where <code>name</code> is a <code>Symbol</code> or string. This will create a column of summary statistics with the provided name.</li></ul></li><li><code>cols</code> : a keyword argument allowing to select only a subset of columns from <code>df</code> to describe. Can be any column selector (<code>Symbol</code>, string or integer; <code>:</code>, <code>All</code>, <code>Between</code>, <code>Not</code>, a regular expression, or a vector of <code>Symbol</code>s, strings or integers).</li></ul><p><strong>Details</strong></p><p>For <code>Real</code> columns, compute the mean, standard deviation, minimum, first quantile, median, third quantile, and maximum. If a column does not derive from <code>Real</code>, <code>describe</code> will attempt to calculate all statistics, using <code>nothing</code> as a fall-back in the case of an error.</p><p>When <code>stats</code> contains <code>:nunique</code>, <code>describe</code> will report the number of unique values in a column. If a column&#39;s base type derives from <code>Real</code>, <code>:nunique</code> will return <code>nothing</code>s.</p><p>Missing values are filtered in the calculation of all statistics, however the column <code>:nmissing</code> will report the number of missing values of that variable.</p><p>If custom functions are provided, they are called repeatedly with the vector corresponding to each column as the only argument. For columns allowing for missing values, the vector is wrapped in a call to <code>skipmissing</code>: custom functions must therefore support such objects (and not only vectors), and cannot access missing values.</p><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; df = DataFrame(i=1:10, x=0.1:0.1:1.0, y=&#39;a&#39;:&#39;j&#39;);

julia&gt; describe(df)
3×7 DataFrame
│ Row │ variable │ mean   │ min │ median │ max │ nmissing │ eltype   │
│     │ Symbol   │ Union… │ Any │ Union… │ Any │ Int64    │ DataType │
├─────┼──────────┼────────┼─────┼────────┼─────┼──────────┼──────────┤
│ 1   │ i        │ 5.5    │ 1   │ 5.5    │ 10  │ 0        │ Int64    │
│ 2   │ x        │ 0.55   │ 0.1 │ 0.55   │ 1.0 │ 0        │ Float64  │
│ 3   │ y        │        │ &#39;a&#39; │        │ &#39;j&#39; │ 0        │ Char     │

julia&gt; describe(df, :min, :max)
3×3 DataFrame
│ Row │ variable │ min │ max │
│     │ Symbol   │ Any │ Any │
├─────┼──────────┼─────┼─────┤
│ 1   │ i        │ 1   │ 10  │
│ 2   │ x        │ 0.1 │ 1.0 │
│ 3   │ y        │ &#39;a&#39; │ &#39;j&#39; │

julia&gt; describe(df, :min, :sum =&gt; sum)
3×3 DataFrame
│ Row │ variable │ min │ sum │
│     │ Symbol   │ Any │ Any │
├─────┼──────────┼─────┼─────┤
│ 1   │ i        │ 1   │ 55  │
│ 2   │ x        │ 0.1 │ 5.5 │
│ 3   │ y        │ &#39;a&#39; │     │

julia&gt; describe(df, :min, :sum =&gt; sum, cols=:x)
1×3 DataFrame
│ Row │ variable │ min     │ sum     │
│     │ Symbol   │ Float64 │ Float64 │
├─────┼──────────┼─────────┼─────────┤
│ 1   │ x        │ 0.1     │ 5.5     │</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/6b0feaadd019c5ee36010ab956b5fee7b67681d5/src/abstractdataframe/abstractdataframe.jl#L462-L540">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.length" href="#Base.length"><code>Base.length</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">length(dfr::DataFrameRow)</code></pre><p>Return the number of elements of <code>dfr</code>.</p><p>See also: <a href="#Base.size"><code>size</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; dfr = DataFrame(a=1:3, b=&#39;a&#39;:&#39;c&#39;)[1, :];

julia&gt; length(dfr)
2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/6b0feaadd019c5ee36010ab956b5fee7b67681d5/src/dataframerow/dataframerow.jl#L343-L357">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFrames.ncol" href="#DataFrames.ncol"><code>DataFrames.ncol</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">nrow(df::AbstractDataFrame)
ncol(df::AbstractDataFrame)</code></pre><p>Return the number of rows or columns in an <code>AbstractDataFrame</code> <code>df</code>.</p><p>See also <a href="#Base.size"><code>size</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; df = DataFrame(i = 1:10, x = rand(10), y = rand([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;], 10));

julia&gt; size(df)
(10, 3)

julia&gt; nrow(df)
10

julia&gt; ncol(df)
3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/6b0feaadd019c5ee36010ab956b5fee7b67681d5/src/abstractdataframe/abstractdataframe.jl#L1567-L1590">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.ndims" href="#Base.ndims"><code>Base.ndims</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">ndims(::AbstractDataFrame)
ndims(::Type{&lt;:AbstractDataFrame})</code></pre><p>Return the number of dimensions of a data frame, which is always <code>2</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/6b0feaadd019c5ee36010ab956b5fee7b67681d5/src/abstractdataframe/abstractdataframe.jl#L335-L340">source</a></section><section><div><pre><code class="language-none">ndims(::DataFrameRow)
ndims(::Type{&lt;:DataFrameRow})</code></pre><p>Return the number of dimensions of a data frame row, which is always <code>1</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/6b0feaadd019c5ee36010ab956b5fee7b67681d5/src/dataframerow/dataframerow.jl#L360-L365">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFrames.nrow" href="#DataFrames.nrow"><code>DataFrames.nrow</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">nrow(df::AbstractDataFrame)
ncol(df::AbstractDataFrame)</code></pre><p>Return the number of rows or columns in an <code>AbstractDataFrame</code> <code>df</code>.</p><p>See also <a href="#Base.size"><code>size</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; df = DataFrame(i = 1:10, x = rand(10), y = rand([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;], 10));

julia&gt; size(df)
(10, 3)

julia&gt; nrow(df)
10

julia&gt; ncol(df)
3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/6b0feaadd019c5ee36010ab956b5fee7b67681d5/src/abstractdataframe/abstractdataframe.jl#L1567-L1590">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFrames.rownumber" href="#DataFrames.rownumber"><code>DataFrames.rownumber</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">rownumber(dfr::DataFrameRow)</code></pre><p>Return a row number in the <code>AbstractDataFrame</code> that <code>dfr</code> was created from.</p><p>Note that this differs from the first element in the tuple returned by <code>parentindices</code>. The latter gives the row number in the <code>parent(dfr)</code>, which is the source <code>DataFrame</code> where data that <code>dfr</code> gives access to is stored.</p><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; df = DataFrame(reshape(1:12, 3, 4))
3×4 DataFrame
│ Row │ x1    │ x2    │ x3    │ x4    │
│     │ Int64 │ Int64 │ Int64 │ Int64 │
├─────┼───────┼───────┼───────┼───────┤
│ 1   │ 1     │ 4     │ 7     │ 10    │
│ 2   │ 2     │ 5     │ 8     │ 11    │
│ 3   │ 3     │ 6     │ 9     │ 12    │

julia&gt; dfr = df[2, :]
DataFrameRow
│ Row │ x1    │ x2    │ x3    │ x4    │
│     │ Int64 │ Int64 │ Int64 │ Int64 │
├─────┼───────┼───────┼───────┼───────┤
│ 2   │ 2     │ 5     │ 8     │ 11    │

julia&gt; rownumber(dfr)
2

julia&gt; parentindices(dfr)
(2, Base.OneTo(4))

julia&gt; parent(dfr)
3×4 DataFrame
│ Row │ x1    │ x2    │ x3    │ x4    │
│     │ Int64 │ Int64 │ Int64 │ Int64 │
├─────┼───────┼───────┼───────┼───────┤
│ 1   │ 1     │ 4     │ 7     │ 10    │
│ 2   │ 2     │ 5     │ 8     │ 11    │
│ 3   │ 3     │ 6     │ 9     │ 12    │

julia&gt; dfv = @view df[2:3, 1:3]
2×3 SubDataFrame
│ Row │ x1    │ x2    │ x3    │
│     │ Int64 │ Int64 │ Int64 │
├─────┼───────┼───────┼───────┤
│ 1   │ 2     │ 5     │ 8     │
│ 2   │ 3     │ 6     │ 9     │

julia&gt; dfrv = dfv[2, :]
DataFrameRow
│ Row │ x1    │ x2    │ x3    │
│     │ Int64 │ Int64 │ Int64 │
├─────┼───────┼───────┼───────┤
│ 3   │ 3     │ 6     │ 9     │

julia&gt; rownumber(dfrv)
2

julia&gt; parentindices(dfrv)
(3, 1:3)

julia&gt; parent(dfrv)
3×4 DataFrame
│ Row │ x1    │ x2    │ x3    │ x4    │
│     │ Int64 │ Int64 │ Int64 │ Int64 │
├─────┼───────┼───────┼───────┼───────┤
│ 1   │ 1     │ 4     │ 7     │ 10    │
│ 2   │ 2     │ 5     │ 8     │ 11    │
│ 3   │ 3     │ 6     │ 9     │ 12    │</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/6b0feaadd019c5ee36010ab956b5fee7b67681d5/src/dataframerow/dataframerow.jl#L121-L193">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.show" href="#Base.show"><code>Base.show</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">show([io::IO,] df::AbstractDataFrame;
     allrows::Bool = !get(io, :limit, false),
     allcols::Bool = !get(io, :limit, false),
     allgroups::Bool = !get(io, :limit, false),
     splitcols::Bool = get(io, :limit, false),
     rowlabel::Symbol = :Row,
     summary::Bool = true,
     eltypes::Bool = true)</code></pre><p>Render a data frame to an I/O stream. The specific visual representation chosen depends on the width of the display.</p><p>If <code>io</code> is omitted, the result is printed to <code>stdout</code>, and <code>allrows</code>, <code>allcols</code> and <code>allgroups</code> default to <code>false</code> while <code>splitcols</code> defaults to <code>true</code>.</p><p><strong>Arguments</strong></p><ul><li><code>io::IO</code>: The I/O stream to which <code>df</code> will be printed.</li><li><code>df::AbstractDataFrame</code>: The data frame to print.</li><li><code>allrows::Bool</code>: Whether to print all rows, rather than a subset that fits the device height. By default this is the case only if <code>io</code> does not have the <code>IOContext</code> property <code>limit</code> set.</li><li><code>allcols::Bool</code>: Whether to print all columns, rather than a subset that fits the device width. By default this is the case only if <code>io</code> does not have the <code>IOContext</code> property <code>limit</code> set.</li><li><code>allgroups::Bool</code>: Whether to print all groups rather than the first and last, when <code>df</code> is a <code>GroupedDataFrame</code>. By default this is the case only if <code>io</code> does not have the <code>IOContext</code> property <code>limit</code> set.</li><li><code>splitcols::Bool</code>: Whether to split printing in chunks of columns fitting the screen width rather than printing all columns in the same block. Only applies if <code>allcols</code> is <code>true</code>. By default this is the case only if <code>io</code> has the <code>IOContext</code> property <code>limit</code> set.</li><li><code>rowlabel::Symbol = :Row</code>: The label to use for the column containing row numbers.</li><li><code>summary::Bool = true</code>: Whether to print a brief string summary of the data frame.</li><li><code>eltypes::Bool = true</code>: Whether to print the column types under column names.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using DataFrames

julia&gt; df = DataFrame(A = 1:3, B = [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;]);

julia&gt; show(df, allcols=true)
3×2 DataFrame
│ Row │ A     │ B      │
│     │ Int64 │ String │
├─────┼───────┼────────┤
│ 1   │ 1     │ x      │
│ 2   │ 2     │ y      │
│ 3   │ 3     │ z      │</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/6b0feaadd019c5ee36010ab956b5fee7b67681d5/src/abstractdataframe/show.jl#L604-L657">source</a></section><section><div><pre><code class="language-none">show(io::IO, mime::MIME, df::AbstractDataFrame)</code></pre><p>Render a data frame to an I/O stream in MIME type <code>mime</code>.</p><p><strong>Arguments</strong></p><ul><li><code>io::IO</code>: The I/O stream to which <code>df</code> will be printed.</li><li><code>mime::MIME</code>: supported MIME types are: <code>&quot;text/plain&quot;</code>, <code>&quot;text/html&quot;</code>, <code>&quot;text/latex&quot;</code>, <code>&quot;text/csv&quot;</code>, <code>&quot;text/tab-separated-values&quot;</code> (the last two MIME types do not support  showing <code>#undef</code> values)</li><li><code>df::AbstractDataFrame</code>: The data frame to print.</li></ul><p>Additionally selected MIME types support passing the following keyword arguments:</p><ul><li>MIME type <code>&quot;text/plain&quot;</code> accepts all listed keyword arguments and therir behavior is identical as for <code>show(::IO, ::AbstractDataFrame)</code></li><li>MIME type <code>&quot;text/html&quot;</code> accepts <code>summary</code> keyword argument which allows to choose whether to print a brief string summary of the data frame.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; show(stdout, MIME(&quot;text/latex&quot;), DataFrame(A = 1:3, B = [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;]))
\begin{tabular}{r|cc}
        &amp; A &amp; B\\
        \hline
        &amp; Int64 &amp; String\\
        \hline
        1 &amp; 1 &amp; x \\
        2 &amp; 2 &amp; y \\
        3 &amp; 3 &amp; z \\
\end{tabular}
14

julia&gt; show(stdout, MIME(&quot;text/csv&quot;), DataFrame(A = 1:3, B = [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;]))
&quot;A&quot;,&quot;B&quot;
1,&quot;x&quot;
2,&quot;y&quot;
3,&quot;z&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/6b0feaadd019c5ee36010ab956b5fee7b67681d5/src/abstractdataframe/io.jl#L1-L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.size" href="#Base.size"><code>Base.size</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">size(df::AbstractDataFrame, [dim])</code></pre><p>Return a tuple containing the number of rows and columns of <code>df</code>. Optionally a dimension <code>dim</code> can be specified, where <code>1</code> corresponds to rows and <code>2</code> corresponds to columns.</p><p>See also: <a href="#DataFrames.nrow"><code>nrow</code></a>, <a href="#DataFrames.ncol"><code>ncol</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; df = DataFrame(a=1:3, b=&#39;a&#39;:&#39;c&#39;);

julia&gt; size(df)
(3, 2)

julia&gt; size(df, 1)
3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/6b0feaadd019c5ee36010ab956b5fee7b67681d5/src/abstractdataframe/abstractdataframe.jl#L299-L318">source</a></section><section><div><pre><code class="language-none">size(dfr::DataFrameRow, [dim])</code></pre><p>Return a 1-tuple containing the number of elements of <code>dfr</code>. If an optional dimension <code>dim</code> is specified, it must be <code>1</code>, and the number of elements is returned directly as a number.</p><p>See also: <a href="#Base.length"><code>length</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; dfr = DataFrame(a=1:3, b=&#39;a&#39;:&#39;c&#39;)[1, :];

julia&gt; size(dfr)
(2,)

julia&gt; size(dfr, 1)
2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/6b0feaadd019c5ee36010ab956b5fee7b67681d5/src/dataframerow/dataframerow.jl#L320-L339">source</a></section></article><h2 id="Working-with-column-names"><a class="docs-heading-anchor" href="#Working-with-column-names">Working with column names</a><a id="Working-with-column-names-1"></a><a class="docs-heading-anchor-permalink" href="#Working-with-column-names" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Base.names" href="#Base.names"><code>Base.names</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">names(df::AbstractDataFrame)
names(df::AbstractDataFrame, cols)</code></pre><p>Return a freshly allocated <code>Vector{String}</code> of names of columns contained in <code>df</code>.</p><p>If <code>cols</code> is passed then restrict returned column names to those matching the selector (this is useful in particular with regular expressions, <code>Not</code>, and <code>Between</code>). <code>cols</code> can be any column selector (<code>Symbol</code>, string or integer; <code>:</code>, <code>All</code>, <code>Between</code>, <code>Not</code>, a regular expression, or a vector of <code>Symbol</code>s, strings or integers).</p><p>See also <a href="#Base.propertynames"><code>propertynames</code></a> which returns a <code>Vector{Symbol}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/6b0feaadd019c5ee36010ab956b5fee7b67681d5/src/abstractdataframe/abstractdataframe.jl#L63-L74">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.propertynames" href="#Base.propertynames"><code>Base.propertynames</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">propertynames(df::AbstractDataFrame)</code></pre><p>Return a freshly allocated <code>Vector{Symbol}</code> of names of columns contained in <code>df</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/6b0feaadd019c5ee36010ab956b5fee7b67681d5/src/abstractdataframe/abstractdataframe.jl#L349-L353">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFrames.rename" href="#DataFrames.rename"><code>DataFrames.rename</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">rename(df::AbstractDataFrame, vals::AbstractVector{Symbol};
       makeunique::Bool=false)
rename(df::AbstractDataFrame, vals::AbstractVector{&lt;:AbstractString};
       makeunique::Bool=false)
rename(df::AbstractDataFrame, (from =&gt; to)::Pair...)
rename(df::AbstractDataFrame, d::AbstractDict)
rename(df::AbstractDataFrame, d::AbstractVector{&lt;:Pair})
rename(f::Function, df::AbstractDataFrame)</code></pre><p>Create a new data frame that is a copy of <code>df</code> with changed column names. Each name is changed at most once. Permutation of names is allowed.</p><p><strong>Arguments</strong></p><ul><li><code>df</code> : the <code>AbstractDataFrame</code>; if it is a <code>SubDataFrame</code> then renaming is only allowed if it was created using <code>:</code> as a column selector.</li><li><code>d</code> : an <code>AbstractDict</code> or an <code>AbstractVector</code> of <code>Pair</code>s that maps the original names or column numbers to new names</li><li><code>f</code> : a function which for each column takes the old name as a <code>String</code> and returns the new name that gets converted to a <code>Symbol</code></li><li><code>vals</code> : new column names as a vector of <code>Symbol</code>s or <code>AbstractString</code>s of the same length as the number of columns in <code>df</code></li><li><code>makeunique</code> : if <code>false</code> (the default), an error will be raised if duplicate names are found; if <code>true</code>, duplicate names will be suffixed with <code>_i</code> (<code>i</code> starting at 1 for the first duplicate).</li></ul><p>If pairs are passed to <code>rename</code> (as positional arguments or in a dictionary or a vector) then:</p><ul><li><code>from</code> value can be a <code>Symbol</code>, an <code>AbstractString</code> or an <code>Integer</code>;</li><li><code>to</code> value can be a <code>Symbol</code> or an <code>AbstractString</code>.</li></ul><p>Mixing symbols and strings in <code>to</code> and <code>from</code> is not allowed.</p><p>See also: <a href="#DataFrames.rename!"><code>rename!</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; df = DataFrame(i = 1, x = 2, y = 3)
1×3 DataFrame
│ Row │ i     │ x     │ y     │
│     │ Int64 │ Int64 │ Int64 │
├─────┼───────┼───────┼───────┤
│ 1   │ 1     │ 2     │ 3     │

julia&gt; rename(df, :i =&gt; :A, :x =&gt; :X)
1×3 DataFrame
│ Row │ A     │ X     │ y     │
│     │ Int64 │ Int64 │ Int64 │
├─────┼───────┼───────┼───────┤
│ 1   │ 1     │ 2     │ 3     │

julia&gt; rename(df, :x =&gt; :y, :y =&gt; :x)
1×3 DataFrame
│ Row │ i     │ y     │ x     │
│     │ Int64 │ Int64 │ Int64 │
├─────┼───────┼───────┼───────┤
│ 1   │ 1     │ 2     │ 3     │

julia&gt; rename(df, [1 =&gt; :A, 2 =&gt; :X])
1×3 DataFrame
│ Row │ A     │ X     │ y     │
│     │ Int64 │ Int64 │ Int64 │
├─────┼───────┼───────┼───────┤
│ 1   │ 1     │ 2     │ 3     │

julia&gt; rename(df, Dict(&quot;i&quot; =&gt; &quot;A&quot;, &quot;x&quot; =&gt; &quot;X&quot;))
1×3 DataFrame
│ Row │ A     │ X     │ y     │
│     │ Int64 │ Int64 │ Int64 │
├─────┼───────┼───────┼───────┤
│ 1   │ 1     │ 2     │ 3     │

julia&gt; rename(uppercase, df)
1×3 DataFrame
│ Row │ I     │ X     │ Y     │
│     │ Int64 │ Int64 │ Int64 │
├─────┼───────┼───────┼───────┤
│ 1   │ 1     │ 2     │ 3     │</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/6b0feaadd019c5ee36010ab956b5fee7b67681d5/src/abstractdataframe/abstractdataframe.jl#L212-L291">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFrames.rename!" href="#DataFrames.rename!"><code>DataFrames.rename!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">rename!(df::AbstractDataFrame, vals::AbstractVector{Symbol};
        makeunique::Bool=false)
rename!(df::AbstractDataFrame, vals::AbstractVector{&lt;:AbstractString};
        makeunique::Bool=false)
rename!(df::AbstractDataFrame, (from =&gt; to)::Pair...)
rename!(df::AbstractDataFrame, d::AbstractDict)
rename!(df::AbstractDataFrame, d::AbstractVector{&lt;:Pair})
rename!(f::Function, df::AbstractDataFrame)</code></pre><p>Rename columns of <code>df</code> in-place. Each name is changed at most once. Permutation of names is allowed.</p><p><strong>Arguments</strong></p><ul><li><code>df</code> : the <code>AbstractDataFrame</code></li><li><code>d</code> : an <code>AbstractDict</code> or an <code>AbstractVector</code> of <code>Pair</code>s that maps the original names or column numbers to new names</li><li><code>f</code> : a function which for each column takes the old name as a <code>String</code> and returns the new name that gets converted to a <code>Symbol</code></li><li><code>vals</code> : new column names as a vector of <code>Symbol</code>s or <code>AbstractString</code>s of the same length as the number of columns in <code>df</code></li><li><code>makeunique</code> : if <code>false</code> (the default), an error will be raised if duplicate names are found; if <code>true</code>, duplicate names will be suffixed with <code>_i</code> (<code>i</code> starting at 1 for the first duplicate).</li></ul><p>If pairs are passed to <code>rename!</code> (as positional arguments or in a dictionary or a vector) then:</p><ul><li><code>from</code> value can be a <code>Symbol</code>, an <code>AbstractString</code> or an <code>Integer</code>;</li><li><code>to</code> value can be a <code>Symbol</code> or an <code>AbstractString</code>.</li></ul><p>Mixing symbols and strings in <code>to</code> and <code>from</code> is not allowed.</p><p>See also: <a href="#DataFrames.rename"><code>rename</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; df = DataFrame(i = 1, x = 2, y = 3)
1×3 DataFrame
│ Row │ i     │ x     │ y     │
│     │ Int64 │ Int64 │ Int64 │
├─────┼───────┼───────┼───────┤
│ 1   │ 1     │ 2     │ 3     │

julia&gt; rename!(df, Dict(:i =&gt; &quot;A&quot;, :x =&gt; &quot;X&quot;))
1×3 DataFrame
│ Row │ A     │ X     │ y     │
│     │ Int64 │ Int64 │ Int64 │
├─────┼───────┼───────┼───────┤
│ 1   │ 1     │ 2     │ 3     │

julia&gt; rename!(df, [:a, :b, :c])
1×3 DataFrame
│ Row │ a     │ b     │ c     │
│     │ Int64 │ Int64 │ Int64 │
├─────┼───────┼───────┼───────┤
│ 1   │ 1     │ 2     │ 3     │

julia&gt; rename!(df, [:a, :b, :a])
ERROR: ArgumentError: Duplicate variable names: :a. Pass makeunique=true to make
them unique using a suffix automatically.

julia&gt; rename!(df, [:a, :b, :a], makeunique=true)
1×3 DataFrame
│ Row │ a     │ b     │ a_1   │
│     │ Int64 │ Int64 │ Int64 │
├─────┼───────┼───────┼───────┤
│ 1   │ 1     │ 2     │ 3     │

julia&gt; rename!(uppercase, df)
1×3 DataFrame
│ Row │ A     │ B     │ A_1   │
│     │ Int64 │ Int64 │ Int64 │
├─────┼───────┼───────┼───────┤
│ 1   │ 1     │ 2     │ 3     │</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/6b0feaadd019c5ee36010ab956b5fee7b67681d5/src/abstractdataframe/abstractdataframe.jl#L91-L166">source</a></section></article><h2 id="Mutating-and-transforming-data-frames-and-grouped-data-frames"><a class="docs-heading-anchor" href="#Mutating-and-transforming-data-frames-and-grouped-data-frames">Mutating and transforming data frames and grouped data frames</a><a id="Mutating-and-transforming-data-frames-and-grouped-data-frames-1"></a><a class="docs-heading-anchor-permalink" href="#Mutating-and-transforming-data-frames-and-grouped-data-frames" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Base.append!" href="#Base.append!"><code>Base.append!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">append!(df::DataFrame, df2::AbstractDataFrame; cols::Symbol=:setequal,
        promote::Bool=(cols in [:union, :subset]))
append!(df::DataFrame, table; cols::Symbol=:setequal,
        promote::Bool=(cols in [:union, :subset]))</code></pre><p>Add the rows of <code>df2</code> to the end of <code>df</code>. If the second argument <code>table</code> is not an <code>AbstractDataFrame</code> then it is converted using <code>DataFrame(table, copycols=false)</code> before being appended.</p><p>The exact behavior of <code>append!</code> depends on the <code>cols</code> argument:</p><ul><li>If <code>cols == :setequal</code> (this is the default) then <code>df2</code> must contain exactly the same columns as <code>df</code> (but possibly in a different order).</li><li>If <code>cols == :orderequal</code> then <code>df2</code> must contain the same columns in the same order (for <code>AbstractDict</code> this option requires that <code>keys(row)</code> matches <code>propertynames(df)</code> to allow for support of ordered dicts; however, if <code>df2</code> is a <code>Dict</code> an error is thrown as it is an unordered collection).</li><li>If <code>cols == :intersect</code> then <code>df2</code> may contain more columns than <code>df</code>, but all column names that are present in <code>df</code> must be present in <code>df2</code> and only these are used.</li><li>If <code>cols == :subset</code> then <code>append!</code> behaves like for <code>:intersect</code> but if some column is missing in <code>df2</code> then a <code>missing</code> value is pushed to <code>df</code>.</li><li>If <code>cols == :union</code> then <code>append!</code> adds columns missing in <code>df</code> that are present in <code>row</code>, for columns present in <code>df</code> but missing in <code>row</code> a <code>missing</code> value is pushed.</li></ul><p>If <code>promote=true</code> and element type of a column present in <code>df</code> does not allow the type of a pushed argument then a new column with a promoted element type allowing it is freshly allocated and stored in <code>df</code>. If <code>promote=false</code> an error is thrown.</p><p>The above rule has the following exceptions:</p><ul><li>If <code>df</code> has no columns then copies of columns from <code>df2</code> are added to it.</li><li>If <code>df2</code> has no columns then calling <code>append!</code> leaves <code>df</code> unchanged.</li></ul><p>Please note that <code>append!</code> must not be used on a <code>DataFrame</code> that contains columns that are aliases (equal when compared with <code>===</code>).</p><p><strong>See also</strong></p><p>Use <a href="#Base.push!"><code>push!</code></a> to add individual rows to a data frame and <a href="#Base.vcat"><code>vcat</code></a> to vertically concatenate data frames.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; df1 = DataFrame(A=1:3, B=1:3);

julia&gt; df2 = DataFrame(A=4.0:6.0, B=4:6);

julia&gt; append!(df1, df2);

julia&gt; df1
6×2 DataFrame
│ Row │ A     │ B     │
│     │ Int64 │ Int64 │
├─────┼───────┼───────┤
│ 1   │ 1     │ 1     │
│ 2   │ 2     │ 2     │
│ 3   │ 3     │ 3     │
│ 4   │ 4     │ 4     │
│ 5   │ 5     │ 5     │
│ 6   │ 6     │ 6     │</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/6b0feaadd019c5ee36010ab956b5fee7b67681d5/src/dataframe/dataframe.jl#L993-L1057">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFrames.combine" href="#DataFrames.combine"><code>DataFrames.combine</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">combine(df::AbstractDataFrame, args...)
combine(arg, df::AbstractDataFrame)</code></pre><p>Create a new data frame that contains columns from <code>df</code> specified by <code>args</code> and return it. The result can have any number of rows that is determined by the values returned by passed transformations.</p><p>See <a href="#DataFrames.select"><code>select</code></a> for detailed rules regarding accepted values for <code>args</code> in <code>combine(df, args...)</code> form. For <code>combine(arg, df)</code> the same rules as for <code>combine</code> on <code>GroupedDataFrame</code> apply except that a <code>df</code> with zero rows is currently not allowed.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; df = DataFrame(a=1:3, b=4:6)
3×2 DataFrame
│ Row │ a     │ b     │
│     │ Int64 │ Int64 │
├─────┼───────┼───────┤
│ 1   │ 1     │ 4     │
│ 2   │ 2     │ 5     │
│ 3   │ 3     │ 6     │

julia&gt; combine(df, :a =&gt; sum, nrow)
1×2 DataFrame
│ Row │ a_sum │ nrow  │
│     │ Int64 │ Int64 │
├─────┼───────┼───────┤
│ 1   │ 6     │ 3     │</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/6b0feaadd019c5ee36010ab956b5fee7b67681d5/src/abstractdataframe/selection.jl#L509-L540">source</a></section><section><div><pre><code class="language-none">combine(gd::GroupedDataFrame, args...; keepkeys::Bool=true, ungroup::Bool=true)
combine(fun::Union{Function, Type}, gd::GroupedDataFrame;
        keepkeys::Bool=true, ungroup::Bool=true)
combine(pair::Pair, gd::GroupedDataFrame; keepkeys::Bool=true, ungroup::Bool=true)</code></pre><p>Apply operations to each group in a <a href="../types/#DataFrames.GroupedDataFrame"><code>GroupedDataFrame</code></a> and return the combined result as a <code>DataFrame</code> if <code>ungroup=true</code> or <code>GroupedDataFrame</code> if <code>ungroup=false</code>.</p><p>If an <code>AbstractDataFrame</code> is passed, apply operations to the data frame as a whole and a <code>DataFrame</code> is always returend.</p><p>Arguments passed as <code>args...</code> can be:</p><ul><li>Any index that is allowed for column indexing (<code>Symbol</code>, string or integer, <code>:</code>, <code>All</code>, <code>Between</code>, <code>Not</code>, a regular expression, or a vector of <code>Symbol</code>s, strings or integers).</li><li>Column transformation operations using the <code>Pair</code> notation that is described below and vectors of such pairs.</li></ul><p>Transformations allowed using <code>Pair</code>s follow the rules specified for <a href="#DataFrames.select"><code>select</code></a> and have the form <code>source_cols =&gt; fun</code>, <code>source_cols =&gt; fun =&gt; target_col</code>, or <code>source_col =&gt; target_col</code>. Function <code>fun</code> is passed <code>SubArray</code> views as positional arguments for each column specified to be selected, or a <code>NamedTuple</code> containing these <code>SubArray</code>s if <code>source_cols</code> is an <code>AsTable</code> selector. It can return a vector or a single value (defined precisely below).</p><p>As a special case <code>nrow</code> or <code>nrow =&gt; target_col</code> can be passed without specifying input columns to efficiently calculate number of rows in each group. If <code>nrow</code> is passed the resulting column name is <code>:nrow</code>.</p><p>If multiple <code>args</code> are passed then return values of different <code>fun</code>s are allowed to mix single values and vectors. In this case single values will be broadcasted to match the length of columns specified by returned vectors. As a particular rule, values wrapped in a <code>Ref</code> or a <code>0</code>-dimensional <code>AbstractArray</code> are unwrapped and then broadcasted.</p><p>If the first or last argument is <code>pair</code> then it must be a <code>Pair</code> following the rules for pairs described above, except that in this case function defined by <code>fun</code> can return any return value defined below.</p><p>If the first or last argument is a function <code>fun</code>, it is passed a <a href="../types/#DataFrames.SubDataFrame"><code>SubDataFrame</code></a> view for each group and can return any return value defined below. Note that this form is slower than <code>pair</code> or <code>args</code> due to type instability.</p><p>If <code>gd</code> has zero groups then no transformations are applied.</p><p><code>fun</code> can return a single value, a row, a vector, or multiple rows. The type of the returned value determines the shape of the resulting <code>DataFrame</code>. There are four kind of return values allowed:</p><ul><li>A single value gives a <code>DataFrame</code> with a single additional column and one row per group.</li><li>A named tuple of single values or a <a href="../types/#DataFrames.DataFrameRow"><code>DataFrameRow</code></a> gives a <code>DataFrame</code> with one additional column for each field and one row per group (returning a named tuple will be faster). It is not allowed to mix single values and vectors if a named tuple is returned.</li><li>A vector gives a <code>DataFrame</code> with a single additional column and as many rows for each group as the length of the returned vector for that group.</li><li>A data frame, a named tuple of vectors or a matrix gives a <code>DataFrame</code> with the same additional columns and as many rows for each group as the rows returned for that group (returning a named tuple is the fastest option). Returning a table with zero columns is allowed, whatever the number of columns returned for other groups.</li></ul><p><code>fun</code> must always return the same kind of object (out of four kinds defined above) for all groups, and with the same column names.</p><p>Optimized methods are used when standard summary functions (<code>sum</code>, <code>prod</code>, <code>minimum</code>, <code>maximum</code>, <code>mean</code>, <code>var</code>, <code>std</code>, <code>first</code>, <code>last</code> and <code>length</code>) are specified using the <code>Pair</code> syntax (e.g. <code>:col =&gt; sum</code>). When computing the <code>sum</code> or <code>mean</code> over floating point columns, results will be less accurate than the standard <code>sum</code> function (which uses pairwise summation). Use <code>col =&gt; x -&gt; sum(x)</code> to avoid the optimized method and use the slower, more accurate one.</p><p>Column names are automatically generated when necessary using the rules defined in <a href="#DataFrames.select"><code>select</code></a> if the <code>Pair</code> syntax is used and <code>fun</code> returns a single value or a vector (e.g. for <code>:col =&gt; sum</code> the column name is <code>col_sum</code>); otherwise (if <code>fun</code> is a function or a return value is an <code>AbstractMatrix</code>) columns are named <code>x1</code>, <code>x2</code> and so on.</p><p>If <code>keepkeys=true</code>, the resulting <code>DataFrame</code> contains all the grouping columns in addition to those generated. In this case if the returned value contains columns with the same names as the grouping columns, they are required to be equal. If <code>keepkeys=false</code> and some generated columns have the same name as grouping columns, they are kept and are not required to be equal to grouping columns.</p><p>If <code>ungroup=true</code> (the default) a <code>DataFrame</code> is returned. If <code>ungroup=false</code> a <code>GroupedDataFrame</code> grouped using <code>keycols(gdf)</code> is returned.</p><p>If <code>gd</code> has zero groups then transformations are applied to vectors of zero length.</p><p>Ordering of rows follows the order of groups in <code>gdf</code>.</p><p><strong>See also</strong></p><p><a href="#DataFrames.groupby"><code>groupby</code></a>, <a href="#DataFrames.select"><code>select</code></a>, <a href="#DataFrames.select!"><code>select!</code></a>, <a href="#DataFrames.transform"><code>transform</code></a>, <a href="#DataFrames.transform!"><code>transform!</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; df = DataFrame(a = repeat([1, 2, 3, 4], outer=[2]),
                      b = repeat([2, 1], outer=[4]),
                      c = 1:8);

julia&gt; gd = groupby(df, :a);

julia&gt; combine(gd, :c =&gt; sum, nrow)
4×3 DataFrame
│ Row │ a     │ c_sum │ nrow  │
│     │ Int64 │ Int64 │ Int64 │
├─────┼───────┼───────┼───────┤
│ 1   │ 1     │ 6     │ 2     │
│ 2   │ 2     │ 8     │ 2     │
│ 3   │ 3     │ 10    │ 2     │
│ 4   │ 4     │ 12    │ 2     │

julia&gt; combine(gd, :c =&gt; sum, nrow, ungroup=false)
GroupedDataFrame with 4 groups based on key: a
First Group (1 row): a = 1
│ Row │ a     │ c_sum │ nrow  │
│     │ Int64 │ Int64 │ Int64 │
├─────┼───────┼───────┼───────┤
│ 1   │ 1     │ 6     │ 2     │
⋮
Last Group (1 row): a = 4
│ Row │ a     │ c_sum │ nrow  │
│     │ Int64 │ Int64 │ Int64 │
├─────┼───────┼───────┼───────┤
│ 1   │ 4     │ 12    │ 2     │

julia&gt; combine(sdf -&gt; sum(sdf.c), gd) # Slower variant
4×2 DataFrame
│ Row │ a     │ x1    │
│     │ Int64 │ Int64 │
├─────┼───────┼───────┤
│ 1   │ 1     │ 6     │
│ 2   │ 2     │ 8     │
│ 3   │ 3     │ 10    │
│ 4   │ 4     │ 12    │

julia&gt; combine(gdf) do d # do syntax for the slower variant
           sum(d.c)
       end
4×2 DataFrame
│ Row │ a     │ x1    │
│     │ Int64 │ Int64 │
├─────┼───────┼───────┤
│ 1   │ 1     │ 6     │
│ 2   │ 2     │ 8     │
│ 3   │ 3     │ 10    │
│ 4   │ 4     │ 12    │

julia&gt; combine(gd, :c =&gt; (x -&gt; sum(log, x)) =&gt; :sum_log_c) # specifying a name for target column
4×2 DataFrame
│ Row │ a     │ sum_log_c │
│     │ Int64 │ Float64   │
├─────┼───────┼───────────┤
│ 1   │ 1     │ 1.60944   │
│ 2   │ 2     │ 2.48491   │
│ 3   │ 3     │ 3.04452   │
│ 4   │ 4     │ 3.46574   │


julia&gt; combine(gd, [:b, :c] .=&gt; sum) # passing a vector of pairs
4×3 DataFrame
│ Row │ a     │ b_sum │ c_sum │
│     │ Int64 │ Int64 │ Int64 │
├─────┼───────┼───────┼───────┤
│ 1   │ 1     │ 4     │ 6     │
│ 2   │ 2     │ 2     │ 8     │
│ 3   │ 3     │ 4     │ 10    │
│ 4   │ 4     │ 2     │ 12    │

julia&gt; combine(gd) do sdf # dropping group when DataFrame() is returned
          sdf.c[1] != 1 ? sdf : DataFrame()
       end
6×3 DataFrame
│ Row │ a     │ b     │ c     │
│     │ Int64 │ Int64 │ Int64 │
├─────┼───────┼───────┼───────┤
│ 1   │ 2     │ 1     │ 2     │
│ 2   │ 2     │ 1     │ 6     │
│ 3   │ 3     │ 2     │ 3     │
│ 4   │ 3     │ 2     │ 7     │
│ 5   │ 4     │ 1     │ 4     │
│ 6   │ 4     │ 1     │ 8     │

julia&gt; combine(gd, :b =&gt; :b1, :c =&gt; :c1,
               [:b, :c] =&gt; +, keepkeys=false) # auto-splatting, renaming and keepkeys
8×3 DataFrame
│ Row │ b1    │ c1    │ b_c_+ │
│     │ Int64 │ Int64 │ Int64 │
├─────┼───────┼───────┼───────┤
│ 1   │ 2     │ 1     │ 3     │
│ 2   │ 2     │ 5     │ 7     │
│ 3   │ 1     │ 2     │ 3     │
│ 4   │ 1     │ 6     │ 7     │
│ 5   │ 2     │ 3     │ 5     │
│ 6   │ 2     │ 7     │ 9     │
│ 7   │ 1     │ 4     │ 5     │
│ 8   │ 1     │ 8     │ 9     │

julia&gt; combine(gd, :b, :c =&gt; sum) # passing columns and broadcasting
8×3 DataFrame
│ Row │ a     │ b     │ c_sum │
│     │ Int64 │ Int64 │ Int64 │
├─────┼───────┼───────┼───────┤
│ 1   │ 1     │ 2     │ 6     │
│ 2   │ 1     │ 2     │ 6     │
│ 3   │ 2     │ 1     │ 8     │
│ 4   │ 2     │ 1     │ 8     │
│ 5   │ 3     │ 2     │ 10    │
│ 6   │ 3     │ 2     │ 10    │
│ 7   │ 4     │ 1     │ 12    │
│ 8   │ 4     │ 1     │ 12    │

julia&gt; combine(gd, [:b, :c] .=&gt; Ref)
4×3 DataFrame
│ Row │ a     │ b_Ref    │ c_Ref    │
│     │ Int64 │ SubArra… │ SubArra… │
├─────┼───────┼──────────┼──────────┤
│ 1   │ 1     │ [2, 2]   │ [1, 5]   │
│ 2   │ 2     │ [1, 1]   │ [2, 6]   │
│ 3   │ 3     │ [2, 2]   │ [3, 7]   │
│ 4   │ 4     │ [1, 1]   │ [4, 8]   │

julia&gt; combine(gd, AsTable(:) =&gt; Ref)
4×2 DataFrame
│ Row │ a     │ a_b_c_Ref                            │
│     │ Int64 │ NamedTuple…                          │
├─────┼───────┼──────────────────────────────────────┤
│ 1   │ 1     │ (a = [1, 1], b = [2, 2], c = [1, 5]) │
│ 2   │ 2     │ (a = [2, 2], b = [1, 1], c = [2, 6]) │
│ 3   │ 3     │ (a = [3, 3], b = [2, 2], c = [3, 7]) │
│ 4   │ 4     │ (a = [4, 4], b = [1, 1], c = [4, 8]) │

julia&gt; combine(gd, :, AsTable(Not(:a)) =&gt; sum)
8×4 DataFrame
│ Row │ a     │ b     │ c     │ b_c_sum │
│     │ Int64 │ Int64 │ Int64 │ Int64   │
├─────┼───────┼───────┼───────┼─────────┤
│ 1   │ 1     │ 2     │ 1     │ 3       │
│ 2   │ 1     │ 2     │ 5     │ 7       │
│ 3   │ 2     │ 1     │ 2     │ 3       │
│ 4   │ 2     │ 1     │ 6     │ 7       │
│ 5   │ 3     │ 2     │ 3     │ 5       │
│ 6   │ 3     │ 2     │ 7     │ 9       │
│ 7   │ 4     │ 1     │ 4     │ 5       │
│ 8   │ 4     │ 1     │ 8     │ 9       │</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/6b0feaadd019c5ee36010ab956b5fee7b67681d5/src/groupeddataframe/splitapplycombine.jl#L274-L450">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFrames.flatten" href="#DataFrames.flatten"><code>DataFrames.flatten</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">flatten(df::AbstractDataFrame, cols)</code></pre><p>When columns <code>cols</code> of data frame <code>df</code> have iterable elements that define <code>length</code> (for example a <code>Vector</code> of <code>Vector</code>s), return a <code>DataFrame</code> where each element of each <code>col</code> in <code>cols</code> is flattened, meaning the column corresponding to <code>col</code> becomes a longer vector where the original entries are concatenated. Elements of row <code>i</code> of <code>df</code> in columns other than <code>cols</code> will be repeated according to the length of <code>df[i, col]</code>. These lengths must therefore be the same for each <code>col</code> in <code>cols</code>, or else an error is raised. Note that these elements are not copied, and thus if they are mutable changing them in the returned <code>DataFrame</code> will affect <code>df</code>.</p><p><code>cols</code> can be any column selector (<code>Symbol</code>, string or integer; <code>:</code>, <code>All</code>, <code>Between</code>, <code>Not</code>, a regular expression, or a vector of <code>Symbol</code>s, strings or integers).</p><p><strong>Examples</strong></p><pre><code class="language-none">julia&gt; df1 = DataFrame(a = [1, 2], b = [[1, 2], [3, 4]], c = [[5, 6], [7, 8]])
2×3 DataFrame
│ Row │ a     │ b      │ c      │
│     │ Int64 │ Array… │ Array… │
├─────┼───────┼────────┼────────┤
│ 1   │ 1     │ [1, 2] │ [5, 6] │
│ 2   │ 2     │ [3, 4] │ [7, 8] │

julia&gt; flatten(df1, :b)
4×3 DataFrame
│ Row │ a     │ b     │ c      │
│     │ Int64 │ Int64 │ Array… │
├─────┼───────┼───────┼────────┤
│ 1   │ 1     │ 1     │ [5, 6] │
│ 2   │ 1     │ 2     │ [5, 6] │
│ 3   │ 2     │ 3     │ [7, 8] │
│ 4   │ 2     │ 4     │ [7, 8] │

julia&gt; flatten(df1, [:b, :c])
4×3 DataFrame
│ Row │ a     │ b     │ c     │
│     │ Int64 │ Int64 │ Int64 │
├─────┼───────┼───────┼───────┤
│ 1   │ 1     │ 1     │ 5     │
│ 2   │ 1     │ 2     │ 6     │
│ 3   │ 2     │ 3     │ 7     │
│ 4   │ 2     │ 4     │ 8     │

julia&gt; df2 = DataFrame(a = [1, 2], b = [(&quot;p&quot;, &quot;q&quot;), (&quot;r&quot;, &quot;s&quot;)])
2×2 DataFrame
│ Row │ a     │ b          │
│     │ Int64 │ Tuple…     │
├─────┼───────┼────────────┤
│ 1   │ 1     │ (&quot;p&quot;, &quot;q&quot;) │
│ 2   │ 2     │ (&quot;r&quot;, &quot;s&quot;) │

julia&gt; flatten(df2, :b)
4×2 DataFrame
│ Row │ a     │ b      │
│     │ Int64 │ String │
├─────┼───────┼────────┤
│ 1   │ 1     │ p      │
│ 2   │ 1     │ q      │
│ 3   │ 2     │ r      │
│ 4   │ 2     │ s      │

julia&gt; df3 = DataFrame(a = [1, 2], b = [[1, 2], [3, 4]], c = [[5, 6], [7]])
2×3 DataFrame
│ Row │ a     │ b      │ c      │
│     │ Int64 │ Array… │ Array… │
├─────┼───────┼────────┼────────┤
│ 1   │ 1     │ [1, 2] │ [5, 6] │
│ 2   │ 2     │ [3, 4] │ [7]    │

julia&gt; flatten(df3, [:b, :c])
ERROR: ArgumentError: Lengths of iterables stored in columns :b and :c
are not the same in row 2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/6b0feaadd019c5ee36010ab956b5fee7b67681d5/src/abstractdataframe/abstractdataframe.jl#L1709-L1785">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.hcat" href="#Base.hcat"><code>Base.hcat</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">hcat(df::AbstractDataFrame...;
     makeunique::Bool=false, copycols::Bool=true)
hcat(df::AbstractDataFrame..., vs::AbstractVector;
     makeunique::Bool=false, copycols::Bool=true)
hcat(vs::AbstractVector, df::AbstractDataFrame;
     makeunique::Bool=false, copycols::Bool=true)</code></pre><p>Horizontally concatenate <code>AbstractDataFrames</code> and optionally <code>AbstractVector</code>s.</p><p>If <code>AbstractVector</code> is passed then a column name for it is automatically generated as <code>:x1</code> by default.</p><p>If <code>makeunique=false</code> (the default) column names of passed objects must be unique. If <code>makeunique=true</code> then duplicate column names will be suffixed with <code>_i</code> (<code>i</code> starting at 1 for the first duplicate).</p><p>If <code>copycols=true</code> (the default) then the <code>DataFrame</code> returned by <code>hcat</code> will contain copied columns from the source data frames. If <code>copycols=false</code> then it will contain columns as they are stored in the source (without copying). This option should be used with caution as mutating either the columns in sources or in the returned <code>DataFrame</code> might lead to the corruption of the other object.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia [DataFrame(A=1:3) DataFrame(B=1:3)]
3×2 DataFrame
│ Row │ A     │ B     │
│     │ Int64 │ Int64 │
├─────┼───────┼───────┤
│ 1   │ 1     │ 1     │
│ 2   │ 2     │ 2     │
│ 3   │ 3     │ 3     │

julia&gt; df1 = DataFrame(A=1:3, B=1:3);

julia&gt; df2 = DataFrame(A=4:6, B=4:6);

julia&gt; df3 = hcat(df1, df2, makeunique=true)
3×4 DataFrame
│ Row │ A     │ B     │ A_1   │ B_1   │
│     │ Int64 │ Int64 │ Int64 │ Int64 │
├─────┼───────┼───────┼───────┼───────┤
│ 1   │ 1     │ 1     │ 4     │ 4     │
│ 2   │ 2     │ 2     │ 5     │ 5     │
│ 3   │ 3     │ 3     │ 6     │ 6     │

julia&gt; df3.A === df1.A
false

julia&gt; df3 = hcat(df1, df2, makeunique=true, copycols=false);

julia&gt; df3.A === df1.A
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/6b0feaadd019c5ee36010ab956b5fee7b67681d5/src/abstractdataframe/abstractdataframe.jl#L1211-L1267">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFrames.insertcols!" href="#DataFrames.insertcols!"><code>DataFrames.insertcols!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">insertcols!(df::DataFrame, [col], (name=&gt;val)::Pair...;
            makeunique::Bool=false, copycols::Bool=true)</code></pre><p>Insert a column into a data frame in place. Return the updated <code>DataFrame</code>. If <code>col</code> is omitted it is set to <code>ncol(df)+1</code> (the column is inserted as the last column).</p><p><strong>Arguments</strong></p><ul><li><code>df</code> : the DataFrame to which we want to add columns</li><li><code>col</code> : a position at which we want to insert a column, passed as an integer or a column name (a string or a <code>Symbol</code>); the column selected with <code>col</code> and columns following it are shifted to the right in <code>df</code> after the operation</li><li><code>name</code> : the name of the new column</li><li><code>val</code> : an <code>AbstractVector</code> giving the contents of the new column or a value of any type other than <code>AbstractArray</code> which will be repeated to fill a new vector; As a particular rule a values stored in a <code>Ref</code> or a <code>0</code>-dimensional <code>AbstractArray</code> are unwrapped and treated in the same way.</li><li><code>makeunique</code> : Defines what to do if <code>name</code> already exists in <code>df</code>; if it is <code>false</code> an error will be thrown; if it is <code>true</code> a new unique name will be generated by adding a suffix</li><li><code>copycols</code> : whether vectors passed as columns should be copied</li></ul><p>If <code>val</code> is an <code>AbstractRange</code> then the result of <code>collect(val)</code> is inserted.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; d = DataFrame(a=1:3)
3×1 DataFrame
│ Row │ a     │
│     │ Int64 │
├─────┼───────┤
│ 1   │ 1     │
│ 2   │ 2     │
│ 3   │ 3     │

julia&gt; insertcols!(d, 1, :b =&gt; &#39;a&#39;:&#39;c&#39;)
3×2 DataFrame
│ Row │ b    │ a     │
│     │ Char │ Int64 │
├─────┼──────┼───────┤
│ 1   │ &#39;a&#39;  │ 1     │
│ 2   │ &#39;b&#39;  │ 2     │
│ 3   │ &#39;c&#39;  │ 3     │

julia&gt; insertcols!(d, 2, :c =&gt; 2:4, :c =&gt; 3:5, makeunique=true)
3×4 DataFrame
│ Row │ b    │ c     │ c_1   │ a     │
│     │ Char │ Int64 │ Int64 │ Int64 │
├─────┼──────┼───────┼───────┼───────┤
│ 1   │ &#39;a&#39;  │ 2     │ 3     │ 1     │
│ 2   │ &#39;b&#39;  │ 3     │ 4     │ 2     │
│ 3   │ &#39;c&#39;  │ 4     │ 5     │ 3     │</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/6b0feaadd019c5ee36010ab956b5fee7b67681d5/src/dataframe/dataframe.jl#L605-L659">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFrames.mapcols" href="#DataFrames.mapcols"><code>DataFrames.mapcols</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">mapcols(f::Union{Function,Type}, df::AbstractDataFrame)</code></pre><p>Return a <code>DataFrame</code> where each column of <code>df</code> is transformed using function <code>f</code>. <code>f</code> must return <code>AbstractVector</code> objects all with the same length or scalars (all values other than <code>AbstractVector</code> are considered to be a scalar).</p><p>Note that <code>mapcols</code> guarantees not to reuse the columns from <code>df</code> in the returned <code>DataFrame</code>. If <code>f</code> returns its argument then it gets copied before being stored.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; df = DataFrame(x=1:4, y=11:14)
4×2 DataFrame
│ Row │ x     │ y     │
│     │ Int64 │ Int64 │
├─────┼───────┼───────┤
│ 1   │ 1     │ 11    │
│ 2   │ 2     │ 12    │
│ 3   │ 3     │ 13    │
│ 4   │ 4     │ 14    │

julia&gt; mapcols(x -&gt; x.^2, df)
4×2 DataFrame
│ Row │ x     │ y     │
│     │ Int64 │ Int64 │
├─────┼───────┼───────┤
│ 1   │ 1     │ 121   │
│ 2   │ 4     │ 144   │
│ 3   │ 9     │ 169   │
│ 4   │ 16    │ 196   │</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/6b0feaadd019c5ee36010ab956b5fee7b67681d5/src/abstractdataframe/iteration.jl#L315-L347">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFrames.mapcols!" href="#DataFrames.mapcols!"><code>DataFrames.mapcols!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">mapcols!(f::Union{Function,Type}, df::DataFrame)</code></pre><p>Update a <code>DataFrame</code> in-place where each column of <code>df</code> is transformed using function <code>f</code>. <code>f</code> must return <code>AbstractVector</code> objects all with the same length or scalars (all values other than <code>AbstractVector</code> are considered to be a scalar).</p><p>Note that <code>mapcols!</code> reuses the columns from <code>df</code> if they are returned by <code>f</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; df = DataFrame(x=1:4, y=11:14)
4×2 DataFrame
│ Row │ x     │ y     │
│     │ Int64 │ Int64 │
├─────┼───────┼───────┤
│ 1   │ 1     │ 11    │
│ 2   │ 2     │ 12    │
│ 3   │ 3     │ 13    │
│ 4   │ 4     │ 14    │

julia&gt; mapcols!(x -&gt; x.^2, df);

julia&gt; df
4×2 DataFrame
│ Row │ x     │ y     │
│     │ Int64 │ Int64 │
├─────┼───────┼───────┤
│ 1   │ 1     │ 121   │
│ 2   │ 4     │ 144   │
│ 3   │ 9     │ 169   │
│ 4   │ 16    │ 196   │</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/6b0feaadd019c5ee36010ab956b5fee7b67681d5/src/abstractdataframe/iteration.jl#L372-L405">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.push!" href="#Base.push!"><code>Base.push!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">push!(df::DataFrame, row::Union{Tuple, AbstractArray}; promote::Bool=false)
push!(df::DataFrame, row::Union{DataFrameRow, NamedTuple, AbstractDict};
      cols::Symbol=:setequal, promote::Bool=(cols in [:union, :subset]))</code></pre><p>Add in-place one row at the end of <code>df</code> taking the values from <code>row</code>.</p><p>Column types of <code>df</code> are preserved, and new values are converted if necessary. An error is thrown if conversion fails.</p><p>If <code>row</code> is neither a <code>DataFrameRow</code>, <code>NamedTuple</code> nor <code>AbstractDict</code> then it must be a <code>Tuple</code> or an <code>AbstractArray</code> and columns are matched by order of appearance. In this case <code>row</code> must contain the same number of elements as the number of columns in <code>df</code>.</p><p>If <code>row</code> is a <code>DataFrameRow</code>, <code>NamedTuple</code> or <code>AbstractDict</code> then values in <code>row</code> are matched to columns in <code>df</code> based on names. The exact behavior depends on the <code>cols</code> argument value in the following way:</p><ul><li>If <code>cols == :setequal</code> (this is the default) then <code>row</code> must contain exactly the same columns as <code>df</code> (but possibly in a different order).</li><li>If <code>cols == :orderequal</code> then <code>row</code> must contain the same columns in the same order (for <code>AbstractDict</code> this option requires that <code>keys(row)</code> matches <code>propertynames(df)</code> to allow for support of ordered dicts; however, if <code>row</code> is a <code>Dict</code> an error is thrown as it is an unordered collection).</li><li>If <code>cols == :intersect</code> then <code>row</code> may contain more columns than <code>df</code>, but all column names that are present in <code>df</code> must be present in <code>row</code> and only they are used to populate a new row in <code>df</code>.</li><li>If <code>cols == :subset</code> then <code>push!</code> behaves like for <code>:intersect</code> but if some column is missing in <code>row</code> then a <code>missing</code> value is pushed to <code>df</code>.</li><li>If <code>cols == :union</code> then columns missing in <code>df</code> that are present in <code>row</code> are added to <code>df</code> (using <code>missing</code> for existing rows) and a <code>missing</code> value is pushed to columns missing in <code>row</code> that are present in <code>df</code>.</li></ul><p>If <code>promote=true</code> and element type of a column present in <code>df</code> does not allow the type of a pushed argument then a new column with a promoted element type allowing it is freshly allocated and stored in <code>df</code>. If <code>promote=false</code> an error is thrown.</p><p>As a special case, if <code>df</code> has no columns and <code>row</code> is a <code>NamedTuple</code> or <code>DataFrameRow</code>, columns are created for all values in <code>row</code>, using their names and order.</p><p>Please note that <code>push!</code> must not be used on a <code>DataFrame</code> that contains columns that are aliases (equal when compared with <code>===</code>).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; df = DataFrame(A=1:3, B=1:3);

julia&gt; push!(df, (true, false))
4×2 DataFrame
│ Row │ A     │ B     │
│     │ Int64 │ Int64 │
├─────┼───────┼───────┤
│ 1   │ 1     │ 1     │
│ 2   │ 2     │ 2     │
│ 3   │ 3     │ 3     │
│ 4   │ 1     │ 0     │

julia&gt; push!(df, df[1, :])
5×2 DataFrame
│ Row │ A     │ B     │
│     │ Int64 │ Int64 │
├─────┼───────┼───────┤
│ 1   │ 1     │ 1     │
│ 2   │ 2     │ 2     │
│ 3   │ 3     │ 3     │
│ 4   │ 1     │ 0     │
│ 5   │ 1     │ 1     │

julia&gt; push!(df, (C=&quot;something&quot;, A=true, B=false), cols=:intersect)
6×2 DataFrame
│ Row │ A     │ B     │
│     │ Int64 │ Int64 │
├─────┼───────┼───────┤
│ 1   │ 1     │ 1     │
│ 2   │ 2     │ 2     │
│ 3   │ 3     │ 3     │
│ 4   │ 1     │ 0     │
│ 5   │ 1     │ 1     │
│ 6   │ 1     │ 0     │

julia&gt; push!(df, Dict(:A=&gt;1.0, :C=&gt;1.0), cols=:union)
7×3 DataFrame
│ Row │ A       │ B       │ C        │
│     │ Float64 │ Int64?  │ Float64? │
├─────┼─────────┼─────────┼──────────┤
│ 1   │ 1.0     │ 1       │ missing  │
│ 2   │ 2.0     │ 2       │ missing  │
│ 3   │ 3.0     │ 3       │ missing  │
│ 4   │ 1.0     │ 0       │ missing  │
│ 5   │ 1.0     │ 1       │ missing  │
│ 6   │ 1.0     │ 0       │ missing  │
│ 7   │ 1.0     │ missing │ 1.0      │

julia&gt; push!(df, NamedTuple(), cols=:subset)
8×3 DataFrame
│ Row │ A        │ B       │ C        │
│     │ Float64? │ Int64?  │ Float64? │
├─────┼──────────┼─────────┼──────────┤
│ 1   │ 1.0      │ 1       │ missing  │
│ 2   │ 2.0      │ 2       │ missing  │
│ 3   │ 3.0      │ 3       │ missing  │
│ 4   │ 1.0      │ 0       │ missing  │
│ 5   │ 1.0      │ 1       │ missing  │
│ 6   │ 1.0      │ 0       │ missing  │
│ 7   │ 1.0      │ missing │ 1.0      │
│ 8   │ missing  │ missing │ missing  │</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/6b0feaadd019c5ee36010ab956b5fee7b67681d5/src/dataframe/dataframe.jl#L1313-L1423">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.repeat" href="#Base.repeat"><code>Base.repeat</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">repeat(df::AbstractDataFrame; inner::Integer = 1, outer::Integer = 1)</code></pre><p>Construct a data frame by repeating rows in <code>df</code>. <code>inner</code> specifies how many times each row is repeated, and <code>outer</code> specifies how many times the full set of rows is repeated.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; df = DataFrame(a = 1:2, b = 3:4)
2×2 DataFrame
│ Row │ a     │ b     │
│     │ Int64 │ Int64 │
├─────┼───────┼───────┤
│ 1   │ 1     │ 3     │
│ 2   │ 2     │ 4     │

julia&gt; repeat(df, inner = 2, outer = 3)
12×2 DataFrame
│ Row │ a     │ b     │
│     │ Int64 │ Int64 │
├─────┼───────┼───────┤
│ 1   │ 1     │ 3     │
│ 2   │ 1     │ 3     │
│ 3   │ 2     │ 4     │
│ 4   │ 2     │ 4     │
│ 5   │ 1     │ 3     │
│ 6   │ 1     │ 3     │
│ 7   │ 2     │ 4     │
│ 8   │ 2     │ 4     │
│ 9   │ 1     │ 3     │
│ 10  │ 1     │ 3     │
│ 11  │ 2     │ 4     │
│ 12  │ 2     │ 4     │</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/6b0feaadd019c5ee36010ab956b5fee7b67681d5/src/abstractdataframe/abstractdataframe.jl#L1468-L1503">source</a></section><section><div><pre><code class="language-none">repeat(df::AbstractDataFrame, count::Integer)</code></pre><p>Construct a data frame by repeating each row in <code>df</code> the number of times specified by <code>count</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; df = DataFrame(a = 1:2, b = 3:4)
2×2 DataFrame
│ Row │ a     │ b     │
│     │ Int64 │ Int64 │
├─────┼───────┼───────┤
│ 1   │ 1     │ 3     │
│ 2   │ 2     │ 4     │

julia&gt; repeat(df, 2)
4×2 DataFrame
│ Row │ a     │ b     │
│     │ Int64 │ Int64 │
├─────┼───────┼───────┤
│ 1   │ 1     │ 3     │
│ 2   │ 2     │ 4     │
│ 3   │ 1     │ 3     │
│ 4   │ 2     │ 4     │</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/6b0feaadd019c5ee36010ab956b5fee7b67681d5/src/abstractdataframe/abstractdataframe.jl#L1510-L1536">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFrames.repeat!" href="#DataFrames.repeat!"><code>DataFrames.repeat!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">repeat!(df::DataFrame; inner::Integer = 1, outer::Integer = 1)</code></pre><p>Update a data frame <code>df</code> in-place by repeating its rows. <code>inner</code> specifies how many times each row is repeated, and <code>outer</code> specifies how many times the full set of rows is repeated. Columns of <code>df</code> are freshly allocated.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; df = DataFrame(a = 1:2, b = 3:4)
2×2 DataFrame
│ Row │ a     │ b     │
│     │ Int64 │ Int64 │
├─────┼───────┼───────┤
│ 1   │ 1     │ 3     │
│ 2   │ 2     │ 4     │

julia&gt; repeat!(df, inner = 2, outer = 3);

julia&gt; df
12×2 DataFrame
│ Row │ a     │ b     │
│     │ Int64 │ Int64 │
├─────┼───────┼───────┤
│ 1   │ 1     │ 3     │
│ 2   │ 1     │ 3     │
│ 3   │ 2     │ 4     │
│ 4   │ 2     │ 4     │
│ 5   │ 1     │ 3     │
│ 6   │ 1     │ 3     │
│ 7   │ 2     │ 4     │
│ 8   │ 2     │ 4     │
│ 9   │ 1     │ 3     │
│ 10  │ 1     │ 3     │
│ 11  │ 2     │ 4     │
│ 12  │ 2     │ 4     │</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/6b0feaadd019c5ee36010ab956b5fee7b67681d5/src/dataframe/dataframe.jl#L1469-L1506">source</a></section><section><div><pre><code class="language-none">repeat!(df::DataFrame, count::Integer)</code></pre><p>Update a data frame <code>df</code> in-place by repeating its rows the number of times specified by <code>count</code>. Columns of <code>df</code> are freshly allocated.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; df = DataFrame(a = 1:2, b = 3:4)
2×2 DataFrame
│ Row │ a     │ b     │
│     │ Int64 │ Int64 │
├─────┼───────┼───────┤
│ 1   │ 1     │ 3     │
│ 2   │ 2     │ 4     │

julia&gt; repeat(df, 2)
4×2 DataFrame
│ Row │ a     │ b     │
│     │ Int64 │ Int64 │
├─────┼───────┼───────┤
│ 1   │ 1     │ 3     │
│ 2   │ 2     │ 4     │
│ 3   │ 1     │ 3     │
│ 4   │ 2     │ 4     │</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/6b0feaadd019c5ee36010ab956b5fee7b67681d5/src/dataframe/dataframe.jl#L1513-L1539">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFrames.select" href="#DataFrames.select"><code>DataFrames.select</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">select(df::AbstractDataFrame, args...; copycols::Bool=true)</code></pre><p>Create a new data frame that contains columns from <code>df</code> specified by <code>args</code> and return it. The result is guaranteed to have the same number of rows as <code>df</code>, except when no columns are selected (in which case the result has zero rows)..</p><p>If <code>df</code> is a <code>DataFrame</code> or <code>copycols=true</code> then column renaming and transformations are supported.</p><p>Arguments passed as <code>args...</code> can be:</p><ul><li>Any index that is allowed for column indexing (<code>Symbol</code>, string or integer; <code>:</code>, <code>All</code>, <code>Between</code>, <code>Not</code>, a regular expression, or a vector of <code>Symbol</code>s, strings or integers).</li><li>Column transformation operations using the <code>Pair</code> notation that is described below and vectors of such pairs.</li></ul><p>Columns can be renamed using the <code>old_column =&gt; new_column_name</code> syntax, and transformed using the <code>old_column =&gt; fun =&gt; new_column_name</code> syntax. <code>new_column_name</code> must be a <code>Symbol</code> or a string, and <code>fun</code> a function or a type. If <code>old_column</code> is a <code>Symbol</code>, a string, or an integer then <code>fun</code> is applied to the corresponding column vector. Otherwise <code>old_column</code> can be any column indexing syntax, in which case <code>fun</code> will be passed the column vectors specified by <code>old_column</code> as separate arguments. The only exception is when <code>old_column</code> is an <code>AsTable</code> type wrapping a selector, in which case <code>fun</code> is passed a <code>NamedTuple</code> containing the selected columns.</p><p>If <code>fun</code> returns a value of type other than <code>AbstractVector</code> then it will be broadcasted into a vector matching the target number of rows in the data frame, unless its type is one of <code>AbstractDataFrame</code>, <code>NamedTuple</code>, <code>DataFrameRow</code>, <code>AbstractMatrix</code>, in which case an error is thrown as currently these return types are not allowed. As a particular rule, values wrapped in a <code>Ref</code> or a <code>0</code>-dimensional <code>AbstractArray</code> are unwrapped and then broadcasted.</p><p>To apply <code>fun</code> to each row instead of whole columns, it can be wrapped in a <code>ByRow</code> struct. In this case if <code>old_column</code> is a <code>Symbol</code>, a string, or an integer then <code>fun</code> is applied to each element (row) of <code>old_column</code> using broadcasting. Otherwise <code>old_column</code> can be any column indexing syntax, in which case <code>fun</code> will be passed one argument for each of the columns specified by <code>old_column</code>. If <code>ByRow</code> is used it is not allowed for <code>old_column</code> to select an empty set of columns nor for <code>fun</code> to return a <code>NamedTuple</code> or a <code>DataFrameRow</code>.</p><p>Column transformation can also be specified using the short <code>old_column =&gt; fun</code> form. In this case, <code>new_column_name</code> is automatically generated as <code>$(old_column)_$(fun)</code>. Up to three column names are used for multiple input columns and they are joined using <code>_</code>; if more than three columns are passed then the name consists of the first two names and <code>etc</code> suffix then, e.g. <code>[:a,:b,:c,:d] =&gt; fun</code> produces the new column name <code>:a_b_etc_fun</code>.</p><p>Column renaming and transformation operations can be passed wrapped in vectors (this is useful when combined with broadcasting).</p><p>As a special rule passing <code>nrow</code> without specifying <code>old_column</code> creates a column named <code>:nrow</code> containing a number of rows in a source data frame, and passing <code>nrow =&gt; new_column_name</code> stores the number of rows in source data frame in <code>new_column_name</code> column.</p><p>If a collection of column names is passed to <code>select!</code> or <code>select</code> then requesting duplicate column names in target data frame are accepted (e.g. <code>select!(df, [:a], :, r&quot;a&quot;)</code> is allowed) and only the first occurrence is used. In particular a syntax to move column <code>:col</code> to the first position in the data frame is <code>select!(df, :col, :)</code>. On the contrary, output column names of renaming, transformation and single column selection operations must be unique, so e.g. <code>select!(df, :a, :a =&gt; :a)</code> or <code>select!(df, :a, :a =&gt; ByRow(sin) =&gt; :a)</code> are not allowed.</p><p>If <code>df</code> is a <code>DataFrame</code> a new <code>DataFrame</code> is returned. If <code>copycols=false</code>, then the returned <code>DataFrame</code> shares column vectors with <code>df</code> where possible. If <code>copycols=true</code> (the default), then the returned <code>DataFrame</code> will not share columns with <code>df</code>. The only exception for this rule is the <code>old_column =&gt; fun =&gt; new_column</code> transformation when <code>fun</code> returns a vector that is not allocated by <code>fun</code> but is neither a <code>SubArray</code> nor one of the input vectors. In such a case a new <code>DataFrame</code> might contain aliases. Such a situation can only happen with transformations which returns vectors other than their inputs, e.g. with <code>select(df, :a =&gt; (x -&gt; c) =&gt; :c1, :b =&gt; (x -&gt; c) =&gt; :c2)</code>  when <code>c</code> is a vector object or with <code>select(df, :a =&gt; (x -&gt; df.c) =&gt; :c2)</code>.</p><p>If <code>df</code> is a <code>SubDataFrame</code> and <code>copycols=true</code> then a <code>DataFrame</code> is returned and the same copying rules apply as for a <code>DataFrame</code> input: this means in particular that selected columns will be copied. If <code>copycols=false</code>, a <code>SubDataFrame</code> is returned without copying columns.</p><p>Note that including the same column several times in the data frame via renaming or transformations that return the same object when <code>copycols=false</code> will create column aliases. An example of such a situation is <code>select(df, :a, :a =&gt; :b, :a =&gt; identity =&gt; :c, copycols=false)</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; df = DataFrame(a=1:3, b=4:6)
3×2 DataFrame
│ Row │ a     │ b     │
│     │ Int64 │ Int64 │
├─────┼───────┼───────┤
│ 1   │ 1     │ 4     │
│ 2   │ 2     │ 5     │
│ 3   │ 3     │ 6     │

julia&gt; select(df, :b)
3×1 DataFrame
│ Row │ b     │
│     │ Int64 │
├─────┼───────┤
│ 1   │ 4     │
│ 2   │ 5     │
│ 3   │ 6     │

julia&gt; select(df, Not(:b)) # drop column :b from df
3×1 DataFrame
│ Row │ a     │
│     │ Int64 │
├─────┼───────┤
│ 1   │ 1     │
│ 2   │ 2     │
│ 3   │ 3     │

julia&gt; select(df, :a =&gt; :c, :b)
3×2 DataFrame
│ Row │ c     │ b     │
│     │ Int64 │ Int64 │
├─────┼───────┼───────┤
│ 1   │ 1     │ 4     │
│ 2   │ 2     │ 5     │
│ 3   │ 3     │ 6     │

julia&gt; select(df, :a =&gt; ByRow(sin) =&gt; :c, :b)
3×2 DataFrame
│ Row │ c        │ b     │
│     │ Float64  │ Int64 │
├─────┼──────────┼───────┤
│ 1   │ 0.841471 │ 4     │
│ 2   │ 0.909297 │ 5     │
│ 3   │ 0.14112  │ 6     │

julia&gt; select(df, :, [:a, :b] =&gt; (a,b) -&gt; a .+ b .- sum(b)/length(b))
3×3 DataFrame
│ Row │ a     │ b     │ a_b_function │
│     │ Int64 │ Int64 │ Float64      │
├─────┼───────┼───────┼──────────────┤
│ 1   │ 1     │ 4     │ 0.0          │
│ 2   │ 2     │ 5     │ 2.0          │
│ 3   │ 3     │ 6     │ 4.0          │

julia&gt; select(df, names(df) .=&gt; sum)
3×2 DataFrame
│ Row │ a_sum │ b_sum │
│     │ Int64 │ Int64 │
├─────┼───────┼───────┤
│ 1   │ 6     │ 15    │
│ 2   │ 6     │ 15    │
│ 3   │ 6     │ 15    │

julia&gt; select(df, names(df) .=&gt; sum .=&gt; [:A, :B])
3×2 DataFrame
│ Row │ A     │ B     │
│     │ Int64 │ Int64 │
├─────┼───────┼───────┤
│ 1   │ 6     │ 15    │
│ 2   │ 6     │ 15    │
│ 3   │ 6     │ 15    │

julia&gt; select(df, AsTable(:) =&gt; ByRow(mean))
3×1 DataFrame
│ Row │ a_b_mean │
│     │ Float64  │
├─────┼──────────┤
│ 1   │ 2.5      │
│ 2   │ 3.5      │
│ 3   │ 4.5      │</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/6b0feaadd019c5ee36010ab956b5fee7b67681d5/src/abstractdataframe/selection.jl#L373-L492">source</a></section><section><div><pre><code class="language-none">select(gd::GroupedDataFrame, args...;
       copycols::Bool=true, keepkeys::Bool=true, ungroup::Bool=true)</code></pre><p>Apply <code>args</code> to <code>gd</code> following the rules described in <a href="#DataFrames.combine"><code>combine</code></a>.</p><p>If <code>ungroup=true</code> the result is a <code>DataFrame</code>. If  <code>ungroup=false</code> the result is a <code>GroupedDataFrame</code> (in this case the returned value retains the order of groups of <code>gd</code>).</p><p>The <code>parent</code> of the returned value has as many rows as <code>parent(gd)</code> and in the same order, except when the returned value has no columns (in which case it has zero rows). If an operation in <code>args</code> returns a single value it is always broadcasted to have this number of rows.</p><p>If <code>copycols=false</code> then do not perform copying of columns that are not transformed.</p><p>If <code>keepkeys=true</code>, the resulting <code>DataFrame</code> contains all the grouping columns in addition to those generated. In this case if the returned value contains columns with the same names as the grouping columns, they are required to be equal. If <code>keepkeys=false</code> and some generated columns have the same name as grouping columns, they are kept and are not required to be equal to grouping columns.</p><p>If <code>ungroup=true</code> (the default) a <code>DataFrame</code> is returned. If <code>ungroup=false</code> a <code>GroupedDataFrame</code> grouped using <code>keycols(gdf)</code> is returned.</p><p>If <code>gd</code> has zero groups then transformations are applied to vectors of zero length.</p><p><strong>See also</strong></p><p><a href="#DataFrames.groupby"><code>groupby</code></a>, <a href="#DataFrames.combine"><code>combine</code></a>, <a href="#DataFrames.select!"><code>select!</code></a>, <a href="#DataFrames.transform"><code>transform</code></a>, <a href="#DataFrames.transform!"><code>transform!</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; df = DataFrame(a = [1, 1, 1, 2, 2, 1, 1, 2],
                      b = repeat([2, 1], outer=[4]),
                      c = 1:8)
8×3 DataFrame
│ Row │ a     │ b     │ c     │
│     │ Int64 │ Int64 │ Int64 │
├─────┼───────┼───────┼───────┤
│ 1   │ 1     │ 2     │ 1     │
│ 2   │ 1     │ 1     │ 2     │
│ 3   │ 1     │ 2     │ 3     │
│ 4   │ 2     │ 1     │ 4     │
│ 5   │ 2     │ 2     │ 5     │
│ 6   │ 1     │ 1     │ 6     │
│ 7   │ 1     │ 2     │ 7     │
│ 8   │ 2     │ 1     │ 8     │

julia&gt; gd = groupby(df, :a);

julia&gt; select(gd, :c =&gt; sum, nrow)
8×3 DataFrame
│ Row │ a     │ c_sum │ nrow  │
│     │ Int64 │ Int64 │ Int64 │
├─────┼───────┼───────┼───────┤
│ 1   │ 1     │ 19    │ 5     │
│ 2   │ 1     │ 19    │ 5     │
│ 3   │ 1     │ 19    │ 5     │
│ 4   │ 2     │ 17    │ 3     │
│ 5   │ 2     │ 17    │ 3     │
│ 6   │ 1     │ 19    │ 5     │
│ 7   │ 1     │ 19    │ 5     │
│ 8   │ 2     │ 17    │ 3     │

julia&gt; select(gd, :c =&gt; sum, nrow, ungroup=false)
GroupedDataFrame with 2 groups based on key: a
First Group (5 rows): a = 1
│ Row │ a     │ c_sum │ nrow  │
│     │ Int64 │ Int64 │ Int64 │
├─────┼───────┼───────┼───────┤
│ 1   │ 1     │ 19    │ 5     │
│ 2   │ 1     │ 19    │ 5     │
│ 3   │ 1     │ 19    │ 5     │
│ 4   │ 1     │ 19    │ 5     │
│ 5   │ 1     │ 19    │ 5     │
⋮
Last Group (3 rows): a = 2
│ Row │ a     │ c_sum │ nrow  │
│     │ Int64 │ Int64 │ Int64 │
├─────┼───────┼───────┼───────┤
│ 1   │ 2     │ 17    │ 3     │
│ 2   │ 2     │ 17    │ 3     │
│ 3   │ 2     │ 17    │ 3     │

julia&gt; select(gd, :c =&gt; (x -&gt; sum(log, x)) =&gt; :sum_log_c) # specifying a name for target column
8×2 DataFrame
│ Row │ a     │ sum_log_c │
│     │ Int64 │ Float64   │
├─────┼───────┼───────────┤
│ 1   │ 1     │ 5.52943   │
│ 2   │ 1     │ 5.52943   │
│ 3   │ 1     │ 5.52943   │
│ 4   │ 2     │ 5.07517   │
│ 5   │ 2     │ 5.07517   │
│ 6   │ 1     │ 5.52943   │
│ 7   │ 1     │ 5.52943   │
│ 8   │ 2     │ 5.07517   │

julia&gt; select(gd, [:b, :c] .=&gt; sum) # passing a vector of pairs
8×3 DataFrame
│ Row │ a     │ b_sum │ c_sum │
│     │ Int64 │ Int64 │ Int64 │
├─────┼───────┼───────┼───────┤
│ 1   │ 1     │ 8     │ 19    │
│ 2   │ 1     │ 8     │ 19    │
│ 3   │ 1     │ 8     │ 19    │
│ 4   │ 2     │ 4     │ 17    │
│ 5   │ 2     │ 4     │ 17    │
│ 6   │ 1     │ 8     │ 19    │
│ 7   │ 1     │ 8     │ 19    │
│ 8   │ 2     │ 4     │ 17    │

julia&gt; select(gd, :b =&gt; :b1, :c =&gt; :c1,
              [:b, :c] =&gt; +, keepkeys=false) # multiple arguments, renaming and keepkeys
8×3 DataFrame
│ Row │ b1    │ c1    │ b_c_+ │
│     │ Int64 │ Int64 │ Int64 │
├─────┼───────┼───────┼───────┤
│ 1   │ 2     │ 1     │ 3     │
│ 2   │ 1     │ 2     │ 3     │
│ 3   │ 2     │ 3     │ 5     │
│ 4   │ 1     │ 4     │ 5     │
│ 5   │ 2     │ 5     │ 7     │
│ 6   │ 1     │ 6     │ 7     │
│ 7   │ 2     │ 7     │ 9     │
│ 8   │ 1     │ 8     │ 9     │

julia&gt; select(gd, :b, :c =&gt; sum) # passing columns and broadcasting
8×3 DataFrame
│ Row │ a     │ b     │ c_sum │
│     │ Int64 │ Int64 │ Int64 │
├─────┼───────┼───────┼───────┤
│ 1   │ 1     │ 2     │ 19    │
│ 2   │ 1     │ 1     │ 19    │
│ 3   │ 1     │ 2     │ 19    │
│ 4   │ 2     │ 1     │ 17    │
│ 5   │ 2     │ 2     │ 17    │
│ 6   │ 1     │ 1     │ 19    │
│ 7   │ 1     │ 2     │ 19    │
│ 8   │ 2     │ 1     │ 17    │

julia&gt; select(gd, :, AsTable(Not(:a)) =&gt; sum)
8×4 DataFrame
│ Row │ a     │ b     │ c     │ b_c_sum │
│     │ Int64 │ Int64 │ Int64 │ Int64   │
├─────┼───────┼───────┼───────┼─────────┤
│ 1   │ 1     │ 2     │ 1     │ 3       │
│ 2   │ 1     │ 1     │ 2     │ 3       │
│ 3   │ 1     │ 2     │ 3     │ 5       │
│ 4   │ 2     │ 1     │ 4     │ 5       │
│ 5   │ 2     │ 2     │ 5     │ 7       │
│ 6   │ 1     │ 1     │ 6     │ 7       │
│ 7   │ 1     │ 2     │ 7     │ 9       │
│ 8   │ 2     │ 1     │ 8     │ 9       │</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/6b0feaadd019c5ee36010ab956b5fee7b67681d5/src/groupeddataframe/splitapplycombine.jl#L1555-L1703">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFrames.select!" href="#DataFrames.select!"><code>DataFrames.select!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">select!(df::DataFrame, args...)</code></pre><p>Mutate <code>df</code> in place to retain only columns specified by <code>args...</code> and return it. The result is guaranteed to have the same number of rows as <code>df</code>, except when no columns are selected (in which case the result has zero rows).</p><p>Arguments passed as <code>args...</code> can be:</p><ul><li>Any index that is allowed for column indexing (<code>Symbol</code>, string or integer; <code>:</code>, <code>All</code>, <code>Between</code>, <code>Not</code>, a regular expression, or a vector of <code>Symbol</code>s, strings or integers).</li><li>Column transformation operations using the <code>Pair</code> notation that is described below and vectors of such pairs.</li></ul><p>Columns can be renamed using the <code>old_column =&gt; new_column_name</code> syntax, and transformed using the <code>old_column =&gt; fun =&gt; new_column_name</code> syntax. <code>new_column_name</code> must be a <code>Symbol</code> or a string, and <code>fun</code> a function or a type. If <code>old_column</code> is a <code>Symbol</code>, a string, or an integer then <code>fun</code> is applied to the corresponding column vector. Otherwise <code>old_column</code> can be any column indexing syntax, in which case <code>fun</code> will be passed the column vectors specified by <code>old_column</code> as separate arguments. The only exception is when <code>old_column</code> is an <code>AsTable</code> type wrapping a selector, in which case <code>fun</code> is passed a <code>NamedTuple</code> containing the selected columns.</p><p>If <code>fun</code> returns a value of type other than <code>AbstractVector</code> then it will be broadcasted into a vector matching the target number of rows in the data frame, unless its type is one of <code>AbstractDataFrame</code>, <code>NamedTuple</code>, <code>DataFrameRow</code>, <code>AbstractMatrix</code>, in which case an error is thrown as currently these return types are not allowed. As a particular rule, values wrapped in a <code>Ref</code> or a <code>0</code>-dimensional <code>AbstractArray</code> are unwrapped and then broadcasted.</p><p>To apply <code>fun</code> to each row instead of whole columns, it can be wrapped in a <code>ByRow</code> struct. In this case if <code>old_column</code> is a <code>Symbol</code>, a string, or an integer then <code>fun</code> is applied to each element (row) of <code>old_column</code> using broadcasting. Otherwise <code>old_column</code> can be any column indexing syntax, in which case <code>fun</code> will be passed one argument for each of the columns specified by <code>old_column</code>. If <code>ByRow</code> is used it is not allowed for <code>old_column</code> to select an empty set of columns nor for <code>fun</code> to return a <code>NamedTuple</code> or a <code>DataFrameRow</code>.</p><p>Column transformation can also be specified using the short <code>old_column =&gt; fun</code> form. In this case, <code>new_column_name</code> is automatically generated as <code>$(old_column)_$(fun)</code>. Up to three column names are used for multiple input columns and they are joined using <code>_</code>; if more than three columns are passed then the name consists of the first two names and <code>etc</code> suffix then, e.g. <code>[:a,:b,:c,:d] =&gt; fun</code> produces the new column name <code>:a_b_etc_fun</code>.</p><p>Column renaming and transformation operations can be passed wrapped in vectors (this is useful when combined with broadcasting).</p><p>As a special rule passing <code>nrow</code> without specifying <code>old_column</code> creates a column named <code>:nrow</code> containing a number of rows in a source data frame, and passing <code>nrow =&gt; new_column_name</code> stores the number of rows in source data frame in <code>new_column_name</code> column.</p><p>If a collection of column names is passed to <code>select!</code> or <code>select</code> then requesting duplicate column names in target data frame are accepted (e.g. <code>select!(df, [:a], :, r&quot;a&quot;)</code> is allowed) and only the first occurrence is used. In particular a syntax to move column <code>:col</code> to the first position in the data frame is <code>select!(df, :col, :)</code>. On the contrary, output column names of renaming, transformation and single column selection operations must be unique, so e.g. <code>select!(df, :a, :a =&gt; :a)</code> or <code>select!(df, :a, :a =&gt; ByRow(sin) =&gt; :a)</code> are not allowed.</p><p>Note that including the same column several times in the data frame via renaming or transformations that return the same object without copying will create column aliases. An example of such a situation is <code>select!(df, :a, :a =&gt; :b, :a =&gt; identity =&gt; :c)</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; df = DataFrame(a=1:3, b=4:6)
3×2 DataFrame
│ Row │ a     │ b     │
│     │ Int64 │ Int64 │
├─────┼───────┼───────┤
│ 1   │ 1     │ 4     │
│ 2   │ 2     │ 5     │
│ 3   │ 3     │ 6     │

julia&gt; select!(df, 2)
3×1 DataFrame
│ Row │ b     │
│     │ Int64 │
├─────┼───────┤
│ 1   │ 4     │
│ 2   │ 5     │
│ 3   │ 6     │

julia&gt; df = DataFrame(a=1:3, b=4:6);

julia&gt; select!(df, :a =&gt; ByRow(sin) =&gt; :c, :b)
3×2 DataFrame
│ Row │ c        │ b     │
│     │ Float64  │ Int64 │
├─────┼──────────┼───────┤
│ 1   │ 0.841471 │ 4     │
│ 2   │ 0.909297 │ 5     │
│ 3   │ 0.14112  │ 6     │

julia&gt; select!(df, :, [:c, :b] =&gt; (c,b) -&gt; c .+ b .- sum(b)/length(b))
3×3 DataFrame
│ Row │ c        │ b     │ c_b_function │
│     │ Float64  │ Int64 │ Float64      │
├─────┼──────────┼───────┼──────────────┤
│ 1   │ 0.841471 │ 4     │ -0.158529    │
│ 2   │ 0.909297 │ 5     │ 0.909297     │
│ 3   │ 0.14112  │ 6     │ 1.14112      │

julia&gt; df = DataFrame(a=1:3, b=4:6);

julia&gt; select!(df, names(df) .=&gt; sum);

julia&gt; df
3×2 DataFrame
│ Row │ a_sum │ b_sum │
│     │ Int64 │ Int64 │
├─────┼───────┼───────┤
│ 1   │ 6     │ 15    │
│ 2   │ 6     │ 15    │
│ 3   │ 6     │ 15    │

julia&gt; df = DataFrame(a=1:3, b=4:6);

julia&gt; using Statistics

julia&gt; select!(df, AsTable(:) =&gt; ByRow(mean))
3×1 DataFrame
│ Row │ a_b_mean │
│     │ Float64  │
├─────┼──────────┤
│ 1   │ 2.5      │
│ 2   │ 3.5      │
│ 3   │ 4.5      │</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/6b0feaadd019c5ee36010ab956b5fee7b67681d5/src/abstractdataframe/selection.jl#L277-L358">source</a></section><section><div><pre><code class="language-none">select!(gd::GroupedDataFrame{DataFrame}, args...; ungroup::Bool=true)</code></pre><p>An equivalent of <code>select(gd, args..., copycols=false, keepkeys=true, ungroup=ungroup)</code> but updates <code>parent(gd)</code> in place.</p><p><code>gd</code> is updated to reflect the new rows of its updated parent. If there are independent <code>GroupedDataFrame</code> objects constructed using the same parent data frame they might get corrupt.</p><p><strong>See also</strong></p><p><a href="#DataFrames.groupby"><code>groupby</code></a>, <a href="#DataFrames.combine"><code>combine</code></a>, <a href="#DataFrames.select"><code>select</code></a>, <a href="#DataFrames.transform"><code>transform</code></a>, <a href="#DataFrames.transform!"><code>transform!</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/6b0feaadd019c5ee36010ab956b5fee7b67681d5/src/groupeddataframe/splitapplycombine.jl#L1731-L1745">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFrames.transform" href="#DataFrames.transform"><code>DataFrames.transform</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">transform(df::AbstractDataFrame, args...; copycols::Bool=true)</code></pre><p>Create a new data frame that contains columns from <code>df</code> and adds columns specified by <code>args</code> and return it. The result is guaranteed to have the same number of rows as <code>df</code>. Equivalent to <code>select(df, :, args..., copycols=copycols)</code>.</p><p>See <a href="#DataFrames.select"><code>select</code></a> for detailed rules regarding accepted values for <code>args</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/6b0feaadd019c5ee36010ab956b5fee7b67681d5/src/abstractdataframe/selection.jl#L496-L505">source</a></section><section><div><pre><code class="language-none">transform(gd::GroupedDataFrame, args...;
          copycols::Bool=true, keepkeys::Bool=true, ungroup::Bool=true)</code></pre><p>An equivalent of <code>select(gd, :, args..., copycols=copycols, keepkeys=keepkeys, ungroup=ungroup)</code> but keeps the columns of <code>parent(gd)</code> in their original order.</p><p><strong>See also</strong></p><p><a href="#DataFrames.groupby"><code>groupby</code></a>, <a href="#DataFrames.combine"><code>combine</code></a>, <a href="#DataFrames.select"><code>select</code></a>, <a href="#DataFrames.select!"><code>select!</code></a>, <a href="#DataFrames.transform!"><code>transform!</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/6b0feaadd019c5ee36010ab956b5fee7b67681d5/src/groupeddataframe/splitapplycombine.jl#L1709-L1720">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFrames.transform!" href="#DataFrames.transform!"><code>DataFrames.transform!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">transform!(df::DataFrame, args...)</code></pre><p>Mutate <code>df</code> in place to add columns specified by <code>args...</code> and return it. The result is guaranteed to have the same number of rows as <code>df</code>. Equivalent to <code>select!(df, :, args...)</code>.</p><p>See <a href="#DataFrames.select!"><code>select!</code></a> for detailed rules regarding accepted values for <code>args</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/6b0feaadd019c5ee36010ab956b5fee7b67681d5/src/abstractdataframe/selection.jl#L362-L370">source</a></section><section><div><pre><code class="language-none">transform!(gd::GroupedDataFrame{DataFrame}, args...; ungroup::Bool=true)</code></pre><p>An equivalent of <code>transform(gd, args..., copycols=false, keepkeys=true, ungroup=ungroup)</code> but updates <code>parent(gd)</code> in place and keeps the columns of <code>parent(gd)</code> in their original order.</p><p><strong>See also</strong></p><p><a href="#DataFrames.groupby"><code>groupby</code></a>, <a href="#DataFrames.combine"><code>combine</code></a>, <a href="#DataFrames.select"><code>select</code></a>, <a href="#DataFrames.select!"><code>select!</code></a>, <a href="#DataFrames.transform"><code>transform</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/6b0feaadd019c5ee36010ab956b5fee7b67681d5/src/groupeddataframe/splitapplycombine.jl#L1753-L1764">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.vcat" href="#Base.vcat"><code>Base.vcat</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">vcat(dfs::AbstractDataFrame...;
     cols::Union{Symbol, AbstractVector{Symbol},
                 AbstractVector{&lt;:AbstractString}}=:setequal)</code></pre><p>Vertically concatenate <code>AbstractDataFrame</code>s.</p><p>The <code>cols</code> keyword argument determines the columns of the returned data frame:</p><ul><li><code>:setequal</code>: require all data frames to have the same column names disregarding order. If they appear in different orders, the order of the first provided data frame is used.</li><li><code>:orderequal</code>: require all data frames to have the same column names and in the same order.</li><li><code>:intersect</code>: only the columns present in <em>all</em> provided data frames are kept. If the intersection is empty, an empty data frame is returned.</li><li><code>:union</code>: columns present in <em>at least one</em> of the provided data frames are kept. Columns not present in some data frames are filled with <code>missing</code> where necessary.</li><li>A vector of <code>Symbol</code>s or strings: only listed columns are kept. Columns not present in some data frames are filled with <code>missing</code> where necessary.</li></ul><p>The order of columns is determined by the order they appear in the included data frames, searching through the header of the first data frame, then the second, etc.</p><p>The element types of columns are determined using <code>promote_type</code>, as with <code>vcat</code> for <code>AbstractVector</code>s.</p><p><code>vcat</code> ignores empty data frames, making it possible to initialize an empty data frame at the beginning of a loop and <code>vcat</code> onto it.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; df1 = DataFrame(A=1:3, B=1:3);

julia&gt; df2 = DataFrame(A=4:6, B=4:6);

julia&gt; df3 = DataFrame(A=7:9, C=7:9);

julia&gt; d4 = DataFrame();

julia&gt; vcat(df1, df2)
6×2 DataFrame
│ Row │ A     │ B     │
│     │ Int64 │ Int64 │
├─────┼───────┼───────┤
│ 1   │ 1     │ 1     │
│ 2   │ 2     │ 2     │
│ 3   │ 3     │ 3     │
│ 4   │ 4     │ 4     │
│ 5   │ 5     │ 5     │
│ 6   │ 6     │ 6     │

julia&gt; vcat(df1, df3, cols=:union)
6×3 DataFrame
│ Row │ A     │ B       │ C       │
│     │ Int64 │ Int64?  │ Int64?  │
├─────┼───────┼─────────┼─────────┤
│ 1   │ 1     │ 1       │ missing │
│ 2   │ 2     │ 2       │ missing │
│ 3   │ 3     │ 3       │ missing │
│ 4   │ 7     │ missing │ 7       │
│ 5   │ 8     │ missing │ 8       │
│ 6   │ 9     │ missing │ 9       │

julia&gt; vcat(df1, df3, cols=:intersect)
6×1 DataFrame
│ Row │ A     │
│     │ Int64 │
├─────┼───────┤
│ 1   │ 1     │
│ 2   │ 2     │
│ 3   │ 3     │
│ 4   │ 7     │
│ 5   │ 8     │
│ 6   │ 9     │

julia&gt; vcat(d4, df1)
3×2 DataFrame
│ Row │ A     │ B     │
│     │ Int64 │ Int64 │
├─────┼───────┼───────┤
│ 1   │ 1     │ 1     │
│ 2   │ 2     │ 2     │
│ 3   │ 3     │ 3     │</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/6b0feaadd019c5ee36010ab956b5fee7b67681d5/src/abstractdataframe/abstractdataframe.jl#L1288-L1375">source</a></section></article><h2 id="Reshaping-data-frames-between-tall-and-wide-formats"><a class="docs-heading-anchor" href="#Reshaping-data-frames-between-tall-and-wide-formats">Reshaping data frames between tall and wide formats</a><a id="Reshaping-data-frames-between-tall-and-wide-formats-1"></a><a class="docs-heading-anchor-permalink" href="#Reshaping-data-frames-between-tall-and-wide-formats" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="DataFrames.stack" href="#DataFrames.stack"><code>DataFrames.stack</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">stack(df::AbstractDataFrame, [measure_vars], [id_vars];
      variable_name=:variable, value_name=:value,
      view::Bool=false, variable_eltype::Type=String)</code></pre><p>Stack a data frame <code>df</code>, i.e. convert it from wide to long format.</p><p>Return the long-format <code>DataFrame</code> with: columns for each of the <code>id_vars</code>, column <code>variable_name</code> (<code>:value</code> by default) holding the values of the stacked columns (<code>measure_vars</code>), and column <code>variable_name</code> (<code>:variable</code> by default) a vector holding the name of the corresponding <code>measure_vars</code> variable.</p><p>If <code>view=true</code> then return a stacked view of a data frame (long format). The result is a view because the columns are special <code>AbstractVectors</code> that return views into the original data frame.</p><p><strong>Arguments</strong></p><ul><li><code>df</code> : the AbstractDataFrame to be stacked</li><li><code>measure_vars</code> : the columns to be stacked (the measurement variables), as a column selector (<code>Symbol</code>, string or integer; <code>:</code>, <code>All</code>, <code>Between</code>, <code>Not</code>, a regular expression, or a vector of <code>Symbol</code>s, strings or integers). If neither <code>measure_vars</code> or <code>id_vars</code> are given, <code>measure_vars</code> defaults to all floating point columns.</li><li><code>id_vars</code> : the identifier columns that are repeated during stacking, as a column selector (<code>Symbol</code>, string or integer; <code>:</code>, <code>All</code>, <code>Between</code>, <code>Not</code>, a regular expression, or a vector of <code>Symbol</code>s, strings or integers). Defaults to all variables that are not <code>measure_vars</code></li><li><code>variable_name</code> : the name (<code>Symbol</code> or string) of the new stacked column that shall hold the names of each of <code>measure_vars</code></li><li><code>value_name</code> : the name (<code>Symbol</code> or string) of the new stacked column containing the values from each of <code>measure_vars</code></li><li><code>view</code> : whether the stacked data frame should be a view rather than contain freshly allocated vectors.</li><li><code>variable_eltype</code> : determines the element type of column <code>variable_name</code>. By default a <code>PooledArray{String}</code> is created. If <code>variable_eltype=Symbol</code> a <code>PooledVector{Symbol}</code> is created, and if <code>variable_eltype=CategoricalValue{String}</code> a <code>CategoricalArray{String}</code> is produced. Passing any other type <code>T</code> will produce a <code>PooledVector{T}</code> column as long as it supports conversion from <code>String</code>. When <code>view=true</code>, a <code>RepeatedVector{T}</code> is produced.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia">d1 = DataFrame(a = repeat([1:3;], inner = [4]),
               b = repeat([1:4;], inner = [3]),
               c = randn(12),
               d = randn(12),
               e = map(string, &#39;a&#39;:&#39;l&#39;))

d1s = stack(d1, [:c, :d])
d1s2 = stack(d1, [:c, :d], [:a])
d1m = stack(d1, Not([:a, :b, :e]))
d1s_name = stack(d1, Not([:a, :b, :e]), variable_name=:somemeasure)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/6b0feaadd019c5ee36010ab956b5fee7b67681d5/src/abstractdataframe/reshape.jl#L1-L57">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFrames.unstack" href="#DataFrames.unstack"><code>DataFrames.unstack</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">unstack(df::AbstractDataFrame, rowkeys, colkey, value; renamecols::Function=identity)
unstack(df::AbstractDataFrame, colkey, value; renamecols::Function=identity)
unstack(df::AbstractDataFrame; renamecols::Function=identity)</code></pre><p>Unstack data frame <code>df</code>, i.e. convert it from long to wide format.</p><p>If <code>colkey</code> contains <code>missing</code> values then they will be skipped and a warning will be printed.</p><p>If combination of <code>rowkeys</code> and <code>colkey</code> contains duplicate entries then last <code>value</code> will be retained and a warning will be printed.</p><p><strong>Arguments</strong></p><ul><li><code>df</code> : the AbstractDataFrame to be unstacked</li><li><code>rowkeys</code> : the columns with a unique key for each row, if not given, find a key by grouping on anything not a <code>colkey</code> or <code>value</code>. Can be any column selector (<code>Symbol</code>, string or integer; <code>:</code>, <code>All</code>, <code>Between</code>, <code>Not</code>, a regular expression, or a vector of <code>Symbol</code>s, strings or integers).</li><li><code>colkey</code> : the column (<code>Symbol</code>, string or integer) holding the column names in wide format, defaults to <code>:variable</code></li><li><code>value</code> : the value column (<code>Symbol</code>, string or integer), defaults to <code>:value</code></li><li><code>renamecols</code> : a function called on each unique value in <code>colkey</code> which must                return the name of the column to be created (typically as a string                or a <code>Symbol</code>). Duplicate names are not allowed.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia">wide = DataFrame(id = 1:12,
                 a  = repeat([1:3;], inner = [4]),
                 b  = repeat([1:4;], inner = [3]),
                 c  = randn(12),
                 d  = randn(12))

long = stack(wide)
wide0 = unstack(long)
wide1 = unstack(long, :variable, :value)
wide2 = unstack(long, :id, :variable, :value)
wide3 = unstack(long, [:id, :a], :variable, :value)
wide4 = unstack(long, :id, :variable, :value, renamecols=x-&gt;Symbol(:_, x))</code></pre><p>Note that there are some differences between the widened results above.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/6b0feaadd019c5ee36010ab956b5fee7b67681d5/src/abstractdataframe/reshape.jl#L123-L165">source</a></section></article><h2 id="Sorting"><a class="docs-heading-anchor" href="#Sorting">Sorting</a><a id="Sorting-1"></a><a class="docs-heading-anchor-permalink" href="#Sorting" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Base.issorted" href="#Base.issorted"><code>Base.issorted</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">issorted(df::AbstractDataFrame, cols;
         lt=isless, by=identity, rev::Bool=false, order::Ordering=Forward)</code></pre><p>Test whether data frame <code>df</code> sorted by column(s) <code>cols</code>.</p><p><code>cols</code> can be any column selector (<code>Symbol</code>, string or integer; <code>:</code>, <code>All</code>, <code>Between</code>, <code>Not</code>, a regular expression, or a vector of <code>Symbol</code>s, strings or integers).</p><p>If <code>rev</code> is <code>true</code>, reverse sorting is performed. To enable reverse sorting only for some columns, pass <code>order(c, rev=true)</code> in <code>cols</code>, with <code>c</code> the corresponding column index (see example below). See other methods for a description of other keyword arguments.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/6b0feaadd019c5ee36010ab956b5fee7b67681d5/src/abstractdataframe/sort.jl#L307-L319">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFrames.order" href="#DataFrames.order"><code>DataFrames.order</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">order(col::ColumnIndex; kwargs...)</code></pre><p>Specify sorting order for a column <code>col</code> in a data frame. <code>kwargs</code> can be <code>lt</code>, <code>by</code>, <code>rev</code>, and <code>order</code> with values following the rules defined in <a href="#Base.sort!"><code>sort!</code></a>.</p><p>See also: <a href="#Base.sort!"><code>sort!</code></a>, <a href="#Base.sort"><code>sort</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; df = DataFrame(x = [-3, -1, 0, 2, 4], y = 1:5)
5×2 DataFrame
│ Row │ x     │ y     │
│     │ Int64 │ Int64 │
├─────┼───────┼───────┤
│ 1   │ -3    │ 1     │
│ 2   │ -1    │ 2     │
│ 3   │ 0     │ 3     │
│ 4   │ 2     │ 4     │
│ 5   │ 4     │ 5     │

julia&gt; sort(df, order(:x, rev=true))
5×2 DataFrame
│ Row │ x     │ y     │
│     │ Int64 │ Int64 │
├─────┼───────┼───────┤
│ 1   │ 4     │ 5     │
│ 2   │ 2     │ 4     │
│ 3   │ 0     │ 3     │
│ 4   │ -1    │ 2     │
│ 5   │ -3    │ 1     │

julia&gt; sort(df, order(:x, by=abs))
5×2 DataFrame
│ Row │ x     │ y     │
│     │ Int64 │ Int64 │
├─────┼───────┼───────┤
│ 1   │ 0     │ 3     │
│ 2   │ -1    │ 2     │
│ 3   │ 2     │ 4     │
│ 4   │ -3    │ 1     │
│ 5   │ 4     │ 5     │</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/6b0feaadd019c5ee36010ab956b5fee7b67681d5/src/abstractdataframe/sort.jl#L22-L66">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.sort" href="#Base.sort"><code>Base.sort</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">sort(df::AbstractDataFrame, cols;
     alg::Union{Algorithm, Nothing}=nothing, lt=isless, by=identity,
     rev::Bool=false, order::Ordering=Forward)</code></pre><p>Return a copy of data frame <code>df</code> sorted by column(s) <code>cols</code>.</p><p><code>cols</code> can be any column selector (<code>Symbol</code>, string or integer; <code>:</code>, <code>All</code>, <code>Between</code>, <code>Not</code>, a regular expression, or a vector of <code>Symbol</code>s, strings or integers).</p><p>If <code>alg</code> is <code>nothing</code> (the default), the most appropriate algorithm is chosen automatically among <code>TimSort</code>, <code>MergeSort</code> and <code>RadixSort</code> depending on the type of the sorting columns and on the number of rows in <code>df</code>. If <code>rev</code> is <code>true</code>, reverse sorting is performed. To enable reverse sorting only for some columns, pass <code>order(c, rev=true)</code> in <code>cols</code>, with <code>c</code> the corresponding column index (see example below). See <a href="#Base.sort!"><code>sort!</code></a> for a description of other keyword arguments.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; df = DataFrame(x = [3, 1, 2, 1], y = [&quot;b&quot;, &quot;c&quot;, &quot;a&quot;, &quot;b&quot;])
4×2 DataFrame
│ Row │ x     │ y      │
│     │ Int64 │ String │
├─────┼───────┼────────┤
│ 1   │ 3     │ b      │
│ 2   │ 1     │ c      │
│ 3   │ 2     │ a      │
│ 4   │ 1     │ b      │

julia&gt; sort(df, :x)
4×2 DataFrame
│ Row │ x     │ y      │
│     │ Int64 │ String │
├─────┼───────┼────────┤
│ 1   │ 1     │ c      │
│ 2   │ 1     │ b      │
│ 3   │ 2     │ a      │
│ 4   │ 3     │ b      │

julia&gt; sort(df, [:x, :y])
4×2 DataFrame
│ Row │ x     │ y      │
│     │ Int64 │ String │
├─────┼───────┼────────┤
│ 1   │ 1     │ b      │
│ 2   │ 1     │ c      │
│ 3   │ 2     │ a      │
│ 4   │ 3     │ b      │

julia&gt; sort(df, [:x, :y], rev=true)
4×2 DataFrame
│ Row │ x     │ y      │
│     │ Int64 │ String │
├─────┼───────┼────────┤
│ 1   │ 3     │ b      │
│ 2   │ 2     │ a      │
│ 3   │ 1     │ c      │
│ 4   │ 1     │ b      │

julia&gt; sort(df, [:x, order(:y, rev=true)])
4×2 DataFrame
│ Row │ x     │ y      │
│     │ Int64 │ String │
├─────┼───────┼────────┤
│ 1   │ 1     │ c      │
│ 2   │ 1     │ b      │
│ 3   │ 2     │ a      │
│ 4   │ 3     │ b      │</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/6b0feaadd019c5ee36010ab956b5fee7b67681d5/src/abstractdataframe/sort.jl#L357-L426">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.sort!" href="#Base.sort!"><code>Base.sort!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">sort!(df::AbstractDataFrame, cols;
      alg::Union{Algorithm, Nothing}=nothing, lt=isless, by=identity,
      rev::Bool=false, order::Ordering=Forward)</code></pre><p>Sort data frame <code>df</code> by column(s) <code>cols</code>.</p><p><code>cols</code> can be any column selector (<code>Symbol</code>, string or integer; <code>:</code>, <code>All</code>, <code>Between</code>, <code>Not</code>, a regular expression, or a vector of <code>Symbol</code>s, strings or integers).</p><p>If <code>alg</code> is <code>nothing</code> (the default), the most appropriate algorithm is chosen automatically among <code>TimSort</code>, <code>MergeSort</code> and <code>RadixSort</code> depending on the type of the sorting columns and on the number of rows in <code>df</code>. If <code>rev</code> is <code>true</code>, reverse sorting is performed. To enable reverse sorting only for some columns, pass <code>order(c, rev=true)</code> in <code>cols</code>, with <code>c</code> the corresponding column index (see example below). See other methods for a description of other keyword arguments.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; df = DataFrame(x = [3, 1, 2, 1], y = [&quot;b&quot;, &quot;c&quot;, &quot;a&quot;, &quot;b&quot;])
4×2 DataFrame
│ Row │ x     │ y      │
│     │ Int64 │ String │
├─────┼───────┼────────┤
│ 1   │ 3     │ b      │
│ 2   │ 1     │ c      │
│ 3   │ 2     │ a      │
│ 4   │ 1     │ b      │

julia&gt; sort!(df, :x)
4×2 DataFrame
│ Row │ x     │ y      │
│     │ Int64 │ String │
├─────┼───────┼────────┤
│ 1   │ 1     │ c      │
│ 2   │ 1     │ b      │
│ 3   │ 2     │ a      │
│ 4   │ 3     │ b      │

julia&gt; sort!(df, [:x, :y])
4×2 DataFrame
│ Row │ x     │ y      │
│     │ Int64 │ String │
├─────┼───────┼────────┤
│ 1   │ 1     │ b      │
│ 2   │ 1     │ c      │
│ 3   │ 2     │ a      │
│ 4   │ 3     │ b      │

julia&gt; sort!(df, [:x, :y], rev=true)
4×2 DataFrame
│ Row │ x     │ y      │
│     │ Int64 │ String │
├─────┼───────┼────────┤
│ 1   │ 3     │ b      │
│ 2   │ 2     │ a      │
│ 3   │ 1     │ c      │
│ 4   │ 1     │ b      │

julia&gt; sort!(df, (:x, order(:y, rev=true)))
4×2 DataFrame
│ Row │ x     │ y      │
│     │ Int64 │ String │
├─────┼───────┼────────┤
│ 1   │ 1     │ c      │
│ 2   │ 1     │ b      │
│ 3   │ 2     │ a      │
│ 4   │ 3     │ b      │</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/6b0feaadd019c5ee36010ab956b5fee7b67681d5/src/dataframe/sort.jl#L2-L71">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.sortperm" href="#Base.sortperm"><code>Base.sortperm</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">sortperm(df::AbstractDataFrame, cols;
         alg::Union{Algorithm, Nothing}=nothing, lt=isless, by=identity,
         rev::Bool=false, order::Ordering=Forward)</code></pre><p>Return a permutation vector of row indices of data frame <code>df</code> that puts them in sorted order according to column(s) <code>cols</code>.</p><p><code>cols</code> can be any column selector (<code>Symbol</code>, string or integer; <code>:</code>, <code>All</code>, <code>Between</code>, <code>Not</code>, a regular expression, or a vector of <code>Symbol</code>s, strings or integers).</p><p>If <code>alg</code> is <code>nothing</code> (the default), the most appropriate algorithm is chosen automatically among <code>TimSort</code>, <code>MergeSort</code> and <code>RadixSort</code> depending on the type of the sorting columns and on the number of rows in <code>df</code>. If <code>rev</code> is <code>true</code>, reverse sorting is performed. To enable reverse sorting only for some columns, pass <code>order(c, rev=true)</code> in <code>cols</code>, with <code>c</code> the corresponding column index (see example below). See other methods for a description of other keyword arguments.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; df = DataFrame(x = [3, 1, 2, 1], y = [&quot;b&quot;, &quot;c&quot;, &quot;a&quot;, &quot;b&quot;])
4×2 DataFrame
│ Row │ x     │ y      │
│     │ Int64 │ String │
├─────┼───────┼────────┤
│ 1   │ 3     │ b      │
│ 2   │ 1     │ c      │
│ 3   │ 2     │ a      │
│ 4   │ 1     │ b      │

julia&gt; sortperm(df, :x)
4-element Array{Int64,1}:
 2
 4
 3
 1

julia&gt; sortperm(df, (:x, :y))
4-element Array{Int64,1}:
 4
 2
 3
 1

julia&gt; sortperm(df, (:x, :y), rev=true)
4-element Array{Int64,1}:
 1
 3
 2
 4

 julia&gt; sortperm(df, (:x, order(:y, rev=true)))
 4-element Array{Int64,1}:
  2
  4
  3
  1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/6b0feaadd019c5ee36010ab956b5fee7b67681d5/src/abstractdataframe/sort.jl#L429-L487">source</a></section></article><h2 id="Joining"><a class="docs-heading-anchor" href="#Joining">Joining</a><a id="Joining-1"></a><a class="docs-heading-anchor-permalink" href="#Joining" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="DataFrames.antijoin" href="#DataFrames.antijoin"><code>DataFrames.antijoin</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">antijoin(df1, df2; on, makeunique = false, validate = (false, false))</code></pre><p>Perform an anti join of two data frame objects and return a <code>DataFrame</code> containing the result. An anti join returns the subset of rows of <code>df1</code> that do not match with the keys in <code>df2</code>.</p><p>The order of rows in the result is undefined and may change in the future releases.</p><p><strong>Arguments</strong></p><ul><li><code>df1</code>, <code>df2</code>: the <code>AbstractDataFrames</code> to be joined</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>on</code> : A column name to join <code>df1</code> and <code>df2</code> on. If the columns on which <code>df1</code> and <code>df2</code> will be joined have different names, then a <code>left=&gt;right</code> pair can be passed. It is also allowed to perform a join on multiple columns, in which case a vector of column names or column name pairs can be passed (mixing names and pairs is allowed).</li><li><code>makeunique</code> : if <code>false</code> (the default), an error will be raised if duplicate names are found in columns not joined on; if <code>true</code>, duplicate names will be suffixed with <code>_i</code> (<code>i</code> starting at 1 for the first duplicate).</li><li><code>validate</code> : whether to check that columns passed as the <code>on</code> argument  define unique keys in each input data frame (according to <code>isequal</code>).  Can be a tuple or a pair, with the first element indicating whether to  run check for <code>df1</code> and the second element for <code>df2</code>.  By default no check is performed.</li></ul><p>When merging <code>on</code> categorical columns that differ in the ordering of their levels, the ordering of the left data frame takes precedence over the ordering of the right data frame.</p><p>See also: <a href="#DataFrames.innerjoin"><code>innerjoin</code></a>, <a href="#DataFrames.leftjoin"><code>leftjoin</code></a>, <a href="#DataFrames.rightjoin"><code>rightjoin</code></a>,           <a href="#DataFrames.outerjoin"><code>outerjoin</code></a>, <a href="#DataFrames.semijoin"><code>semijoin</code></a>, <a href="#DataFrames.crossjoin"><code>crossjoin</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; name = DataFrame(ID = [1, 2, 3], Name = [&quot;John Doe&quot;, &quot;Jane Doe&quot;, &quot;Joe Blogs&quot;])
3×2 DataFrame
│ Row │ ID    │ Name      │
│     │ Int64 │ String    │
├─────┼───────┼───────────┤
│ 1   │ 1     │ John Doe  │
│ 2   │ 2     │ Jane Doe  │
│ 3   │ 3     │ Joe Blogs │

julia&gt; job = DataFrame(ID = [1, 2, 4], Job = [&quot;Lawyer&quot;, &quot;Doctor&quot;, &quot;Farmer&quot;])
3×2 DataFrame
│ Row │ ID    │ Job    │
│     │ Int64 │ String │
├─────┼───────┼────────┤
│ 1   │ 1     │ Lawyer │
│ 2   │ 2     │ Doctor │
│ 3   │ 4     │ Farmer │

julia&gt; antijoin(name, job, on = :ID)
1×2 DataFrame
│ Row │ ID    │ Name      │
│     │ Int64 │ String    │
├─────┼───────┼───────────┤
│ 1   │ 3     │ Joe Blogs │

julia&gt; job2 = DataFrame(identifier = [1, 2, 4], Job = [&quot;Lawyer&quot;, &quot;Doctor&quot;, &quot;Farmer&quot;])
3×2 DataFrame
│ Row │ identifier │ Job    │
│     │ Int64      │ String │
├─────┼────────────┼────────┤
│ 1   │ 1          │ Lawyer │
│ 2   │ 2          │ Doctor │
│ 3   │ 4          │ Farmer │

julia&gt; antijoin(name, job2, on = :ID =&gt; :identifier)
1×2 DataFrame
│ Row │ ID    │ Name      │
│     │ Int64 │ String    │
├─────┼───────┼───────────┤
│ 1   │ 3     │ Joe Blogs │

julia&gt; antijoin(name, job2, on = [:ID =&gt; :identifier])
1×2 DataFrame
│ Row │ ID    │ Name      │
│     │ Int64 │ String    │
├─────┼───────┼───────────┤
│ 1   │ 3     │ Joe Blogs │</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/6b0feaadd019c5ee36010ab956b5fee7b67681d5/src/abstractdataframe/join.jl#L1052-L1137">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFrames.crossjoin" href="#DataFrames.crossjoin"><code>DataFrames.crossjoin</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">crossjoin(df1, df2, dfs...; makeunique = false)</code></pre><p>Perform a cross join of two or more data frame objects and return a <code>DataFrame</code> containing the result. A cross join returns the cartesian product of rows from all passed data frames, where the first passed data frame is assigned to the dimension that changes the slowest and the last data frame is assigned to the dimension that changes the fastest.</p><p><strong>Arguments</strong></p><ul><li><code>df1</code>, <code>df2</code>, <code>dfs...</code> : the <code>AbstractDataFrames</code> to be joined</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>makeunique</code> : if <code>false</code> (the default), an error will be raised if duplicate names are found in columns not joined on; if <code>true</code>, duplicate names will be suffixed with <code>_i</code> (<code>i</code> starting at 1 for the first duplicate).</li></ul><p>If more than two data frames are passed, the join is performed recursively with left associativity.</p><p>See also: <a href="#DataFrames.innerjoin"><code>innerjoin</code></a>, <a href="#DataFrames.leftjoin"><code>leftjoin</code></a>, <a href="#DataFrames.rightjoin"><code>rightjoin</code></a>,           <a href="#DataFrames.outerjoin"><code>outerjoin</code></a>, <a href="#DataFrames.semijoin"><code>semijoin</code></a>, <a href="#DataFrames.antijoin"><code>antijoin</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; df1 = DataFrame(X=1:3)
3×1 DataFrame
│ Row │ X     │
│     │ Int64 │
├─────┼───────┤
│ 1   │ 1     │
│ 2   │ 2     │
│ 3   │ 3     │

julia&gt; df2 = DataFrame(Y=[&quot;a&quot;, &quot;b&quot;])
2×1 DataFrame
│ Row │ Y      │
│     │ String │
├─────┼────────┤
│ 1   │ a      │
│ 2   │ b      │

julia&gt; crossjoin(df1, df2)
6×2 DataFrame
│ Row │ X     │ Y      │
│     │ Int64 │ String │
├─────┼───────┼────────┤
│ 1   │ 1     │ a      │
│ 2   │ 1     │ b      │
│ 3   │ 2     │ a      │
│ 4   │ 2     │ b      │
│ 5   │ 3     │ a      │
│ 6   │ 3     │ b      │</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/6b0feaadd019c5ee36010ab956b5fee7b67681d5/src/abstractdataframe/join.jl#L1145-L1200">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFrames.innerjoin" href="#DataFrames.innerjoin"><code>DataFrames.innerjoin</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">innerjoin(df1, df2; on, makeunique = false,
          validate = (false, false), renamecols = identity =&gt; identity)
innerjoin(df1, df2, dfs...; on, makeunique = false,
          validate = (false, false))</code></pre><p>Perform an inner join of two or more data frame objects and return a <code>DataFrame</code> containing the result. An inner join includes rows with keys that match in all passed data frames.</p><p>The order of rows in the result is undefined and may change in the future releases.</p><p><strong>Arguments</strong></p><ul><li><code>df1</code>, <code>df2</code>, <code>dfs...</code>: the <code>AbstractDataFrames</code> to be joined</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>on</code> : A column name to join <code>df1</code> and <code>df2</code> on. If the columns on which <code>df1</code> and <code>df2</code> will be joined have different names, then a <code>left=&gt;right</code> pair can be passed. It is also allowed to perform a join on multiple columns, in which case a vector of column names or column name pairs can be passed (mixing names and pairs is allowed). If more than two data frames are joined then only a column name or a vector of column names are allowed. <code>on</code> is a required argument.</li><li><code>makeunique</code> : if <code>false</code> (the default), an error will be raised if duplicate names are found in columns not joined on; if <code>true</code>, duplicate names will be suffixed with <code>_i</code> (<code>i</code> starting at 1 for the first duplicate).</li><li><code>validate</code> : whether to check that columns passed as the <code>on</code> argument define unique keys in each input data frame (according to <code>isequal</code>). Can be a tuple or a pair, with the first element indicating whether to run check for <code>df1</code> and the second element for <code>df2</code>. By default no check is performed.</li><li><code>renamecols</code> : a <code>Pair</code> specifying how columns of left and right data frames should be renamed in the resulting data frame. Each element of the pair can be a string or a <code>Symbol</code> can be passed in which case it is appended to the original column name; alternatively a function can be passed in which case it is applied to each column name, which is passed to it as a <code>String</code>. Note that <code>renamecols</code> does not affect <code>on</code> columns, whose names are always taken from the left data frame and left unchanged.</li></ul><p>When merging <code>on</code> categorical columns that differ in the ordering of their levels, the ordering of the left data frame takes precedence over the ordering of the right data frame.</p><p>If more than two data frames are passed, the join is performed recursively with left associativity. In this case the <code>validate</code> keyword argument is applied recursively with left associativity.</p><p>See also: <a href="#DataFrames.leftjoin"><code>leftjoin</code></a>, <a href="#DataFrames.rightjoin"><code>rightjoin</code></a>, <a href="#DataFrames.outerjoin"><code>outerjoin</code></a>,           <a href="#DataFrames.semijoin"><code>semijoin</code></a>, <a href="#DataFrames.antijoin"><code>antijoin</code></a>, <a href="#DataFrames.crossjoin"><code>crossjoin</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; name = DataFrame(ID = [1, 2, 3], Name = [&quot;John Doe&quot;, &quot;Jane Doe&quot;, &quot;Joe Blogs&quot;])
3×2 DataFrame
│ Row │ ID    │ Name      │
│     │ Int64 │ String    │
├─────┼───────┼───────────┤
│ 1   │ 1     │ John Doe  │
│ 2   │ 2     │ Jane Doe  │
│ 3   │ 3     │ Joe Blogs │

julia&gt; job = DataFrame(ID = [1, 2, 4], Job = [&quot;Lawyer&quot;, &quot;Doctor&quot;, &quot;Farmer&quot;])
3×2 DataFrame
│ Row │ ID    │ Job    │
│     │ Int64 │ String │
├─────┼───────┼────────┤
│ 1   │ 1     │ Lawyer │
│ 2   │ 2     │ Doctor │
│ 3   │ 4     │ Farmer │

julia&gt; innerjoin(name, job, on = :ID)
2×3 DataFrame
│ Row │ ID    │ Name     │ Job    │
│     │ Int64 │ String   │ String │
├─────┼───────┼──────────┼────────┤
│ 1   │ 1     │ John Doe │ Lawyer │
│ 2   │ 2     │ Jane Doe │ Doctor │

julia&gt; job2 = DataFrame(identifier = [1, 2, 4], Job = [&quot;Lawyer&quot;, &quot;Doctor&quot;, &quot;Farmer&quot;])
3×2 DataFrame
│ Row │ identifier │ Job    │
│     │ Int64      │ String │
├─────┼────────────┼────────┤
│ 1   │ 1          │ Lawyer │
│ 2   │ 2          │ Doctor │
│ 3   │ 4          │ Farmer │

julia&gt; innerjoin(name, job2, on = :ID =&gt; :identifier, renamecols = &quot;_left&quot; =&gt; &quot;_right&quot;)
2×3 DataFrame
│ Row │ ID    │ Name_left │ Job_right │
│     │ Int64 │ String    │ String    │
├─────┼───────┼───────────┼───────────┤
│ 1   │ 1     │ John Doe  │ Lawyer    │
│ 2   │ 2     │ Jane Doe  │ Doctor    │

julia&gt; innerjoin(name, job2, on = [:ID =&gt; :identifier], renamecols = uppercase =&gt; lowercase)
2×3 DataFrame
│ Row │ ID    │ NAME     │ job    │
│     │ Int64 │ String   │ String │
├─────┼───────┼──────────┼────────┤
│ 1   │ 1     │ John Doe │ Lawyer │
│ 2   │ 2     │ Jane Doe │ Doctor │</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/6b0feaadd019c5ee36010ab956b5fee7b67681d5/src/abstractdataframe/join.jl#L450-L554">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFrames.leftjoin" href="#DataFrames.leftjoin"><code>DataFrames.leftjoin</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">leftjoin(df1, df2; on, makeunique = false, indicator = nothing,
         validate = (false, false), renamecols = identity =&gt; identity)</code></pre><p>Perform a left join of twodata frame objects and return a <code>DataFrame</code> containing the result. A left join includes all rows from <code>df1</code>.</p><p>The order of rows in the result is undefined and may change in the future releases.</p><p><strong>Arguments</strong></p><ul><li><code>df1</code>, <code>df2</code>: the <code>AbstractDataFrames</code> to be joined</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>on</code> : A column name to join <code>df1</code> and <code>df2</code> on. If the columns on which <code>df1</code> and <code>df2</code> will be joined have different names, then a <code>left=&gt;right</code> pair can be passed. It is also allowed to perform a join on multiple columns, in which case a vector of column names or column name pairs can be passed (mixing names and pairs is allowed).</li><li><code>makeunique</code> : if <code>false</code> (the default), an error will be raised if duplicate names are found in columns not joined on; if <code>true</code>, duplicate names will be suffixed with <code>_i</code> (<code>i</code> starting at 1 for the first duplicate).</li><li><code>indicator</code> : Default: <code>nothing</code>. If a <code>Symbol</code> or string, adds categorical indicator column with the given name, for whether a row appeared in only <code>df1</code> (<code>&quot;left_only&quot;</code>), only <code>df2</code> (<code>&quot;right_only&quot;</code>) or in both (<code>&quot;both&quot;</code>). If the name is already in use, the column name will be modified if <code>makeunique=true</code>.</li><li><code>validate</code> : whether to check that columns passed as the <code>on</code> argument define unique keys in each input data frame (according to <code>isequal</code>). Can be a tuple or a pair, with the first element indicating whether to run check for <code>df1</code> and the second element for <code>df2</code>. By default no check is performed.</li><li><code>renamecols</code> : a <code>Pair</code> specifying how columns of left and right data frames should be renamed in the resulting data frame. Each element of the pair can be a string or a <code>Symbol</code> can be passed in which case it is appended to the original column name; alternatively a function can be passed in which case it is applied to each column name, which is passed to it as a <code>String</code>. Note that <code>renamecols</code> does not affect <code>on</code> columns, whose names are always taken from the left data frame and left unchanged.</li></ul><p>All columns of the returned data table will support missing values.</p><p>When merging <code>on</code> categorical columns that differ in the ordering of their levels, the ordering of the left data frame takes precedence over the ordering of the right data frame.</p><p>See also: <a href="#DataFrames.innerjoin"><code>innerjoin</code></a>, <a href="#DataFrames.rightjoin"><code>rightjoin</code></a>, <a href="#DataFrames.outerjoin"><code>outerjoin</code></a>,           <a href="#DataFrames.semijoin"><code>semijoin</code></a>, <a href="#DataFrames.antijoin"><code>antijoin</code></a>, <a href="#DataFrames.crossjoin"><code>crossjoin</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; name = DataFrame(ID = [1, 2, 3], Name = [&quot;John Doe&quot;, &quot;Jane Doe&quot;, &quot;Joe Blogs&quot;])
3×2 DataFrame
│ Row │ ID    │ Name      │
│     │ Int64 │ String    │
├─────┼───────┼───────────┤
│ 1   │ 1     │ John Doe  │
│ 2   │ 2     │ Jane Doe  │
│ 3   │ 3     │ Joe Blogs │

julia&gt; job = DataFrame(ID = [1, 2, 4], Job = [&quot;Lawyer&quot;, &quot;Doctor&quot;, &quot;Farmer&quot;])
3×2 DataFrame
│ Row │ ID    │ Job    │
│     │ Int64 │ String │
├─────┼───────┼────────┤
│ 1   │ 1     │ Lawyer │
│ 2   │ 2     │ Doctor │
│ 3   │ 4     │ Farmer │

julia&gt; leftjoin(name, job, on = :ID)
3×3 DataFrame
│ Row │ ID    │ Name      │ Job     │
│     │ Int64 │ String    │ String? │
├─────┼───────┼───────────┼─────────┤
│ 1   │ 1     │ John Doe  │ Lawyer  │
│ 2   │ 2     │ Jane Doe  │ Doctor  │
│ 3   │ 3     │ Joe Blogs │ missing │

julia&gt; job2 = DataFrame(identifier = [1, 2, 4], Job = [&quot;Lawyer&quot;, &quot;Doctor&quot;, &quot;Farmer&quot;])
3×2 DataFrame
│ Row │ identifier │ Job    │
│     │ Int64      │ String │
├─────┼────────────┼────────┤
│ 1   │ 1          │ Lawyer │
│ 2   │ 2          │ Doctor │
│ 3   │ 4          │ Farmer │

julia&gt; leftjoin(name, job2, on = :ID =&gt; :identifier, renamecols = &quot;_left&quot; =&gt; &quot;_right&quot;)
3×3 DataFrame
│ Row │ ID    │ Name_left │ Job_right │
│     │ Int64 │ String    │ String?   │
├─────┼───────┼───────────┼───────────┤
│ 1   │ 1     │ John Doe  │ Lawyer    │
│ 2   │ 2     │ Jane Doe  │ Doctor    │
│ 3   │ 3     │ Joe Blogs │ missing   │

julia&gt; leftjoin(name, job2, on = [:ID =&gt; :identifier], renamecols = uppercase =&gt; lowercase)
3×3 DataFrame
│ Row │ ID    │ NAME      │ job     │
│     │ Int64 │ String    │ String? │
├─────┼───────┼───────────┼─────────┤
│ 1   │ 1     │ John Doe  │ Lawyer  │
│ 2   │ 2     │ Jane Doe  │ Doctor  │
│ 3   │ 3     │ Joe Blogs │ missing │</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/6b0feaadd019c5ee36010ab956b5fee7b67681d5/src/abstractdataframe/join.jl#L576-L680">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFrames.outerjoin" href="#DataFrames.outerjoin"><code>DataFrames.outerjoin</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">outerjoin(df1, df2; on, kind = :inner, makeunique = false, indicator = nothing,
          validate = (false, false), renamecols = identity =&gt; identity)
outerjoin(df1, df2, dfs...; on, kind = :inner, makeunique = false,
          validate = (false, false))</code></pre><p>Perform an outer join of two or more data frame objects and return a <code>DataFrame</code> containing the result. An outer join includes rows with keys that appear in any of the passed data frames.</p><p>The order of rows in the result is undefined and may change in the future releases.</p><p><strong>Arguments</strong></p><ul><li><code>df1</code>, <code>df2</code>, <code>dfs...</code> : the <code>AbstractDataFrames</code> to be joined</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>on</code> : A column name to join <code>df1</code> and <code>df2</code> on. If the columns on which <code>df1</code> and <code>df2</code> will be joined have different names, then a <code>left=&gt;right</code> pair can be passed. It is also allowed to perform a join on multiple columns, in which case a vector of column names or column name pairs can be passed (mixing names and pairs is allowed). If more than two data frames are joined then only a column name or a vector of column names are allowed. <code>on</code> is a required argument.</li><li><code>makeunique</code> : if <code>false</code> (the default), an error will be raised if duplicate names are found in columns not joined on; if <code>true</code>, duplicate names will be suffixed with <code>_i</code> (<code>i</code> starting at 1 for the first duplicate).</li><li><code>indicator</code> : Default: <code>nothing</code>. If a <code>Symbol</code> or string, adds categorical indicator column with the given name for whether a row appeared in only <code>df1</code> (<code>&quot;left_only&quot;</code>), only <code>df2</code> (<code>&quot;right_only&quot;</code>) or in both (<code>&quot;both&quot;</code>). If the name is already in use, the column name will be modified if <code>makeunique=true</code>. This argument is only supported when joining exactly two data frames.</li><li><code>validate</code> : whether to check that columns passed as the <code>on</code> argument define unique keys in each input data frame (according to <code>isequal</code>). Can be a tuple or a pair, with the first element indicating whether to run check for <code>df1</code> and the second element for <code>df2</code>. By default no check is performed.</li><li><code>renamecols</code> : a <code>Pair</code> specifying how columns of left and right data frames should be renamed in the resulting data frame. Each element of the pair can be a string or a <code>Symbol</code> can be passed in which case it is appended to the original column name; alternatively a function can be passed in which case it is applied to each column name, which is passed to it as a <code>String</code>. Note that <code>renamecols</code> does not affect <code>on</code> columns, whose names are always taken from the left data frame and left unchanged.</li></ul><p>All columns of the returned data table will support missing values.</p><p>When merging <code>on</code> categorical columns that differ in the ordering of their levels, the ordering of the left data frame takes precedence over the ordering of the right data frame.</p><p>If more than two data frames are passed, the join is performed recursively with left associativity. In this case the <code>indicator</code> keyword argument is not supported and <code>validate</code> keyword argument is applied recursively with left associativity.</p><p>See also: <a href="#DataFrames.innerjoin"><code>innerjoin</code></a>, <a href="#DataFrames.leftjoin"><code>leftjoin</code></a>, <a href="#DataFrames.rightjoin"><code>rightjoin</code></a>,           <a href="#DataFrames.semijoin"><code>semijoin</code></a>, <a href="#DataFrames.antijoin"><code>antijoin</code></a>, <a href="#DataFrames.crossjoin"><code>crossjoin</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; name = DataFrame(ID = [1, 2, 3], Name = [&quot;John Doe&quot;, &quot;Jane Doe&quot;, &quot;Joe Blogs&quot;])
3×2 DataFrame
│ Row │ ID    │ Name      │
│     │ Int64 │ String    │
├─────┼───────┼───────────┤
│ 1   │ 1     │ John Doe  │
│ 2   │ 2     │ Jane Doe  │
│ 3   │ 3     │ Joe Blogs │

julia&gt; job = DataFrame(ID = [1, 2, 4], Job = [&quot;Lawyer&quot;, &quot;Doctor&quot;, &quot;Farmer&quot;])
3×2 DataFrame
│ Row │ ID    │ Job    │
│     │ Int64 │ String │
├─────┼───────┼────────┤
│ 1   │ 1     │ Lawyer │
│ 2   │ 2     │ Doctor │
│ 3   │ 4     │ Farmer │

julia&gt; outerjoin(name, job, on = :ID)
4×3 DataFrame
│ Row │ ID    │ Name      │ Job     │
│     │ Int64 │ String?   │ String? │
├─────┼───────┼───────────┼─────────┤
│ 1   │ 1     │ John Doe  │ Lawyer  │
│ 2   │ 2     │ Jane Doe  │ Doctor  │
│ 3   │ 3     │ Joe Blogs │ missing │
│ 4   │ 4     │ missing   │ Farmer  │

julia&gt; job2 = DataFrame(identifier = [1, 2, 4], Job = [&quot;Lawyer&quot;, &quot;Doctor&quot;, &quot;Farmer&quot;])
3×2 DataFrame
│ Row │ identifier │ Job    │
│     │ Int64      │ String │
├─────┼────────────┼────────┤
│ 1   │ 1          │ Lawyer │
│ 2   │ 2          │ Doctor │
│ 3   │ 4          │ Farmer │

julia&gt; rightjoin(name, job2, on = :ID =&gt; :identifier, renamecols = &quot;_left&quot; =&gt; &quot;_right&quot;)
3×3 DataFrame
│ Row │ ID    │ Name_left │ Job_right │
│     │ Int64 │ String?   │ String    │
├─────┼───────┼───────────┼───────────┤
│ 1   │ 1     │ John Doe  │ Lawyer    │
│ 2   │ 2     │ Jane Doe  │ Doctor    │
│ 3   │ 4     │ missing   │ Farmer    │

julia&gt; rightjoin(name, job2, on = [:ID =&gt; :identifier], renamecols = uppercase =&gt; lowercase)
3×3 DataFrame
│ Row │ ID    │ NAME     │ job    │
│     │ Int64 │ String?  │ String │
├─────┼───────┼──────────┼────────┤
│ 1   │ 1     │ John Doe │ Lawyer │
│ 2   │ 2     │ Jane Doe │ Doctor │
│ 3   │ 4     │ missing  │ Farmer │</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/6b0feaadd019c5ee36010ab956b5fee7b67681d5/src/abstractdataframe/join.jl#L814-L931">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFrames.rightjoin" href="#DataFrames.rightjoin"><code>DataFrames.rightjoin</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">rightjoin(df1, df2; on, makeunique = false, indicator = nothing,
          validate = (false, false), renamecols = identity =&gt; identity)</code></pre><p>Perform a right join on two data frame objects and return a <code>DataFrame</code> containing the result. A right join includes all rows from <code>df2</code>.</p><p>The order of rows in the result is undefined and may change in the future releases.</p><p><strong>Arguments</strong></p><ul><li><code>df1</code>, <code>df2</code>: the <code>AbstractDataFrames</code> to be joined</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>on</code> : A column name to join <code>df1</code> and <code>df2</code> on. If the columns on which <code>df1</code> and <code>df2</code> will be joined have different names, then a <code>left=&gt;right</code> pair can be passed. It is also allowed to perform a join on multiple columns, in which case a vector of column names or column name pairs can be passed (mixing names and pairs is allowed).</li><li><code>makeunique</code> : if <code>false</code> (the default), an error will be raised if duplicate names are found in columns not joined on; if <code>true</code>, duplicate names will be suffixed with <code>_i</code> (<code>i</code> starting at 1 for the first duplicate).</li><li><code>indicator</code> : Default: <code>nothing</code>. If a <code>Symbol</code> or string, adds categorical indicator column with the given name for whether a row appeared in only <code>df1</code> (<code>&quot;left_only&quot;</code>), only <code>df2</code> (<code>&quot;right_only&quot;</code>) or in both (<code>&quot;both&quot;</code>). If the name is already in use, the column name will be modified if <code>makeunique=true</code>.</li><li><code>validate</code> : whether to check that columns passed as the <code>on</code> argument define unique keys in each input data frame (according to <code>isequal</code>). Can be a tuple or a pair, with the first element indicating whether to run check for <code>df1</code> and the second element for <code>df2</code>. By default no check is performed.</li><li><code>renamecols</code> : a <code>Pair</code> specifying how columns of left and right data frames should be renamed in the resulting data frame. Each element of the pair can be a string or a <code>Symbol</code> can be passed in which case it is appended to the original column name; alternatively a function can be passed in which case it is applied to each column name, which is passed to it as a <code>String</code>. Note that <code>renamecols</code> does not affect <code>on</code> columns, whose names are always taken from the left data frame and left unchanged.</li></ul><p>All columns of the returned data table will support missing values.</p><p>When merging <code>on</code> categorical columns that differ in the ordering of their levels, the ordering of the left data frame takes precedence over the ordering of the right data frame.</p><p>See also: <a href="#DataFrames.innerjoin"><code>innerjoin</code></a>, <a href="#DataFrames.leftjoin"><code>leftjoin</code></a>, <a href="#DataFrames.outerjoin"><code>outerjoin</code></a>,           <a href="#DataFrames.semijoin"><code>semijoin</code></a>, <a href="#DataFrames.antijoin"><code>antijoin</code></a>, <a href="#DataFrames.crossjoin"><code>crossjoin</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; name = DataFrame(ID = [1, 2, 3], Name = [&quot;John Doe&quot;, &quot;Jane Doe&quot;, &quot;Joe Blogs&quot;])
3×2 DataFrame
│ Row │ ID    │ Name      │
│     │ Int64 │ String    │
├─────┼───────┼───────────┤
│ 1   │ 1     │ John Doe  │
│ 2   │ 2     │ Jane Doe  │
│ 3   │ 3     │ Joe Blogs │

julia&gt; job = DataFrame(ID = [1, 2, 4], Job = [&quot;Lawyer&quot;, &quot;Doctor&quot;, &quot;Farmer&quot;])
3×2 DataFrame
│ Row │ ID    │ Job    │
│     │ Int64 │ String │
├─────┼───────┼────────┤
│ 1   │ 1     │ Lawyer │
│ 2   │ 2     │ Doctor │
│ 3   │ 4     │ Farmer │

julia&gt; rightjoin(name, job, on = :ID)
3×3 DataFrame
│ Row │ ID    │ Name     │ Job    │
│     │ Int64 │ String?  │ String │
├─────┼───────┼──────────┼────────┤
│ 1   │ 1     │ John Doe │ Lawyer │
│ 2   │ 2     │ Jane Doe │ Doctor │
│ 3   │ 4     │ missing  │ Farmer │

julia&gt; job2 = DataFrame(identifier = [1, 2, 4], Job = [&quot;Lawyer&quot;, &quot;Doctor&quot;, &quot;Farmer&quot;])
3×2 DataFrame
│ Row │ identifier │ Job    │
│     │ Int64      │ String │
├─────┼────────────┼────────┤
│ 1   │ 1          │ Lawyer │
│ 2   │ 2          │ Doctor │
│ 3   │ 4          │ Farmer │

julia&gt; rightjoin(name, job2, on = :ID =&gt; :identifier, renamecols = &quot;_left&quot; =&gt; &quot;_right&quot;)
3×3 DataFrame
│ Row │ ID    │ Name_left │ Job_right │
│     │ Int64 │ String?   │ String    │
├─────┼───────┼───────────┼───────────┤
│ 1   │ 1     │ John Doe  │ Lawyer    │
│ 2   │ 2     │ Jane Doe  │ Doctor    │
│ 3   │ 4     │ missing   │ Farmer    │

julia&gt; rightjoin(name, job2, on = [:ID =&gt; :identifier], renamecols = uppercase =&gt; lowercase)
3×3 DataFrame
│ Row │ ID    │ NAME     │ job    │
│     │ Int64 │ String?  │ String │
├─────┼───────┼──────────┼────────┤
│ 1   │ 1     │ John Doe │ Lawyer │
│ 2   │ 2     │ Jane Doe │ Doctor │
│ 3   │ 4     │ missing  │ Farmer │</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/6b0feaadd019c5ee36010ab956b5fee7b67681d5/src/abstractdataframe/join.jl#L695-L799">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFrames.semijoin" href="#DataFrames.semijoin"><code>DataFrames.semijoin</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">semijoin(df1, df2; on, makeunique = false, validate = (false, false))</code></pre><p>Perform a semi join of two data frame objects and return a <code>DataFrame</code> containing the result. A semi join returns the subset of rows of <code>df1</code> that match with the keys in <code>df2</code>.</p><p>The order of rows in the result is undefined and may change in the future releases.</p><p><strong>Arguments</strong></p><ul><li><code>df1</code>, <code>df2</code>: the <code>AbstractDataFrames</code> to be joined</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>on</code> : A column name to join <code>df1</code> and <code>df2</code> on. If the columns on which <code>df1</code> and <code>df2</code> will be joined have different names, then a <code>left=&gt;right</code> pair can be passed. It is also allowed to perform a join on multiple columns, in which case a vector of column names or column name pairs can be passed (mixing names and pairs is allowed).</li><li><code>makeunique</code> : if <code>false</code> (the default), an error will be raised if duplicate names are found in columns not joined on; if <code>true</code>, duplicate names will be suffixed with <code>_i</code> (<code>i</code> starting at 1 for the first duplicate).</li><li><code>indicator</code> : Default: <code>nothing</code>. If a <code>Symbol</code> or string, adds categorical indicator  column with the given name for whether a row appeared in only <code>df1</code> (<code>&quot;left_only&quot;</code>),  only <code>df2</code> (<code>&quot;right_only&quot;</code>) or in both (<code>&quot;both&quot;</code>). If the name is already in use,  the column name will be modified if <code>makeunique=true</code>.</li><li><code>validate</code> : whether to check that columns passed as the <code>on</code> argument  define unique keys in each input data frame (according to <code>isequal</code>).  Can be a tuple or a pair, with the first element indicating whether to  run check for <code>df1</code> and the second element for <code>df2</code>.  By default no check is performed.</li></ul><p>When merging <code>on</code> categorical columns that differ in the ordering of their levels, the ordering of the left data frame takes precedence over the ordering of the right data frame.</p><p>See also: <a href="#DataFrames.innerjoin"><code>innerjoin</code></a>, <a href="#DataFrames.leftjoin"><code>leftjoin</code></a>, <a href="#DataFrames.rightjoin"><code>rightjoin</code></a>,           <a href="#DataFrames.outerjoin"><code>outerjoin</code></a>, <a href="#DataFrames.antijoin"><code>antijoin</code></a>, <a href="#DataFrames.crossjoin"><code>crossjoin</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; name = DataFrame(ID = [1, 2, 3], Name = [&quot;John Doe&quot;, &quot;Jane Doe&quot;, &quot;Joe Blogs&quot;])
3×2 DataFrame
│ Row │ ID    │ Name      │
│     │ Int64 │ String    │
├─────┼───────┼───────────┤
│ 1   │ 1     │ John Doe  │
│ 2   │ 2     │ Jane Doe  │
│ 3   │ 3     │ Joe Blogs │

julia&gt; job = DataFrame(ID = [1, 2, 4], Job = [&quot;Lawyer&quot;, &quot;Doctor&quot;, &quot;Farmer&quot;])
3×2 DataFrame
│ Row │ ID    │ Job    │
│     │ Int64 │ String │
├─────┼───────┼────────┤
│ 1   │ 1     │ Lawyer │
│ 2   │ 2     │ Doctor │
│ 3   │ 4     │ Farmer │

julia&gt; semijoin(name, job, on = :ID)
2×2 DataFrame
│ Row │ ID    │ Name     │
│     │ Int64 │ String   │
├─────┼───────┼──────────┤
│ 1   │ 1     │ John Doe │
│ 2   │ 2     │ Jane Doe │

julia&gt; job2 = DataFrame(identifier = [1, 2, 4], Job = [&quot;Lawyer&quot;, &quot;Doctor&quot;, &quot;Farmer&quot;])
3×2 DataFrame
│ Row │ identifier │ Job    │
│     │ Int64      │ String │
├─────┼────────────┼────────┤
│ 1   │ 1          │ Lawyer │
│ 2   │ 2          │ Doctor │
│ 3   │ 4          │ Farmer │

julia&gt; semijoin(name, job2, on = :ID =&gt; :identifier)
2×2 DataFrame
│ Row │ ID    │ Name     │
│     │ Int64 │ String   │
├─────┼───────┼──────────┤
│ 1   │ 1     │ John Doe │
│ 2   │ 2     │ Jane Doe │

julia&gt; semijoin(name, job2, on = [:ID =&gt; :identifier])
2×2 DataFrame
│ Row │ ID    │ Name     │
│     │ Int64 │ String   │
├─────┼───────┼──────────┤
│ 1   │ 1     │ John Doe │
│ 2   │ 2     │ Jane Doe │</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/6b0feaadd019c5ee36010ab956b5fee7b67681d5/src/abstractdataframe/join.jl#L952-L1044">source</a></section></article><h2 id="Grouping"><a class="docs-heading-anchor" href="#Grouping">Grouping</a><a id="Grouping-1"></a><a class="docs-heading-anchor-permalink" href="#Grouping" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Base.get" href="#Base.get"><code>Base.get</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">get(gd::GroupedDataFrame, key, default)</code></pre><p>Get a group based on the values of the grouping columns.</p><p><code>key</code> may be a <code>GroupKey</code>, <code>NamedTuple</code> or <code>Tuple</code> of grouping column values (in the same order as the <code>cols</code> argument to <code>groupby</code>). It may also be an <code>AbstractDict</code>, in which case the  order of the arguments does not matter. </p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; df = DataFrame(a = repeat([:foo, :bar, :baz], outer=[2]),
                      b = repeat([2, 1], outer=[3]),
                      c = 1:6);

julia&gt; gd = groupby(df, :a)
GroupedDataFrame with 3 groups based on key: a
First Group (2 rows): a = :foo
│ Row │ a      │ b     │ c     │
│     │ Symbol │ Int64 │ Int64 │
├─────┼────────┼───────┼───────┤
│ 1   │ foo    │ 2     │ 1     │
│ 2   │ foo    │ 1     │ 4     │
⋮
Last Group (2 rows): a = :baz
│ Row │ a      │ b     │ c     │
│     │ Symbol │ Int64 │ Int64 │
├─────┼────────┼───────┼───────┤
│ 1   │ baz    │ 2     │ 3     │
│ 2   │ baz    │ 1     │ 6     │

julia&gt; get(gd, (a=:bar,), nothing)
2×3 SubDataFrame
│ Row │ a      │ b     │ c     │
│     │ Symbol │ Int64 │ Int64 │
├─────┼────────┼───────┼───────┤
│ 1   │ bar    │ 1     │ 2     │
│ 2   │ bar    │ 2     │ 5     │

julia&gt; get(gd, (:baz,), nothing)
2×3 SubDataFrame
│ Row │ a      │ b     │ c     │
│     │ Symbol │ Int64 │ Int64 │
├─────┼────────┼───────┼───────┤
│ 1   │ baz    │ 2     │ 3     │
│ 2   │ baz    │ 1     │ 6     │

julia&gt; get(gd, (:qux,), nothing)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/6b0feaadd019c5ee36010ab956b5fee7b67681d5/src/groupeddataframe/groupeddataframe.jl#L608-L658">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFrames.groupby" href="#DataFrames.groupby"><code>DataFrames.groupby</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">groupby(d::AbstractDataFrame, cols; sort=false, skipmissing=false)</code></pre><p>Return a <code>GroupedDataFrame</code> representing a view of an <code>AbstractDataFrame</code> split into row groups.</p><p><strong>Arguments</strong></p><ul><li><code>df</code> : an <code>AbstractDataFrame</code> to split</li><li><code>cols</code> : data frame columns to group by. Can be any column selector (<code>Symbol</code>, string or integer; <code>:</code>, <code>All</code>, <code>Between</code>, <code>Not</code>, a regular expression, or a vector of <code>Symbol</code>s, strings or integers).</li><li><code>sort</code> : whether to sort groups according to the values of the grouping columns <code>cols</code>; if all <code>cols</code> are <code>CategoricalVector</code>s then groups are always sorted irrespective of the value of <code>sort</code></li><li><code>skipmissing</code> : whether to skip groups with <code>missing</code> values in one of the grouping columns <code>cols</code></li></ul><p><strong>Details</strong></p><p>An iterator over a <code>GroupedDataFrame</code> returns a <code>SubDataFrame</code> view for each grouping into <code>df</code>. Within each group, the order of rows in <code>df</code> is preserved.</p><p><code>cols</code> can be any valid data frame indexing expression. In particular if it is an empty vector then a single-group <code>GroupedDataFrame</code> is created.</p><p>A <code>GroupedDataFrame</code> also supports indexing by groups, <code>map</code> (which applies a function to each group) and <code>combine</code> (which applies a function to each group and combines the result into a data frame).</p><p><code>GroupedDataFrame</code> also supports the dictionary interface. The keys are <a href="../types/#DataFrames.GroupKey"><code>GroupKey</code></a> objects returned by <a href="#Base.keys"><code>keys(::GroupedDataFrame)</code></a>, which can also be used to get the values of the grouping columns for each group. <code>Tuples</code> and <code>NamedTuple</code>s containing the values of the grouping columns (in the same order as the <code>cols</code> argument) are also accepted as indices. Finally, an <code>AbstractDict</code> can be used to index into a grouped data frame where the keys are column names of the data frame. The order of the keys does not matter in this case.</p><p><strong>See also</strong></p><p><a href="#DataFrames.combine"><code>combine</code></a>, <a href="#DataFrames.select"><code>select</code></a>, <a href="#DataFrames.select!"><code>select!</code></a>, <a href="#DataFrames.transform"><code>transform</code></a>, <a href="#DataFrames.transform!"><code>transform!</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; df = DataFrame(a = repeat([1, 2, 3, 4], outer=[2]),
                      b = repeat([2, 1], outer=[4]),
                      c = 1:8);

julia&gt; gd = groupby(df, :a)
GroupedDataFrame with 4 groups based on key: a
First Group (2 rows): a = 1
│ Row │ a     │ b     │ c     │
│     │ Int64 │ Int64 │ Int64 │
├─────┼───────┼───────┼───────┤
│ 1   │ 1     │ 2     │ 1     │
│ 2   │ 1     │ 2     │ 5     │
⋮
Last Group (2 rows): a = 4
│ Row │ a     │ b     │ c     │
│     │ Int64 │ Int64 │ Int64 │
├─────┼───────┼───────┼───────┤
│ 1   │ 4     │ 1     │ 4     │
│ 2   │ 4     │ 1     │ 8     │

julia&gt; gd[1]
2×3 SubDataFrame
│ Row │ a     │ b     │ c     │
│     │ Int64 │ Int64 │ Int64 │
├─────┼───────┼───────┼───────┤
│ 1   │ 1     │ 2     │ 1     │
│ 2   │ 1     │ 2     │ 5     │

julia&gt; last(gd)
2×3 SubDataFrame
│ Row │ a     │ b     │ c     │
│     │ Int64 │ Int64 │ Int64 │
├─────┼───────┼───────┼───────┤
│ 1   │ 4     │ 1     │ 4     │
│ 2   │ 4     │ 1     │ 8     │

julia&gt; gd[(a=3,)]
2×3 SubDataFrame
│ Row │ a     │ b     │ c     │
│     │ Int64 │ Int64 │ Int64 │
├─────┼───────┼───────┼───────┤
│ 1   │ 3     │ 2     │ 3     │
│ 2   │ 3     │ 2     │ 7     │

julia&gt; gd[Dict(&quot;a&quot; =&gt; 3)]
2×3 SubDataFrame
│ Row │ a     │ b     │ c     │
│     │ Int64 │ Int64 │ Int64 │
├─────┼───────┼───────┼───────┤
│ 1   │ 3     │ 2     │ 3     │
│ 2   │ 3     │ 2     │ 7     │

julia&gt; gd[(3,)]
2×3 SubDataFrame
│ Row │ a     │ b     │ c     │
│     │ Int64 │ Int64 │ Int64 │
├─────┼───────┼───────┼───────┤
│ 1   │ 3     │ 2     │ 3     │
│ 2   │ 3     │ 2     │ 7     │

julia&gt; k = first(keys(gd))
GroupKey: (a = 3)

julia&gt; gd[k]
2×3 SubDataFrame
│ Row │ a     │ b     │ c     │
│     │ Int64 │ Int64 │ Int64 │
├─────┼───────┼───────┼───────┤
│ 1   │ 3     │ 2     │ 3     │
│ 2   │ 3     │ 2     │ 7     │

julia&gt; for g in gd
           println(g)
       end
2×3 SubDataFrame
│ Row │ a     │ b     │ c     │
│     │ Int64 │ Int64 │ Int64 │
├─────┼───────┼───────┼───────┤
│ 1   │ 1     │ 2     │ 1     │
│ 2   │ 1     │ 2     │ 5     │
2×3 SubDataFrame
│ Row │ a     │ b     │ c     │
│     │ Int64 │ Int64 │ Int64 │
├─────┼───────┼───────┼───────┤
│ 1   │ 2     │ 1     │ 2     │
│ 2   │ 2     │ 1     │ 6     │
2×3 SubDataFrame
│ Row │ a     │ b     │ c     │
│     │ Int64 │ Int64 │ Int64 │
├─────┼───────┼───────┼───────┤
│ 1   │ 3     │ 2     │ 3     │
│ 2   │ 3     │ 2     │ 7     │
2×3 SubDataFrame
│ Row │ a     │ b     │ c     │
│     │ Int64 │ Int64 │ Int64 │
├─────┼───────┼───────┼───────┤
│ 1   │ 4     │ 1     │ 4     │
│ 2   │ 4     │ 1     │ 8     │</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/6b0feaadd019c5ee36010ab956b5fee7b67681d5/src/groupeddataframe/splitapplycombine.jl#L5-L149">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFrames.groupcols" href="#DataFrames.groupcols"><code>DataFrames.groupcols</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">groupcols(gd::GroupedDataFrame)</code></pre><p>Return a vector of <code>Symbol</code> column names in <code>parent(gd)</code> used for grouping.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/6b0feaadd019c5ee36010ab956b5fee7b67681d5/src/groupeddataframe/groupeddataframe.jl#L142-L146">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFrames.groupindices" href="#DataFrames.groupindices"><code>DataFrames.groupindices</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">groupindices(gd::GroupedDataFrame)</code></pre><p>Return a vector of group indices for each row of <code>parent(gd)</code>.</p><p>Rows appearing in group <code>gd[i]</code> are attributed index <code>i</code>. Rows not present in any group are attributed <code>missing</code> (this can happen if <code>skipmissing=true</code> was passed when creating <code>gd</code>, or if <code>gd</code> is a subset from a larger <a href="../types/#DataFrames.GroupedDataFrame"><code>GroupedDataFrame</code></a>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/6b0feaadd019c5ee36010ab956b5fee7b67681d5/src/groupeddataframe/groupeddataframe.jl#L130-L139">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.keys" href="#Base.keys"><code>Base.keys</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">keys(gd::GroupedDataFrame)</code></pre><p>Get the set of keys for each group of the <code>GroupedDataFrame</code> <code>gd</code> as a <a href="../types/#DataFrames.GroupKeys"><code>GroupKeys</code></a> object. Each key is a <a href="../types/#DataFrames.GroupKey"><code>GroupKey</code></a>, which behaves like a <code>NamedTuple</code> holding the values of the grouping columns for a given group. Unlike the equivalent <code>Tuple</code>, <code>NamedTuple</code>, and <code>AbstractDict</code>, these keys can be used to index into <code>gd</code> efficiently. The ordering of the keys is identical to the ordering of the groups of <code>gd</code> under iteration and integer indexing.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; df = DataFrame(a = repeat([:foo, :bar, :baz], outer=[4]),
                      b = repeat([2, 1], outer=[6]),
                      c = 1:12);

julia&gt; gd = groupby(df, [:a, :b])
GroupedDataFrame with 6 groups based on keys: a, b
First Group (2 rows): a = :foo, b = 2
│ Row │ a      │ b     │ c     │
│     │ Symbol │ Int64 │ Int64 │
├─────┼────────┼───────┼───────┤
│ 1   │ foo    │ 2     │ 1     │
│ 2   │ foo    │ 2     │ 7     │
⋮
Last Group (2 rows): a = :baz, b = 1
│ Row │ a      │ b     │ c     │
│     │ Symbol │ Int64 │ Int64 │
├─────┼────────┼───────┼───────┤
│ 1   │ baz    │ 1     │ 6     │
│ 2   │ baz    │ 1     │ 12    │

julia&gt; keys(gd)
6-element DataFrames.GroupKeys{GroupedDataFrame{DataFrame}}:
 GroupKey: (a = :foo, b = 2)
 GroupKey: (a = :bar, b = 1)
 GroupKey: (a = :baz, b = 2)
 GroupKey: (a = :foo, b = 1)
 GroupKey: (a = :bar, b = 2)
 GroupKey: (a = :baz, b = 1)</code></pre><p><code>GroupKey</code> objects behave similarly to <code>NamedTuple</code>s:</p><pre><code class="language-julia-repl">julia&gt; k = keys(gd)[1]
GroupKey: (a = :foo, b = 2)

julia&gt; keys(k)
(:a, :b)

julia&gt; values(k)  # Same as Tuple(k)
(:foo, 2)

julia&gt; NamedTuple(k)
(a = :foo, b = 2)

julia&gt; k.a
:foo

julia&gt; k[:a]
:foo

julia&gt; k[1]
:foo</code></pre><p>Keys can be used as indices to retrieve the corresponding group from their <code>GroupedDataFrame</code>:</p><pre><code class="language-julia-repl">julia&gt; gd[k]
2×3 SubDataFrame
│ Row │ a      │ b     │ c     │
│     │ Symbol │ Int64 │ Int64 │
├─────┼────────┼───────┼───────┤
│ 1   │ foo    │ 2     │ 1     │
│ 2   │ foo    │ 2     │ 7     │

julia&gt; gd[keys(gd)[1]] == gd[1]
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/6b0feaadd019c5ee36010ab956b5fee7b67681d5/src/groupeddataframe/groupeddataframe.jl#L487-L570">source</a></section><section><div><pre><code class="language-none">keys(dfc::DataFrameColumns)</code></pre><p>Get a vector of column names of <code>dfc</code> as <code>Symbol</code>s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/6b0feaadd019c5ee36010ab956b5fee7b67681d5/src/abstractdataframe/iteration.jl#L208-L212">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.parent" href="#Base.parent"><code>Base.parent</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">parent(gd::GroupedDataFrame)</code></pre><p>Return the parent data frame of <code>gd</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/6b0feaadd019c5ee36010ab956b5fee7b67681d5/src/groupeddataframe/groupeddataframe.jl#L80-L84">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFrames.valuecols" href="#DataFrames.valuecols"><code>DataFrames.valuecols</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">valuecols(gd::GroupedDataFrame)</code></pre><p>Return a vector of <code>Symbol</code> column names in <code>parent(gd)</code> not used for grouping.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/6b0feaadd019c5ee36010ab956b5fee7b67681d5/src/groupeddataframe/groupeddataframe.jl#L153-L157">source</a></section></article><h2 id="Filtering-rows"><a class="docs-heading-anchor" href="#Filtering-rows">Filtering rows</a><a id="Filtering-rows-1"></a><a class="docs-heading-anchor-permalink" href="#Filtering-rows" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Base.delete!" href="#Base.delete!"><code>Base.delete!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">delete!(df::DataFrame, inds)</code></pre><p>Delete rows specified by <code>inds</code> from a <code>DataFrame</code> <code>df</code> in place and return it.</p><p>Internally <code>deleteat!</code> is called for all columns so <code>inds</code> must be: a vector of sorted and unique integers, a boolean vector, an integer, or <code>Not</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; d = DataFrame(a=1:3, b=4:6)
3×2 DataFrame
│ Row │ a     │ b     │
│     │ Int64 │ Int64 │
├─────┼───────┼───────┤
│ 1   │ 1     │ 4     │
│ 2   │ 2     │ 5     │
│ 3   │ 3     │ 6     │

julia&gt; delete!(d, 2)
2×2 DataFrame
│ Row │ a     │ b     │
│     │ Int64 │ Int64 │
├─────┼───────┼───────┤
│ 1   │ 1     │ 4     │
│ 2   │ 3     │ 6     │</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/6b0feaadd019c5ee36010ab956b5fee7b67681d5/src/dataframe/dataframe.jl#L793-L821">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.empty" href="#Base.empty"><code>Base.empty</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">empty(df::AbstractDataFrame)</code></pre><p>Create a new <code>DataFrame</code> with the same column names and column element types as <code>df</code> but with zero rows.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/6b0feaadd019c5ee36010ab956b5fee7b67681d5/src/abstractdataframe/abstractdataframe.jl#L375-L380">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.empty!" href="#Base.empty!"><code>Base.empty!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">empty!(df::DataFrame)</code></pre><p>Remove all rows from <code>df</code>, making each of its columns empty.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/6b0feaadd019c5ee36010ab956b5fee7b67681d5/src/dataframe/dataframe.jl#L843-L847">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.filter" href="#Base.filter"><code>Base.filter</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">filter(fun, df::AbstractDataFrame)
filter(cols =&gt; fun, df::AbstractDataFrame)</code></pre><p>Return a copy of data frame <code>df</code> containing only rows for which <code>fun</code> returns <code>true</code>.</p><p>If <code>cols</code> is not specified then the predicate <code>fun</code> is passed <code>DataFrameRow</code>s.</p><p>If <code>cols</code> is specified then the predicate <code>fun</code> is passed elements of the corresponding columns as separate positional arguments, unless <code>cols</code> is an <code>AsTable</code> selector, in which case a <code>NamedTuple</code> of these arguments is passed. <code>cols</code> can be any column selector (<code>Symbol</code>, string or integer; <code>:</code>, <code>All</code>, <code>Between</code>, <code>Not</code>, a regular expression, or a vector of <code>Symbol</code>s, strings or integers), and column duplicates are allowed if a vector of <code>Symbol</code>s, strings, or integers is passed.</p><p>Passing <code>cols</code> leads to a more efficient execution of the operation for large data frames.</p><p>See also: <a href="#Base.filter!"><code>filter!</code></a></p><p><strong>Examples</strong></p><pre><code class="language-none">julia&gt; df = DataFrame(x = [3, 1, 2, 1], y = [&quot;b&quot;, &quot;c&quot;, &quot;a&quot;, &quot;b&quot;])
4×2 DataFrame
│ Row │ x     │ y      │
│     │ Int64 │ String │
├─────┼───────┼────────┤
│ 1   │ 3     │ b      │
│ 2   │ 1     │ c      │
│ 3   │ 2     │ a      │
│ 4   │ 1     │ b      │

julia&gt; filter(row -&gt; row.x &gt; 1, df)
2×2 DataFrame
│ Row │ x     │ y      │
│     │ Int64 │ String │
├─────┼───────┼────────┤
│ 1   │ 3     │ b      │
│ 2   │ 2     │ a      │

julia&gt; filter(:x =&gt; x -&gt; x &gt; 1, df)
2×2 DataFrame
│ Row │ x     │ y      │
│     │ Int64 │ String │
├─────┼───────┼────────┤
│ 1   │ 3     │ b      │
│ 2   │ 2     │ a      │

julia&gt; filter([:x, :y] =&gt; (x, y) -&gt; x == 1 || y == &quot;b&quot;, df)
3×2 DataFrame
│ Row │ x     │ y      │
│     │ Int64 │ String │
├─────┼───────┼────────┤
│ 1   │ 3     │ b      │
│ 2   │ 1     │ c      │
│ 3   │ 1     │ b      │

julia&gt; filter(AsTable(:) =&gt; nt -&gt; nt.x == 1 || nt.y == &quot;b&quot;, df)
3×2 DataFrame
│ Row │ x     │ y      │
│     │ Int64 │ String │
├─────┼───────┼────────┤
│ 1   │ 3     │ b      │
│ 2   │ 1     │ c      │
│ 3   │ 1     │ b      │</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/6b0feaadd019c5ee36010ab956b5fee7b67681d5/src/abstractdataframe/abstractdataframe.jl#L887-L953">source</a></section><section><div><pre><code class="language-none">filter(fun, gdf::GroupedDataFrame)
filter(cols =&gt; fun, gdf::GroupedDataFrame)</code></pre><p>Return a new <code>GroupedDataFrame</code> containing only groups for which <code>fun</code> returns <code>true</code>.</p><p>If <code>cols</code> is not specified then the predicate <code>fun</code> is called with a <code>SubDataFrame</code> for each group.</p><p>If <code>cols</code> is specified then the predicate <code>fun</code> is called for each group with views of the corresponding columns as separate positional arguments, unless <code>cols</code> is an <code>AsTable</code> selector, in which case a <code>NamedTuple</code> of these arguments is passed. <code>cols</code> can be any column selector (<code>Symbol</code>, string or integer; <code>:</code>, <code>All</code>, <code>Between</code>, <code>Not</code>, a regular expression, or a vector of <code>Symbol</code>s, strings or integers), and column duplicates are allowed if a vector of <code>Symbol</code>s, strings, or integers is passed.</p><p><strong>Examples</strong></p><pre><code class="language-none">julia&gt; df = DataFrame(g=[1, 2], x=[&#39;a&#39;, &#39;b&#39;]);

julia&gt; gd = groupby(df, :g)
GroupedDataFrame with 2 groups based on key: g
First Group (1 row): g = 1
│ Row │ g     │ x    │
│     │ Int64 │ Char │
├─────┼───────┼──────┤
│ 1   │ 1     │ &#39;a&#39;  │
⋮
Last Group (1 row): g = 2
│ Row │ g     │ x    │
│     │ Int64 │ Char │
├─────┼───────┼──────┤
│ 1   │ 2     │ &#39;b&#39;  │

julia&gt; filter(x -&gt; x.x[1] == &#39;a&#39;, gd)
GroupedDataFrame with 1 group based on key: g
First Group (1 row): g = 1
│ Row │ g     │ x    │
│     │ Int64 │ Char │
├─────┼───────┼──────┤
│ 1   │ 1     │ &#39;a&#39;  │

julia&gt; filter(:x =&gt; x -&gt; x[1] == &#39;a&#39;, gd)
GroupedDataFrame with 1 group based on key: g
First Group (1 row): g = 1
│ Row │ g     │ x    │
│     │ Int64 │ Char │
├─────┼───────┼──────┤
│ 1   │ 1     │ &#39;a&#39;  │
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/6b0feaadd019c5ee36010ab956b5fee7b67681d5/src/groupeddataframe/groupeddataframe.jl#L667-L719">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.filter!" href="#Base.filter!"><code>Base.filter!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">filter!(fun, df::AbstractDataFrame)
filter!(cols =&gt; fun, df::AbstractDataFrame)</code></pre><p>Remove rows from data frame <code>df</code> for which <code>fun</code> returns <code>false</code>.</p><p>If <code>cols</code> is not specified then the predicate <code>fun</code> is passed <code>DataFrameRow</code>s.</p><p>If <code>cols</code> is specified then the predicate <code>fun</code> is passed elements of the corresponding columns as separate positional arguments, unless <code>cols</code> is an <code>AsTable</code> selector, in which case a <code>NamedTuple</code> of these arguments is passed. <code>cols</code> can be any column selector (<code>Symbol</code>, string or integer; <code>:</code>, <code>All</code>, <code>Between</code>, <code>Not</code>, a regular expression, or a vector of <code>Symbol</code>s, strings or integers), and column duplicates are allowed if a vector of <code>Symbol</code>s, strings, or integers is passed.</p><p>Passing <code>cols</code> leads to a more efficient execution of the operation for large data frames.</p><p>See also: <a href="#Base.filter"><code>filter</code></a></p><p><strong>Examples</strong></p><pre><code class="language-none">julia&gt; df = DataFrame(x = [3, 1, 2, 1], y = [&quot;b&quot;, &quot;c&quot;, &quot;a&quot;, &quot;b&quot;])
4×2 DataFrame
│ Row │ x     │ y      │
│     │ Int64 │ String │
├─────┼───────┼────────┤
│ 1   │ 3     │ b      │
│ 2   │ 1     │ c      │
│ 3   │ 2     │ a      │
│ 4   │ 1     │ b      │

julia&gt; filter!(row -&gt; row.x &gt; 1, df);

julia&gt; df
2×2 DataFrame
│ Row │ x     │ y      │
│     │ Int64 │ String │
├─────┼───────┼────────┤
│ 1   │ 3     │ b      │
│ 2   │ 2     │ a      │

julia&gt; filter!(:x =&gt; x -&gt; x == 3, df);

julia&gt; df
1×2 DataFrame
│ Row │ x     │ y      │
│     │ Int64 │ String │
├─────┼───────┼────────┤
│ 1   │ 3     │ b      │

julia&gt; df = DataFrame(x = [3, 1, 2, 1], y = [&quot;b&quot;, &quot;c&quot;, &quot;a&quot;, &quot;b&quot;]);

julia&gt; filter!([:x, :y] =&gt; (x, y) -&gt; x == 1 || y == &quot;b&quot;, df);

julia&gt; df
3×2 DataFrame
│ Row │ x     │ y      │
│     │ Int64 │ String │
├─────┼───────┼────────┤
│ 1   │ 3     │ b      │
│ 2   │ 1     │ c      │
│ 3   │ 1     │ b      │

julia&gt; df = DataFrame(x = [3, 1, 2, 1], y = [&quot;b&quot;, &quot;c&quot;, &quot;a&quot;, &quot;b&quot;]);

julia&gt; filter!(AsTable(:) =&gt; nt -&gt; nt.x == 1 || nt.y == &quot;b&quot;, df)
3×2 DataFrame
│ Row │ x     │ y      │
│     │ Int64 │ String │
├─────┼───────┼────────┤
│ 1   │ 3     │ b      │
│ 2   │ 1     │ c      │
│ 3   │ 1     │ b      │</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/6b0feaadd019c5ee36010ab956b5fee7b67681d5/src/abstractdataframe/abstractdataframe.jl#L987-L1061">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.first" href="#Base.first"><code>Base.first</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">first(df::AbstractDataFrame)</code></pre><p>Get the first row of <code>df</code> as a <code>DataFrameRow</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/6b0feaadd019c5ee36010ab956b5fee7b67681d5/src/abstractdataframe/abstractdataframe.jl#L433-L437">source</a></section><section><div><pre><code class="language-none">first(df::AbstractDataFrame, n::Integer)</code></pre><p>Get a data frame with the <code>n</code> first rows of <code>df</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/6b0feaadd019c5ee36010ab956b5fee7b67681d5/src/abstractdataframe/abstractdataframe.jl#L440-L444">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.last" href="#Base.last"><code>Base.last</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">last(df::AbstractDataFrame)</code></pre><p>Get the last row of <code>df</code> as a <code>DataFrameRow</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/6b0feaadd019c5ee36010ab956b5fee7b67681d5/src/abstractdataframe/abstractdataframe.jl#L447-L451">source</a></section><section><div><pre><code class="language-none">last(df::AbstractDataFrame, n::Integer)</code></pre><p>Get a data frame with the <code>n</code> last rows of <code>df</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/6b0feaadd019c5ee36010ab956b5fee7b67681d5/src/abstractdataframe/abstractdataframe.jl#L454-L458">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFrames.nonunique" href="#DataFrames.nonunique"><code>DataFrames.nonunique</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">nonunique(df::AbstractDataFrame)
nonunique(df::AbstractDataFrame, cols)</code></pre><p>Return a <code>Vector{Bool}</code> in which <code>true</code> entries indicate duplicate rows. A row is a duplicate if there exists a prior row with all columns containing equal values (according to <code>isequal</code>).</p><p>See also <a href="#Base.unique"><code>unique</code></a> and <a href="#Base.unique!"><code>unique!</code></a>.</p><p><strong>Arguments</strong></p><ul><li><code>df</code> : <code>AbstractDataFrame</code></li><li><code>cols</code> : a selector specifying the column(s) to compare. Can be any column selector (<code>Symbol</code>, string or integer; <code>:</code>, <code>All</code>, <code>Between</code>, <code>Not</code>, a regular expression, or a vector of <code>Symbol</code>s, strings or integers).</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia">df = DataFrame(i = 1:10, x = rand(10), y = rand([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;], 10))
df = vcat(df, df)
nonunique(df)
nonunique(df, 1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/6b0feaadd019c5ee36010ab956b5fee7b67681d5/src/abstractdataframe/abstractdataframe.jl#L1129-L1151">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.unique" href="#Base.unique"><code>Base.unique</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">unique(df::AbstractDataFrame)
unique(df::AbstractDataFrame, cols)
unique!(df::AbstractDataFrame)
unique!(df::AbstractDataFrame, cols)</code></pre><p>Delete duplicate rows of data frame <code>df</code>, keeping only the first occurrence of unique rows. When <code>cols</code> is specified, the returned <code>DataFrame</code> contains complete rows, retaining in each case the first instance for which <code>df[cols]</code> is unique. <code>cols</code> can be any column selector (<code>Symbol</code>, string or integer; <code>:</code>, <code>All</code>, <code>Between</code>, <code>Not</code>, a regular expression, or a vector of <code>Symbol</code>s, strings or integers).</p><p>When <code>unique</code> is called a new data frame is returned; <code>unique!</code> updates <code>df</code> in-place.</p><p>See also <a href="#DataFrames.nonunique"><code>nonunique</code></a>.</p><p><strong>Arguments</strong></p><ul><li><code>df</code> : the AbstractDataFrame</li><li><code>cols</code> :  column indicator (Symbol, Int, Vector{Symbol}, Regex, etc.)</li></ul><p>specifying the column(s) to compare.</p><p><strong>Examples</strong></p><pre><code class="language-julia">df = DataFrame(i = 1:10, x = rand(10), y = rand([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;], 10))
df = vcat(df, df)
unique(df)   # doesn&#39;t modify df
unique(df, 1)
unique!(df)  # modifies df</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/6b0feaadd019c5ee36010ab956b5fee7b67681d5/src/abstractdataframe/abstractdataframe.jl#L1180-L1208">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.unique!" href="#Base.unique!"><code>Base.unique!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">unique(df::AbstractDataFrame)
unique(df::AbstractDataFrame, cols)
unique!(df::AbstractDataFrame)
unique!(df::AbstractDataFrame, cols)</code></pre><p>Delete duplicate rows of data frame <code>df</code>, keeping only the first occurrence of unique rows. When <code>cols</code> is specified, the returned <code>DataFrame</code> contains complete rows, retaining in each case the first instance for which <code>df[cols]</code> is unique. <code>cols</code> can be any column selector (<code>Symbol</code>, string or integer; <code>:</code>, <code>All</code>, <code>Between</code>, <code>Not</code>, a regular expression, or a vector of <code>Symbol</code>s, strings or integers).</p><p>When <code>unique</code> is called a new data frame is returned; <code>unique!</code> updates <code>df</code> in-place.</p><p>See also <a href="#DataFrames.nonunique"><code>nonunique</code></a>.</p><p><strong>Arguments</strong></p><ul><li><code>df</code> : the AbstractDataFrame</li><li><code>cols</code> :  column indicator (Symbol, Int, Vector{Symbol}, Regex, etc.)</li></ul><p>specifying the column(s) to compare.</p><p><strong>Examples</strong></p><pre><code class="language-julia">df = DataFrame(i = 1:10, x = rand(10), y = rand([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;], 10))
df = vcat(df, df)
unique(df)   # doesn&#39;t modify df
unique(df, 1)
unique!(df)  # modifies df</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/6b0feaadd019c5ee36010ab956b5fee7b67681d5/src/abstractdataframe/abstractdataframe.jl#L1180-L1208">source</a></section></article><h2 id="Working-with-missing-values"><a class="docs-heading-anchor" href="#Working-with-missing-values">Working with missing values</a><a id="Working-with-missing-values-1"></a><a class="docs-heading-anchor-permalink" href="#Working-with-missing-values" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Missings.allowmissing" href="#Missings.allowmissing"><code>Missings.allowmissing</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">allowmissing(df::AbstractDataFrame, cols=:)</code></pre><p>Return a copy of data frame <code>df</code> with columns <code>cols</code> converted to element type <code>Union{T, Missing}</code> from <code>T</code> to allow support for missing values.</p><p><code>cols</code> can be any column selector (<code>Symbol</code>, string or integer; <code>:</code>, <code>All</code>, <code>Between</code>, <code>Not</code>, a regular expression, or a vector of <code>Symbol</code>s, strings or integers).</p><p>If <code>cols</code> is omitted all columns in the data frame are converted.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; df = DataFrame(a=[1,2])
2×1 DataFrame
│ Row │ a     │
│     │ Int64 │
├─────┼───────┤
│ 1   │ 1     │
│ 2   │ 2     │

julia&gt; allowmissing(df)
2×1 DataFrame
│ Row │ a      │
│     │ Int64? │
├─────┼────────┤
│ 1   │ 1      │
│ 2   │ 2      │</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/6b0feaadd019c5ee36010ab956b5fee7b67681d5/src/abstractdataframe/abstractdataframe.jl#L1663-L1692">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFrames.allowmissing!" href="#DataFrames.allowmissing!"><code>DataFrames.allowmissing!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">allowmissing!(df::DataFrame, cols=:)</code></pre><p>Convert columns <code>cols</code> of data frame <code>df</code> from element type <code>T</code> to <code>Union{T, Missing}</code> to support missing values.</p><p><code>cols</code> can be any column selector (<code>Symbol</code>, string or integer; <code>:</code>, <code>All</code>, <code>Between</code>, <code>Not</code>, a regular expression, or a vector of <code>Symbol</code>s, strings or integers).</p><p>If <code>cols</code> is omitted all columns in the data frame are converted.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/6b0feaadd019c5ee36010ab956b5fee7b67681d5/src/dataframe/dataframe.jl#L910-L919">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFrames.completecases" href="#DataFrames.completecases"><code>DataFrames.completecases</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">completecases(df::AbstractDataFrame, cols=:)</code></pre><p>Return a Boolean vector with <code>true</code> entries indicating rows without missing values (complete cases) in data frame <code>df</code>.</p><p>If <code>cols</code> is provided, only missing values in the corresponding columns areconsidered. <code>cols</code> can be any column selector (<code>Symbol</code>, string or integer; <code>:</code>, <code>All</code>, <code>Between</code>, <code>Not</code>, a regular expression, or a vector of <code>Symbol</code>s, strings or integers).</p><p>See also: <a href="#DataFrames.dropmissing"><code>dropmissing</code></a> and <a href="#DataFrames.dropmissing!"><code>dropmissing!</code></a>. Use <code>findall(completecases(df))</code> to get the indices of the rows.</p><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; df = DataFrame(i = 1:5,
                      x = [missing, 4, missing, 2, 1],
                      y = [missing, missing, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;])
5×3 DataFrame
│ Row │ i     │ x       │ y       │
│     │ Int64 │ Int64?  │ String? │
├─────┼───────┼─────────┼─────────┤
│ 1   │ 1     │ missing │ missing │
│ 2   │ 2     │ 4       │ missing │
│ 3   │ 3     │ missing │ c       │
│ 4   │ 4     │ 2       │ d       │
│ 5   │ 5     │ 1       │ e       │

julia&gt; completecases(df)
5-element BitArray{1}:
 false
 false
 false
  true
  true

julia&gt; completecases(df, :x)
5-element BitArray{1}:
 false
  true
 false
  true
  true

julia&gt; completecases(df, [:x, :y])
5-element BitArray{1}:
 false
 false
 false
  true
  true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/6b0feaadd019c5ee36010ab956b5fee7b67681d5/src/abstractdataframe/abstractdataframe.jl#L676-L728">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Missings.disallowmissing" href="#Missings.disallowmissing"><code>Missings.disallowmissing</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">disallowmissing(df::AbstractDataFrame, cols=:; error::Bool=true)</code></pre><p>Return a copy of data frame <code>df</code> with columns <code>cols</code> converted from element type <code>Union{T, Missing}</code> to <code>T</code> to drop support for missing values.</p><p><code>cols</code> can be any column selector (<code>Symbol</code>, string or integer; <code>:</code>, <code>All</code>, <code>Between</code>, <code>Not</code>, a regular expression, or a vector of <code>Symbol</code>s, strings or integers).</p><p>If <code>cols</code> is omitted all columns in the data frame are converted.</p><p>If <code>error=false</code> then columns containing a <code>missing</code> value will be skipped instead of throwing an error.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; df = DataFrame(a=Union{Int,Missing}[1,2])
2×1 DataFrame
│ Row │ a      │
│     │ Int64? │
├─────┼────────┤
│ 1   │ 1      │
│ 2   │ 2      │

julia&gt; disallowmissing(df)
2×1 DataFrame
│ Row │ a     │
│     │ Int64 │
├─────┼───────┤
│ 1   │ 1     │
│ 2   │ 2     │

julia&gt; df = DataFrame(a=[1,missing])
2×2 DataFrame
│ Row │ a       │ b      │
│     │ Int64?  │ Int64? │
├─────┼─────────┼────────┤
│ 1   │ 1       │ 1      │
│ 2   │ missing │ 2      │

julia&gt; disallowmissing(df, error=false)
2×2 DataFrame
│ Row │ a       │ b     │
│     │ Int64?  │ Int64 │
├─────┼─────────┼───────┤
│ 1   │ 1       │ 1     │
│ 2   │ missing │ 2     │</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/6b0feaadd019c5ee36010ab956b5fee7b67681d5/src/abstractdataframe/abstractdataframe.jl#L1593-L1641">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFrames.disallowmissing!" href="#DataFrames.disallowmissing!"><code>DataFrames.disallowmissing!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">disallowmissing!(df::DataFrame, cols=:; error::Bool=true)</code></pre><p>Convert columns <code>cols</code> of data frame <code>df</code> from element type <code>Union{T, Missing}</code> to <code>T</code> to drop support for missing values.</p><p><code>cols</code> can be any column selector (<code>Symbol</code>, string or integer; <code>:</code>, <code>All</code>, <code>Between</code>, <code>Not</code>, a regular expression, or a vector of <code>Symbol</code>s, strings or integers).</p><p>If <code>cols</code> is omitted all columns in the data frame are converted.</p><p>If <code>error=false</code> then columns containing a <code>missing</code> value will be skipped instead of throwing an error.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/6b0feaadd019c5ee36010ab956b5fee7b67681d5/src/dataframe/dataframe.jl#L948-L960">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFrames.dropmissing" href="#DataFrames.dropmissing"><code>DataFrames.dropmissing</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">dropmissing(df::AbstractDataFrame, cols=:; disallowmissing::Bool=true)</code></pre><p>Return a copy of data frame <code>df</code> excluding rows with missing values.</p><p>If <code>cols</code> is provided, only missing values in the corresponding columns are considered. <code>cols</code> can be any column selector (<code>Symbol</code>, string or integer; <code>:</code>, <code>All</code>, <code>Between</code>, <code>Not</code>, a regular expression, or a vector of <code>Symbol</code>s, strings or integers).</p><p>If <code>disallowmissing</code> is <code>true</code> (the default) then columns specified in <code>cols</code> will be converted so as not to allow for missing values using <a href="#DataFrames.disallowmissing!"><code>disallowmissing!</code></a>.</p><p>See also: <a href="#DataFrames.completecases"><code>completecases</code></a> and <a href="#DataFrames.dropmissing!"><code>dropmissing!</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; df = DataFrame(i = 1:5,
                      x = [missing, 4, missing, 2, 1],
                      y = [missing, missing, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;])
5×3 DataFrame
│ Row │ i     │ x       │ y       │
│     │ Int64 │ Int64?  │ String? │
├─────┼───────┼─────────┼─────────┤
│ 1   │ 1     │ missing │ missing │
│ 2   │ 2     │ 4       │ missing │
│ 3   │ 3     │ missing │ c       │
│ 4   │ 4     │ 2       │ d       │
│ 5   │ 5     │ 1       │ e       │

julia&gt; dropmissing(df)
2×3 DataFrame
│ Row │ i     │ x     │ y      │
│     │ Int64 │ Int64 │ String │
├─────┼───────┼───────┼────────┤
│ 1   │ 4     │ 2     │ d      │
│ 2   │ 5     │ 1     │ e      │

julia&gt; dropmissing(df, disallowmissing=false)
2×3 DataFrame
│ Row │ i     │ x      │ y       │
│     │ Int64 │ Int64? │ String? │
├─────┼───────┼────────┼─────────┤
│ 1   │ 4     │ 2      │ d       │
│ 2   │ 5     │ 1      │ e       │

julia&gt; dropmissing(df, :x)
3×3 DataFrame
│ Row │ i     │ x     │ y       │
│     │ Int64 │ Int64 │ String? │
├─────┼───────┼───────┼─────────┤
│ 1   │ 2     │ 4     │ missing │
│ 2   │ 4     │ 2     │ d       │
│ 3   │ 5     │ 1     │ e       │

julia&gt; dropmissing(df, [:x, :y])
2×3 DataFrame
│ Row │ i     │ x     │ y      │
│     │ Int64 │ Int64 │ String │
├─────┼───────┼───────┼────────┤
│ 1   │ 4     │ 2     │ d      │
│ 2   │ 5     │ 1     │ e      │</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/6b0feaadd019c5ee36010ab956b5fee7b67681d5/src/abstractdataframe/abstractdataframe.jl#L747-L809">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFrames.dropmissing!" href="#DataFrames.dropmissing!"><code>DataFrames.dropmissing!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">dropmissing!(df::AbstractDataFrame, cols=:; disallowmissing::Bool=true)</code></pre><p>Remove rows with missing values from data frame <code>df</code> and return it.</p><p>If <code>cols</code> is provided, only missing values in the corresponding columns are considered. <code>cols</code> can be any column selector (<code>Symbol</code>, string or integer; <code>:</code>, <code>All</code>, <code>Between</code>, <code>Not</code>, a regular expression, or a vector of <code>Symbol</code>s, strings or integers).</p><p>If <code>disallowmissing</code> is <code>true</code> (the default) then the <code>cols</code> columns will get converted using <a href="#DataFrames.disallowmissing!"><code>disallowmissing!</code></a>.</p><p>See also: <a href="#DataFrames.dropmissing"><code>dropmissing</code></a> and <a href="#DataFrames.completecases"><code>completecases</code></a>.</p><pre><code class="language-julia-repl">julia&gt; df = DataFrame(i = 1:5,
                      x = [missing, 4, missing, 2, 1],
                      y = [missing, missing, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;])
5×3 DataFrame
│ Row │ i     │ x       │ y       │
│     │ Int64 │ Int64?  │ String? │
├─────┼───────┼─────────┼─────────┤
│ 1   │ 1     │ missing │ missing │
│ 2   │ 2     │ 4       │ missing │
│ 3   │ 3     │ missing │ c       │
│ 4   │ 4     │ 2       │ d       │
│ 5   │ 5     │ 1       │ e       │

julia&gt; dropmissing!(copy(df))
2×3 DataFrame
│ Row │ i     │ x     │ y      │
│     │ Int64 │ Int64 │ String │
├─────┼───────┼───────┼────────┤
│ 1   │ 4     │ 2     │ d      │
│ 2   │ 5     │ 1     │ e      │

julia&gt; dropmissing!(copy(df), disallowmissing=false)
2×3 DataFrame
│ Row │ i     │ x      │ y       │
│     │ Int64 │ Int64? │ String? │
├─────┼───────┼────────┼─────────┤
│ 1   │ 4     │ 2      │ d       │
│ 2   │ 5     │ 1      │ e       │

julia&gt; dropmissing!(copy(df), :x)
3×3 DataFrame
│ Row │ i     │ x     │ y       │
│     │ Int64 │ Int64 │ String? │
├─────┼───────┼───────┼─────────┤
│ 1   │ 2     │ 4     │ missing │
│ 2   │ 4     │ 2     │ d       │
│ 3   │ 5     │ 1     │ e       │

julia&gt; dropmissing!(df3, [:x, :y])
2×3 DataFrame
│ Row │ i     │ x     │ y      │
│     │ Int64 │ Int64 │ String │
├─────┼───────┼───────┼────────┤
│ 1   │ 4     │ 2     │ d      │
│ 2   │ 5     │ 1     │ e      │</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/6b0feaadd019c5ee36010ab956b5fee7b67681d5/src/abstractdataframe/abstractdataframe.jl#L818-L878">source</a></section></article><h2 id="Iteration"><a class="docs-heading-anchor" href="#Iteration">Iteration</a><a id="Iteration-1"></a><a class="docs-heading-anchor-permalink" href="#Iteration" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Compat.eachcol" href="#Compat.eachcol"><code>Compat.eachcol</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">eachcol(df::AbstractDataFrame)</code></pre><p>Return a <code>DataFrameColumns</code> object that is a vector-like that allows iterating an <code>AbstractDataFrame</code> column by column.</p><p>Indexing into <code>DataFrameColumns</code> objects using integer, <code>Symbol</code> or string returns the corresponding column (without copying). Indexing into <code>DataFrameColumns</code> objects using a multiple column selector returns a subsetted <code>DataFrameColumns</code> object with a new parent containing only the selected columns (without copying).</p><p><code>DataFrameColumns</code> supports most of the <code>AbstractVector</code> API. The key differences are that it is read-only and that the <code>keys</code> function returns a vector of <code>Symbol</code>s (and not integers as for normal vectors).</p><p>In particular <code>findnext</code>, <code>findprev</code>, <code>findfirst</code>, <code>findlast</code>, and <code>findall</code> functions are supported, and in <code>findnext</code> and <code>findprev</code> functions it is allowed to pass an integer, string, or <code>Symbol</code> as a reference index.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; df = DataFrame(x=1:4, y=11:14)
4×2 DataFrame
│ Row │ x     │ y     │
│     │ Int64 │ Int64 │
├─────┼───────┼───────┤
│ 1   │ 1     │ 11    │
│ 2   │ 2     │ 12    │
│ 3   │ 3     │ 13    │
│ 4   │ 4     │ 14    │

julia&gt; collect(eachcol(df))
2-element Array{AbstractArray{T,1} where T,1}:
 [1, 2, 3, 4]
 [11, 12, 13, 14]

julia&gt; map(eachcol(df)) do col
           maximum(col) - minimum(col)
       end
2-element Array{Int64,1}:
 3
 3

julia&gt; sum.(eachcol(df))
2-element Array{Int64,1}:
 10
 50</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/6b0feaadd019c5ee36010ab956b5fee7b67681d5/src/abstractdataframe/iteration.jl#L131-L168">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Compat.eachrow" href="#Compat.eachrow"><code>Compat.eachrow</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">eachrow(df::AbstractDataFrame)</code></pre><p>Return a <code>DataFrameRows</code> that iterates a data frame row by row, with each row represented as a <code>DataFrameRow</code>.</p><p>Because <code>DataFrameRow</code>s have an <code>eltype</code> of <code>Any</code>, use <code>copy(dfr::DataFrameRow)</code> to obtain a named tuple, which supports iteration and property access like a <code>DataFrameRow</code>, but also passes information on the <code>eltypes</code> of the columns of <code>df</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; df = DataFrame(x=1:4, y=11:14)
4×2 DataFrame
│ Row │ x     │ y     │
│     │ Int64 │ Int64 │
├─────┼───────┼───────┤
│ 1   │ 1     │ 11    │
│ 2   │ 2     │ 12    │
│ 3   │ 3     │ 13    │
│ 4   │ 4     │ 14    │

julia&gt; eachrow(df)
4-element DataFrameRows:
 DataFrameRow (row 1)
x  1
y  11
 DataFrameRow (row 2)
x  2
y  12
 DataFrameRow (row 3)
x  3
y  13
 DataFrameRow (row 4)
x  4
y  14

julia&gt; copy.(eachrow(df))
4-element Array{NamedTuple{(:x, :y),Tuple{Int64,Int64}},1}:
 (x = 1, y = 11)
 (x = 2, y = 12)
 (x = 3, y = 13)
 (x = 4, y = 14)

julia&gt; eachrow(view(df, [4,3], [2,1]))
2-element DataFrameRows:
 DataFrameRow (row 4)
y  14
x  4
 DataFrameRow (row 3)
y  13
x  3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/6b0feaadd019c5ee36010ab956b5fee7b67681d5/src/abstractdataframe/iteration.jl#L27-L80">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.values" href="#Base.values"><code>Base.values</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">values(dfc::DataFrameColumns)</code></pre><p>Get a vector of columns from <code>dfc</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/6b0feaadd019c5ee36010ab956b5fee7b67681d5/src/abstractdataframe/iteration.jl#L215-L219">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.pairs" href="#Base.pairs"><code>Base.pairs</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">pairs(dfc::DataFrameColumns)</code></pre><p>Return an iterator of pairs associating the name of each column of <code>dfc</code> with the corresponding column vector, i.e. <code>name =&gt; col</code> where <code>name</code> is the column name of the column <code>col</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/6b0feaadd019c5ee36010ab956b5fee7b67681d5/src/abstractdataframe/iteration.jl#L222-L228">source</a></section></article><h2 id="Equality"><a class="docs-heading-anchor" href="#Equality">Equality</a><a id="Equality-1"></a><a class="docs-heading-anchor-permalink" href="#Equality" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Base.isapprox" href="#Base.isapprox"><code>Base.isapprox</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">isapprox(df1::AbstractDataFrame, df2::AbstractDataFrame;
         rtol::Real=atol&gt;0 ? 0 : √eps, atol::Real=0,
         nans::Bool=false, norm::Function=norm)</code></pre><p>Inexact equality comparison. <code>df1</code> and <code>df2</code> must have the same size and column names. Return  <code>true</code> if <code>isapprox</code> with given keyword arguments applied to all pairs of columns stored in <code>df1</code> and <code>df2</code> returns <code>true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/6b0feaadd019c5ee36010ab956b5fee7b67681d5/src/abstractdataframe/abstractdataframe.jl#L411-L419">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../types/">« Types</a><a class="docs-footer-nextpage" href="../indexing/">Indexing »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Monday 31 August 2020 18:20">Monday 31 August 2020</span>. Using Julia version 1.0.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
