<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Functions · DataFrames.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../../"><img class="logo" src="../../assets/logo.png" alt="DataFrames.jl logo"/></a><h1>DataFrames.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../">Introduction</a></li><li><span class="toctext">User Guide</span><ul><li><a class="toctext" href="../../man/getting_started/">Getting Started</a></li><li><a class="toctext" href="../../man/joins/">Joins</a></li><li><a class="toctext" href="../../man/split_apply_combine/">Split-apply-combine</a></li><li><a class="toctext" href="../../man/reshaping_and_pivoting/">Reshaping</a></li><li><a class="toctext" href="../../man/sorting/">Sorting</a></li><li><a class="toctext" href="../../man/categorical/">Categorical Data</a></li><li><a class="toctext" href="../../man/missing/">Missing Data</a></li><li><a class="toctext" href="../../man/querying_frameworks/">Data manipulation frameworks</a></li></ul></li><li><span class="toctext">API</span><ul><li><a class="toctext" href="../types/">Types</a></li><li class="current"><a class="toctext" href>Functions</a><ul class="internal"><li><a class="toctext" href="#Grouping,-Joining,-and-Split-Apply-Combine-1">Grouping, Joining, and Split-Apply-Combine</a></li><li><a class="toctext" href="#Basics-1">Basics</a></li></ul></li><li><a class="toctext" href="../indexing/">Indexing</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>API</li><li><a href>Functions</a></li></ul><a class="edit-page" href="https://github.com/JuliaData/DataFrames.jl/blob/master/docs/src/lib/functions.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Functions</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Functions-1" href="#Functions-1">Functions</a></h1><ul><li><a href="#Base.append!"><code>Base.append!</code></a></li><li><a href="#Base.copy"><code>Base.copy</code></a></li><li><a href="#Base.filter"><code>Base.filter</code></a></li><li><a href="#Base.filter!"><code>Base.filter!</code></a></li><li><a href="#Base.get"><code>Base.get</code></a></li><li><a href="#Base.hcat"><code>Base.hcat</code></a></li><li><a href="#Base.join"><code>Base.join</code></a></li><li><a href="#Base.keys"><code>Base.keys</code></a></li><li><a href="#Base.map"><code>Base.map</code></a></li><li><a href="#Base.names"><code>Base.names</code></a></li><li><a href="#Base.push!"><code>Base.push!</code></a></li><li><a href="#Base.repeat"><code>Base.repeat</code></a></li><li><a href="#Base.show"><code>Base.show</code></a></li><li><a href="#Base.sort"><code>Base.sort</code></a></li><li><a href="#Base.sort!"><code>Base.sort!</code></a></li><li><a href="#Base.unique!"><code>Base.unique!</code></a></li><li><a href="#Base.vcat"><code>Base.vcat</code></a></li><li><a href="#CategoricalArrays.categorical"><code>CategoricalArrays.categorical</code></a></li><li><a href="#Compat.eachcol"><code>Compat.eachcol</code></a></li><li><a href="#Compat.eachrow"><code>Compat.eachrow</code></a></li><li><a href="#DataAPI.describe"><code>DataAPI.describe</code></a></li><li><a href="#DataFrames.DataFrame!"><code>DataFrames.DataFrame!</code></a></li><li><a href="#DataFrames.aggregate"><code>DataFrames.aggregate</code></a></li><li><a href="#DataFrames.allowmissing!"><code>DataFrames.allowmissing!</code></a></li><li><a href="#DataFrames.by"><code>DataFrames.by</code></a></li><li><a href="#DataFrames.categorical!"><code>DataFrames.categorical!</code></a></li><li><a href="#DataFrames.combine"><code>DataFrames.combine</code></a></li><li><a href="#DataFrames.completecases"><code>DataFrames.completecases</code></a></li><li><a href="#DataFrames.deleterows!"><code>DataFrames.deleterows!</code></a></li><li><a href="#DataFrames.disallowmissing!"><code>DataFrames.disallowmissing!</code></a></li><li><a href="#DataFrames.dropmissing"><code>DataFrames.dropmissing</code></a></li><li><a href="#DataFrames.dropmissing!"><code>DataFrames.dropmissing!</code></a></li><li><a href="#DataFrames.flatten"><code>DataFrames.flatten</code></a></li><li><a href="#DataFrames.groupby"><code>DataFrames.groupby</code></a></li><li><a href="#DataFrames.groupindices"><code>DataFrames.groupindices</code></a></li><li><a href="#DataFrames.groupvars"><code>DataFrames.groupvars</code></a></li><li><a href="#DataFrames.insertcols!"><code>DataFrames.insertcols!</code></a></li><li><a href="#DataFrames.mapcols"><code>DataFrames.mapcols</code></a></li><li><a href="#DataFrames.ncol"><code>DataFrames.ncol</code></a></li><li><a href="#DataFrames.nonunique"><code>DataFrames.nonunique</code></a></li><li><a href="#DataFrames.nrow"><code>DataFrames.nrow</code></a></li><li><a href="#DataFrames.rename"><code>DataFrames.rename</code></a></li><li><a href="#DataFrames.rename!"><code>DataFrames.rename!</code></a></li><li><a href="#DataFrames.select"><code>DataFrames.select</code></a></li><li><a href="#DataFrames.select!"><code>DataFrames.select!</code></a></li><li><a href="#DataFrames.stack"><code>DataFrames.stack</code></a></li><li><a href="#DataFrames.unstack"><code>DataFrames.unstack</code></a></li><li><a href="#Missings.allowmissing"><code>Missings.allowmissing</code></a></li><li><a href="#Missings.disallowmissing"><code>Missings.disallowmissing</code></a></li></ul><h2><a class="nav-anchor" id="Grouping,-Joining,-and-Split-Apply-Combine-1" href="#Grouping,-Joining,-and-Split-Apply-Combine-1">Grouping, Joining, and Split-Apply-Combine</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataFrames.aggregate" href="#DataFrames.aggregate"><code>DataFrames.aggregate</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">aggregate(df::AbstractDataFrame, fs)
aggregate(df::AbstractDataFrame, cols, fs; sort=false, skipmissing=false)
aggregate(gd::GroupedDataFrame, fs; sort=false)</code></pre><p>Split-apply-combine that applies a set of functions over columns of an <code>AbstractDataFrame</code> or <a href="../types/#DataFrames.GroupedDataFrame"><code>GroupedDataFrame</code></a>. Return an aggregated data frame.</p><p><strong>Arguments</strong></p><ul><li><code>df</code> : an <code>AbstractDataFrame</code></li><li><code>gd</code> : a <code>GroupedDataFrame</code></li><li><code>cols</code> : a column indicator (<code>Symbol</code>, <code>Int</code>, <code>Vector{Symbol}</code>, etc.)</li><li><code>fs</code> : a function or vector of functions to be applied to vectors within groups; expects each argument to be a column vector</li><li><code>sort</code> : whether to sort rows according to the values of the grouping columns</li><li><code>skipmissing</code> : whether to skip rows with <code>missing</code> values in one of the grouping columns <code>cols</code></li></ul><p>Each <code>fs</code> should return a value or vector. All returns must be the same length.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Statistics

julia&gt; df = DataFrame(a = repeat([1, 2, 3, 4], outer=[2]),
                      b = repeat([2, 1], outer=[4]),
                      c = 1:8);

julia&gt; aggregate(df, :a, sum)
4×3 DataFrame
│ Row │ a     │ b_sum │ c_sum │
│     │ Int64 │ Int64 │ Int64 │
├─────┼───────┼───────┼───────┤
│ 1   │ 1     │ 4     │ 6     │
│ 2   │ 2     │ 2     │ 8     │
│ 3   │ 3     │ 4     │ 10    │
│ 4   │ 4     │ 2     │ 12    │

julia&gt; aggregate(df, :a, [sum, x-&gt;mean(skipmissing(x))])
4×5 DataFrame
│ Row │ a     │ b_sum │ c_sum │ b_function │ c_function │
│     │ Int64 │ Int64 │ Int64 │ Float64    │ Float64    │
├─────┼───────┼───────┼───────┼────────────┼────────────┤
│ 1   │ 1     │ 4     │ 6     │ 2.0        │ 3.0        │
│ 2   │ 2     │ 2     │ 8     │ 1.0        │ 4.0        │
│ 3   │ 3     │ 4     │ 10    │ 2.0        │ 5.0        │
│ 4   │ 4     │ 2     │ 12    │ 1.0        │ 6.0        │

julia&gt; aggregate(groupby(df, :a), [sum, x-&gt;mean(skipmissing(x))])
4×5 DataFrame
│ Row │ a     │ b_sum │ c_sum │ b_function │ c_function │
│     │ Int64 │ Int64 │ Int64 │ Float64    │ Float64    │
├─────┼───────┼───────┼───────┼────────────┼────────────┤
│ 1   │ 1     │ 4     │ 6     │ 2.0        │ 3.0        │
│ 2   │ 2     │ 2     │ 8     │ 1.0        │ 4.0        │
│ 3   │ 3     │ 4     │ 10    │ 2.0        │ 5.0        │
│ 4   │ 4     │ 2     │ 12    │ 1.0        │ 6.0        │</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/f46a404bfb0b738215af1322166894a28f2361c5/src/groupeddataframe/splitapplycombine.jl#L1149-L1208">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataFrames.by" href="#DataFrames.by"><code>DataFrames.by</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">by(df::AbstractDataFrame, keys, cols=&gt;f...;
   sort::Bool=false, skipmissing::Bool=false)
by(df::AbstractDataFrame, keys; (colname = cols =&gt; f)...,
   sort::Bool=false, skipmissing::Bool=false)
by(df::AbstractDataFrame, keys, f;
   sort::Bool=false, skipmissing::Bool=false)
by(f, df::AbstractDataFrame, keys;
   sort::Bool=false, skipmissing::Bool=false)</code></pre><p>Split-apply-combine in one step: apply <code>f</code> to each grouping in <code>df</code> based on grouping columns <code>keys</code>, and return a <code>DataFrame</code>.</p><p><code>keys</code> can be either a single column index, or a vector thereof.</p><p>If the last argument(s) consist(s) in one or more <code>cols =&gt; f</code> pair(s), or if <code>colname = cols =&gt; f</code> keyword arguments are provided, <code>cols</code> must be a column name or index, or a vector or tuple thereof, and <code>f</code> must be a callable. A pair or a (named) tuple of pairs can also be provided as the first or last argument. If <code>cols</code> is a single column index, <code>f</code> is called with a <code>SubArray</code> view into that column for each group; else, <code>f</code> is called with a named tuple holding <code>SubArray</code> views into these columns.</p><p>If the last argument is a callable <code>f</code>, it is passed a <a href="../types/#DataFrames.SubDataFrame"><code>SubDataFrame</code></a> view for each group, and the returned <code>DataFrame</code> then consists of the returned rows plus the grouping columns. If the returned data frame contains columns with the same names as the grouping columns, they are required to be equal. Note that this second form is much slower than the first one due to type instability. A method is defined with <code>f</code> as the first argument, so do-block notation can be used.</p><p><code>f</code> can return a single value, a row or multiple rows. In all cases, the resulting <code>DataFrame</code> contains all the grouping columns in addition to those generated by the application of <code>f</code>. The type of the returned value determines the shape of the resulting <code>DataFrame</code>, which is determined using the following rules:</p><ul><li>A single value gives a <code>DataFrame</code> with a single additional column and one row per group.</li><li>A named tuple of single values or a <a href="../types/#DataFrames.DataFrameRow"><code>DataFrameRow</code></a> gives a <code>DataFrame</code> with one additional column for each field and one row per group.</li><li>A vector gives a data frame with a single additional column and as many rows for each group as the length of the returned vector for that group.</li><li>A data frame, a named tuple of vectors or a matrix gives a <code>DataFrame</code> with the same additional columns and as many rows for each group as the rows returned for that group.</li></ul><p><code>f</code> must always return the same kind of object (as defined in the above list) for all groups, and if a named tuple or data frame, with the same fields or columns. Named tuples cannot mix single values and vectors. Due to type instability, returning a single value or a named tuple is dramatically faster than returning a data frame.</p><p>As a special case, if multiple pairs are passed as last arguments, each function is required to return a single value or vector, which will produce each a separate column.</p><p>Column names are automatically generated when necessary: for functions operating on a single column and returning a single value or vector, the function name is appended to the input colummn name; for other functions, columns are called <code>x1</code>, <code>x2</code> and so on. The resulting data frame will be sorted on <code>keys</code> if <code>sort=true</code>. Otherwise, ordering of rows is undefined. If <code>skipmissing=true</code> then the resulting data frame will not contain groups with <code>missing</code> values in one of the <code>keys</code> columns.</p><p>Optimized methods are used when standard summary functions (<code>sum</code>, <code>prod</code>, <code>minimum</code>, <code>maximum</code>, <code>mean</code>, <code>var</code>, <code>std</code>, <code>first</code>, <code>last</code> and <code>length) are specified using the pair syntax (e.g.</code>col =&gt; sum<code>). When computing the</code>sum<code>or</code>mean<code>over floating point columns, results will be less accurate than the standard [</code>sum<code>](@ref) function (which uses pairwise summation). Use</code>col =&gt; x -&gt; sum(x)` to avoid the optimized method and use the slower, more accurate one.</p><p><code>by(d, cols, f)</code> is equivalent to <code>combine(f, groupby(d, cols))</code> and to the less efficient <code>combine(map(f, groupby(d, cols)))</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; df = DataFrame(a = repeat([1, 2, 3, 4], outer=[2]),
                      b = repeat([2, 1], outer=[4]),
                      c = 1:8);

julia&gt; by(df, :a, :c =&gt; sum)
4×2 DataFrame
│ Row │ a     │ c_sum │
│     │ Int64 │ Int64 │
├─────┼───────┼───────┤
│ 1   │ 1     │ 6     │
│ 2   │ 2     │ 8     │
│ 3   │ 3     │ 10    │
│ 4   │ 4     │ 12    │

julia&gt; by(df, :a, d -&gt; sum(d.c)) # Slower variant
4×2 DataFrame
│ Row │ a     │ x1    │
│     │ Int64 │ Int64 │
├─────┼───────┼───────┤
│ 1   │ 1     │ 6     │
│ 2   │ 2     │ 8     │
│ 3   │ 3     │ 10    │
│ 4   │ 4     │ 12    │

julia&gt; by(df, :a) do d # do syntax for the slower variant
           sum(d.c)
       end
4×2 DataFrame
│ Row │ a     │ x1    │
│     │ Int64 │ Int64 │
├─────┼───────┼───────┤
│ 1   │ 1     │ 6     │
│ 2   │ 2     │ 8     │
│ 3   │ 3     │ 10    │
│ 4   │ 4     │ 12    │

julia&gt; by(df, :a, :c =&gt; x -&gt; 2 .* x)
8×2 DataFrame
│ Row │ a     │ c_function │
│     │ Int64 │ Int64      │
├─────┼───────┼────────────┤
│ 1   │ 1     │ 2          │
│ 2   │ 1     │ 10         │
│ 3   │ 2     │ 4          │
│ 4   │ 2     │ 12         │
│ 5   │ 3     │ 6          │
│ 6   │ 3     │ 14         │
│ 7   │ 4     │ 8          │
│ 8   │ 4     │ 16         │

julia&gt; by(df, :a, c_sum = :c =&gt; sum, c_sum2 = :c =&gt; x -&gt; sum(x.^2))
4×3 DataFrame
│ Row │ a     │ c_sum │ c_sum2 │
│     │ Int64 │ Int64 │ Int64  │
├─────┼───────┼───────┼────────┤
│ 1   │ 1     │ 6     │ 26     │
│ 2   │ 2     │ 8     │ 40     │
│ 3   │ 3     │ 10    │ 58     │
│ 4   │ 4     │ 12    │ 80     │

julia&gt; by(df, :a, (:b, :c) =&gt; x -&gt; (minb = minimum(x.b), sumc = sum(x.c)))
4×3 DataFrame
│ Row │ a     │ minb  │ sumc  │
│     │ Int64 │ Int64 │ Int64 │
├─────┼───────┼───────┼───────┤
│ 1   │ 1     │ 2     │ 6     │
│ 2   │ 2     │ 1     │ 8     │
│ 3   │ 3     │ 2     │ 10    │
│ 4   │ 4     │ 1     │ 12    │</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/f46a404bfb0b738215af1322166894a28f2361c5/src/groupeddataframe/splitapplycombine.jl#L989-L1132">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataFrames.combine" href="#DataFrames.combine"><code>DataFrames.combine</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">combine(gd::GroupedDataFrame, cols =&gt; f...)
combine(gd::GroupedDataFrame; (colname = cols =&gt; f)...)
combine(gd::GroupedDataFrame, f)
combine(f, gd::GroupedDataFrame)</code></pre><p>Transform a <a href="../types/#DataFrames.GroupedDataFrame"><code>GroupedDataFrame</code></a> into a <code>DataFrame</code>.</p><p>If the last argument(s) consist(s) in one or more <code>cols =&gt; f</code> pair(s), or if <code>colname = cols =&gt; f</code> keyword arguments are provided, <code>cols</code> must be a column name or index, or a vector or tuple thereof, and <code>f</code> must be a callable. A pair or a (named) tuple of pairs can also be provided as the first or last argument. If <code>cols</code> is a single column index, <code>f</code> is called with a <code>SubArray</code> view into that column for each group; else, <code>f</code> is called with a named tuple holding <code>SubArray</code> views into these columns.</p><p>If the last argument is a callable <code>f</code>, it is passed a <a href="../types/#DataFrames.SubDataFrame"><code>SubDataFrame</code></a> view for each group, and the returned <code>DataFrame</code> then consists of the returned rows plus the grouping columns. If the returned data frame contains columns with the same names as the grouping columns, they are required to be equal. Note that this second form is much slower than the first one due to type instability. A method is defined with <code>f</code> as the first argument, so do-block notation can be used.</p><p><code>f</code> can return a single value, a row or multiple rows. In all cases, the resulting <code>DataFrame</code> contains all the grouping columns in addition to those generated by the application of <code>f</code>. The type of the returned value determines the shape of the resulting <code>DataFrame</code>, which is determined using the following rules:</p><ul><li>A single value gives a <code>DataFrame</code> with a single additional column and one row per group.</li><li>A named tuple of single values or a <a href="../types/#DataFrames.DataFrameRow"><code>DataFrameRow</code></a> gives a <code>DataFrame</code> with one additional column for each field and one row per group.</li><li>A vector gives a data frame with a single additional column and as many rows for each group as the length of the returned vector for that group.</li><li>A data frame, a named tuple of vectors or a matrix gives a <code>DataFrame</code> with the same additional columns and as many rows for each group as the rows returned for that group.</li></ul><p><code>f</code> must always return the same kind of object (as defined in the above list) for all groups, and if a named tuple or data frame, with the same fields or columns. Named tuples cannot mix single values and vectors. Due to type instability, returning a single value or a named tuple is dramatically faster than returning a data frame.</p><p>As a special case, if a tuple or vector of pairs is passed as the first argument, each function is required to return a single value or vector, which will produce each a separate column.</p><p>Column names are automatically generated when necessary: for functions operating on a single column and returning a single value or vector, the function name is appended to the input column name; for other functions, columns are called <code>x1</code>, <code>x2</code> and so on. The resulting data frame will be sorted if <code>sort=true</code> was passed to the <a href="#DataFrames.groupby"><code>groupby</code></a> call from which <code>gd</code> was constructed. Otherwise, ordering of rows is undefined.</p><p>Optimized methods are used when standard summary functions (<code>sum</code>, <code>prod</code>, <code>minimum</code>, <code>maximum</code>, <code>mean</code>, <code>var</code>, <code>std</code>, <code>first</code>, <code>last</code> and <code>length</code>) are specified using the pair syntax (e.g. <code>col =&gt; sum</code>). When computing the <code>sum</code> or <code>mean</code> over floating point columns, results will be less accurate than the standard <a href="lib/@ref"><code>sum</code></a> function (which uses pairwise summation). Use <code>col =&gt; x -&gt; sum(x)</code> to avoid the optimized method and use the slower, more accurate one.</p><p>See also:</p><ul><li><a href="#DataFrames.by"><code>by(f, df, cols)</code></a> is a shorthand for <code>combine(f, groupby(df, cols))</code>.</li><li><a href="#Base.map"><code>map</code></a>: <code>combine(f, groupby(df, cols))</code> is a more efficient equivalent</li></ul><p>of <code>combine(map(f, groupby(df, cols)))</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; df = DataFrame(a = repeat([1, 2, 3, 4], outer=[2]),
                      b = repeat([2, 1], outer=[4]),
                      c = 1:8);

julia&gt; gd = groupby(df, :a);

julia&gt; combine(gd, :c =&gt; sum)
4×2 DataFrame
│ Row │ a     │ c_sum │
│     │ Int64 │ Int64 │
├─────┼───────┼───────┤
│ 1   │ 1     │ 6     │
│ 2   │ 2     │ 8     │
│ 3   │ 3     │ 10    │
│ 4   │ 4     │ 12    │

julia&gt; combine(:c =&gt; sum, gd)
4×2 DataFrame
│ Row │ a     │ c_sum │
│     │ Int64 │ Int64 │
├─────┼───────┼───────┤
│ 1   │ 1     │ 6     │
│ 2   │ 2     │ 8     │
│ 3   │ 3     │ 10    │
│ 4   │ 4     │ 12    │

julia&gt; combine(df -&gt; sum(df.c), gd) # Slower variant
4×2 DataFrame
│ Row │ a     │ x1    │
│     │ Int64 │ Int64 │
├─────┼───────┼───────┤
│ 1   │ 1     │ 6     │
│ 2   │ 2     │ 8     │
│ 3   │ 3     │ 10    │
│ 4   │ 4     │ 12    │</code></pre><p>See <a href="#DataFrames.by"><code>by</code></a> for more examples.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/f46a404bfb0b738215af1322166894a28f2361c5/src/groupeddataframe/splitapplycombine.jl#L307-L412">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataFrames.groupby" href="#DataFrames.groupby"><code>DataFrames.groupby</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">groupby(d::AbstractDataFrame, cols; sort=false, skipmissing=false)</code></pre><p>Return a <code>GroupedDataFrame</code> representing a view of an <code>AbstractDataFrame</code> split into row groups.</p><p><strong>Arguments</strong></p><ul><li><code>df</code> : an <code>AbstractDataFrame</code> to split</li><li><code>cols</code> : data frame columns to group by</li><li><code>sort</code> : whether to sort rows according to the values of the grouping columns <code>cols</code></li><li><code>skipmissing</code> : whether to skip rows with <code>missing</code> values in one of the grouping columns <code>cols</code></li></ul><p><strong>Details</strong></p><p>An iterator over a <code>GroupedDataFrame</code> returns a <code>SubDataFrame</code> view for each grouping into <code>df</code>. Within each group, the order of rows in <code>df</code> is preserved.</p><p><code>cols</code> can be any valid data frame indexing expression. In particular if it is an empty vector then a single-group <code>GroupedDataFrame</code> is created.</p><p>A <code>GroupedDataFrame</code> also supports indexing by groups, <code>map</code> (which applies a function to each group) and <code>combine</code> (which applies a function to each group and combines the result into a data frame).</p><p>See the following for additional split-apply-combine operations:</p><ul><li><a href="#DataFrames.by"><code>by</code></a> : split-apply-combine using functions</li><li><a href="#DataFrames.aggregate"><code>aggregate</code></a> : split-apply-combine; applies functions in the form of a cross product</li><li><a href="#Base.map"><code>map</code></a> : apply a function to each group of a <code>GroupedDataFrame</code> (without combining)</li><li><a href="#DataFrames.combine"><code>combine</code></a> : combine a <code>GroupedDataFrame</code>, optionally applying a function to each group</li></ul><p><code>GroupedDataFrame</code> also supports the dictionary interface. The keys are <a href="../types/#DataFrames.GroupKey"><code>GroupKey</code></a> objects returned by <a href="#Base.keys"><code>keys(::GroupedDataFrame)</code></a>, which can also be used to get the values of the grouping columns for each group. <code>Tuples</code> and <code>NamedTuple</code>s containing the values of the grouping columns (in the same order as the <code>cols</code> argument) are also accepted as indices, but this will be slower than using the equivalent <code>GroupKey</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; df = DataFrame(a = repeat([1, 2, 3, 4], outer=[2]),
                      b = repeat([2, 1], outer=[4]),
                      c = 1:8);

julia&gt; gd = groupby(df, :a)
GroupedDataFrame with 4 groups based on key: a
First Group (2 rows): a = 1
│ Row │ a     │ b     │ c     │
│     │ Int64 │ Int64 │ Int64 │
├─────┼───────┼───────┼───────┤
│ 1   │ 1     │ 2     │ 1     │
│ 2   │ 1     │ 2     │ 5     │
⋮
Last Group (2 rows): a = 4
│ Row │ a     │ b     │ c     │
│     │ Int64 │ Int64 │ Int64 │
├─────┼───────┼───────┼───────┤
│ 1   │ 4     │ 1     │ 4     │
│ 2   │ 4     │ 1     │ 8     │

julia&gt; gd[1]
2×3 SubDataFrame
│ Row │ a     │ b     │ c     │
│     │ Int64 │ Int64 │ Int64 │
├─────┼───────┼───────┼───────┤
│ 1   │ 1     │ 2     │ 1     │
│ 2   │ 1     │ 2     │ 5     │

julia&gt; last(gd)
2×3 SubDataFrame
│ Row │ a     │ b     │ c     │
│     │ Int64 │ Int64 │ Int64 │
├─────┼───────┼───────┼───────┤
│ 1   │ 4     │ 1     │ 4     │
│ 2   │ 4     │ 1     │ 8     │

julia&gt; gd[(a=3,)]
2×3 SubDataFrame
│ Row │ a     │ b     │ c     │
│     │ Int64 │ Int64 │ Int64 │
├─────┼───────┼───────┼───────┤
│ 1   │ 3     │ 2     │ 3     │
│ 2   │ 3     │ 2     │ 7     │

julia&gt; gd[(3,)]
2×3 SubDataFrame
│ Row │ a     │ b     │ c     │
│     │ Int64 │ Int64 │ Int64 │
├─────┼───────┼───────┼───────┤
│ 1   │ 3     │ 2     │ 3     │
│ 2   │ 3     │ 2     │ 7     │

julia&gt; k = first(keys(gd))
GroupKey: (a = 3)

julia&gt; gd[k]
2×3 SubDataFrame
│ Row │ a     │ b     │ c     │
│     │ Int64 │ Int64 │ Int64 │
├─────┼───────┼───────┼───────┤
│ 1   │ 3     │ 2     │ 3     │
│ 2   │ 3     │ 2     │ 7     │

julia&gt; for g in gd
           println(g)
       end
2×3 SubDataFrame
│ Row │ a     │ b     │ c     │
│     │ Int64 │ Int64 │ Int64 │
├─────┼───────┼───────┼───────┤
│ 1   │ 1     │ 2     │ 1     │
│ 2   │ 1     │ 2     │ 5     │
2×3 SubDataFrame
│ Row │ a     │ b     │ c     │
│     │ Int64 │ Int64 │ Int64 │
├─────┼───────┼───────┼───────┤
│ 1   │ 2     │ 1     │ 2     │
│ 2   │ 2     │ 1     │ 6     │
2×3 SubDataFrame
│ Row │ a     │ b     │ c     │
│     │ Int64 │ Int64 │ Int64 │
├─────┼───────┼───────┼───────┤
│ 1   │ 3     │ 2     │ 3     │
│ 2   │ 3     │ 2     │ 7     │
2×3 SubDataFrame
│ Row │ a     │ b     │ c     │
│     │ Int64 │ Int64 │ Int64 │
├─────┼───────┼───────┼───────┤
│ 1   │ 4     │ 1     │ 4     │
│ 2   │ 4     │ 1     │ 8     │</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/f46a404bfb0b738215af1322166894a28f2361c5/src/groupeddataframe/splitapplycombine.jl#L5-L137">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataFrames.groupindices" href="#DataFrames.groupindices"><code>DataFrames.groupindices</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">groupindices(gd::GroupedDataFrame)</code></pre><p>Return a vector of group indices for each row of <code>parent(gd)</code>.</p><p>Rows appearing in group <code>gd[i]</code> are attributed index <code>i</code>. Rows not present in any group are attributed <code>missing</code> (this can happen if <code>skipmissing=true</code> was passed when creating <code>gd</code>, or if <code>gd</code> is a subset from a larger <a href="../types/#DataFrames.GroupedDataFrame"><code>GroupedDataFrame</code></a>).</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/f46a404bfb0b738215af1322166894a28f2361c5/src/groupeddataframe/groupeddataframe.jl#L78-L86">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataFrames.groupvars" href="#DataFrames.groupvars"><code>DataFrames.groupvars</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">groupvars(gd::GroupedDataFrame)</code></pre><p>Return a vector of column names in <code>parent(gd)</code> used for grouping.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/f46a404bfb0b738215af1322166894a28f2361c5/src/groupeddataframe/groupeddataframe.jl#L89-L93">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.keys" href="#Base.keys"><code>Base.keys</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">keys(gd::GroupedDataFrame)</code></pre><p>Get the set of keys for each group of the <code>GroupedDataFrame</code> <code>gd</code> as a <a href="lib/@ref"><code>GroupKeys</code></a> object. Each key is a <a href="../types/#DataFrames.GroupKey"><code>GroupKey</code></a>, which behaves like a <code>NamedTuple</code> holding the values of the grouping columns for a given group. Unlike the equivalent <code>Tuple</code> and <code>NamedTuple</code>, these keys can be used to index into <code>gd</code> efficiently. The ordering of the keys is identical to the ordering of the groups of <code>gd</code> under iteration and integer indexing.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; df = DataFrame(a = repeat([:foo, :bar, :baz], outer=[4]),
                      b = repeat([2, 1], outer=[6]),
                      c = 1:12);

julia&gt; gd = groupby(df, [:a, :b])
GroupedDataFrame with 6 groups based on keys: a, b
First Group (2 rows): a = :foo, b = 2
│ Row │ a      │ b     │ c     │
│     │ Symbol │ Int64 │ Int64 │
├─────┼────────┼───────┼───────┤
│ 1   │ foo    │ 2     │ 1     │
│ 2   │ foo    │ 2     │ 7     │
⋮
Last Group (2 rows): a = :baz, b = 1
│ Row │ a      │ b     │ c     │
│     │ Symbol │ Int64 │ Int64 │
├─────┼────────┼───────┼───────┤
│ 1   │ baz    │ 1     │ 6     │
│ 2   │ baz    │ 1     │ 12    │

julia&gt; keys(gd)
6-element DataFrames.GroupKeys{GroupedDataFrame{DataFrame}}:
 GroupKey: (a = :foo, b = 2)
 GroupKey: (a = :bar, b = 1)
 GroupKey: (a = :baz, b = 2)
 GroupKey: (a = :foo, b = 1)
 GroupKey: (a = :bar, b = 2)
 GroupKey: (a = :baz, b = 1)</code></pre><p><code>GroupKey</code> objects behave similarly to <code>NamedTuple</code>s:</p><pre><code class="language-julia-repl">julia&gt; k = keys(gd)[1]
GroupKey: (a = :foo, b = 2)

julia&gt; keys(k)
(:a, :b)

julia&gt; values(k)  # Same as Tuple(k)
(:foo, 2)

julia&gt; NamedTuple(k)
(a = :foo, b = 2)

julia&gt; k.a
:foo

julia&gt; k[:a]
:foo

julia&gt; k[1]
:foo</code></pre><p>Keys can be used as indices to retrieve the corresponding group from their <code>GroupedDataFrame</code>:</p><pre><code class="language-julia-repl">julia&gt; gd[k]
2×3 SubDataFrame
│ Row │ a      │ b     │ c     │
│     │ Symbol │ Int64 │ Int64 │
├─────┼────────┼───────┼───────┤
│ 1   │ foo    │ 2     │ 1     │
│ 2   │ foo    │ 2     │ 7     │

julia&gt; gd[keys(gd)[1]] == gd[1]
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/f46a404bfb0b738215af1322166894a28f2361c5/src/groupeddataframe/groupeddataframe.jl#L248-L331">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.get" href="#Base.get"><code>Base.get</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">get(gd::GroupedDataFrame, key, default)</code></pre><p>Get a group based on the values of the grouping columns.</p><p><code>key</code> may be a <code>NamedTuple</code> or <code>Tuple</code> of grouping column values (in the same order as the <code>cols</code> argument to <code>groupby</code>).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; df = DataFrame(a = repeat([:foo, :bar, :baz], outer=[2]),
                      b = repeat([2, 1], outer=[3]),
                      c = 1:6);

julia&gt; gd = groupby(df, :a)
GroupedDataFrame with 3 groups based on key: a
First Group (2 rows): a = :foo
│ Row │ a      │ b     │ c     │
│     │ Symbol │ Int64 │ Int64 │
├─────┼────────┼───────┼───────┤
│ 1   │ foo    │ 2     │ 1     │
│ 2   │ foo    │ 1     │ 4     │
⋮
Last Group (2 rows): a = :baz
│ Row │ a      │ b     │ c     │
│     │ Symbol │ Int64 │ Int64 │
├─────┼────────┼───────┼───────┤
│ 1   │ baz    │ 2     │ 3     │
│ 2   │ baz    │ 1     │ 6     │

julia&gt; get(gd, (a=:bar,), nothing)
2×3 SubDataFrame
│ Row │ a      │ b     │ c     │
│     │ Symbol │ Int64 │ Int64 │
├─────┼────────┼───────┼───────┤
│ 1   │ bar    │ 1     │ 2     │
│ 2   │ bar    │ 2     │ 5     │

julia&gt; get(gd, (:baz,), nothing)
2×3 SubDataFrame
│ Row │ a      │ b     │ c     │
│     │ Symbol │ Int64 │ Int64 │
├─────┼────────┼───────┼───────┤
│ 1   │ baz    │ 2     │ 3     │
│ 2   │ baz    │ 1     │ 6     │

julia&gt; get(gd, (:qux,), nothing)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/f46a404bfb0b738215af1322166894a28f2361c5/src/groupeddataframe/groupeddataframe.jl#L356-L405">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.join" href="#Base.join"><code>Base.join</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">join(df1, df2; on = Symbol[], kind = :inner, makeunique = false,
     indicator = nothing, validate = (false, false))
join(df1, df2, dfs...; on = Symbol[], kind = :inner, makeunique = false,
     validate = (false, false))</code></pre><p>Join two or more <code>DataFrame</code> objects and return a <code>DataFrame</code> containing the result.</p><p><strong>Arguments</strong></p><ul><li><code>df1</code>, <code>df2</code>, <code>dfs...</code> : the <code>AbstractDataFrames</code> to be joined</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><p><code>on</code> : A column name to join <code>df1</code> and <code>df2</code> on. If the columns on which <code>df1</code> and <code>df2</code> will be joined have different names, then a <code>left=&gt;right</code> pair can be passed. It is also allowed to perform a join on multiple columns, in which case a vector of column names or column name pairs can be passed (mixing names and pairs is allowed). If more than two data frames are joined then only a column name or a vector of column names are allowed. <code>on</code> is a required argument for all joins except for <code>kind = :cross</code>.</p></li><li><p><code>kind</code> : the type of join, options include:</p><ul><li><code>:inner</code> : only include rows with keys that match in both <code>df1</code> and <code>df2</code>, the default</li><li><code>:outer</code> : include all rows from <code>df1</code> and <code>df2</code></li><li><code>:left</code> : include all rows from <code>df1</code></li><li><code>:right</code> : include all rows from <code>df2</code></li><li><code>:semi</code> : return rows of <code>df1</code> that match with the keys in <code>df2</code></li><li><code>:anti</code> : return rows of <code>df1</code> that do not match with the keys in <code>df2</code></li><li><code>:cross</code> : a full Cartesian product of the key combinations; every row of <code>df1</code> is matched with every row of <code>df2</code></li></ul><p>When joining more than two data frames only <code>:inner</code>, <code>:outer</code> and <code>:cross</code> joins are allowed.</p></li><li><p><code>makeunique</code> : if <code>false</code> (the default), an error will be raised if duplicate names are found in columns not joined on; if <code>true</code>, duplicate names will be suffixed with <code>_i</code> (<code>i</code> starting at 1 for the first duplicate).</p></li><li><p><code>indicator</code> : Default: <code>nothing</code>. If a <code>Symbol</code>, adds categorical indicator  column named <code>Symbol</code> for whether a row appeared in only <code>df1</code> (<code>&quot;left_only&quot;</code>),  only <code>df2</code> (<code>&quot;right_only&quot;</code>) or in both (<code>&quot;both&quot;</code>). If <code>Symbol</code> is already in use,  the column name will be modified if <code>makeunique=true</code>.  This argument is only supported when joining exactly two data frames.</p></li><li><p><code>validate</code> : whether to check that columns passed as the <code>on</code> argument  define unique keys in each input data frame (according to <a href="lib/@ref"><code>isequal</code></a>).  Can be a tuple or a pair, with the first element indicating whether to  run check for <code>df1</code> and the second element for <code>df2</code>.  By default no check is performed.</p></li></ul><p>For the three join operations that may introduce missing values (<code>:outer</code>, <code>:left</code>, and <code>:right</code>), all columns of the returned data table will support missing values.</p><p>When merging <code>on</code> categorical columns that differ in the ordering of their levels, the ordering of the left <code>DataFrame</code> takes precedence over the ordering of the right <code>DataFrame</code>.</p><p>If more than two data frames are passed, the join is performed recursively with left associativity. In this case the <code>indicator</code> keyword argument is not supported.</p><p><strong>Examples</strong></p><pre><code class="language-julia">name = DataFrame(ID = [1, 2, 3], Name = [&quot;John Doe&quot;, &quot;Jane Doe&quot;, &quot;Joe Blogs&quot;])
job = DataFrame(ID = [1, 2, 4], Job = [&quot;Lawyer&quot;, &quot;Doctor&quot;, &quot;Farmer&quot;])

join(name, job, on = :ID)
join(name, job, on = :ID, kind = :outer)
join(name, job, on = :ID, kind = :left)
join(name, job, on = :ID, kind = :right)
join(name, job, on = :ID, kind = :semi)
join(name, job, on = :ID, kind = :anti)
join(name, job, kind = :cross)

job2 = DataFrame(identifier = [1, 2, 4], Job = [&quot;Lawyer&quot;, &quot;Doctor&quot;, &quot;Farmer&quot;])
join(name, job2, on = :ID =&gt; :identifier)
join(name, job2, on = [:ID =&gt; :identifier])</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/f46a404bfb0b738215af1322166894a28f2361c5/src/abstractdataframe/join.jl#L228-L308">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.map" href="#Base.map"><code>Base.map</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">map(cols =&gt; f, gd::GroupedDataFrame)
map(f, gd::GroupedDataFrame)</code></pre><p>Apply a function to each group of rows and return a <a href="../types/#DataFrames.GroupedDataFrame"><code>GroupedDataFrame</code></a>.</p><p>If the first argument is a <code>cols =&gt; f</code> pair, <code>cols</code> must be a column name or index, or a vector or tuple thereof, and <code>f</code> must be a callable. If <code>cols</code> is a single column index, <code>f</code> is called with a <code>SubArray</code> view into that column for each group; else, <code>f</code> is called with a named tuple holding <code>SubArray</code> views into these columns.</p><p>If the first argument is a vector, tuple or named tuple of such pairs, each pair is handled as described above. If it is a named tuple then field names are used to name each generated column.</p><p>If the first argument is a callable <code>f</code>, it is passed a <a href="../types/#DataFrames.SubDataFrame"><code>SubDataFrame</code></a> view for each group, and the returned <code>GroupedDataFrame</code> then consists of the returned rows plus the grouping columns. If the table object returned  by <code>f</code> contains columns with the same names as the grouping columns, they are required to be equal. Note that this second form is much slower than the first one due to type instability.</p><p><code>f</code> can return a single value, a row or multiple rows. In all cases, the resulting <code>GroupedDataFrame</code> contains all the grouping columns in addition to those generated by the application of <code>f</code>. The type of the returned value determines the shape of the resulting groups in <code>GroupedDataFrame</code>, which is determined using the following rules:</p><ul><li>A single value gives a single additional column and one row per group.</li><li>A named tuple of single values or a <a href="../types/#DataFrames.DataFrameRow"><code>DataFrameRow</code></a> gives one additional column for each field and one row per group.</li><li>A vector gives a single additional column and as many rows for each group as the length of the returned vector for that group.</li><li>A data frame, a named tuple of vectors or a matrix gives the same additional columns and as many rows for each group as the rows returned for that group.</li></ul><p><code>f</code> must always return the same kind of object (as defined in the above list) for all groups, and if a named tuple or data frame, with the same fields or columns. Named tuples cannot mix single values and vectors. Due to type instability, returning a single value or a named tuple is dramatically faster than returning a data frame.</p><p>As a special case, if a tuple or vector of pairs is passed as the first argument, each function is required to return a single value or vector, which will produce each a separate column.</p><p>Column names are automatically generated when necessary: for functions operating on a single column and returning a single value or vector, the function name is appended to the input column name; for other functions, columns are called <code>x1</code>, <code>x2</code> and so on.</p><p>Optimized methods are used when standard summary functions (<code>sum</code>, <code>prod</code>, <code>minimum</code>, <code>maximum</code>, <code>mean</code>, <code>var</code>, <code>std</code>, <code>first</code>, <code>last</code> and <code>length</code>) are specified using the pair syntax (e.g. <code>col =&gt; sum</code>). When computing the <code>sum</code> or <code>mean</code> over floating point columns, results will be less accurate than the standard <a href="lib/@ref"><code>sum</code></a> function (which uses pairwise summation). Use <code>col =&gt; x -&gt; sum(x)</code> to avoid the optimized method and use the slower, more accurate one.</p><p>See also <a href="#DataFrames.combine"><code>combine(f, gd)</code></a> that returns a <code>DataFrame</code> rather than a <code>GroupedDataFrame</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; df = DataFrame(a = repeat([1, 2, 3, 4], outer=[2]),
                      b = repeat([2, 1], outer=[4]),
                      c = 1:8);

julia&gt; gd = groupby(df, :a);

julia&gt; map(:c =&gt; sum, gd)
GroupedDataFrame{DataFrame} with 4 groups based on key: :a
First Group: 1 row
│ Row │ a     │ c_sum │
│     │ Int64 │ Int64 │
├─────┼───────┼───────┤
│ 1   │ 1     │ 6     │
⋮
Last Group: 1 row
│ Row │ a     │ c_sum │
│     │ Int64 │ Int64 │
├─────┼───────┼───────┤
│ 1   │ 4     │ 12    │

julia&gt; map(df -&gt; sum(df.c), gd) # Slower variant
GroupedDataFrame{DataFrame} with 4 groups based on key: :a
First Group: 1 row
│ Row │ a     │ x1    │
│     │ Int64 │ Int64 │
├─────┼───────┼───────┤
│ 1   │ 1     │ 6     │
⋮
Last Group: 1 row
│ Row │ a     │ x1    │
│     │ Int64 │ Int64 │
├─────┼───────┼───────┤
│ 1   │ 4     │ 12    │</code></pre><p>See <a href="#DataFrames.by"><code>by</code></a> for more examples.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/f46a404bfb0b738215af1322166894a28f2361c5/src/groupeddataframe/splitapplycombine.jl#L171-L266">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataFrames.stack" href="#DataFrames.stack"><code>DataFrames.stack</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">stack(df::AbstractDataFrame, [measure_vars], [id_vars];
      variable_name::Symbol=:variable, value_name::Symbol=:value,
      view::Bool=false, variable_eltype::Type=CategoricalString)</code></pre><p>Stack a data frame <code>df</code>, i.e. convert it from wide to long format.</p><p>Return the long-format <code>DataFrame</code> with column <code>variable_name</code> (<code>:value</code> by default) holding the values of the stacked columns (<code>measure_vars</code>), with column <code>variable_name</code> (<code>:variable</code> by default) a vector holding the name of the corresponding <code>measure_vars</code> variable, and with columns for each of the <code>id_vars</code>.</p><p>If <code>view=true</code> then return a stacked view of a data frame (long format). The result is a view because the columns are special <code>AbstractVectors</code> that return views into the original data frame.</p><p><strong>Arguments</strong></p><ul><li><code>df</code> : the AbstractDataFrame to be stacked</li><li><code>measure_vars</code> : the columns to be stacked (the measurement variables), a normal column indexing type, like a <code>Symbol</code>, <code>Vector{Symbol}</code>, Int, etc.; If neither <code>measure_vars</code> or <code>id_vars</code> are given, <code>measure_vars</code> defaults to all floating point columns.</li><li><code>id_vars</code> : the identifier columns that are repeated during stacking, a normal column indexing type; defaults to all variables that are not <code>measure_vars</code></li><li><code>variable_name</code> : the name of the new stacked column that shall hold the names of each of <code>measure_vars</code></li><li><code>value_name</code> : the name of the new stacked column containing the values from each of <code>measure_vars</code></li><li><code>view</code> : whether the stacked data frame should be a view rather than contain  freshly allocated vectors.</li><li><code>variable_eltype</code> : determines the element type of column <code>variable_name</code>. By default  a categorical vector of strings is created.  If <code>variable_eltype=Symbol</code> it is a vector of <code>Symbol</code>,  and if <code>variable_eltype=String</code> a vector of <code>String</code> is produced.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia">d1 = DataFrame(a = repeat([1:3;], inner = [4]),
               b = repeat([1:4;], inner = [3]),
               c = randn(12),
               d = randn(12),
               e = map(string, &#39;a&#39;:&#39;l&#39;))

d1s = stack(d1, [:c, :d])
d1s2 = stack(d1, [:c, :d], [:a])
d1m = stack(d1, Not([:a, :b, :e]))
d1s_name = stack(d1, Not([:a, :b, :e]), variable_name=:somemeasure)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/f46a404bfb0b738215af1322166894a28f2361c5/src/abstractdataframe/reshape.jl#L1-L53">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataFrames.unstack" href="#DataFrames.unstack"><code>DataFrames.unstack</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">unstack(df::AbstractDataFrame, rowkeys::Union{Integer, Symbol},
        colkey::Union{Integer, Symbol}, value::Union{Integer, Symbol};
        renamecols::Function=identity)
unstack(df::AbstractDataFrame, rowkeys::AbstractVector{&lt;:Union{Integer, Symbol}},
        colkey::Union{Integer, Symbol}, value::Union{Integer, Symbol};
        renamecols::Function=identity)
unstack(df::AbstractDataFrame, colkey::Union{Integer, Symbol},
        value::Union{Integer, Symbol}; renamecols::Function=identity)
unstack(df::AbstractDataFrame; renamecols::Function=identity)</code></pre><p>Unstack data frame <code>df</code>, i.e. convert it from long to wide format.</p><p>If <code>colkey</code> contains <code>missing</code> values then they will be skipped and a warning will be printed.</p><p>If combination of <code>rowkeys</code> and <code>colkey</code> contains duplicate entries then last <code>value</code> will be retained and a warning will be printed.</p><p><strong>Arguments</strong></p><ul><li><code>df</code> : the AbstractDataFrame to be unstacked</li><li><code>rowkeys</code> : the column(s) with a unique key for each row, if not given, find a key by grouping on anything not a <code>colkey</code> or <code>value</code></li><li><code>colkey</code> : the column holding the column names in wide format, defaults to <code>:variable</code></li><li><code>value</code> : the value column, defaults to <code>:value</code></li><li><code>renamecols</code> : a function called on each unique value in <code>colkey</code> which must                return the name of the column to be created (typically as a string                or a <code>Symbol</code>). Duplicate names are not allowed.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia">wide = DataFrame(id = 1:12,
                 a  = repeat([1:3;], inner = [4]),
                 b  = repeat([1:4;], inner = [3]),
                 c  = randn(12),
                 d  = randn(12))

long = stack(wide)
wide0 = unstack(long)
wide1 = unstack(long, :variable, :value)
wide2 = unstack(long, :id, :variable, :value)
wide3 = unstack(long, [:id, :a], :variable, :value)
wide4 = unstack(long, :id, :variable, :value, renamecols=x-&gt;Symbol(:_, x))</code></pre><p>Note that there are some differences between the widened results above.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/f46a404bfb0b738215af1322166894a28f2361c5/src/abstractdataframe/reshape.jl#L124-L169">source</a></section><h2><a class="nav-anchor" id="Basics-1" href="#Basics-1">Basics</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Missings.allowmissing" href="#Missings.allowmissing"><code>Missings.allowmissing</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">allowmissing(df::AbstractDataFrame,
             cols::Union{ColumnIndex, AbstractVector, Regex, Not, Between, All, Colon}=:)</code></pre><p>Return a copy of data frame <code>df</code> with columns <code>cols</code> converted to element type <code>Union{T, Missing}</code> from <code>T</code> to allow support for missing values.</p><p>If <code>cols</code> is omitted all columns in the data frame are converted.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; df = DataFrame(a=[1,2])
2×1 DataFrame
│ Row │ a     │
│     │ Int64 │
├─────┼───────┤
│ 1   │ 1     │
│ 2   │ 2     │

julia&gt; allowmissing(df)
2×1 DataFrame
│ Row │ a      │
│     │ Int64⍰ │
├─────┼────────┤
│ 1   │ 1      │
│ 2   │ 2      │</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/f46a404bfb0b738215af1322166894a28f2361c5/src/abstractdataframe/abstractdataframe.jl#L1452-L1480">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataFrames.allowmissing!" href="#DataFrames.allowmissing!"><code>DataFrames.allowmissing!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">allowmissing!(df::DataFrame, cols::Colon=:)
allowmissing!(df::DataFrame, cols::Union{Integer, Symbol})
allowmissing!(df::DataFrame, cols::Union{AbstractVector, Regex, Not, Between, All})</code></pre><p>Convert columns <code>cols</code> of data frame <code>df</code> from element type <code>T</code> to <code>Union{T, Missing}</code> to support missing values.</p><p>If <code>cols</code> is omitted all columns in the data frame are converted.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/f46a404bfb0b738215af1322166894a28f2361c5/src/dataframe/dataframe.jl#L937-L946">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CategoricalArrays.categorical" href="#CategoricalArrays.categorical"><code>CategoricalArrays.categorical</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">categorical(df::AbstractDataFrame, cols::Type=Union{AbstractString, Missing};
            compress::Bool=false)
categorical(df::AbstractDataFrame,
            cols::Union{ColumnIndex, AbstractVector, Regex, Not, Between, All, Colon};
            compress::Bool=false)</code></pre><p>Return a copy of data frame <code>df</code> with columns <code>cols</code> converted to <code>CategoricalVector</code>. If <code>categorical</code> is called with the <code>cols</code> argument being a <code>Type</code>, then all columns whose element type is a subtype of this type (by default <code>Union{AbstractString, Missing}</code>) will be converted to categorical.</p><p>If the <code>compress</code> keyword argument is set to <code>true</code> then the created <code>CategoricalVector</code>s will be compressed.</p><p>All created <code>CategoricalVector</code>s are unordered.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; df = DataFrame(a=[1,2], b=[&quot;a&quot;,&quot;b&quot;])
2×2 DataFrame
│ Row │ a     │ b      │
│     │ Int64 │ String │
├─────┼───────┼────────┤
│ 1   │ 1     │ a      │
│ 2   │ 2     │ b      │

julia&gt; categorical(df)
2×2 DataFrame
│ Row │ a     │ b            │
│     │ Int64 │ Categorical… │
├─────┼───────┼──────────────┤
│ 1   │ 1     │ a            │
│ 2   │ 2     │ b            │

julia&gt; categorical(df, :)
2×2 DataFrame
│ Row │ a            │ b            │
│     │ Categorical… │ Categorical… │
├─────┼──────────────┼──────────────┤
│ 1   │ 1            │ a            │
│ 2   │ 2            │ b            │</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/f46a404bfb0b738215af1322166894a28f2361c5/src/abstractdataframe/abstractdataframe.jl#L1497-L1541">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataFrames.categorical!" href="#DataFrames.categorical!"><code>DataFrames.categorical!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">categorical!(df::DataFrame, cols::Type=Union{AbstractString, Missing};
             compress::Bool=false)
categorical!(df::DataFrame, cname::Union{Integer, Symbol};
             compress::Bool=false)
categorical!(df::DataFrame, cnames::Vector{&lt;:Union{Integer, Symbol}};
             compress::Bool=false)
categorical!(df::DataFrame, cnames::Union{Regex, Not, Between, All};
             compress::Bool=false)</code></pre><p>Change columns selected by <code>cname</code> or <code>cnames</code> in data frame <code>df</code> to <code>CategoricalVector</code>.</p><p>If <code>categorical!</code> is called with the <code>cols</code> argument being a <code>Type</code>, then all columns whose element type is a subtype of this type (by default <code>Union{AbstractString, Missing}</code>) will be converted to categorical.</p><p>If the <code>compress</code> keyword argument is set to <code>true</code> then the created <code>CategoricalVector</code>s will be compressed.</p><p>All created <code>CategoricalVector</code>s are unordered.</p><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; df = DataFrame(X=[&quot;a&quot;, &quot;b&quot;], Y=[1, 2], Z=[&quot;p&quot;, &quot;q&quot;])
2×3 DataFrame
│ Row │ X      │ Y     │ Z      │
│     │ String │ Int64 │ String │
├─────┼────────┼───────┼────────┤
│ 1   │ a      │ 1     │ p      │
│ 2   │ b      │ 2     │ q      │

julia&gt; categorical!(df)
2×3 DataFrame
│ Row │ X            │ Y     │ Z            │
│     │ Categorical… │ Int64 │ Categorical… │
├─────┼──────────────┼───────┼──────────────┤
│ 1   │ a            │ 1     │ p            │
│ 2   │ b            │ 2     │ q            │

julia&gt; eltype.(eachcol(df))
3-element Array{DataType,1}:
 CategoricalString{UInt32}
 Int64
 CategoricalString{UInt32}

julia&gt; df = DataFrame(X=[&quot;a&quot;, &quot;b&quot;], Y=[1, 2], Z=[&quot;p&quot;, &quot;q&quot;])
2×3 DataFrame
│ Row │ X      │ Y     │ Z      │
│     │ String │ Int64 │ String │
├─────┼────────┼───────┼────────┤
│ 1   │ a      │ 1     │ p      │
│ 2   │ b      │ 2     │ q      │

julia&gt; categorical!(df, :Y, compress=true)
2×3 DataFrame
│ Row │ X      │ Y            │ Z      │
│     │ String │ Categorical… │ String │
├─────┼────────┼──────────────┼────────┤
│ 1   │ a      │ 1            │ p      │
│ 2   │ b      │ 2            │ q      │

julia&gt; eltype.(eachcol(df))
3-element Array{DataType,1}:
 String
 CategoricalValue{Int64,UInt8}
 String</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/f46a404bfb0b738215af1322166894a28f2361c5/src/dataframe/dataframe.jl#L1026-L1094">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataFrames.completecases" href="#DataFrames.completecases"><code>DataFrames.completecases</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">completecases(df::AbstractDataFrame, cols::Colon=:)
completecases(df::AbstractDataFrame, cols::Union{AbstractVector, Regex, Not, Between, All})
completecases(df::AbstractDataFrame, cols::Union{Integer, Symbol})</code></pre><p>Return a Boolean vector with <code>true</code> entries indicating rows without missing values (complete cases) in data frame <code>df</code>. If <code>cols</code> is provided, only missing values in the corresponding columns are considered.</p><p>See also: <a href="#DataFrames.dropmissing"><code>dropmissing</code></a> and <a href="#DataFrames.dropmissing!"><code>dropmissing!</code></a>. Use <code>findall(completecases(df))</code> to get the indices of the rows.</p><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; df = DataFrame(i = 1:5,
                      x = [missing, 4, missing, 2, 1],
                      y = [missing, missing, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;])
5×3 DataFrame
│ Row │ i     │ x       │ y       │
│     │ Int64 │ Int64⍰  │ String⍰ │
├─────┼───────┼─────────┼─────────┤
│ 1   │ 1     │ missing │ missing │
│ 2   │ 2     │ 4       │ missing │
│ 3   │ 3     │ missing │ c       │
│ 4   │ 4     │ 2       │ d       │
│ 5   │ 5     │ 1       │ e       │

julia&gt; completecases(df)
5-element BitArray{1}:
 false
 false
 false
  true
  true

julia&gt; completecases(df, :x)
5-element BitArray{1}:
 false
  true
 false
  true
  true

julia&gt; completecases(df, [:x, :y])
5-element BitArray{1}:
 false
 false
 false
  true
  true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/f46a404bfb0b738215af1322166894a28f2361c5/src/abstractdataframe/abstractdataframe.jl#L622-L674">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.copy" href="#Base.copy"><code>Base.copy</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">copy(df::DataFrame; copycols::Bool=true)</code></pre><p>Copy data frame <code>df</code>. If <code>copycols=true</code> (the default), return a new  <code>DataFrame</code> holding copies of column vectors in <code>df</code>. If <code>copycols=false</code>, return a new <code>DataFrame</code> sharing column vectors with <code>df</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/f46a404bfb0b738215af1322166894a28f2361c5/src/dataframe/dataframe.jl#L681-L688">source</a><div><div><pre><code class="language-none">copy(dfr::DataFrameRow)</code></pre><p>Construct a <code>NamedTuple</code> with the same contents as the <a href="../types/#DataFrames.DataFrameRow"><code>DataFrameRow</code></a>. This method returns a <code>NamedTuple</code> so that the returned object is not affected by changes to the parent data frame of which <code>dfr</code> is a view.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/f46a404bfb0b738215af1322166894a28f2361c5/src/dataframerow/dataframerow.jl#L212-L219">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataFrames.DataFrame!" href="#DataFrames.DataFrame!"><code>DataFrames.DataFrame!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">DataFrame!(args...; kwargs...)</code></pre><p>Equivalent to <code>DataFrame(args...; copycols=false, kwargs...)</code>.</p><p>If <code>kwargs</code> contains the <code>copycols</code> keyword argument an error is thrown.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; df1 = DataFrame(a=1:3)
3×1 DataFrame
│ Row │ a     │
│     │ Int64 │
├─────┼───────┤
│ 1   │ 1     │
│ 2   │ 2     │
│ 3   │ 3     │

julia&gt; df2 = DataFrame!(df1)

julia&gt; df1.a === df2.a
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/f46a404bfb0b738215af1322166894a28f2361c5/src/dataframe/dataframe.jl#L218-L241">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataFrames.deleterows!" href="#DataFrames.deleterows!"><code>DataFrames.deleterows!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">deleterows!(df::DataFrame, inds)</code></pre><p>Delete rows specified by <code>inds</code> from a <code>DataFrame</code> <code>df</code> in place and return it.</p><p>Internally <code>deleteat!</code> is called for all columns so <code>inds</code> must be: a vector of sorted and unique integers, a boolean vector or an integer.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; d = DataFrame(a=1:3, b=4:6)
3×2 DataFrame
│ Row │ a     │ b     │
│     │ Int64 │ Int64 │
├─────┼───────┼───────┤
│ 1   │ 1     │ 4     │
│ 2   │ 2     │ 5     │
│ 3   │ 3     │ 6     │

julia&gt; deleterows!(d, 2)
2×2 DataFrame
│ Row │ a     │ b     │
│     │ Int64 │ Int64 │
├─────┼───────┼───────┤
│ 1   │ 1     │ 4     │
│ 2   │ 3     │ 6     │</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/f46a404bfb0b738215af1322166894a28f2361c5/src/dataframe/dataframe.jl#L697-L725">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataAPI.describe" href="#DataAPI.describe"><code>DataAPI.describe</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">describe(df::AbstractDataFrame; cols=:)
describe(df::AbstractDataFrame, stats::Union{Symbol, Pair{&lt;:Symbol}}...; cols=:)</code></pre><p>Return descriptive statistics for a data frame as a new <code>DataFrame</code> where each row represents a variable and each column a summary statistic.</p><p><strong>Arguments</strong></p><ul><li><code>df</code> : the <code>AbstractDataFrame</code></li><li><code>stats::Union{Symbol, Pair{&lt;:Symbol}}...</code> : the summary statistics to report. Arguments can be:<ul><li>A symbol from the list <code>:mean</code>, <code>:std</code>, <code>:min</code>, <code>:q25</code>, <code>:median</code>, <code>:q75</code>, <code>:max</code>, <code>:eltype</code>, <code>:nunique</code>, <code>:first</code>, <code>:last</code>, and <code>:nmissing</code>. The default statistics used are <code>:mean</code>, <code>:min</code>, <code>:median</code>, <code>:max</code>, <code>:nunique</code>, <code>:nmissing</code>, and <code>:eltype</code>.</li><li><code>:all</code> as the only <code>Symbol</code> argument to return all statistics.</li><li>A <code>name =&gt; function</code> pair where <code>name</code> is a <code>Symbol</code>. This will create a column of summary statistics with the provided name.</li></ul></li><li><code>cols</code> : a keyword argument allowing to select only a subset of columns from <code>df</code> to describe; all standard column selection methods are allowed.</li></ul><p><strong>Details</strong></p><p>For <code>Real</code> columns, compute the mean, standard deviation, minimum, first quantile, median, third quantile, and maximum. If a column does not derive from <code>Real</code>, <code>describe</code> will attempt to calculate all statistics, using <code>nothing</code> as a fall-back in the case of an error.</p><p>When <code>stats</code> contains <code>:nunique</code>, <code>describe</code> will report the number of unique values in a column. If a column&#39;s base type derives from <code>Real</code>, <code>:nunique</code> will return <code>nothing</code>s.</p><p>Missing values are filtered in the calculation of all statistics, however the column <code>:nmissing</code> will report the number of missing values of that variable. If the column does not allow missing values, <code>nothing</code> is returned. Consequently, <code>nmissing = 0</code> indicates that the column allows missing values, but does not currently contain any.</p><p>If custom functions are provided, they are called repeatedly with the vector corresponding to each column as the only argument. For columns allowing for missing values, the vector is wrapped in a call to <a href="lib/@ref"><code>skipmissing</code></a>: custom functions must therefore support such objects (and not only vectors), and cannot access missing values.</p><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; df = DataFrame(i=1:10, x=0.1:0.1:1.0, y=&#39;a&#39;:&#39;j&#39;)
10×3 DataFrame
│ Row │ i     │ x       │ y    │
│     │ Int64 │ Float64 │ Char │
├─────┼───────┼─────────┼──────┤
│ 1   │ 1     │ 0.1     │ &#39;a&#39;  │
│ 2   │ 2     │ 0.2     │ &#39;b&#39;  │
│ 3   │ 3     │ 0.3     │ &#39;c&#39;  │
│ 4   │ 4     │ 0.4     │ &#39;d&#39;  │
│ 5   │ 5     │ 0.5     │ &#39;e&#39;  │
│ 6   │ 6     │ 0.6     │ &#39;f&#39;  │
│ 7   │ 7     │ 0.7     │ &#39;g&#39;  │
│ 8   │ 8     │ 0.8     │ &#39;h&#39;  │
│ 9   │ 9     │ 0.9     │ &#39;i&#39;  │
│ 10  │ 10    │ 1.0     │ &#39;j&#39;  │

julia&gt; describe(df)
3×8 DataFrame
│ Row │ variable │ mean   │ min │ median │ max │ nunique │ nmissing │ eltype   │
│     │ Symbol   │ Union… │ Any │ Union… │ Any │ Union…  │ Nothing  │ DataType │
├─────┼──────────┼────────┼─────┼────────┼─────┼─────────┼──────────┼──────────┤
│ 1   │ i        │ 5.5    │ 1   │ 5.5    │ 10  │         │          │ Int64    │
│ 2   │ x        │ 0.55   │ 0.1 │ 0.55   │ 1.0 │         │          │ Float64  │
│ 3   │ y        │        │ &#39;a&#39; │        │ &#39;j&#39; │ 10      │          │ Char     │

julia&gt; describe(df, :min, :max)
3×3 DataFrame
│ Row │ variable │ min │ max │
│     │ Symbol   │ Any │ Any │
├─────┼──────────┼─────┼─────┤
│ 1   │ i        │ 1   │ 10  │
│ 2   │ x        │ 0.1 │ 1.0 │
│ 3   │ y        │ &#39;a&#39; │ &#39;j&#39; │

julia&gt; describe(df, :min, :sum =&gt; sum)
3×3 DataFrame
│ Row │ variable │ min │ sum │
│     │ Symbol   │ Any │ Any │
├─────┼──────────┼─────┼─────┤
│ 1   │ i        │ 1   │ 55  │
│ 2   │ x        │ 0.1 │ 5.5 │
│ 3   │ y        │ &#39;a&#39; │     │

julia&gt; describe(df, :min, :sum =&gt; sum, cols=:x)
1×3 DataFrame
│ Row │ variable │ min     │ sum     │
│     │ Symbol   │ Float64 │ Float64 │
├─────┼──────────┼─────────┼─────────┤
│ 1   │ x        │ 0.1     │ 5.5     │</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/f46a404bfb0b738215af1322166894a28f2361c5/src/abstractdataframe/abstractdataframe.jl#L381-L474">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Missings.disallowmissing" href="#Missings.disallowmissing"><code>Missings.disallowmissing</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">disallowmissing(df::AbstractDataFrame,
                cols::Union{ColumnIndex, AbstractVector, Regex, Not, Between, All, Colon}=:;
                error::Bool=true)</code></pre><p>Return a copy of data frame <code>df</code> with columns <code>cols</code> converted from element type <code>Union{T, Missing}</code> to <code>T</code> to drop support for missing values.</p><p>If <code>cols</code> is omitted all columns in the data frame are converted.</p><p>If <code>error=false</code> then columns containing a <code>missing</code> value will be skipped instead of throwing an error.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; df = DataFrame(a=Union{Int,Missing}[1,2])
2×1 DataFrame
│ Row │ a      │
│     │ Int64⍰ │
├─────┼────────┤
│ 1   │ 1      │
│ 2   │ 2      │

julia&gt; disallowmissing(df)
2×1 DataFrame
│ Row │ a     │
│     │ Int64 │
├─────┼───────┤
│ 1   │ 1     │
│ 2   │ 2     │</code></pre><p>julia&gt; df = DataFrame(a=[1,missing]) 2×2 DataFrame │ Row │ a       │ b      │ │     │ Int64⍰  │ Int64⍰ │ ├─────┼─────────┼────────┤ │ 1   │ 1       │ 1      │ │ 2   │ missing │ 2      │</p><p>julia&gt; disallowmissing(df, error=false) 2×2 DataFrame │ Row │ a       │ b     │ │     │ Int64⍰  │ Int64 │ ├─────┼─────────┼───────┤ │ 1   │ 1       │ 1     │ │ 2   │ missing │ 2     │</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/f46a404bfb0b738215af1322166894a28f2361c5/src/abstractdataframe/abstractdataframe.jl#L1383-L1430">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataFrames.disallowmissing!" href="#DataFrames.disallowmissing!"><code>DataFrames.disallowmissing!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">disallowmissing!(df::DataFrame, cols::Colon=:; error::Bool=true)
disallowmissing!(df::DataFrame, cols::Union{Integer, Symbol}; error::Bool=true)
disallowmissing!(df::DataFrame, cols::Union{AbstractVector, Regex, Not, Between, All};
                 error::Bool=true)</code></pre><p>Convert columns <code>cols</code> of data frame <code>df</code> from element type <code>Union{T, Missing}</code> to <code>T</code> to drop support for missing values.</p><p>If <code>cols</code> is omitted all columns in the data frame are converted.</p><p>If <code>error=false</code> then columns containing a <code>missing</code> value will be skipped instead of throwing an error.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/f46a404bfb0b738215af1322166894a28f2361c5/src/dataframe/dataframe.jl#L975-L987">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataFrames.dropmissing" href="#DataFrames.dropmissing"><code>DataFrames.dropmissing</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">dropmissing(df::AbstractDataFrame, cols::Colon=:; disallowmissing::Bool=true)
dropmissing(df::AbstractDataFrame, cols::Union{AbstractVector, Regex, Not, Between, All};
            disallowmissing::Bool=true)
dropmissing(df::AbstractDataFrame, cols::Union{Integer, Symbol};
            disallowmissing::Bool=true)</code></pre><p>Return a copy of data frame <code>df</code> excluding rows with missing values. If <code>cols</code> is provided, only missing values in the corresponding columns are considered.</p><p>If <code>disallowmissing</code> is <code>true</code> (the default) then columns specified in <code>cols</code> will be converted so as not to allow for missing values using <a href="#DataFrames.disallowmissing!"><code>disallowmissing!</code></a>.</p><p>See also: <a href="#DataFrames.completecases"><code>completecases</code></a> and <a href="#DataFrames.dropmissing!"><code>dropmissing!</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; df = DataFrame(i = 1:5,
                      x = [missing, 4, missing, 2, 1],
                      y = [missing, missing, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;])
5×3 DataFrame
│ Row │ i     │ x       │ y       │
│     │ Int64 │ Int64⍰  │ String⍰ │
├─────┼───────┼─────────┼─────────┤
│ 1   │ 1     │ missing │ missing │
│ 2   │ 2     │ 4       │ missing │
│ 3   │ 3     │ missing │ c       │
│ 4   │ 4     │ 2       │ d       │
│ 5   │ 5     │ 1       │ e       │

julia&gt; dropmissing(df)
2×3 DataFrame
│ Row │ i     │ x     │ y      │
│     │ Int64 │ Int64 │ String │
├─────┼───────┼───────┼────────┤
│ 1   │ 4     │ 2     │ d      │
│ 2   │ 5     │ 1     │ e      │

julia&gt; dropmissing(df, disallowmissing=false)
2×3 DataFrame
│ Row │ i     │ x      │ y       │
│     │ Int64 │ Int64⍰ │ String⍰ │
├─────┼───────┼────────┼─────────┤
│ 1   │ 4     │ 2      │ d       │
│ 2   │ 5     │ 1      │ e       │

julia&gt; dropmissing(df, :x)
3×3 DataFrame
│ Row │ i     │ x     │ y       │
│     │ Int64 │ Int64 │ String⍰ │
├─────┼───────┼───────┼─────────┤
│ 1   │ 2     │ 4     │ missing │
│ 2   │ 4     │ 2     │ d       │
│ 3   │ 5     │ 1     │ e       │

julia&gt; dropmissing(df, [:x, :y])
2×3 DataFrame
│ Row │ i     │ x     │ y      │
│     │ Int64 │ Int64 │ String │
├─────┼───────┼───────┼────────┤
│ 1   │ 4     │ 2     │ d      │
│ 2   │ 5     │ 1     │ e      │</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/f46a404bfb0b738215af1322166894a28f2361c5/src/abstractdataframe/abstractdataframe.jl#L695-L759">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataFrames.dropmissing!" href="#DataFrames.dropmissing!"><code>DataFrames.dropmissing!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">dropmissing!(df::AbstractDataFrame, cols::Colon=:; disallowmissing::Bool=true)
dropmissing!(df::AbstractDataFrame, cols::Union{AbstractVector, Regex, Not, Between, All};
             disallowmissing::Bool=true)
dropmissing!(df::AbstractDataFrame, cols::Union{Integer, Symbol};
             disallowmissing::Bool=true)</code></pre><p>Remove rows with missing values from data frame <code>df</code> and return it. If <code>cols</code> is provided, only missing values in the corresponding columns are considered.</p><p>If <code>disallowmissing</code> is <code>true</code> (the default) then the <code>cols</code> columns will get converted using <a href="#DataFrames.disallowmissing!"><code>disallowmissing!</code></a>.</p><p>See also: <a href="#DataFrames.dropmissing"><code>dropmissing</code></a> and <a href="#DataFrames.completecases"><code>completecases</code></a>.</p><pre><code class="language-julia-repl">julia&gt; df = DataFrame(i = 1:5,
                      x = [missing, 4, missing, 2, 1],
                      y = [missing, missing, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;])
5×3 DataFrame
│ Row │ i     │ x       │ y       │
│     │ Int64 │ Int64⍰  │ String⍰ │
├─────┼───────┼─────────┼─────────┤
│ 1   │ 1     │ missing │ missing │
│ 2   │ 2     │ 4       │ missing │
│ 3   │ 3     │ missing │ c       │
│ 4   │ 4     │ 2       │ d       │
│ 5   │ 5     │ 1       │ e       │

julia&gt; dropmissing!(copy(df))
2×3 DataFrame
│ Row │ i     │ x     │ y      │
│     │ Int64 │ Int64 │ String │
├─────┼───────┼───────┼────────┤
│ 1   │ 4     │ 2     │ d      │
│ 2   │ 5     │ 1     │ e      │

julia&gt; dropmissing!(copy(df), disallowmissing=false)
2×3 DataFrame
│ Row │ i     │ x      │ y       │
│     │ Int64 │ Int64⍰ │ String⍰ │
├─────┼───────┼────────┼─────────┤
│ 1   │ 4     │ 2      │ d       │
│ 2   │ 5     │ 1      │ e       │

julia&gt; dropmissing!(copy(df), :x)
3×3 DataFrame
│ Row │ i     │ x     │ y       │
│     │ Int64 │ Int64 │ String⍰ │
├─────┼───────┼───────┼─────────┤
│ 1   │ 2     │ 4     │ missing │
│ 2   │ 4     │ 2     │ d       │
│ 3   │ 5     │ 1     │ e       │

julia&gt; dropmissing!(df3, [:x, :y])
2×3 DataFrame
│ Row │ i     │ x     │ y      │
│     │ Int64 │ Int64 │ String │
├─────┼───────┼───────┼────────┤
│ 1   │ 4     │ 2     │ d      │
│ 2   │ 5     │ 1     │ e      │</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/f46a404bfb0b738215af1322166894a28f2361c5/src/abstractdataframe/abstractdataframe.jl#L768-L830">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Compat.eachrow" href="#Compat.eachrow"><code>Compat.eachrow</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">eachrow(df::AbstractDataFrame)</code></pre><p>Return a <code>DataFrameRows</code> that iterates a data frame row by row, with each row represented as a <code>DataFrameRow</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; df = DataFrame(x=1:4, y=11:14)
4×2 DataFrame
│ Row │ x     │ y     │
│     │ Int64 │ Int64 │
├─────┼───────┼───────┤
│ 1   │ 1     │ 11    │
│ 2   │ 2     │ 12    │
│ 3   │ 3     │ 13    │
│ 4   │ 4     │ 14    │

julia&gt; eachrow(df)
4-element DataFrameRows:
 DataFrameRow (row 1)
x  1
y  11
 DataFrameRow (row 2)
x  2
y  12
 DataFrameRow (row 3)
x  3
y  13
 DataFrameRow (row 4)
x  4
y  14

julia&gt; copy.(eachrow(df))
4-element Array{NamedTuple{(:x, :y),Tuple{Int64,Int64}},1}:
 (x = 1, y = 11)
 (x = 2, y = 12)
 (x = 3, y = 13)
 (x = 4, y = 14)

julia&gt; eachrow(view(df, [4,3], [2,1]))
2-element DataFrameRows:
 DataFrameRow (row 4)
y  14
x  4
 DataFrameRow (row 3)
y  13
x  3</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/f46a404bfb0b738215af1322166894a28f2361c5/src/abstractdataframe/iteration.jl#L23-L72">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Compat.eachcol" href="#Compat.eachcol"><code>Compat.eachcol</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">eachcol(df::AbstractDataFrame, names::Bool=false)</code></pre><p>Return a <code>DataFrameColumns</code> that iterates an <code>AbstractDataFrame</code> column by column. If <code>names</code> is equal to <code>false</code> (the default) iteration returns column vectors. If <code>names</code> is equal to <code>true</code> pairs consisting of column name and column vector are yielded.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; df = DataFrame(x=1:4, y=11:14)
4×2 DataFrame
│ Row │ x     │ y     │
│     │ Int64 │ Int64 │
├─────┼───────┼───────┤
│ 1   │ 1     │ 11    │
│ 2   │ 2     │ 12    │
│ 3   │ 3     │ 13    │
│ 4   │ 4     │ 14    │

julia&gt; collect(eachcol(df))
2-element Array{AbstractArray{T,1} where T,1}:
 [1, 2, 3, 4]
 [11, 12, 13, 14]

julia&gt; map(eachcol(df)) do col
           maximum(col) - minimum(col)
       end
2-element Array{Int64,1}:
 3
 3

julia&gt; sum.(eachcol(df))
2-element Array{Int64,1}:
 10
 50

julia&gt; collect(eachcol(df, true))
2-element Array{Pair{Symbol,AbstractArray{T,1} where T},1}:
 :x =&gt; [1, 2, 3, 4]
 :y =&gt; [11, 12, 13, 14]</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/f46a404bfb0b738215af1322166894a28f2361c5/src/abstractdataframe/iteration.jl#L110-L152">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.filter" href="#Base.filter"><code>Base.filter</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">filter(function, df::AbstractDataFrame)</code></pre><p>Return a copy of data frame <code>df</code> containing only rows for which <code>function</code> returns <code>true</code>. The function is passed a <code>DataFrameRow</code> as its only argument.</p><p><strong>Examples</strong></p><pre><code class="language-none">julia&gt; df = DataFrame(x = [3, 1, 2, 1], y = [&quot;b&quot;, &quot;c&quot;, &quot;a&quot;, &quot;b&quot;])
4×2 DataFrame
│ Row │ x     │ y      │
│     │ Int64 │ String │
├─────┼───────┼────────┤
│ 1   │ 3     │ b      │
│ 2   │ 1     │ c      │
│ 3   │ 2     │ a      │
│ 4   │ 1     │ b      │

julia&gt; filter(row -&gt; row[:x] &gt; 1, df)
2×2 DataFrame
│ Row │ x     │ y      │
│     │ Int64 │ String │
├─────┼───────┼────────┤
│ 1   │ 3     │ b      │
│ 2   │ 2     │ a      │</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/f46a404bfb0b738215af1322166894a28f2361c5/src/abstractdataframe/abstractdataframe.jl#L839-L865">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.filter!" href="#Base.filter!"><code>Base.filter!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">filter!(function, df::AbstractDataFrame)</code></pre><p>Remove rows from data frame <code>df</code> for which <code>function</code> returns <code>false</code>. The function is passed a <code>DataFrameRow</code> as its only argument.</p><p><strong>Examples</strong></p><pre><code class="language-none">julia&gt; df = DataFrame(x = [3, 1, 2, 1], y = [&quot;b&quot;, &quot;c&quot;, &quot;a&quot;, &quot;b&quot;])
4×2 DataFrame
│ Row │ x     │ y      │
│     │ Int64 │ String │
├─────┼───────┼────────┤
│ 1   │ 3     │ b      │
│ 2   │ 1     │ c      │
│ 3   │ 2     │ a      │
│ 4   │ 1     │ b      │

julia&gt; filter!(row -&gt; row[:x] &gt; 1, df);

julia&gt; df
2×2 DataFrame
│ Row │ x     │ y      │
│     │ Int64 │ String │
├─────┼───────┼────────┤
│ 1   │ 3     │ b      │
│ 2   │ 2     │ a      │</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/f46a404bfb0b738215af1322166894a28f2361c5/src/abstractdataframe/abstractdataframe.jl#L868-L896">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataFrames.flatten" href="#DataFrames.flatten"><code>DataFrames.flatten</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">flatten(df::AbstractDataFrame, col::Union{Integer, Symbol})</code></pre><p>When column <code>col</code> of data frame <code>df</code> has iterable elements that define <code>length</code> (for example a <code>Vector</code> of <code>Vector</code>s), return a <code>DataFrame</code> where each element of <code>col</code> is flattened, meaning the column corresponding to <code>col</code> becomes a longer <code>Vector</code> where the original entries are concatenated. Elements of row <code>i</code> of <code>df</code> in columns other than <code>col</code> will be repeated according to the length of <code>df[i, col]</code>. Note that these elements are not copied, and thus if they are mutable changing them in the returned <code>DataFrame</code> will affect <code>df</code>.</p><p><strong>Examples</strong></p><pre><code class="language-none">julia&gt; df1 = DataFrame(a = [1, 2], b = [[1, 2], [3, 4]])
2×2 DataFrame
│ Row │ a     │ b      │
│     │ Int64 │ Array… │
├─────┼───────┼────────┤
│ 1   │ 1     │ [1, 2] │
│ 2   │ 2     │ [3, 4] │

julia&gt; flatten(df1, :b)
4×2 DataFrame
│ Row │ a     │ b     │
│     │ Int64 │ Int64 │
├─────┼───────┼───────┤
│ 1   │ 1     │ 1     │
│ 2   │ 1     │ 2     │
│ 3   │ 2     │ 3     │
│ 4   │ 2     │ 4     │

julia&gt; df2 = DataFrame(a = [1, 2], b = [(&quot;p&quot;, &quot;q&quot;), (&quot;r&quot;, &quot;s&quot;)])
2×2 DataFrame
│ Row │ a     │ b          │
│     │ Int64 │ Tuple…     │
├─────┼───────┼────────────┤
│ 1   │ 1     │ (&quot;p&quot;, &quot;q&quot;) │
│ 2   │ 2     │ (&quot;r&quot;, &quot;s&quot;) │

julia&gt; flatten(df2, :b)
4×2 DataFrame
│ Row │ a     │ b      │
│     │ Int64 │ String │
├─────┼───────┼────────┤
│ 1   │ 1     │ p      │
│ 2   │ 1     │ q      │
│ 3   │ 2     │ r      │
│ 4   │ 2     │ s      │
</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/f46a404bfb0b738215af1322166894a28f2361c5/src/abstractdataframe/abstractdataframe.jl#L1575-L1625">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.hcat" href="#Base.hcat"><code>Base.hcat</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">hcat(df::AbstractDataFrame...;
     makeunique::Bool=false, copycols::Bool=true)
hcat(df::AbstractDataFrame..., vs::AbstractVector;
     makeunique::Bool=false, copycols::Bool=true)
hcat(vs::AbstractVector, df::AbstractDataFrame;
     makeunique::Bool=false, copycols::Bool=true)</code></pre><p>Horizontally concatenate <code>AbstractDataFrames</code> and optionally <code>AbstractVector</code>s.</p><p>If <code>AbstractVector</code> is passed then a column name for it is automatically generated as <code>:x1</code> by default.</p><p>If <code>makeunique=false</code> (the default) column names of passed objects must be unique. If <code>makeunique=true</code> then duplicate column names will be suffixed with <code>_i</code> (<code>i</code> starting at 1 for the first duplicate).</p><p>If <code>copycols=true</code> (the default) then the <code>DataFrame</code> returned by <code>hcat</code> will contain copied columns from the source data frames. If <code>copycols=false</code> then it will contain columns as they are stored in the source (without copying). This option should be used with caution as mutating either the columns in sources or in the returned <code>DataFrame</code> might lead to the corruption of the other object.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia [DataFrame(A=1:3) DataFrame(B=1:3)]
3×2 DataFrame
│ Row │ A     │ B     │
│     │ Int64 │ Int64 │
├─────┼───────┼───────┤
│ 1   │ 1     │ 1     │
│ 2   │ 2     │ 2     │
│ 3   │ 3     │ 3     │

julia&gt; df1 = DataFrame(A=1:3, B=1:3);

julia&gt; df2 = DataFrame(A=4:6, B=4:6);

julia&gt; df3 = hcat(df1, df2, makeunique=true)
3×4 DataFrame
│ Row │ A     │ B     │ A_1   │ B_1   │
│     │ Int64 │ Int64 │ Int64 │ Int64 │
├─────┼───────┼───────┼───────┼───────┤
│ 1   │ 1     │ 1     │ 4     │ 4     │
│ 2   │ 2     │ 2     │ 5     │ 5     │
│ 3   │ 3     │ 3     │ 6     │ 6     │

julia&gt; df3.A === df1.A
false

julia&gt; df3 = hcat(df1, df2, makeunique=true, copycols=false);

julia&gt; df3.A === df1.A
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/f46a404bfb0b738215af1322166894a28f2361c5/src/abstractdataframe/abstractdataframe.jl#L1019-L1075">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataFrames.insertcols!" href="#DataFrames.insertcols!"><code>DataFrames.insertcols!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">insertcols!(df::DataFrame, ind::Int; name=col,
            makeunique::Bool=false)
insertcols!(df::DataFrame, ind::Int, (:name =&gt; col)::Pair{Symbol,&lt;:AbstractVector};
            makeunique::Bool=false)</code></pre><p>Insert a column into a data frame in place. Return the updated <code>DataFrame</code>.</p><p><strong>Arguments</strong></p><ul><li><code>df</code> : the DataFrame to which we want to add a column</li><li><code>ind</code> : a position at which we want to insert a column</li><li><code>name</code> : the name of the new column</li><li><code>col</code> : an <code>AbstractVector</code> giving the contents of the new column</li><li><code>makeunique</code> : Defines what to do if <code>name</code> already exists in <code>df</code>; if it is <code>false</code> an error will be thrown; if it is <code>true</code> a new unique name will be generated by adding a suffix</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; d = DataFrame(a=1:3)
3×1 DataFrame
│ Row │ a     │
│     │ Int64 │
├─────┼───────┤
│ 1   │ 1     │
│ 2   │ 2     │
│ 3   │ 3     │

julia&gt; insertcols!(d, 1, b=[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;])
3×2 DataFrame
│ Row │ b    │ a     │
│     │ Char │ Int64 │
├─────┼──────┼───────┤
│ 1   │ &#39;a&#39;  │ 1     │
│ 2   │ &#39;b&#39;  │ 2     │
│ 3   │ &#39;c&#39;  │ 3     │

julia&gt; insertcols!(d, 1, :c =&gt; [2, 3, 4])
3×3 DataFrame
│ Row │ c     │ b    │ a     │
│     │ Int64 │ Char │ Int64 │
├─────┼───────┼──────┼───────┤
│ 1   │ 2     │ &#39;a&#39;  │ 1     │
│ 2   │ 3     │ &#39;b&#39;  │ 2     │
│ 3   │ 4     │ &#39;c&#39;  │ 3     │</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/f46a404bfb0b738215af1322166894a28f2361c5/src/dataframe/dataframe.jl#L591-L637">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataFrames.mapcols" href="#DataFrames.mapcols"><code>DataFrames.mapcols</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">mapcols(f::Union{Function,Type}, df::AbstractDataFrame)</code></pre><p>Return a <code>DataFrame</code> where each column of <code>df</code> is transformed using function <code>f</code>. <code>f</code> must return <code>AbstractVector</code> objects all with the same length or scalars.</p><p>Note that <code>mapcols</code> guarantees not to reuse the columns from <code>df</code> in the returned <code>DataFrame</code>. If <code>f</code> returns its argument then it gets copied before being stored.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; df = DataFrame(x=1:4, y=11:14)
4×2 DataFrame
│ Row │ x     │ y     │
│     │ Int64 │ Int64 │
├─────┼───────┼───────┤
│ 1   │ 1     │ 11    │
│ 2   │ 2     │ 12    │
│ 3   │ 3     │ 13    │
│ 4   │ 4     │ 14    │

julia&gt; mapcols(x -&gt; x.^2, df)
4×2 DataFrame
│ Row │ x     │ y     │
│     │ Int64 │ Int64 │
├─────┼───────┼───────┤
│ 1   │ 1     │ 121   │
│ 2   │ 4     │ 144   │
│ 3   │ 9     │ 169   │
│ 4   │ 16    │ 196   │</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/f46a404bfb0b738215af1322166894a28f2361c5/src/abstractdataframe/iteration.jl#L179-L210">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.names" href="#Base.names"><code>Base.names</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">names(df::AbstractDataFrame)

Return a `Vector{Symbol}` of names of columns contained in `df`.</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/f46a404bfb0b738215af1322166894a28f2361c5/src/abstractdataframe/abstractdataframe.jl#L60-L64">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataFrames.nonunique" href="#DataFrames.nonunique"><code>DataFrames.nonunique</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">nonunique(df::AbstractDataFrame)
nonunique(df::AbstractDataFrame, cols)</code></pre><p>Return a <code>Vector{Bool}</code> in which <code>true</code> entries indicate duplicate rows. A row is a duplicate if there exists a prior row with all columns containing equal values (according to <code>isequal</code>).</p><p>See also <a href="lib/@ref"><code>unique</code></a> and <a href="#Base.unique!"><code>unique!</code></a>.</p><p><strong>Arguments</strong></p><ul><li><code>df</code> : the AbstractDataFrame</li><li><code>cols</code> : a column indicator (Symbol, Int, Vector{Symbol}, etc.) specifying the column(s) to compare</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia">df = DataFrame(i = 1:10, x = rand(10), y = rand([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;], 10))
df = vcat(df, df)
nonunique(df)
nonunique(df, 1)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/f46a404bfb0b738215af1322166894a28f2361c5/src/abstractdataframe/abstractdataframe.jl#L932-L954">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataFrames.nrow" href="#DataFrames.nrow"><code>DataFrames.nrow</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">nrow(df::AbstractDataFrame)
ncol(df::AbstractDataFrame)</code></pre><p>Return the number of rows or columns in an <code>AbstractDataFrame</code> <code>df</code>.</p><p>See also <a href="lib/@ref"><code>size</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; df = DataFrame(i = 1:10, x = rand(10), y = rand([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;], 10));

julia&gt; size(df)
(10, 3)

julia&gt; nrow(df)
10

julia&gt; ncol(df)
3</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/f46a404bfb0b738215af1322166894a28f2361c5/src/abstractdataframe/abstractdataframe.jl#L1357-L1380">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataFrames.ncol" href="#DataFrames.ncol"><code>DataFrames.ncol</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">nrow(df::AbstractDataFrame)
ncol(df::AbstractDataFrame)</code></pre><p>Return the number of rows or columns in an <code>AbstractDataFrame</code> <code>df</code>.</p><p>See also <a href="lib/lib/@ref"><code>size</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; df = DataFrame(i = 1:10, x = rand(10), y = rand([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;], 10));

julia&gt; size(df)
(10, 3)

julia&gt; nrow(df)
10

julia&gt; ncol(df)
3</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/f46a404bfb0b738215af1322166894a28f2361c5/src/abstractdataframe/abstractdataframe.jl#L1357-L1380">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataFrames.rename!" href="#DataFrames.rename!"><code>DataFrames.rename!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">rename!(df::AbstractDataFrame, vals::AbstractVector{Symbol}; makeunique::Bool=false)
rename!(df::AbstractDataFrame, vals::AbstractVector{&lt;:AbstractString}; makeunique::Bool=false)
rename!(df::AbstractDataFrame, (from =&gt; to)::Pair...)
rename!(df::AbstractDataFrame, d::AbstractDict)
rename!(df::AbstractDataFrame, d::AbstractArray{&lt;:Pair})
rename!(f::Function, df::AbstractDataFrame)</code></pre><p>Rename columns of <code>df</code> in-place. Each name is changed at most once. Permutation of names is allowed.</p><p><strong>Arguments</strong></p><ul><li><code>df</code> : the <code>AbstractDataFrame</code></li><li><code>d</code> : an <code>AbstractDict</code> or an <code>AbstractVector</code> of <code>Pair</code>s that maps the original names or column numbers to new names</li><li><code>f</code> : a function which for each column takes the old name (a <code>Symbol</code>) and returns the new name that gets converted to a <code>Symbol</code></li><li><code>vals</code> : new column names as a vector of <code>Symbol</code>s or <code>AbstractString</code>s of the same length as the number of columns in <code>df</code></li><li><code>makeunique</code> : if <code>false</code> (the default), an error will be raised if duplicate names are found; if <code>true</code>, duplicate names will be suffixed with <code>_i</code> (<code>i</code> starting at 1 for the first duplicate).</li></ul><p>If pairs are passed to <code>rename!</code> (as positional arguments or in a dictionary or a vector) then:</p><ul><li><code>from</code> value can be a <code>Symbol</code>, an <code>AbstractString</code> or an <code>Integer</code>;</li><li><code>to</code> value can be a <code>Symbol</code> or an <code>AbstractString</code>.</li></ul><p>Mixing symbols and strings in <code>to</code> and <code>from</code> is not allowed.</p><p>See also: <a href="#DataFrames.rename"><code>rename</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; df = DataFrame(i = 1, x = 2, y = 3)
1×3 DataFrame
│ Row │ i     │ x     │ y     │
│     │ Int64 │ Int64 │ Int64 │
├─────┼───────┼───────┼───────┤
│ 1   │ 1     │ 2     │ 3     │

julia&gt; rename!(df, Dict(:i =&gt; &quot;A&quot;, :x =&gt; &quot;X&quot;))
1×3 DataFrame
│ Row │ A     │ X     │ y     │
│     │ Int64 │ Int64 │ Int64 │
├─────┼───────┼───────┼───────┤
│ 1   │ 1     │ 2     │ 3     │

julia&gt; rename!(df, [:a, :b, :c])
1×3 DataFrame
│ Row │ a     │ b     │ c     │
│     │ Int64 │ Int64 │ Int64 │
├─────┼───────┼───────┼───────┤
│ 1   │ 1     │ 2     │ 3     │

julia&gt; rename!(df, [:a, :b, :a])
ERROR: ArgumentError: Duplicate variable names: :a. Pass makeunique=true to make them unique using a suffix automatically.

julia&gt; rename!(df, [:a, :b, :a], makeunique=true)
1×3 DataFrame
│ Row │ a     │ b     │ a_1   │
│     │ Int64 │ Int64 │ Int64 │
├─────┼───────┼───────┼───────┤
│ 1   │ 1     │ 2     │ 3     │

julia&gt; rename!(df) do x
           uppercase(string(x))
       end
1×3 DataFrame
│ Row │ A     │ B     │ A_1   │
│     │ Int64 │ Int64 │ Int64 │
├─────┼───────┼───────┼───────┤
│ 1   │ 1     │ 2     │ 3     │</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/f46a404bfb0b738215af1322166894a28f2361c5/src/abstractdataframe/abstractdataframe.jl#L70-L144">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataFrames.rename" href="#DataFrames.rename"><code>DataFrames.rename</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">rename(df::AbstractDataFrame, vals::AbstractVector{Symbol}; makeunique::Bool=false)
rename(df::AbstractDataFrame, vals::AbstractVector{&lt;:AbstractString}; makeunique::Bool=false)
rename(df::AbstractDataFrame, (from =&gt; to)::Pair...)
rename(df::AbstractDataFrame, d::AbstractDict)
rename(df::AbstractDataFrame, d::AbstractArray{&lt;:Pair})
rename(f::Function, df::AbstractDataFrame)</code></pre><p>Create a new data frame that is a copy of <code>df</code> with changed column names. Each name is changed at most once. Permutation of names is allowed.</p><p><strong>Arguments</strong></p><ul><li><code>df</code> : the <code>AbstractDataFrame</code></li><li><code>d</code> : an <code>AbstractDict</code> or an <code>AbstractVector</code> of <code>Pair</code>s that maps the original names or column numbers to new names</li><li><code>f</code> : a function which for each column takes the old name (a <code>Symbol</code>) and returns the new name that gets converted to a <code>Symbol</code></li><li><code>vals</code> : new column names as a vector of <code>Symbol</code>s or <code>AbstractString</code>s of the same length as the number of columns in <code>df</code></li><li><code>makeunique</code> : if <code>false</code> (the default), an error will be raised if duplicate names are found; if <code>true</code>, duplicate names will be suffixed with <code>_i</code> (<code>i</code> starting at 1 for the first duplicate).</li></ul><p>If pairs are passed to <code>rename</code> (as positional arguments or in a dictionary or a vector) then:</p><ul><li><code>from</code> value can be a <code>Symbol</code>, an <code>AbstractString</code> or an <code>Integer</code>;</li><li><code>to</code> value can be a <code>Symbol</code> or an <code>AbstractString</code>.</li></ul><p>Mixing symbols and strings in <code>to</code> and <code>from</code> is not allowed.</p><p>See also: <a href="#DataFrames.rename!"><code>rename!</code></a></p><p><strong>Examples</strong></p><p>```julia julia&gt; df = DataFrame(i = 1, x = 2, y = 3) 1×3 DataFrame │ Row │ i     │ x     │ y     │ │     │ Int64 │ Int64 │ Int64 │ ├─────┼───────┼───────┼───────┤ │ 1   │ 1     │ 2     │ 3     │</p><p>julia&gt; rename(df, :i =&gt; :A, :x =&gt; :X) 1×3 DataFrame │ Row │ A     │ X     │ y     │ │     │ Int64 │ Int64 │ Int64 │ ├─────┼───────┼───────┼───────┤ │ 1   │ 1     │ 2     │ 3     │</p><p>julia&gt; rename(df, :x =&gt; :y, :y =&gt; :x) 1×3 DataFrame │ Row │ i     │ y     │ x     │ │     │ Int64 │ Int64 │ Int64 │ ├─────┼───────┼───────┼───────┤ │ 1   │ 1     │ 2     │ 3     │</p><p>julia&gt; rename(df, [1 =&gt; :A, 2 =&gt; :X]) 1×3 DataFrame │ Row │ A     │ X     │ y     │ │     │ Int64 │ Int64 │ Int64 │ ├─────┼───────┼───────┼───────┤ │ 1   │ 1     │ 2     │ 3     │</p><p>julia&gt; rename(df, Dict(&quot;i&quot; =&gt; &quot;A&quot;, &quot;x&quot; =&gt; &quot;X&quot;)) 1×3 DataFrame │ Row │ A     │ X     │ y     │ │     │ Int64 │ Int64 │ Int64 │ ├─────┼───────┼───────┼───────┤ │ 1   │ 1     │ 2     │ 3     │</p><p>julia&gt; rename(df) do x            uppercase(string(x))        end 1×3 DataFrame │ Row │ I     │ X     │ Y     │ │     │ Int64 │ Int64 │ Int64 │ ├─────┼───────┼───────┼───────┤ │ 1   │ 1     │ 2     │ 3     │```</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/f46a404bfb0b738215af1322166894a28f2361c5/src/abstractdataframe/abstractdataframe.jl#L190-L267">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.repeat" href="#Base.repeat"><code>Base.repeat</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">repeat(df::AbstractDataFrame; inner::Integer = 1, outer::Integer = 1)</code></pre><p>Construct a data frame by repeating rows in <code>df</code>. <code>inner</code> specifies how many times each row is repeated, and <code>outer</code> specifies how many times the full set of rows is repeated.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; df = DataFrame(a = 1:2, b = 3:4)
2×2 DataFrame
│ Row │ a     │ b     │
│     │ Int64 │ Int64 │
├─────┼───────┼───────┤
│ 1   │ 1     │ 3     │
│ 2   │ 2     │ 4     │

julia&gt; repeat(df, inner = 2, outer = 3)
12×2 DataFrame
│ Row │ a     │ b     │
│     │ Int64 │ Int64 │
├─────┼───────┼───────┤
│ 1   │ 1     │ 3     │
│ 2   │ 1     │ 3     │
│ 3   │ 2     │ 4     │
│ 4   │ 2     │ 4     │
│ 5   │ 1     │ 3     │
│ 6   │ 1     │ 3     │
│ 7   │ 2     │ 4     │
│ 8   │ 2     │ 4     │
│ 9   │ 1     │ 3     │
│ 10  │ 1     │ 3     │
│ 11  │ 2     │ 4     │
│ 12  │ 2     │ 4     │</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/f46a404bfb0b738215af1322166894a28f2361c5/src/abstractdataframe/abstractdataframe.jl#L1263-L1298">source</a><div><div><pre><code class="language-none">repeat(df::AbstractDataFrame, count::Integer)</code></pre><p>Construct a data frame by repeating each row in <code>df</code> the number of times specified by <code>count</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; df = DataFrame(a = 1:2, b = 3:4)
2×2 DataFrame
│ Row │ a     │ b     │
│     │ Int64 │ Int64 │
├─────┼───────┼───────┤
│ 1   │ 1     │ 3     │
│ 2   │ 2     │ 4     │

julia&gt; repeat(df, 2)
4×2 DataFrame
│ Row │ a     │ b     │
│     │ Int64 │ Int64 │
├─────┼───────┼───────┤
│ 1   │ 1     │ 3     │
│ 2   │ 2     │ 4     │
│ 3   │ 1     │ 3     │
│ 4   │ 2     │ 4     │</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/f46a404bfb0b738215af1322166894a28f2361c5/src/abstractdataframe/abstractdataframe.jl#L1302-L1328">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataFrames.select" href="#DataFrames.select"><code>DataFrames.select</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">select(df::AbstractDataFrame, inds...; copycols::Bool=true)</code></pre><p>Create a new data frame that contains columns from <code>df</code> specified by <code>inds</code> and return it.</p><p>Arguments passed as <code>inds...</code> can be any index that is allowed for column indexing provided that the columns requested in each of them are unique and present in <code>df</code>. In particular, regular expressions, <code>All</code>, <code>Between</code>, and <code>Not</code> selectors  are supported.</p><p>If more than one argument is passed then they are joined as <code>All(inds...)</code>. Note that <code>All</code> selects the union of columns passed to it, so columns selected in different <code>inds...</code> do not have to be unique. For example a call <code>select(df, :col, All())</code> is valid and creates a new data frame with column <code>:col</code> moved to be the first, provided it is present in <code>df</code>.</p><p>If <code>df</code> is a <code>DataFrame</code> return a new <code>DataFrame</code> that contains columns from <code>df</code> specified by <code>inds</code>. If <code>copycols=true</code> (the default), then returned <code>DataFrame</code> holds copies of column vectors in <code>df</code>. If <code>copycols=false</code>, then returned <code>DataFrame</code> shares column vectors with <code>df</code>.</p><p>If <code>df</code> is a <code>SubDataFrame</code> then a <code>SubDataFrame</code> is returned if <code>copycols=false</code> and a <code>DataFrame</code> with freshly allocated columns otherwise.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; df = DataFrame(a=1:3, b=4:6)
3×2 DataFrame
│ Row │ a     │ b     │
│     │ Int64 │ Int64 │
├─────┼───────┼───────┤
│ 1   │ 1     │ 4     │
│ 2   │ 2     │ 5     │
│ 3   │ 3     │ 6     │

julia&gt; select(df, :b)
3×1 DataFrame
│ Row │ b     │
│     │ Int64 │
├─────┼───────┤
│ 1   │ 4     │
│ 2   │ 5     │
│ 3   │ 6     │

julia&gt; select(df, Not(:b)) # drop column :b from df
3×1 DataFrame
│ Row │ a     │
│     │ Int64 │
├─────┼───────┤
│ 1   │ 1     │
│ 2   │ 2     │
│ 3   │ 3     │</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/f46a404bfb0b738215af1322166894a28f2361c5/src/dataframe/dataframe.jl#L811-L867">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataFrames.select!" href="#DataFrames.select!"><code>DataFrames.select!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">select!(df::DataFrame, inds...)</code></pre><p>Mutate <code>df</code> in place to retain only columns specified by <code>inds...</code> and return it.</p><p>Arguments passed as <code>inds...</code> can be any index that is allowed for column indexing provided that the columns requested in each of them are unique and present in <code>df</code>. In particular, regular expressions, <code>All</code>, <code>Between</code>, and <code>Not</code> selectors are supported.</p><p>If more than one argument is passed then they are joined as <code>All(inds...)</code>. Note that <code>All</code> selects the union of columns passed to it, so columns selected in different <code>inds...</code> do not have to be unique. For example a call <code>select!(df, :col, All())</code> is valid and moves column <code>:col</code> in the data frame to be the first, provided it is present in <code>df</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; df = DataFrame(a=1:3, b=4:6)
3×2 DataFrame
│ Row │ a     │ b     │
│     │ Int64 │ Int64 │
├─────┼───────┼───────┤
│ 1   │ 1     │ 4     │
│ 2   │ 2     │ 5     │
│ 3   │ 3     │ 6     │

julia&gt; select!(df, 2)
3×1 DataFrame
│ Row │ b     │
│     │ Int64 │
├─────┼───────┤
│ 1   │ 4     │
│ 2   │ 5     │
│ 3   │ 6     │</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/f46a404bfb0b738215af1322166894a28f2361c5/src/dataframe/dataframe.jl#L744-L780">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.show" href="#Base.show"><code>Base.show</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">show([io::IO,] df::AbstractDataFrame;
     allrows::Bool = !get(io, :limit, false),
     allcols::Bool = !get(io, :limit, false),
     allgroups::Bool = !get(io, :limit, false),
     splitcols::Bool = get(io, :limit, false),
     rowlabel::Symbol = :Row,
     summary::Bool = true)</code></pre><p>Render a data frame to an I/O stream. The specific visual representation chosen depends on the width of the display.</p><p>If <code>io</code> is omitted, the result is printed to <code>stdout</code>, and <code>allrows</code>, <code>allcols</code> and <code>allgroups</code> default to <code>false</code> while <code>splitcols</code> defaults to <code>true</code>.</p><p><strong>Arguments</strong></p><ul><li><code>io::IO</code>: The I/O stream to which <code>df</code> will be printed.</li><li><code>df::AbstractDataFrame</code>: The data frame to print.</li><li><code>allrows::Bool</code>: Whether to print all rows, rather than a subset that fits the device height. By default this is the case only if <code>io</code> does not have the <code>IOContext</code> property <code>limit</code> set.</li><li><code>allcols::Bool</code>: Whether to print all columns, rather than a subset that fits the device width. By default this is the case only if <code>io</code> does not have the <code>IOContext</code> property <code>limit</code> set.</li><li><code>allgroups::Bool</code>: Whether to print all groups rather than the first and last, when <code>df</code> is a <code>GroupedDataFrame</code>. By default this is the case only if <code>io</code> does not have the <code>IOContext</code> property <code>limit</code> set.</li><li><code>splitcols::Bool</code>: Whether to split printing in chunks of columns fitting the screen width rather than printing all columns in the same block. Only applies if <code>allcols</code> is <code>true</code>. By default this is the case only if <code>io</code> has the <code>IOContext</code> property <code>limit</code> set.</li><li><code>rowlabel::Symbol = :Row</code>: The label to use for the column containing row numbers.</li><li><code>summary::Bool = true</code>: Whether to print a brief string summary of the data frame.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using DataFrames

julia&gt; df = DataFrame(A = 1:3, B = [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;]);

julia&gt; show(df, allcols=true)
3×2 DataFrame
│ Row │ A     │ B      │
│     │ Int64 │ String │
├─────┼───────┼────────┤
│ 1   │ 1     │ x      │
│ 2   │ 2     │ y      │
│ 3   │ 3     │ z      │</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/f46a404bfb0b738215af1322166894a28f2361c5/src/abstractdataframe/show.jl#L553-L603">source</a><div><div><pre><code class="language-none">show(io::IO, mime::MIME, df::AbstractDataFrame)</code></pre><p>Render a data frame to an I/O stream in MIME type <code>mime</code>.</p><p><strong>Arguments</strong></p><ul><li><code>io::IO</code>: The I/O stream to which <code>df</code> will be printed.</li><li><code>mime::MIME</code>: supported MIME types are: <code>&quot;text/plain&quot;</code>, <code>&quot;text/html&quot;</code>, <code>&quot;text/latex&quot;</code>, <code>&quot;text/csv&quot;</code>, <code>&quot;text/tab-separated-values&quot;</code></li><li><code>df::AbstractDataFrame</code>: The data frame to print.</li></ul><p>Additionally selected MIME types support passing the following keyword arguments:</p><ul><li>MIME type <code>&quot;text/plain&quot;</code> accepts all listed keyword arguments and therir behavior is identical as for <code>show(::IO, ::AbstractDataFrame)</code></li><li>MIME type <code>&quot;text/html&quot;</code> accepts <code>summary</code> keyword argument which allows to choose whether to print a brief string summary of the data frame.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; show(stdout, MIME(&quot;text/latex&quot;), DataFrame(A = 1:3, B = [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;]))
\begin{tabular}{r|cc}
        &amp; A &amp; B\\
        \hline
        &amp; Int64 &amp; String\\
        \hline
        1 &amp; 1 &amp; x \\
        2 &amp; 2 &amp; y \\
        3 &amp; 3 &amp; z \\
\end{tabular}
14

julia&gt; show(stdout, MIME(&quot;text/csv&quot;), DataFrame(A = 1:3, B = [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;]))
&quot;A&quot;,&quot;B&quot;
1,&quot;x&quot;
2,&quot;y&quot;
3,&quot;z&quot;</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/f46a404bfb0b738215af1322166894a28f2361c5/src/abstractdataframe/io.jl#L1-L38">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.sort" href="#Base.sort"><code>Base.sort</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">sort(df::AbstractDataFrame, cols;
     alg::Union{Algorithm, Nothing}=nothing, lt=isless, by=identity,
     rev::Bool=false, order::Ordering=Forward)</code></pre><p>Return a copy of data frame <code>df</code> sorted by column(s) <code>cols</code>. <code>cols</code> can be either a <code>Symbol</code> or <code>Integer</code> column index, or a tuple or vector of such indices.</p><p>If <code>alg</code> is <code>nothing</code> (the default), the most appropriate algorithm is chosen automatically among <code>TimSort</code>, <code>MergeSort</code> and <code>RadixSort</code> depending on the type of the sorting columns and on the number of rows in <code>df</code>. If <code>rev</code> is <code>true</code>, reverse sorting is performed. To enable reverse sorting only for some columns, pass <code>order(c, rev=true)</code> in <code>cols</code>, with <code>c</code> the corresponding column index (see example below). See <a href="#Base.sort!"><code>sort!</code></a> for a description of other keyword arguments.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; df = DataFrame(x = [3, 1, 2, 1], y = [&quot;b&quot;, &quot;c&quot;, &quot;a&quot;, &quot;b&quot;])
4×2 DataFrame
│ Row │ x     │ y      │
│     │ Int64 │ String │
├─────┼───────┼────────┤
│ 1   │ 3     │ b      │
│ 2   │ 1     │ c      │
│ 3   │ 2     │ a      │
│ 4   │ 1     │ b      │

julia&gt; sort(df, :x)
4×2 DataFrame
│ Row │ x     │ y      │
│     │ Int64 │ String │
├─────┼───────┼────────┤
│ 1   │ 1     │ c      │
│ 2   │ 1     │ b      │
│ 3   │ 2     │ a      │
│ 4   │ 3     │ b      │

julia&gt; sort(df, (:x, :y))
4×2 DataFrame
│ Row │ x     │ y      │
│     │ Int64 │ String │
├─────┼───────┼────────┤
│ 1   │ 1     │ b      │
│ 2   │ 1     │ c      │
│ 3   │ 2     │ a      │
│ 4   │ 3     │ b      │

julia&gt; sort(df, (:x, :y), rev=true)
4×2 DataFrame
│ Row │ x     │ y      │
│     │ Int64 │ String │
├─────┼───────┼────────┤
│ 1   │ 3     │ b      │
│ 2   │ 2     │ a      │
│ 3   │ 1     │ c      │
│ 4   │ 1     │ b      │

julia&gt; sort(df, (:x, order(:y, rev=true)))
4×2 DataFrame
│ Row │ x     │ y      │
│     │ Int64 │ String │
├─────┼───────┼────────┤
│ 1   │ 1     │ c      │
│ 2   │ 1     │ b      │
│ 3   │ 2     │ a      │
│ 4   │ 3     │ b      │</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/f46a404bfb0b738215af1322166894a28f2361c5/src/abstractdataframe/sort.jl#L307-L376">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.sort!" href="#Base.sort!"><code>Base.sort!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">sort!(df::AbstractDataFrame, cols;
      alg::Union{Algorithm, Nothing}=nothing, lt=isless, by=identity,
      rev::Bool=false, order::Ordering=Forward)</code></pre><p>Sort data frame <code>df</code> by column(s) <code>cols</code>. <code>cols</code> can be either a <code>Symbol</code> or <code>Integer</code> column index, or a tuple or vector of such indices.</p><p>If <code>alg</code> is <code>nothing</code> (the default), the most appropriate algorithm is chosen automatically among <code>TimSort</code>, <code>MergeSort</code> and <code>RadixSort</code> depending on the type of the sorting columns and on the number of rows in <code>df</code>. If <code>rev</code> is <code>true</code>, reverse sorting is performed. To enable reverse sorting only for some columns, pass <code>order(c, rev=true)</code> in <code>cols</code>, with <code>c</code> the corresponding column index (see example below). See other methods for a description of other keyword arguments.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; df = DataFrame(x = [3, 1, 2, 1], y = [&quot;b&quot;, &quot;c&quot;, &quot;a&quot;, &quot;b&quot;])
4×2 DataFrame
│ Row │ x     │ y      │
│     │ Int64 │ String │
├─────┼───────┼────────┤
│ 1   │ 3     │ b      │
│ 2   │ 1     │ c      │
│ 3   │ 2     │ a      │
│ 4   │ 1     │ b      │

julia&gt; sort!(df, :x)
4×2 DataFrame
│ Row │ x     │ y      │
│     │ Int64 │ String │
├─────┼───────┼────────┤
│ 1   │ 1     │ c      │
│ 2   │ 1     │ b      │
│ 3   │ 2     │ a      │
│ 4   │ 3     │ b      │

julia&gt; sort!(df, (:x, :y))
4×2 DataFrame
│ Row │ x     │ y      │
│     │ Int64 │ String │
├─────┼───────┼────────┤
│ 1   │ 1     │ b      │
│ 2   │ 1     │ c      │
│ 3   │ 2     │ a      │
│ 4   │ 3     │ b      │

julia&gt; sort!(df, (:x, :y), rev=true)
4×2 DataFrame
│ Row │ x     │ y      │
│     │ Int64 │ String │
├─────┼───────┼────────┤
│ 1   │ 3     │ b      │
│ 2   │ 2     │ a      │
│ 3   │ 1     │ c      │
│ 4   │ 1     │ b      │

julia&gt; sort!(df, (:x, order(:y, rev=true)))
4×2 DataFrame
│ Row │ x     │ y      │
│     │ Int64 │ String │
├─────┼───────┼────────┤
│ 1   │ 1     │ c      │
│ 2   │ 1     │ b      │
│ 3   │ 2     │ a      │
│ 4   │ 3     │ b      │</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/f46a404bfb0b738215af1322166894a28f2361c5/src/dataframe/sort.jl#L2-L71">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.unique!" href="#Base.unique!"><code>Base.unique!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">unique(df::AbstractDataFrame)
unique(df::AbstractDataFrame, cols)
unique!(df::AbstractDataFrame)
unique!(df::AbstractDataFrame, cols)</code></pre><p>Delete duplicate rows of data frame <code>df</code>, keeping only the first occurrence of unique rows. When <code>cols</code> is specified, the return DataFrame contains complete rows, retaining in each case the first instance for which <code>df[cols]</code> is unique.</p><p>When <code>unique</code> is called a new data frame is returned; <code>unique!</code> updates <code>df</code> in-place.</p><p>See also <a href="#DataFrames.nonunique"><code>nonunique</code></a>.</p><p><strong>Arguments</strong></p><ul><li><code>df</code> : the AbstractDataFrame</li><li><code>cols</code> :  column indicator (Symbol, Int, Vector{Symbol}, Regex, etc.)</li></ul><p>specifying the column(s) to compare.</p><p><strong>Examples</strong></p><pre><code class="language-julia">df = DataFrame(i = 1:10, x = rand(10), y = rand([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;], 10))
df = vcat(df, df)
unique(df)   # doesn&#39;t modify df
unique(df, 1)
unique!(df)  # modifies df</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/f46a404bfb0b738215af1322166894a28f2361c5/src/abstractdataframe/abstractdataframe.jl#L982-L1009">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.vcat" href="#Base.vcat"><code>Base.vcat</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">vcat(dfs::AbstractDataFrame...; cols::Union{Symbol, AbstractVector{Symbol}}=:setequal)</code></pre><p>Vertically concatenate <code>AbstractDataFrame</code>s.</p><p>The <code>cols</code> keyword argument determines the columns of the returned data frame:</p><ul><li><code>:setequal</code>: require all data frames to have the same column names disregarding order. If they appear in different orders, the order of the first provided data frame is used.</li><li><code>:orderequal</code>: require all data frames to have the same column names and in the same order.</li><li><code>:intersect</code>: only the columns present in <em>all</em> provided data frames are kept. If the intersection is empty, an empty data frame is returned.</li><li><code>:union</code>: columns present in <em>at least one</em> of the provided data frames are kept. Columns not present in some data frames are filled with <code>missing</code> where necessary.</li><li>A vector of <code>Symbol</code>s: only listed columns are kept. Columns not present in some data frames are filled with <code>missing</code> where necessary.</li></ul><p>The order of columns is determined by the order they appear in the included data frames, searching through the header of the first data frame, then the second, etc.</p><p>The element types of columns are determined using <code>promote_type</code>, as with <code>vcat</code> for <code>AbstractVector</code>s.</p><p><code>vcat</code> ignores empty data frames, making it possible to initialize an empty data frame at the beginning of a loop and <code>vcat</code> onto it.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; df1 = DataFrame(A=1:3, B=1:3);

julia&gt; df2 = DataFrame(A=4:6, B=4:6);

julia&gt; df3 = DataFrame(A=7:9, C=7:9);

julia&gt; d4 = DataFrame();

julia&gt; vcat(df1, df2)
6×2 DataFrame
│ Row │ A     │ B     │
│     │ Int64 │ Int64 │
├─────┼───────┼───────┤
│ 1   │ 1     │ 1     │
│ 2   │ 2     │ 2     │
│ 3   │ 3     │ 3     │
│ 4   │ 4     │ 4     │
│ 5   │ 5     │ 5     │
│ 6   │ 6     │ 6     │

julia&gt; vcat(df1, df3, cols=:union)
6×3 DataFrame
│ Row │ A     │ B       │ C       │
│     │ Int64 │ Int64⍰  │ Int64⍰  │
├─────┼───────┼─────────┼─────────┤
│ 1   │ 1     │ 1       │ missing │
│ 2   │ 2     │ 2       │ missing │
│ 3   │ 3     │ 3       │ missing │
│ 4   │ 7     │ missing │ 7       │
│ 5   │ 8     │ missing │ 8       │
│ 6   │ 9     │ missing │ 9       │

julia&gt; vcat(df1, df3, cols=:intersect)
6×1 DataFrame
│ Row │ A     │
│     │ Int64 │
├─────┼───────┤
│ 1   │ 1     │
│ 2   │ 2     │
│ 3   │ 3     │
│ 4   │ 7     │
│ 5   │ 8     │
│ 6   │ 9     │

julia&gt; vcat(d4, df1)
3×2 DataFrame
│ Row │ A     │ B     │
│     │ Int64 │ Int64 │
├─────┼───────┼───────┤
│ 1   │ 1     │ 1     │
│ 2   │ 2     │ 2     │
│ 3   │ 3     │ 3     │</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/f46a404bfb0b738215af1322166894a28f2361c5/src/abstractdataframe/abstractdataframe.jl#L1096-L1178">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.append!" href="#Base.append!"><code>Base.append!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">append!(df1::DataFrame, df2::AbstractDataFrame; cols::Symbol=:setequal)
append!(df::DataFrame, table; cols::Symbol=:setequal)</code></pre><p>Add the rows of <code>df2</code> to the end of <code>df1</code>. If the second argument <code>table</code> is not an <code>AbstractDataFrame</code> then it is converted using <code>DataFrame(table, copycols=false)</code> before being appended.</p><p>Column names of  <code>df1</code> and <code>df2</code> must be equal. If <code>cols</code> is <code>:setequal</code> (the default) then column names may have different orders and <code>append!</code> is performed by matching column names. If <code>cols</code> is <code>:orderequal</code> then the order of columns in <code>df1</code> and <code>df2</code> or <code>table</code> must be the same. In particular, if <code>table</code> is a <code>Dict</code> an error is thrown as it is an unordered collection.</p><p>The above rule has the following exceptions:</p><ul><li>If <code>df1</code> has no columns then copies of columns from <code>df2</code> are added to it.</li><li>If <code>df2</code> has no columns then calling <code>append!</code> leaves <code>df1</code> unchanged.</li></ul><p>Values corresponding to new rows are appended in-place to the column vectors of <code>df1</code>. Column types are therefore preserved, and new values are converted if necessary. An error is thrown if conversion fails: this is the case in particular if a column in <code>df2</code> contains <code>missing</code> values but the corresponding column in <code>df1</code> does not accept them.</p><p>Please note that <code>append!</code> must not be used on a <code>DataFrame</code> that contains columns that are aliases (equal when compared with <code>===</code>).</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>Use <a href="#Base.vcat"><code>vcat</code></a> instead of <code>append!</code> when more flexibility is needed. Since <code>vcat</code> does not operate in place, it is able to use promotion to find an appropriate element type to hold values from both data frames. It also accepts columns in different orders between <code>df1</code> and <code>df2</code>.</p><p>Use <a href="#Base.push!"><code>push!</code></a> to add individual rows to a data frame.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; df1 = DataFrame(A=1:3, B=1:3);

julia&gt; df2 = DataFrame(A=4.0:6.0, B=4:6);

julia&gt; append!(df1, df2);

julia&gt; df1
6×2 DataFrame
│ Row │ A     │ B     │
│     │ Int64 │ Int64 │
├─────┼───────┼───────┤
│ 1   │ 1     │ 1     │
│ 2   │ 2     │ 2     │
│ 3   │ 3     │ 3     │
│ 4   │ 4     │ 4     │
│ 5   │ 5     │ 5     │
│ 6   │ 6     │ 6     │</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/f46a404bfb0b738215af1322166894a28f2361c5/src/dataframe/dataframe.jl#L1125-L1182">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.push!" href="#Base.push!"><code>Base.push!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">push!(df::DataFrame, row::Union{Tuple, AbstractArray})
push!(df::DataFrame, row::Union{DataFrameRow, NamedTuple, AbstractDict};
      cols::Symbol=:setequal)</code></pre><p>Add in-place one row at the end of <code>df</code> taking the values from <code>row</code>.</p><p>Column types of <code>df</code> are preserved, and new values are converted if necessary. An error is thrown if conversion fails.</p><p>If <code>row</code> is neither a <code>DataFrameRow</code>, <code>NamedTuple</code> nor <code>AbstractDict</code> then it must be a <code>Tuple</code> or an <code>AbstractArray</code> and columns are matched by order of appearance. In this case <code>row</code> must contain the same number of elements as the number of columns in <code>df</code>.</p><p>If <code>row</code> is a <code>DataFrameRow</code>, <code>NamedTuple</code> or <code>AbstractDict</code> then values in <code>row</code> are matched to columns in <code>df</code> based on names. The exact behavior depends on the <code>cols</code> argument value in the following way:</p><ul><li>If <code>cols=:setequal</code> (this is the default) then <code>row</code> must contain exactly the same columns as <code>df</code> (but possibly in a different order).</li><li>If <code>cols=:orderequal</code> then <code>row</code> must contain the same columns in the same order (for <code>AbstractDict</code> this option requires that <code>keys(row)</code> matches <code>names(df)</code>  to allow for support of ordered dicts; however, if <code>row</code> is a <code>Dict</code> an error is thrown  as it is an unordered collection).</li><li>If <code>cols=:intersect</code> then <code>row</code> may contain more columns than <code>df</code>, but all column names that are present in <code>df</code> must be present in <code>row</code> and only they are used to populate a new row in <code>df</code>.</li><li>If <code>cols=:subset</code> then <code>push!</code> behaves like for <code>:intersect</code> but if some column is missing in <code>row</code> then a <code>missing</code> value is pushed to <code>df</code>.</li></ul><p>As a special case, if <code>df</code> has no columns and <code>row</code> is a <code>NamedTuple</code> or <code>DataFrameRow</code>, columns are created for all values in <code>row</code>, using their names and order.</p><p>Please note that <code>push!</code> must not be used on a <code>DataFrame</code> that contains columns that are aliases (equal when compared with <code>===</code>).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; df = DataFrame(A=1:3, B=1:3)
3×2 DataFrame
│ Row │ A     │ B     │
│     │ Int64 │ Int64 │
├─────┼───────┼───────┤
│ 1   │ 1     │ 1     │
│ 2   │ 2     │ 2     │
│ 3   │ 3     │ 3     │

julia&gt; push!(df, (true, false))
4×2 DataFrame
│ Row │ A     │ B     │
│     │ Int64 │ Int64 │
├─────┼───────┼───────┤
│ 1   │ 1     │ 1     │
│ 2   │ 2     │ 2     │
│ 3   │ 3     │ 3     │
│ 4   │ 1     │ 0     │

julia&gt; push!(df, df[1, :])
5×2 DataFrame
│ Row │ A     │ B     │
│     │ Int64 │ Int64 │
├─────┼───────┼───────┤
│ 1   │ 1     │ 1     │
│ 2   │ 2     │ 2     │
│ 3   │ 3     │ 3     │
│ 4   │ 1     │ 0     │
│ 5   │ 1     │ 1     │

julia&gt; push!(df, (C=&quot;something&quot;, A=true, B=false), cols=:intersect)
4×2 DataFrame
│ Row │ A     │ B     │
│     │ Int64 │ Int64 │
├─────┼───────┼───────┤
│ 1   │ 1     │ 1     │
│ 2   │ 2     │ 2     │
│ 3   │ 3     │ 3     │
│ 4   │ 1     │ 0     │
│ 5   │ 1     │ 1     │
│ 6   │ 1     │ 0     │

julia&gt; push!(df, Dict(:A=&gt;1.0, :B=&gt;2.0))
5×2 DataFrame
│ Row │ A     │ B     │
│     │ Int64 │ Int64 │
├─────┼───────┼───────┤
│ 1   │ 1     │ 1     │
│ 2   │ 2     │ 2     │
│ 3   │ 3     │ 3     │
│ 4   │ 1     │ 0     │
│ 5   │ 1     │ 1     │
│ 6   │ 1     │ 0     │
│ 7   │ 1     │ 2     │</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/f46a404bfb0b738215af1322166894a28f2361c5/src/dataframe/dataframe.jl#L1315-L1408">source</a></section><footer><hr/><a class="previous" href="../types/"><span class="direction">Previous</span><span class="title">Types</span></a><a class="next" href="../indexing/"><span class="direction">Next</span><span class="title">Indexing</span></a></footer></article></body></html>
