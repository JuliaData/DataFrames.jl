<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Functions · DataFrames.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link rel="canonical" href="https://juliadata.github.io/DataFrames.jl/stable/lib/functions/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="DataFrames.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">DataFrames.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><a class="tocitem" href="../../man/basics/">First Steps with DataFrames.jl</a></li><li><span class="tocitem">User Guide</span><ul><li><a class="tocitem" href="../../man/getting_started/">Getting Started</a></li><li><a class="tocitem" href="../../man/working_with_dataframes/">Working with DataFrames</a></li><li><a class="tocitem" href="../../man/importing_and_exporting/">Importing and Exporting Data (I/O)</a></li><li><a class="tocitem" href="../../man/joins/">Joins</a></li><li><a class="tocitem" href="../../man/split_apply_combine/">Split-apply-combine</a></li><li><a class="tocitem" href="../../man/reshaping_and_pivoting/">Reshaping</a></li><li><a class="tocitem" href="../../man/sorting/">Sorting</a></li><li><a class="tocitem" href="../../man/categorical/">Categorical Data</a></li><li><a class="tocitem" href="../../man/missing/">Missing Data</a></li><li><a class="tocitem" href="../../man/querying_frameworks/">Data manipulation frameworks</a></li><li><a class="tocitem" href="../../man/comparisons/">Comparison with Python/R/Stata</a></li></ul></li><li><span class="tocitem">API</span><ul><li><a class="tocitem" href="../types/">Types</a></li><li class="is-active"><a class="tocitem" href>Functions</a><ul class="internal"><li><a class="tocitem" href="#Multithreading-support"><span>Multithreading support</span></a></li><li><a class="tocitem" href="#Index"><span>Index</span></a></li><li><a class="tocitem" href="#Constructing-data-frames"><span>Constructing data frames</span></a></li><li><a class="tocitem" href="#Summary-information"><span>Summary information</span></a></li><li><a class="tocitem" href="#Working-with-column-names"><span>Working with column names</span></a></li><li><a class="tocitem" href="#Mutating-and-transforming-data-frames-and-grouped-data-frames"><span>Mutating and transforming data frames and grouped data frames</span></a></li><li><a class="tocitem" href="#Reshaping-data-frames-between-tall-and-wide-formats"><span>Reshaping data frames between tall and wide formats</span></a></li><li><a class="tocitem" href="#Sorting"><span>Sorting</span></a></li><li><a class="tocitem" href="#Joining"><span>Joining</span></a></li><li><a class="tocitem" href="#Grouping"><span>Grouping</span></a></li><li><a class="tocitem" href="#Filtering-rows"><span>Filtering rows</span></a></li><li><a class="tocitem" href="#Working-with-missing-values"><span>Working with missing values</span></a></li><li><a class="tocitem" href="#Iteration"><span>Iteration</span></a></li><li><a class="tocitem" href="#Equality"><span>Equality</span></a></li><li><a class="tocitem" href="#Metadata"><span>Metadata</span></a></li></ul></li><li><a class="tocitem" href="../indexing/">Indexing</a></li><li><a class="tocitem" href="../metadata/">Metadata</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">API</a></li><li class="is-active"><a href>Functions</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Functions</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaData/DataFrames.jl/blob/main/docs/src/lib/functions.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Functions"><a class="docs-heading-anchor" href="#Functions">Functions</a><a id="Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Functions" title="Permalink"></a></h1><h2 id="Multithreading-support"><a class="docs-heading-anchor" href="#Multithreading-support">Multithreading support</a><a id="Multithreading-support-1"></a><a class="docs-heading-anchor-permalink" href="#Multithreading-support" title="Permalink"></a></h2><p>By default, selected operations in DataFrames.jl automatically use multiple threads when available. It is task-based and implemented using the <code>@spawn</code> macro from Julia Base. Functions that take user-defined functions and may run it in parallel accept a <code>threads</code> keyword argument which allows disabling multithreading when the provided function requires serial execution or is not thread-safe.</p><p>This is a list of operations that currently make use of multi-threading:</p><ul><li><code>DataFrame</code> constructor with <code>copycols=true</code>; also recursively all functions that call this constructor, e.g. <code>copy</code>.</li><li><code>getindex</code> when multiple columns are selected.</li><li><code>groupby</code> (both when hashing is required and when fast path using <code>DataAPI.refpool</code> is used).</li><li><code>*join</code> functions for composing output data frame (but currently not for finding matching rows in joined data frames).</li><li><code>combine</code>, <code>select[!]</code>, and <code>transform[!]</code> on <code>GroupedDataFrame</code> when either of the conditions below is met:<ul><li>multiple transformations are performed (each transformation is spawned in a separate task)</li><li>a transformation produces one row per group and the passed transformation is a custom function (i.e. not for standard reductions, which use optimized single-threaded methods).</li></ul></li><li><code>dropmissing</code> when the provided data frame has more than 1 column and <code>view=false</code>  (subsetting of individual columns is spawned in separate tasks).</li></ul><p>In general at least Julia 1.4 is required to ensure that multi-threading is used and the Julia process must be started with more than one thread. Some operations turn on multi-threading only if enough rows in the processed data frame are present (the exact threshold when multi-threading is enabled is considered to be undefined and might change in the future).</p><p>Except for the list above, where multi-threading is used automatically, all functions provided by DataFrames.jl that update a data frame are not thread safe. This means that while they can be called from any thread, the caller is responsible for ensuring that a given <code>DataFrame</code> object is never modified by one thread while others are using it (either for reading or writing). Using the same <code>DataFrame</code> at the same time from different threads is safe as long as it is not modified.</p><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="#Base.Iterators.only"><code>Base.Iterators.only</code></a></li><li><a href="#Base.Iterators.partition"><code>Base.Iterators.partition</code></a></li><li><a href="#Base.allunique"><code>Base.allunique</code></a></li><li><a href="#Base.append!"><code>Base.append!</code></a></li><li><a href="#Base.copy"><code>Base.copy</code></a></li><li><a href="#Base.deleteat!"><code>Base.deleteat!</code></a></li><li><a href="#Base.eachcol"><code>Base.eachcol</code></a></li><li><a href="#Base.eachrow"><code>Base.eachrow</code></a></li><li><a href="#Base.empty"><code>Base.empty</code></a></li><li><a href="#Base.empty!"><code>Base.empty!</code></a></li><li><a href="#Base.filter"><code>Base.filter</code></a></li><li><a href="#Base.filter!"><code>Base.filter!</code></a></li><li><a href="#Base.first"><code>Base.first</code></a></li><li><a href="#Base.get"><code>Base.get</code></a></li><li><a href="#Base.hcat"><code>Base.hcat</code></a></li><li><a href="#Base.insert!"><code>Base.insert!</code></a></li><li><a href="#Base.invpermute!"><code>Base.invpermute!</code></a></li><li><a href="#Base.isapprox"><code>Base.isapprox</code></a></li><li><a href="#Base.isempty"><code>Base.isempty</code></a></li><li><a href="#Base.issorted"><code>Base.issorted</code></a></li><li><a href="#Base.keepat!"><code>Base.keepat!</code></a></li><li><a href="#Base.keys"><code>Base.keys</code></a></li><li><a href="#Base.last"><code>Base.last</code></a></li><li><a href="#Base.length"><code>Base.length</code></a></li><li><a href="#Base.names"><code>Base.names</code></a></li><li><a href="#Base.ndims"><code>Base.ndims</code></a></li><li><a href="#Base.pairs"><code>Base.pairs</code></a></li><li><a href="#Base.parent"><code>Base.parent</code></a></li><li><a href="#Base.permute!"><code>Base.permute!</code></a></li><li><a href="#Base.permutedims"><code>Base.permutedims</code></a></li><li><a href="#Base.pop!"><code>Base.pop!</code></a></li><li><a href="#Base.popat!"><code>Base.popat!</code></a></li><li><a href="#Base.popfirst!"><code>Base.popfirst!</code></a></li><li><a href="#Base.prepend!"><code>Base.prepend!</code></a></li><li><a href="#Base.propertynames"><code>Base.propertynames</code></a></li><li><a href="#Base.push!"><code>Base.push!</code></a></li><li><a href="#Base.pushfirst!"><code>Base.pushfirst!</code></a></li><li><a href="#Base.reduce"><code>Base.reduce</code></a></li><li><a href="#Base.repeat"><code>Base.repeat</code></a></li><li><a href="#Base.resize!"><code>Base.resize!</code></a></li><li><a href="#Base.reverse"><code>Base.reverse</code></a></li><li><a href="#Base.reverse!"><code>Base.reverse!</code></a></li><li><a href="#Base.show"><code>Base.show</code></a></li><li><a href="#Base.similar"><code>Base.similar</code></a></li><li><a href="#Base.size"><code>Base.size</code></a></li><li><a href="#Base.sort"><code>Base.sort</code></a></li><li><a href="#Base.sort!"><code>Base.sort!</code></a></li><li><a href="#Base.sortperm"><code>Base.sortperm</code></a></li><li><a href="#Base.stack"><code>Base.stack</code></a></li><li><a href="#Base.unique"><code>Base.unique</code></a></li><li><a href="#Base.unique!"><code>Base.unique!</code></a></li><li><a href="#Base.values"><code>Base.values</code></a></li><li><a href="#Base.vcat"><code>Base.vcat</code></a></li><li><a href="#DataAPI.allcombinations"><code>DataAPI.allcombinations</code></a></li><li><a href="#DataAPI.antijoin"><code>DataAPI.antijoin</code></a></li><li><a href="#DataAPI.colmetadata"><code>DataAPI.colmetadata</code></a></li><li><a href="#DataAPI.colmetadata!"><code>DataAPI.colmetadata!</code></a></li><li><a href="#DataAPI.colmetadatakeys"><code>DataAPI.colmetadatakeys</code></a></li><li><a href="#DataAPI.crossjoin"><code>DataAPI.crossjoin</code></a></li><li><a href="#DataAPI.deletecolmetadata!"><code>DataAPI.deletecolmetadata!</code></a></li><li><a href="#DataAPI.deletemetadata!"><code>DataAPI.deletemetadata!</code></a></li><li><a href="#DataAPI.describe"><code>DataAPI.describe</code></a></li><li><a href="#DataAPI.emptycolmetadata!"><code>DataAPI.emptycolmetadata!</code></a></li><li><a href="#DataAPI.emptymetadata!"><code>DataAPI.emptymetadata!</code></a></li><li><a href="#DataAPI.innerjoin"><code>DataAPI.innerjoin</code></a></li><li><a href="#DataAPI.leftjoin"><code>DataAPI.leftjoin</code></a></li><li><a href="#DataAPI.metadata"><code>DataAPI.metadata</code></a></li><li><a href="#DataAPI.metadata!"><code>DataAPI.metadata!</code></a></li><li><a href="#DataAPI.metadatakeys"><code>DataAPI.metadatakeys</code></a></li><li><a href="#DataAPI.ncol"><code>DataAPI.ncol</code></a></li><li><a href="#DataAPI.nrow"><code>DataAPI.nrow</code></a></li><li><a href="#DataAPI.outerjoin"><code>DataAPI.outerjoin</code></a></li><li><a href="#DataAPI.rightjoin"><code>DataAPI.rightjoin</code></a></li><li><a href="#DataAPI.rownumber"><code>DataAPI.rownumber</code></a></li><li><a href="#DataAPI.semijoin"><code>DataAPI.semijoin</code></a></li><li><a href="#DataFrames.allowmissing!"><code>DataFrames.allowmissing!</code></a></li><li><a href="#DataFrames.combine"><code>DataFrames.combine</code></a></li><li><a href="#DataFrames.completecases"><code>DataFrames.completecases</code></a></li><li><a href="#DataFrames.disallowmissing!"><code>DataFrames.disallowmissing!</code></a></li><li><a href="#DataFrames.dropmissing"><code>DataFrames.dropmissing</code></a></li><li><a href="#DataFrames.dropmissing!"><code>DataFrames.dropmissing!</code></a></li><li><a href="#DataFrames.fillcombinations"><code>DataFrames.fillcombinations</code></a></li><li><a href="#DataFrames.flatten"><code>DataFrames.flatten</code></a></li><li><a href="#DataFrames.groupby"><code>DataFrames.groupby</code></a></li><li><a href="#DataFrames.groupcols"><code>DataFrames.groupcols</code></a></li><li><a href="#DataFrames.groupindices"><code>DataFrames.groupindices</code></a></li><li><a href="#DataFrames.insertcols"><code>DataFrames.insertcols</code></a></li><li><a href="#DataFrames.insertcols!"><code>DataFrames.insertcols!</code></a></li><li><a href="#DataFrames.leftjoin!"><code>DataFrames.leftjoin!</code></a></li><li><a href="#DataFrames.mapcols"><code>DataFrames.mapcols</code></a></li><li><a href="#DataFrames.mapcols!"><code>DataFrames.mapcols!</code></a></li><li><a href="#DataFrames.nonunique"><code>DataFrames.nonunique</code></a></li><li><a href="#DataFrames.order"><code>DataFrames.order</code></a></li><li><a href="#DataFrames.proprow"><code>DataFrames.proprow</code></a></li><li><a href="#DataFrames.rename"><code>DataFrames.rename</code></a></li><li><a href="#DataFrames.rename!"><code>DataFrames.rename!</code></a></li><li><a href="#DataFrames.repeat!"><code>DataFrames.repeat!</code></a></li><li><a href="#DataFrames.select"><code>DataFrames.select</code></a></li><li><a href="#DataFrames.select!"><code>DataFrames.select!</code></a></li><li><a href="#DataFrames.subset"><code>DataFrames.subset</code></a></li><li><a href="#DataFrames.subset!"><code>DataFrames.subset!</code></a></li><li><a href="#DataFrames.table_transformation"><code>DataFrames.table_transformation</code></a></li><li><a href="#DataFrames.transform"><code>DataFrames.transform</code></a></li><li><a href="#DataFrames.transform!"><code>DataFrames.transform!</code></a></li><li><a href="#DataFrames.unstack"><code>DataFrames.unstack</code></a></li><li><a href="#DataFrames.valuecols"><code>DataFrames.valuecols</code></a></li><li><a href="#Missings.allowmissing"><code>Missings.allowmissing</code></a></li><li><a href="#Missings.disallowmissing"><code>Missings.disallowmissing</code></a></li><li><a href="#Random.shuffle"><code>Random.shuffle</code></a></li><li><a href="#Random.shuffle!"><code>Random.shuffle!</code></a></li></ul><h2 id="Constructing-data-frames"><a class="docs-heading-anchor" href="#Constructing-data-frames">Constructing data frames</a><a id="Constructing-data-frames-1"></a><a class="docs-heading-anchor-permalink" href="#Constructing-data-frames" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="DataAPI.allcombinations" href="#DataAPI.allcombinations"><code>DataAPI.allcombinations</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">allcombinations(DataFrame, pairs::Pair...)
allcombinations(DataFrame; kwargs...)</code></pre><p>Create a <code>DataFrame</code> from all combinations of values in passed arguments. The first passed values vary fastest.</p><p>Arguments associating a column name with values to expand can be specified either as <code>Pair</code>s passed as positional arguments, or as keyword arguments. Column names must be <code>Symbol</code>s or strings and must be unique.</p><p>Column value can be a vector which is consumed as is or an object of any other type (except <code>AbstractArray</code>). In the latter case the passed value is treated as having length one for expansion. As a particular rule values stored in a <code>Ref</code> or a <code>0</code>-dimensional <code>AbstractArray</code> are unwrapped and treated as having length one.</p><p>See also: <a href="#DataAPI.crossjoin"><code>crossjoin</code></a> can be used to get the cartesian product of rows from passed data frames.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; allcombinations(DataFrame, a=1:2, b=&#39;a&#39;:&#39;c&#39;)
6×2 DataFrame
 Row │ a      b
     │ Int64  Char
─────┼─────────────
   1 │     1  a
   2 │     2  a
   3 │     1  b
   4 │     2  b
   5 │     1  c
   6 │     2  c

julia&gt; allcombinations(DataFrame, &quot;a&quot; =&gt; 1:2, &quot;b&quot; =&gt; &#39;a&#39;:&#39;c&#39;, &quot;c&quot; =&gt; &quot;const&quot;)
6×3 DataFrame
 Row │ a      b     c
     │ Int64  Char  String
─────┼─────────────────────
   1 │     1  a     const
   2 │     2  a     const
   3 │     1  b     const
   4 │     2  b     const
   5 │     1  c     const
   6 │     2  c     const</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/a1f75b1dd155265e5767e1e3f64d70be824859d7/src/dataframe/dataframe.jl#L1480-L1526">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.copy" href="#Base.copy"><code>Base.copy</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">copy(df::DataFrame; copycols::Bool=true)</code></pre><p>Copy data frame <code>df</code>. If <code>copycols=true</code> (the default), return a new  <code>DataFrame</code> holding copies of column vectors in <code>df</code>. If <code>copycols=false</code>, return a new <code>DataFrame</code> sharing column vectors with <code>df</code>.</p><p>Metadata: this function preserves all table-level and column-level metadata.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/a1f75b1dd155265e5767e1e3f64d70be824859d7/src/dataframe/dataframe.jl#L795-L804">source</a></section><section><div><pre><code class="nohighlight hljs">copy(dfr::DataFrameRow)</code></pre><p>Construct a <code>NamedTuple</code> with the same contents as the <a href="../types/#DataFrames.DataFrameRow"><code>DataFrameRow</code></a>. This method returns a <code>NamedTuple</code> so that the returned object is not affected by changes to the parent data frame of which <code>dfr</code> is a view.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/a1f75b1dd155265e5767e1e3f64d70be824859d7/src/dataframerow/dataframerow.jl#L433-L440">source</a></section><section><div><pre><code class="nohighlight hljs">copy(key::GroupKey)</code></pre><p>Construct a <code>NamedTuple</code> with the same contents as the <a href="../types/#DataFrames.GroupKey"><code>GroupKey</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/a1f75b1dd155265e5767e1e3f64d70be824859d7/src/groupeddataframe/groupeddataframe.jl#L740-L744">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.similar" href="#Base.similar"><code>Base.similar</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">similar(df::AbstractDataFrame, rows::Integer=nrow(df))</code></pre><p>Create a new <code>DataFrame</code> with the same column names and column element types as <code>df</code>. An optional second argument can be provided to request a number of rows that is different than the number of rows present in <code>df</code>.</p><p>Metadata: this function preserves table-level and column-level <code>:note</code>-style metadata.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/a1f75b1dd155265e5767e1e3f64d70be824859d7/src/abstractdataframe/abstractdataframe.jl#L441-L449">source</a></section></article><h2 id="Summary-information"><a class="docs-heading-anchor" href="#Summary-information">Summary information</a><a id="Summary-information-1"></a><a class="docs-heading-anchor-permalink" href="#Summary-information" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="DataAPI.describe" href="#DataAPI.describe"><code>DataAPI.describe</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">describe(df::AbstractDataFrame; cols=:)
describe(df::AbstractDataFrame, stats::Union{Symbol, Pair}...; cols=:)</code></pre><p>Return descriptive statistics for a data frame as a new <code>DataFrame</code> where each row represents a variable and each column a summary statistic.</p><p><strong>Arguments</strong></p><ul><li><code>df</code> : the <code>AbstractDataFrame</code></li><li><code>stats::Union{Symbol, Pair}...</code> : the summary statistics to report. Arguments can be:<ul><li>A symbol from the list <code>:mean</code>, <code>:std</code>, <code>:min</code>, <code>:q25</code>, <code>:median</code>, <code>:q75</code>, <code>:max</code>, <code>:sum</code>, <code>:eltype</code>, <code>:nunique</code>, <code>:nuniqueall</code>, <code>:first</code>, <code>:last</code>, <code>:nnonmissing</code>, and <code>:nmissing</code>. The default statistics used are <code>:mean</code>, <code>:min</code>, <code>:median</code>, <code>:max</code>, <code>:nmissing</code>, and <code>:eltype</code>.</li><li><code>:detailed</code> as the only <code>Symbol</code> argument to return all statistics except <code>:first</code>, <code>:last</code>, <code>:sum</code>, <code>:nuniqueall</code>, and <code>:nnonmissing</code>.</li><li><code>:all</code> as the only <code>Symbol</code> argument to return all statistics.</li><li>A <code>function =&gt; name</code> pair where <code>name</code> is a <code>Symbol</code> or string. This will create a column of summary statistics with the provided name.</li></ul></li><li><code>cols</code> : a keyword argument allowing to select only a subset or transformation of columns from <code>df</code> to describe. Can be any column selector or transformation accepted by <a href="#DataFrames.select"><code>select</code></a>.</li></ul><p><strong>Details</strong></p><p>For <code>Real</code> columns, compute the mean, standard deviation, minimum, first quantile, median, third quantile, and maximum. If a column does not derive from <code>Real</code>, <code>describe</code> will attempt to calculate all statistics, using <code>nothing</code> as a fall-back in the case of an error.</p><p>When <code>stats</code> contains <code>:nunique</code>, <code>describe</code> will report the number of unique values in a column. If a column&#39;s base type derives from <code>Real</code>, <code>:nunique</code> will return <code>nothing</code>s. Use <code>:nuniqueall</code> to report the number of unique values in all columns.</p><p>Missing values are filtered in the calculation of all statistics, however the column <code>:nmissing</code> will report the number of missing values of that variable and <code>:nnonmissing</code> the number of non-missing values.</p><p>If custom functions are provided, they are called repeatedly with the vector corresponding to each column as the only argument. For columns allowing for missing values, the vector is wrapped in a call to <code>skipmissing</code>: custom functions must therefore support such objects (and not only vectors), and cannot access missing values.</p><p>Metadata: this function drops all metadata.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; df = DataFrame(i=1:10, x=0.1:0.1:1.0, y=&#39;a&#39;:&#39;j&#39;);

julia&gt; describe(df)
3×7 DataFrame
 Row │ variable  mean    min  median  max  nmissing  eltype
     │ Symbol    Union…  Any  Union…  Any  Int64     DataType
─────┼────────────────────────────────────────────────────────
   1 │ i         5.5     1    5.5     10          0  Int64
   2 │ x         0.55    0.1  0.55    1.0         0  Float64
   3 │ y                 a            j           0  Char

julia&gt; describe(df, :min, :max)
3×3 DataFrame
 Row │ variable  min  max
     │ Symbol    Any  Any
─────┼────────────────────
   1 │ i         1    10
   2 │ x         0.1  1.0
   3 │ y         a    j

julia&gt; describe(df, :min, sum =&gt; :sum)
3×3 DataFrame
 Row │ variable  min  sum
     │ Symbol    Any  Union…
─────┼───────────────────────
   1 │ i         1    55
   2 │ x         0.1  5.5
   3 │ y         a

julia&gt; describe(df, :min, sum =&gt; :sum, cols=:x)
1×3 DataFrame
 Row │ variable  min      sum
     │ Symbol    Float64  Float64
─────┼────────────────────────────
   1 │ x             0.1      5.5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/a1f75b1dd155265e5767e1e3f64d70be824859d7/src/abstractdataframe/abstractdataframe.jl#L568-L654">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.isempty" href="#Base.isempty"><code>Base.isempty</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">isempty(df::AbstractDataFrame)</code></pre><p>Return <code>true</code> if data frame <code>df</code> has zero rows, and <code>false</code> otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/a1f75b1dd155265e5767e1e3f64d70be824859d7/src/abstractdataframe/abstractdataframe.jl#L405-L409">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.length" href="#Base.length"><code>Base.length</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">length(dfr::DataFrameRow)</code></pre><p>Return the number of elements of <code>dfr</code>.</p><p>See also: <a href="#Base.size"><code>size</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; dfr = DataFrame(a=1:3, b=&#39;a&#39;:&#39;c&#39;)[1, :]
DataFrameRow
 Row │ a      b
     │ Int64  Char
─────┼─────────────
   1 │     1  a

julia&gt; length(dfr)
2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/a1f75b1dd155265e5767e1e3f64d70be824859d7/src/dataframerow/dataframerow.jl#L355-L374">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataAPI.ncol" href="#DataAPI.ncol"><code>DataAPI.ncol</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">ncol(df::AbstractDataFrame)</code></pre><p>Return the number of columns in an <code>AbstractDataFrame</code> <code>df</code>.</p><p>See also <a href="#DataAPI.nrow"><code>nrow</code></a>, <a href="#Base.size"><code>size</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; df = DataFrame(i=1:10, x=rand(10), y=rand([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;], 10));

julia&gt; ncol(df)
3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/a1f75b1dd155265e5767e1e3f64d70be824859d7/src/abstractdataframe/abstractdataframe.jl#L387-L402">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.ndims" href="#Base.ndims"><code>Base.ndims</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">ndims(::AbstractDataFrame)
ndims(::Type{&lt;:AbstractDataFrame})</code></pre><p>Return the number of dimensions of a data frame, which is always <code>2</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/a1f75b1dd155265e5767e1e3f64d70be824859d7/src/abstractdataframe/abstractdataframe.jl#L414-L419">source</a></section><section><div><pre><code class="nohighlight hljs">ndims(::DataFrameRow)
ndims(::Type{&lt;:DataFrameRow})</code></pre><p>Return the number of dimensions of a data frame row, which is always <code>1</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/a1f75b1dd155265e5767e1e3f64d70be824859d7/src/dataframerow/dataframerow.jl#L377-L382">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataAPI.nrow" href="#DataAPI.nrow"><code>DataAPI.nrow</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">nrow(df::AbstractDataFrame)</code></pre><p>Return the number of rows in an <code>AbstractDataFrame</code> <code>df</code>.</p><p>See also: <a href="#DataAPI.ncol"><code>ncol</code></a>, <a href="#Base.size"><code>size</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; df = DataFrame(i=1:10, x=rand(10), y=rand([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;], 10));

julia&gt; nrow(df)
10</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/a1f75b1dd155265e5767e1e3f64d70be824859d7/src/dataframe/dataframe.jl#L449-L464">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataAPI.rownumber" href="#DataAPI.rownumber"><code>DataAPI.rownumber</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">rownumber(dfr::DataFrameRow)</code></pre><p>Return a row number in the <code>AbstractDataFrame</code> that <code>dfr</code> was created from.</p><p>Note that this differs from the first element in the tuple returned by <code>parentindices</code>. The latter gives the row number in the <code>parent(dfr)</code>, which is the source <code>DataFrame</code> where data that <code>dfr</code> gives access to is stored.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; df = DataFrame(reshape(1:12, 3, 4), :auto)
3×4 DataFrame
 Row │ x1     x2     x3     x4
     │ Int64  Int64  Int64  Int64
─────┼────────────────────────────
   1 │     1      4      7     10
   2 │     2      5      8     11
   3 │     3      6      9     12

julia&gt; dfr = df[2, :]
DataFrameRow
 Row │ x1     x2     x3     x4
     │ Int64  Int64  Int64  Int64
─────┼────────────────────────────
   2 │     2      5      8     11

julia&gt; rownumber(dfr)
2

julia&gt; parentindices(dfr)
(2, Base.OneTo(4))

julia&gt; parent(dfr)
3×4 DataFrame
 Row │ x1     x2     x3     x4
     │ Int64  Int64  Int64  Int64
─────┼────────────────────────────
   1 │     1      4      7     10
   2 │     2      5      8     11
   3 │     3      6      9     12

julia&gt; dfv = @view df[2:3, 1:3]
2×3 SubDataFrame
 Row │ x1     x2     x3
     │ Int64  Int64  Int64
─────┼─────────────────────
   1 │     2      5      8
   2 │     3      6      9

julia&gt; dfrv = dfv[2, :]
DataFrameRow
 Row │ x1     x2     x3
     │ Int64  Int64  Int64
─────┼─────────────────────
   3 │     3      6      9

julia&gt; rownumber(dfrv)
2

julia&gt; parentindices(dfrv)
(3, 1:3)

julia&gt; parent(dfrv)
3×4 DataFrame
 Row │ x1     x2     x3     x4
     │ Int64  Int64  Int64  Int64
─────┼────────────────────────────
   1 │     1      4      7     10
   2 │     2      5      8     11
   3 │     3      6      9     12</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/a1f75b1dd155265e5767e1e3f64d70be824859d7/src/dataframerow/dataframerow.jl#L121-L193">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.show" href="#Base.show"><code>Base.show</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">show([io::IO, ]df::AbstractDataFrame;
     allrows::Bool = !get(io, :limit, false),
     allcols::Bool = !get(io, :limit, false),
     allgroups::Bool = !get(io, :limit, false),
     rowlabel::Symbol = :Row,
     summary::Bool = true,
     eltypes::Bool = true,
     truncate::Int = 32,
     kwargs...)</code></pre><p>Render a data frame to an I/O stream. The specific visual representation chosen depends on the width of the display.</p><p>If <code>io</code> is omitted, the result is printed to <code>stdout</code>, and <code>allrows</code>, <code>allcols</code> and <code>allgroups</code> default to <code>false</code>.</p><p><strong>Arguments</strong></p><ul><li><code>io::IO</code>: The I/O stream to which <code>df</code> will be printed.</li><li><code>df::AbstractDataFrame</code>: The data frame to print.</li><li><code>allrows::Bool</code>: Whether to print all rows, rather than a subset that fits the device height. By default this is the case only if <code>io</code> does not have the <code>IOContext</code> property <code>limit</code> set.</li><li><code>allcols::Bool</code>: Whether to print all columns, rather than a subset that fits the device width. By default this is the case only if <code>io</code> does not have the <code>IOContext</code> property <code>limit</code> set.</li><li><code>allgroups::Bool</code>: Whether to print all groups rather than the first and last, when <code>df</code> is a <code>GroupedDataFrame</code>. By default this is the case only if <code>io</code> does not have the <code>IOContext</code> property <code>limit</code> set.</li><li><code>rowlabel::Symbol = :Row</code>: The label to use for the column containing row numbers.</li><li><code>summary::Bool = true</code>: Whether to print a brief string summary of the data frame.</li><li><code>eltypes::Bool = true</code>: Whether to print the column types under column names.</li><li><code>truncate::Int = 32</code>: the maximal display width the output can use before being truncated (in the <code>textwidth</code> sense, excluding <code>…</code>). If <code>truncate</code> is 0 or less, no truncation is applied.</li><li><code>kwargs...</code>: Any keyword argument supported by the function <code>pretty_table</code> of PrettyTables.jl can be passed here to customize the output.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using DataFrames

julia&gt; df = DataFrame(A=1:3, B=[&quot;x&quot;, &quot;y&quot;, &quot;z&quot;]);

julia&gt; show(df, show_row_number=false)
3×2 DataFrame
 A      B
 Int64  String
───────────────
     1  x
     2  y
     3  z</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/a1f75b1dd155265e5767e1e3f64d70be824859d7/src/abstractdataframe/show.jl#L284-L338">source</a></section><section><div><pre><code class="nohighlight hljs">show(io::IO, mime::MIME, df::AbstractDataFrame)</code></pre><p>Render a data frame to an I/O stream in MIME type <code>mime</code>.</p><p><strong>Arguments</strong></p><ul><li><code>io::IO</code>: The I/O stream to which <code>df</code> will be printed.</li><li><code>mime::MIME</code>: supported MIME types are: <code>&quot;text/plain&quot;</code>, <code>&quot;text/html&quot;</code>, <code>&quot;text/latex&quot;</code>, <code>&quot;text/csv&quot;</code>, <code>&quot;text/tab-separated-values&quot;</code> (the last two MIME types do not support  showing <code>#undef</code> values)</li><li><code>df::AbstractDataFrame</code>: The data frame to print.</li></ul><p>Additionally selected MIME types support passing the following keyword arguments:</p><ul><li>MIME type <code>&quot;text/plain&quot;</code> accepts all listed keyword arguments and their behavior is identical as for <code>show(::IO, ::AbstractDataFrame)</code></li><li>MIME type <code>&quot;text/html&quot;</code> accepts the following keyword arguments:<ul><li><code>eltypes::Bool = true</code>: Whether to print the column types under column names.</li><li><code>summary::Bool = true</code>: Whether to print a brief string summary of the data frame.</li><li><code>max_column_width::AbstractString = &quot;&quot;</code>: The maximum column width. It must     be a string containing a valid CSS length. For example, passing     &quot;100px&quot; will limit the width of all columns to 100 pixels. If empty,     the columns will be rendered without limits.</li><li><code>kwargs...</code>: Any keyword argument supported by the function <code>pretty_table</code> of PrettyTables.jl can be passed here to customize the output.</li></ul></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; show(stdout, MIME(&quot;text/latex&quot;), DataFrame(A=1:3, B=[&quot;x&quot;, &quot;y&quot;, &quot;z&quot;]))
\begin{tabular}{r|cc}
	&amp; A &amp; B\\
	\hline
	&amp; Int64 &amp; String\\
	\hline
	1 &amp; 1 &amp; x \\
	2 &amp; 2 &amp; y \\
	3 &amp; 3 &amp; z \\
\end{tabular}
14

julia&gt; show(stdout, MIME(&quot;text/csv&quot;), DataFrame(A=1:3, B=[&quot;x&quot;, &quot;y&quot;, &quot;z&quot;]))
&quot;A&quot;,&quot;B&quot;
1,&quot;x&quot;
2,&quot;y&quot;
3,&quot;z&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/a1f75b1dd155265e5767e1e3f64d70be824859d7/src/abstractdataframe/io.jl#L89-L134">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.size" href="#Base.size"><code>Base.size</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">size(df::AbstractDataFrame[, dim])</code></pre><p>Return a tuple containing the number of rows and columns of <code>df</code>. Optionally a dimension <code>dim</code> can be specified, where <code>1</code> corresponds to rows and <code>2</code> corresponds to columns.</p><p>See also: <a href="#DataAPI.nrow"><code>nrow</code></a>, <a href="#DataAPI.ncol"><code>ncol</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; df = DataFrame(a=1:3, b=&#39;a&#39;:&#39;c&#39;);

julia&gt; size(df)
(3, 2)

julia&gt; size(df, 1)
3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/a1f75b1dd155265e5767e1e3f64d70be824859d7/src/abstractdataframe/abstractdataframe.jl#L355-L375">source</a></section><section><div><pre><code class="nohighlight hljs">size(dfr::DataFrameRow[, dim])</code></pre><p>Return a 1-tuple containing the number of elements of <code>dfr</code>. If an optional dimension <code>dim</code> is specified, it must be <code>1</code>, and the number of elements is returned directly as a number.</p><p>See also: <a href="#Base.length"><code>length</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; dfr = DataFrame(a=1:3, b=&#39;a&#39;:&#39;c&#39;)[1, :]
DataFrameRow
 Row │ a      b
     │ Int64  Char
─────┼─────────────
   1 │     1  a

julia&gt; size(dfr)
(2,)

julia&gt; size(dfr, 1)
2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/a1f75b1dd155265e5767e1e3f64d70be824859d7/src/dataframerow/dataframerow.jl#L327-L351">source</a></section></article><h2 id="Working-with-column-names"><a class="docs-heading-anchor" href="#Working-with-column-names">Working with column names</a><a id="Working-with-column-names-1"></a><a class="docs-heading-anchor-permalink" href="#Working-with-column-names" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Base.names" href="#Base.names"><code>Base.names</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">names(df::AbstractDataFrame, cols=:)
names(df::DataFrameRow, cols=:)
names(df::GroupedDataFrame, cols=:)
names(df::DataFrameRows, cols=:)
names(df::DataFrameColumns, cols=:)
names(df::GroupKey)</code></pre><p>Return a freshly allocated <code>Vector{String}</code> of names of columns contained in <code>df</code>.</p><p>If <code>cols</code> is passed then restrict returned column names to those matching the selector (this is useful in particular with regular expressions, <code>Cols</code>, <code>Not</code>, and <code>Between</code>). <code>cols</code> can be:</p><ul><li>any column selector (<code>Symbol</code>, string or integer; <code>:</code>, <code>Cols</code>, <code>All</code>, <code>Between</code>, <code>Not</code>, a regular expression, or a vector of <code>Symbol</code>s, strings or integers); these column selectors are documented in the <a href="../indexing/#General-rules">General rules</a> section of the <a href="../indexing/#Indexing">Indexing</a> part of the DataFrames.jl manual</li><li>a <code>Type</code>, in which case names of columns whose <code>eltype</code> is a subtype of <code>T</code> are returned</li><li>a <code>Function</code> predicate taking the column name as a string and returning <code>true</code> for columns that should be kept</li></ul><p>See also <a href="#Base.propertynames"><code>propertynames</code></a> which returns a <code>Vector{Symbol}</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; df = DataFrame(x1=[1, missing, missing], x2=[3, 2, 4], x3=[3, missing, 2], x4=Union{Int, Missing}[2, 4, 4])
3×4 DataFrame
 Row │ x1       x2     x3       x4
     │ Int64?   Int64  Int64?   Int64?
─────┼─────────────────────────────────
   1 │       1      3        3       2
   2 │ missing      2  missing       4
   3 │ missing      4        2       4

julia&gt; names(df)
4-element Vector{String}:
 &quot;x1&quot;
 &quot;x2&quot;
 &quot;x3&quot;
 &quot;x4&quot;

julia&gt; names(df, Int) # pick columns whose element type is Int
1-element Vector{String}:
 &quot;x2&quot;

julia&gt; names(df, x -&gt; x[end] == &#39;2&#39;) # pick columns for which last character in their name is &#39;2&#39;
1-element Vector{String}:
 &quot;x2&quot;

julia&gt; fun(col) = sum(skipmissing(col)) &gt;= 10
fun (generic function with 1 method)

julia&gt; names(df, fun.(eachcol(df))) # pick columns for which sum of their elements is at least 10
1-element Vector{String}:
 &quot;x4&quot;

julia&gt; names(df, eltype.(eachcol(df)) .&gt;: Missing) # pick columns that allow missing values
3-element Vector{String}:
 &quot;x1&quot;
 &quot;x3&quot;
 &quot;x4&quot;

julia&gt; names(df, any.(ismissing, eachcol(df))) # pick columns that contain missing values
2-element Vector{String}:
 &quot;x1&quot;
 &quot;x3&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/a1f75b1dd155265e5767e1e3f64d70be824859d7/src/abstractdataframe/abstractdataframe.jl#L29-L97">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.propertynames" href="#Base.propertynames"><code>Base.propertynames</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">propertynames(df::AbstractDataFrame)</code></pre><p>Return a freshly allocated <code>Vector{Symbol}</code> of names of columns contained in <code>df</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/a1f75b1dd155265e5767e1e3f64d70be824859d7/src/abstractdataframe/abstractdataframe.jl#L428-L432">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFrames.rename" href="#DataFrames.rename"><code>DataFrames.rename</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">rename(df::AbstractDataFrame, vals::AbstractVector{Symbol};
       makeunique::Bool=false)
rename(df::AbstractDataFrame, vals::AbstractVector{&lt;:AbstractString};
       makeunique::Bool=false)
rename(df::AbstractDataFrame, (from =&gt; to)::Pair...)
rename(df::AbstractDataFrame, d::AbstractDict)
rename(df::AbstractDataFrame, d::AbstractVector{&lt;:Pair})
rename(f::Function, df::AbstractDataFrame)</code></pre><p>Create a new data frame that is a copy of <code>df</code> with changed column names. Each name is changed at most once. Permutation of names is allowed.</p><p><strong>Arguments</strong></p><ul><li><code>df</code> : the <code>AbstractDataFrame</code>; if it is a <code>SubDataFrame</code> then renaming is only allowed if it was created using <code>:</code> as a column selector.</li><li><code>d</code> : an <code>AbstractDict</code> or an <code>AbstractVector</code> of <code>Pair</code>s that maps the original names or column numbers to new names</li><li><code>f</code> : a function which for each column takes the old name as a <code>String</code> and returns the new name that gets converted to a <code>Symbol</code></li><li><code>vals</code> : new column names as a vector of <code>Symbol</code>s or <code>AbstractString</code>s of the same length as the number of columns in <code>df</code></li><li><code>makeunique</code> : if <code>false</code> (the default), an error will be raised if duplicate names are found; if <code>true</code>, duplicate names will be suffixed with <code>_i</code> (<code>i</code> starting at 1 for the first duplicate).</li></ul><p>If pairs are passed to <code>rename</code> (as positional arguments or in a dictionary or a vector) then:</p><ul><li><code>from</code> value can be a <code>Symbol</code>, an <code>AbstractString</code> or an <code>Integer</code>;</li><li><code>to</code> value can be a <code>Symbol</code> or an <code>AbstractString</code>.</li></ul><p>Mixing symbols and strings in <code>to</code> and <code>from</code> is not allowed.</p><p>Metadata: this function preserves table-level and column-level <code>:note</code>-style metadata.</p><p>Column-level <code>:note</code>-style metadata is considered to be attached to column number: when a column is renamed, its <code>:note</code>-style metadata becomes associated to its new name.</p><p>See also: <a href="#DataFrames.rename!"><code>rename!</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; df = DataFrame(i=1, x=2, y=3)
1×3 DataFrame
 Row │ i      x      y
     │ Int64  Int64  Int64
─────┼─────────────────────
   1 │     1      2      3

julia&gt; rename(df, :i =&gt; :A, :x =&gt; :X)
1×3 DataFrame
 Row │ A      X      y
     │ Int64  Int64  Int64
─────┼─────────────────────
   1 │     1      2      3

julia&gt; rename(df, :x =&gt; :y, :y =&gt; :x)
1×3 DataFrame
 Row │ i      y      x
     │ Int64  Int64  Int64
─────┼─────────────────────
   1 │     1      2      3

julia&gt; rename(df, [1 =&gt; :A, 2 =&gt; :X])
1×3 DataFrame
 Row │ A      X      y
     │ Int64  Int64  Int64
─────┼─────────────────────
   1 │     1      2      3

julia&gt; rename(df, Dict(&quot;i&quot; =&gt; &quot;A&quot;, &quot;x&quot; =&gt; &quot;X&quot;))
1×3 DataFrame
 Row │ A      X      y
     │ Int64  Int64  Int64
─────┼─────────────────────
   1 │     1      2      3

julia&gt; rename(uppercase, df)
1×3 DataFrame
 Row │ I      X      Y
     │ Int64  Int64  Int64
─────┼─────────────────────
   1 │     1      2      3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/a1f75b1dd155265e5767e1e3f64d70be824859d7/src/abstractdataframe/abstractdataframe.jl#L262-L347">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFrames.rename!" href="#DataFrames.rename!"><code>DataFrames.rename!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">rename!(df::AbstractDataFrame, vals::AbstractVector{Symbol};
        makeunique::Bool=false)
rename!(df::AbstractDataFrame, vals::AbstractVector{&lt;:AbstractString};
        makeunique::Bool=false)
rename!(df::AbstractDataFrame, (from =&gt; to)::Pair...)
rename!(df::AbstractDataFrame, d::AbstractDict)
rename!(df::AbstractDataFrame, d::AbstractVector{&lt;:Pair})
rename!(f::Function, df::AbstractDataFrame)</code></pre><p>Rename columns of <code>df</code> in-place. Each name is changed at most once. Permutation of names is allowed.</p><p><strong>Arguments</strong></p><ul><li><code>df</code> : the <code>AbstractDataFrame</code></li><li><code>d</code> : an <code>AbstractDict</code> or an <code>AbstractVector</code> of <code>Pair</code>s that maps the original names or column numbers to new names</li><li><code>f</code> : a function which for each column takes the old name as a <code>String</code> and returns the new name that gets converted to a <code>Symbol</code></li><li><code>vals</code> : new column names as a vector of <code>Symbol</code>s or <code>AbstractString</code>s of the same length as the number of columns in <code>df</code></li><li><code>makeunique</code> : if <code>false</code> (the default), an error will be raised if duplicate names are found; if <code>true</code>, duplicate names will be suffixed with <code>_i</code> (<code>i</code> starting at 1 for the first duplicate).</li></ul><p>If pairs are passed to <code>rename!</code> (as positional arguments or in a dictionary or a vector) then:</p><ul><li><code>from</code> value can be a <code>Symbol</code>, an <code>AbstractString</code> or an <code>Integer</code>;</li><li><code>to</code> value can be a <code>Symbol</code> or an <code>AbstractString</code>.</li></ul><p>Mixing symbols and strings in <code>to</code> and <code>from</code> is not allowed.</p><p>Metadata: this function preserves table-level and column-level <code>:note</code>-style metadata.</p><p>Metadata having other styles is dropped (from parent data frame when <code>df</code> is a <code>SubDataFrame</code>). Column-level <code>:note</code>-style metadata is considered to be attached to column number: when a column is renamed, its <code>:note</code>-style metadata becomes associated to its new name.</p><p>See also: <a href="#DataFrames.rename"><code>rename</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; df = DataFrame(i=1, x=2, y=3)
1×3 DataFrame
 Row │ i      x      y
     │ Int64  Int64  Int64
─────┼─────────────────────
   1 │     1      2      3

julia&gt; rename!(df, Dict(:i =&gt; &quot;A&quot;, :x =&gt; &quot;X&quot;))
1×3 DataFrame
 Row │ A      X      y
     │ Int64  Int64  Int64
─────┼─────────────────────
   1 │     1      2      3

julia&gt; rename!(df, [:a, :b, :c])
1×3 DataFrame
 Row │ a      b      c
     │ Int64  Int64  Int64
─────┼─────────────────────
   1 │     1      2      3

julia&gt; rename!(df, [:a, :b, :a])
ERROR: ArgumentError: Duplicate variable names: :a. Pass makeunique=true to make them unique using a suffix automatically.

julia&gt; rename!(df, [:a, :b, :a], makeunique=true)
1×3 DataFrame
 Row │ a      b      a_1
     │ Int64  Int64  Int64
─────┼─────────────────────
   1 │     1      2      3

julia&gt; rename!(uppercase, df)
1×3 DataFrame
 Row │ A      B      A_1
     │ Int64  Int64  Int64
─────┼─────────────────────
   1 │     1      2      3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/a1f75b1dd155265e5767e1e3f64d70be824859d7/src/abstractdataframe/abstractdataframe.jl#L118-L198">source</a></section></article><h2 id="Mutating-and-transforming-data-frames-and-grouped-data-frames"><a class="docs-heading-anchor" href="#Mutating-and-transforming-data-frames-and-grouped-data-frames">Mutating and transforming data frames and grouped data frames</a><a id="Mutating-and-transforming-data-frames-and-grouped-data-frames-1"></a><a class="docs-heading-anchor-permalink" href="#Mutating-and-transforming-data-frames-and-grouped-data-frames" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Base.append!" href="#Base.append!"><code>Base.append!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">append!(df::DataFrame, df2::AbstractDataFrame; cols::Symbol=:setequal,
        promote::Bool=(cols in [:union, :subset]))
append!(df::DataFrame, table; cols::Symbol=:setequal,
        promote::Bool=(cols in [:union, :subset]))</code></pre><p>Add the rows of <code>df2</code> to the end of <code>df</code>. If the second argument <code>table</code> is not an <code>AbstractDataFrame</code> then it is converted using <code>DataFrame(table, copycols=false)</code> before being appended.</p><p>The exact behavior of <code>append!</code> depends on the <code>cols</code> argument:</p><ul><li>If <code>cols == :setequal</code> (this is the default) then <code>df2</code> must contain exactly the same columns as <code>df</code> (but possibly in a different order).</li><li>If <code>cols == :orderequal</code> then <code>df2</code> must contain the same columns in the same order (for <code>AbstractDict</code> this option requires that <code>keys(row)</code> matches <code>propertynames(df)</code> to allow for support of ordered dicts; however, if <code>df2</code> is a <code>Dict</code> an error is thrown as it is an unordered collection).</li><li>If <code>cols == :intersect</code> then <code>df2</code> may contain more columns than <code>df</code>, but all column names that are present in <code>df</code> must be present in <code>df2</code> and only these are used.</li><li>If <code>cols == :subset</code> then <code>append!</code> behaves like for <code>:intersect</code> but if some column is missing in <code>df2</code> then a <code>missing</code> value is pushed to <code>df</code>.</li><li>If <code>cols == :union</code> then <code>append!</code> adds columns missing in <code>df</code> that are present in <code>df2</code>, for columns present in <code>df</code> but missing in <code>df2</code> a <code>missing</code> value is pushed.</li></ul><p>If <code>promote=true</code> and element type of a column present in <code>df</code> does not allow the type of a pushed argument then a new column with a promoted element type allowing it is freshly allocated and stored in <code>df</code>. If <code>promote=false</code> an error is thrown.</p><p>The above rule has the following exceptions:</p><ul><li>If <code>df</code> has no columns then copies of columns from <code>df2</code> are added to it.</li><li>If <code>df2</code> has no columns then calling <code>append!</code> leaves <code>df</code> unchanged.</li></ul><p>Please note that <code>append!</code> must not be used on a <code>DataFrame</code> that contains columns that are aliases (equal when compared with <code>===</code>).</p><p>Metadata: table-level <code>:note</code>-style metadata and column-level <code>:note</code>-style metadata for columns present in <code>df</code> are preserved. If new columns are added their <code>:note</code>-style metadata is copied from the appended table. Other metadata is dropped.</p><p>See also: use <a href="#Base.push!"><code>push!</code></a> to add individual rows to a data frame, <a href="#Base.prepend!"><code>prepend!</code></a> to add a table at the beginning, and <a href="#Base.vcat"><code>vcat</code></a> to vertically concatenate data frames.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; df1 = DataFrame(A=1:3, B=1:3)
3×2 DataFrame
 Row │ A      B
     │ Int64  Int64
─────┼──────────────
   1 │     1      1
   2 │     2      2
   3 │     3      3

julia&gt; df2 = DataFrame(A=4.0:6.0, B=4:6)
3×2 DataFrame
 Row │ A        B
     │ Float64  Int64
─────┼────────────────
   1 │     4.0      4
   2 │     5.0      5
   3 │     6.0      6

julia&gt; append!(df1, df2);

julia&gt; df1
6×2 DataFrame
 Row │ A      B
     │ Int64  Int64
─────┼──────────────
   1 │     1      1
   2 │     2      2
   3 │     3      3
   4 │     4      4
   5 │     5      5
   6 │     6      6</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/a1f75b1dd155265e5767e1e3f64d70be824859d7/src/dataframe/insertion.jl#L1-L82">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFrames.combine" href="#DataFrames.combine"><code>DataFrames.combine</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">combine(df::AbstractDataFrame, args...;
        renamecols::Bool=true, threads::Bool=true)
combine(f::Callable, df::AbstractDataFrame;
        renamecols::Bool=true, threads::Bool=true)
combine(gd::GroupedDataFrame, args...;
        keepkeys::Bool=true, ungroup::Bool=true,
        renamecols::Bool=true, threads::Bool=true)
combine(f::Base.Callable, gd::GroupedDataFrame;
        keepkeys::Bool=true, ungroup::Bool=true,
        renamecols::Bool=true, threads::Bool=true)</code></pre><p>Create a new data frame that contains columns from <code>df</code> or <code>gd</code> specified by <code>args</code> and return it. The result can have any number of rows that is determined by the values returned by passed transformations.</p><p>Below detailed common rules for all transformation functions supported by DataFrames.jl are explained and compared.</p><p>All these operations are supported both for <code>AbstractDataFrame</code> (when split and combine steps are skipped) and <code>GroupedDataFrame</code>. Technically, <code>AbstractDataFrame</code> is just considered as being grouped on no columns (meaning it has a single group, or zero groups if it is empty). The only difference is that in this case the <code>keepkeys</code> and <code>ungroup</code> keyword arguments (described below) are not supported and a data frame is always returned, as there are no split and combine steps in this case.</p><p>In order to perform operations by groups you first need to create a <code>GroupedDataFrame</code> object from your data frame using the <code>groupby</code> function that takes two arguments: (1) a data frame to be grouped, and (2) a set of columns to group by.</p><p>Operations can then be applied on each group using one of the following functions:</p><ul><li><code>combine</code>: does not put restrictions on number of rows returned per group; the returned values are vertically concatenated following order of groups in <code>GroupedDataFrame</code>; it is typically used to compute summary statistics by group; for <code>GroupedDataFrame</code> if grouping columns are kept they are put as first columns in the result;</li><li><code>select</code>: return a data frame with the number and order of rows exactly the same as the source data frame, including only new calculated columns; <code>select!</code> is an in-place version of <code>select</code>; for <code>GroupedDataFrame</code> if grouping columns are kept they are put as first columns in the result;</li><li><code>transform</code>: return a data frame with the number and order of rows exactly the same as the source data frame, including all columns from the source and new calculated columns; <code>transform!</code> is an in-place version of <code>transform</code>; existing columns in the source data frame are put as first columns in the result;</li></ul><p>As a special case, if a <code>GroupedDataFrame</code> that has zero groups is passed then the result of the operation is determined by performing a single call to the transformation function with a 0-row argument passed to it. The output of this operation is only used to identify the number and type of produced columns, but the result has zero rows.</p><p>All these functions take a specification of one or more functions to apply to each subset of the <code>DataFrame</code>. This specification can be of the following forms:</p><ol><li>standard column selectors (integers, <code>Symbol</code>s, strings, vectors of integers, vectors of <code>Symbol</code>s, vectors of strings, <code>All</code>, <code>Cols</code>, <code>:</code>, <code>Between</code>, <code>Not</code> and regular expressions)</li><li>a <code>cols =&gt; function</code> pair indicating that <code>function</code> should be called with positional arguments holding columns <code>cols</code>, which can be any valid column selector; in this case target column name is automatically generated and it is assumed that <code>function</code> returns a single value or a vector; the generated name is created by concatenating source column name and <code>function</code> name by default (see examples below).</li><li>a <code>cols =&gt; function =&gt; target_cols</code> form additionally explicitly specifying the target column or columns, which must be a single name (as a <code>Symbol</code> or a string), a vector of names or <code>AsTable</code>. Additionally it can be a <code>Function</code> which takes a string or a vector of strings as an argument containing names of columns selected by <code>cols</code>, and returns the target columns names (all accepted types except <code>AsTable</code> are allowed).</li><li>a <code>col =&gt; target_cols</code> pair, which renames the column <code>col</code> to <code>target_cols</code>, which must be single name (as a <code>Symbol</code> or a string), a vector of names or <code>AsTable</code>.</li><li>column-independent operations <code>function =&gt; target_cols</code> or just <code>function</code> for specific <code>function</code>s where the input columns are omitted; without <code>target_cols</code> the new column has the same name as <code>function</code>, otherwise it must be single name (as a <code>Symbol</code> or a string). Supported <code>function</code>s are:<ul><li><code>nrow</code> to efficiently compute the number of rows in each group.</li><li><code>proprow</code> to efficiently compute the proportion of rows in each group.</li><li><code>eachindex</code> to return a vector holding the number of each row within each group.</li><li><code>groupindices</code> to return the group number.</li></ul></li><li>vectors or matrices containing transformations specified by the <code>Pair</code> syntax described in points 2 to 5</li><li>a function which will be called with a <code>SubDataFrame</code> corresponding to each group if a <code>GroupedDataFrame</code> is processed, or with the data frame itself if an <code>AbstractDataFrame</code> is processed; this form should be avoided due to its poor performance unless the number of groups is small or a very large number of columns are processed (in which case <code>SubDataFrame</code> avoids excessive compilation)</li></ol><p>Note! If the expression of the form <code>x =&gt; y</code> is passed then except for the special convenience form <code>nrow =&gt; target_cols</code> it is always interpreted as <code>cols =&gt; function</code>. In particular the following expression <code>function =&gt; target_cols</code> is not a valid transformation specification.</p><p>Note! If <code>cols</code> or <code>target_cols</code> are one of <code>All</code>, <code>Cols</code>, <code>Between</code>, or <code>Not</code>, broadcasting using <code>.=&gt;</code> is supported and is equivalent to broadcasting the result of <code>names(df, cols)</code> or <code>names(df, target_cols)</code>. This behaves as if broadcasting happened after replacing the selector with selected column names within the data frame scope.</p><p>All functions have two types of signatures. One of them takes a <code>GroupedDataFrame</code> as the first argument and an arbitrary number of transformations described above as following arguments. The second type of signature is when a <code>Function</code> or a <code>Type</code> is passed as the first argument and a <code>GroupedDataFrame</code> as the second argument (similar to <code>map</code>).</p><p>As a special rule, with the <code>cols =&gt; function</code> and <code>cols =&gt; function =&gt; target_cols</code> syntaxes, if <code>cols</code> is wrapped in an <code>AsTable</code> object then a <code>NamedTuple</code> containing columns selected by <code>cols</code> is passed to <code>function</code>. The documentation of <a href="#DataFrames.table_transformation"><code>DataFrames.table_transformation</code></a> provides more information about this functionality, in particular covering performance considerations.</p><p>What is allowed for <code>function</code> to return is determined by the <code>target_cols</code> value:</p><ol><li>If both <code>cols</code> and <code>target_cols</code> are omitted (so only a <code>function</code> is passed), then returning a data frame, a matrix, a <code>NamedTuple</code>, or a <code>DataFrameRow</code> will produce multiple columns in the result. Returning any other value produces a single column.</li><li>If <code>target_cols</code> is a <code>Symbol</code> or a string then the function is assumed to return a single column. In this case returning a data frame, a matrix, a <code>NamedTuple</code>, or a <code>DataFrameRow</code> raises an error.</li><li>If <code>target_cols</code> is a vector of <code>Symbol</code>s or strings or <code>AsTable</code> it is assumed that <code>function</code> returns multiple columns. If <code>function</code> returns one of <code>AbstractDataFrame</code>, <code>NamedTuple</code>, <code>DataFrameRow</code>, <code>AbstractMatrix</code> then rules described in point 1 above apply. If <code>function</code> returns an <code>AbstractVector</code> then each element of this vector must support the <code>keys</code> function, which must return a collection of <code>Symbol</code>s, strings or integers; the return value of <code>keys</code> must be identical for all elements. Then as many columns are created as there are elements in the return value of the <code>keys</code> function. If <code>target_cols</code> is <code>AsTable</code> then their names are set to be equal to the key names except if <code>keys</code> returns integers, in which case they are prefixed by <code>x</code> (so the column names are e.g. <code>x1</code>, <code>x2</code>, ...). If <code>target_cols</code> is a vector of <code>Symbol</code>s or strings then column names produced using the rules above are ignored and replaced by <code>target_cols</code> (the number of columns must be the same as the length of <code>target_cols</code> in this case). If <code>fun</code> returns a value of any other type then it is assumed that it is a table conforming to the Tables.jl API and the <code>Tables.columntable</code> function is called on it to get the resulting columns and their names. The names are retained when <code>target_cols</code> is <code>AsTable</code> and are replaced if <code>target_cols</code> is a vector of <code>Symbol</code>s or strings.</li></ol><p>In all of these cases, <code>function</code> can return either a single row or multiple rows. As a particular rule, values wrapped in a <code>Ref</code> or a <code>0</code>-dimensional <code>AbstractArray</code> are unwrapped and then treated as a single row.</p><p><code>select</code>/<code>select!</code> and <code>transform</code>/<code>transform!</code> always return a data frame with the same number and order of rows as the source (even if <code>GroupedDataFrame</code> had its groups reordered), except when selection results in zero columns in the resulting data frame (in which case the result has zero rows).</p><p>For <code>combine</code>, rows in the returned object appear in the order of groups in the <code>GroupedDataFrame</code>. The functions can return an arbitrary number of rows for each group, but the kind of returned object and the number and names of columns must be the same for all groups, except when a <code>DataFrame()</code> or <code>NamedTuple()</code> is returned, in which case a given group is skipped.</p><p>It is allowed to mix single values and vectors if multiple transformations are requested. In this case single value will be repeated to match the length of columns specified by returned vectors.</p><p>To apply <code>function</code> to each row instead of whole columns, it can be wrapped in a <code>ByRow</code> struct. <code>cols</code> can be any column indexing syntax, in which case <code>function</code> will be passed one argument for each of the columns specified by <code>cols</code> or a <code>NamedTuple</code> of them if specified columns are wrapped in <code>AsTable</code>. If <code>ByRow</code> is used it is allowed for <code>cols</code> to select an empty set of columns, in which case <code>function</code> is called for each row without any arguments and an empty <code>NamedTuple</code> is passed if empty set of columns is wrapped in <code>AsTable</code>.</p><p>If a collection of column names is passed then requesting duplicate column names in target data frame are accepted (e.g. <code>select!(df, [:a], :, r&quot;a&quot;)</code> is allowed) and only the first occurrence is used. In particular a syntax to move column <code>:col</code> to the first position in the data frame is <code>select!(df, :col, :)</code>. On the contrary, output column names of renaming, transformation and single column selection operations must be unique, so e.g. <code>select!(df, :a, :a =&gt; :a)</code> or <code>select!(df, :a, :a =&gt; ByRow(sin) =&gt; :a)</code> are not allowed.</p><p>In general columns returned by transformations are stored in the target data frame without copying. An exception to this rule is when columns from the source data frame are reused in the target data frame. This can happen via expressions like: <code>:x1</code>, <code>[:x1, :x2]</code>, <code>:x1 =&gt; :x2</code>, <code>:x1 =&gt; identity =&gt; :x2</code>, or <code>:x1 =&gt; (x -&gt; @view x[inds])</code> (note that in the last case the source column is reused indirectly via a view). In such cases the behavior depends on the value of the <code>copycols</code> keyword argument:</p><ul><li>if <code>copycols=true</code> then results of such transformations always perform a copy of the source column or its view;</li><li>if <code>copycols=false</code> then copies are only performed to avoid storing the same column several times in the target data frame; more precisely, no copy is made the first time a column is used, but each subsequent reuse of a source column (when compared using <code>===</code>, which excludes views of source columns) performs a copy;</li></ul><p>Note that performing <code>transform!</code> or <code>select!</code> assumes that <code>copycols=false</code>.</p><p>If <code>df</code> is a <code>SubDataFrame</code> and <code>copycols=true</code> then a <code>DataFrame</code> is returned and the same copying rules apply as for a <code>DataFrame</code> input: this means in particular that selected columns will be copied. If <code>copycols=false</code>, a <code>SubDataFrame</code> is returned without copying columns and in this case transforming or renaming columns is not allowed.</p><p>If a <code>GroupedDataFrame</code> is passed and <code>threads=true</code> (the default), a separate task is spawned for each specified transformation; each transformation then spawns as many tasks as Julia threads, and splits processing of groups across them (however, currently transformations with optimized implementations like <code>sum</code> and transformations that return multiple rows use a single task for all groups). This allows for parallel operation when Julia was started with more than one thread. Passed transformation functions must therefore not modify global variables (i.e. they must be pure), use locks to control parallel accesses, or <code>threads=false</code> must be passed to disable multithreading. In the future, parallelism may be extended to other cases, so this requirement also holds for <code>DataFrame</code> inputs.</p><p>In order to improve the performance of the operations some transformations invoke optimized implementation, see <a href="#DataFrames.table_transformation"><code>DataFrames.table_transformation</code></a> for details.</p><p><strong>Keyword arguments</strong></p><ul><li><code>renamecols::Bool=true</code> : whether in the <code>cols =&gt; function</code> form automatically generated column names should include the name of transformation functions or not.</li><li><code>keepkeys::Bool=true</code> : whether grouping columns of <code>gd</code> should be kept in the returned data frame.</li><li><code>ungroup::Bool=true</code> : whether the return value of the operation on <code>gd</code> should be a data frame or a <code>GroupedDataFrame</code>.</li><li><code>threads::Bool=true</code> : whether transformations may be run in separate tasks which can execute in parallel (possibly being applied to multiple rows or groups at the same time). Whether or not tasks are actually spawned and their number are determined automatically. Set to <code>false</code> if some transformations require serial execution or are not thread-safe.</li></ul><p>Metadata: this function propagates table-level <code>:note</code>-style metadata. Column-level <code>:note</code>-style metadata is propagated if: a) a single column is transformed to a single column and the name of the column   does not change (this includes all column selection operations), or b) a single column is transformed with <code>identity</code> or <code>copy</code> to a single column    even if column name is changed (this includes column renaming).    As a special case for <code>GroupedDataFrame</code> if the output has the same name    as a grouping column and <code>keepkeys=true</code>, metadata is taken from    original grouping column.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; df = DataFrame(a=1:3, b=4:6)
3×2 DataFrame
 Row │ a      b
     │ Int64  Int64
─────┼──────────────
   1 │     1      4
   2 │     2      5
   3 │     3      6

julia&gt; combine(df, :a =&gt; sum, nrow, renamecols=false)
1×2 DataFrame
 Row │ a      nrow
     │ Int64  Int64
─────┼──────────────
   1 │     6      3

julia&gt; combine(df, :a =&gt; ByRow(sin) =&gt; :c, :b)
3×2 DataFrame
 Row │ c         b
     │ Float64   Int64
─────┼─────────────────
   1 │ 0.841471      4
   2 │ 0.909297      5
   3 │ 0.14112       6

julia&gt; combine(df, :, [:a, :b] =&gt; (a, b) -&gt; a .+ b .- sum(b)/length(b))
3×3 DataFrame
 Row │ a      b      a_b_function
     │ Int64  Int64  Float64
─────┼────────────────────────────
   1 │     1      4           0.0
   2 │     2      5           2.0
   3 │     3      6           4.0

julia&gt; combine(df, All() .=&gt; [minimum maximum])
1×4 DataFrame
 Row │ a_minimum  b_minimum  a_maximum  b_maximum
     │ Int64      Int64      Int64      Int64
─────┼────────────────────────────────────────────
   1 │         1          4          3          6

julia&gt; using Statistics

julia&gt; combine(df, AsTable(:) =&gt; ByRow(mean), renamecols=false)
3×1 DataFrame
 Row │ a_b
     │ Float64
─────┼─────────
   1 │     2.5
   2 │     3.5
   3 │     4.5

julia&gt; combine(df, AsTable(:) =&gt; ByRow(mean) =&gt; x -&gt; join(x, &quot;_&quot;))
3×1 DataFrame
 Row │ a_b
     │ Float64
─────┼─────────
   1 │     2.5
   2 │     3.5
   3 │     4.5

julia&gt; combine(first, df)
1×2 DataFrame
 Row │ a      b
     │ Int64  Int64
─────┼──────────────
   1 │     1      4

julia&gt; df = DataFrame(a=1:3, b=4:6, c=7:9)
3×3 DataFrame
 Row │ a      b      c
     │ Int64  Int64  Int64
─────┼─────────────────────
   1 │     1      4      7
   2 │     2      5      8
   3 │     3      6      9

julia&gt; combine(df, AsTable(:) =&gt; ByRow(x -&gt; (mean=mean(x), std=std(x))) =&gt; :stats,
               AsTable(:) =&gt; ByRow(x -&gt; (mean=mean(x), std=std(x))) =&gt; AsTable)
3×3 DataFrame
 Row │ stats                    mean     std
     │ NamedTup…                Float64  Float64
─────┼───────────────────────────────────────────
   1 │ (mean = 4.0, std = 3.0)      4.0      3.0
   2 │ (mean = 5.0, std = 3.0)      5.0      3.0
   3 │ (mean = 6.0, std = 3.0)      6.0      3.0

julia&gt; df = DataFrame(a=repeat([1, 2, 3, 4], outer=[2]),
                      b=repeat([2, 1], outer=[4]),
                      c=1:8);

julia&gt; gd = groupby(df, :a);

julia&gt; combine(gd, :c =&gt; sum, nrow)
4×3 DataFrame
 Row │ a      c_sum  nrow
     │ Int64  Int64  Int64
─────┼─────────────────────
   1 │     1      6      2
   2 │     2      8      2
   3 │     3     10      2
   4 │     4     12      2

julia&gt; combine(gd, :c =&gt; sum, nrow, ungroup=false)
GroupedDataFrame with 4 groups based on key: a
First Group (1 row): a = 1
 Row │ a      c_sum  nrow
     │ Int64  Int64  Int64
─────┼─────────────────────
   1 │     1      6      2
⋮
Last Group (1 row): a = 4
 Row │ a      c_sum  nrow
     │ Int64  Int64  Int64
─────┼─────────────────────
   1 │     4     12      2

julia&gt; combine(gd) do d # do syntax for the slower variant
           sum(d.c)
       end
4×2 DataFrame
 Row │ a      x1
     │ Int64  Int64
─────┼──────────────
   1 │     1      6
   2 │     2      8
   3 │     3     10
   4 │     4     12

julia&gt; combine(gd, :c =&gt; (x -&gt; sum(log, x)) =&gt; :sum_log_c) # specifying a name for target column
4×2 DataFrame
 Row │ a      sum_log_c
     │ Int64  Float64
─────┼──────────────────
   1 │     1    1.60944
   2 │     2    2.48491
   3 │     3    3.04452
   4 │     4    3.46574

julia&gt; combine(gd, [:b, :c] .=&gt; sum) # passing a vector of pairs
4×3 DataFrame
 Row │ a      b_sum  c_sum
     │ Int64  Int64  Int64
─────┼─────────────────────
   1 │     1      4      6
   2 │     2      2      8
   3 │     3      4     10
   4 │     4      2     12

julia&gt; combine(gd) do sdf # dropping group when DataFrame() is returned
          sdf.c[1] != 1 ? sdf : DataFrame()
       end
6×3 DataFrame
 Row │ a      b      c
     │ Int64  Int64  Int64
─────┼─────────────────────
   1 │     2      1      2
   2 │     2      1      6
   3 │     3      2      3
   4 │     3      2      7
   5 │     4      1      4
   6 │     4      1      8</code></pre><p><strong>auto-splatting, renaming and keepkeys</strong></p><pre><code class="language-julia-repl hljs">julia&gt; df = DataFrame(a=repeat([1, 2, 3, 4], outer=[2]),
                      b=repeat([2, 1], outer=[4]),
                      c=1:8);

julia&gt; gd = groupby(df, :a);

julia&gt; combine(gd, :b =&gt; :b1, :c =&gt; :c1, [:b, :c] =&gt; +, keepkeys=false)
8×3 DataFrame
 Row │ b1     c1     b_c_+
     │ Int64  Int64  Int64
─────┼─────────────────────
   1 │     2      1      3
   2 │     2      5      7
   3 │     1      2      3
   4 │     1      6      7
   5 │     2      3      5
   6 │     2      7      9
   7 │     1      4      5
   8 │     1      8      9</code></pre><p><strong>broadcasting and column expansion</strong></p><pre><code class="language-julia-repl hljs">julia&gt; df = DataFrame(a=repeat([1, 2, 3, 4], outer=[2]),
                      b=repeat([2, 1], outer=[4]),
                      c=1:8);

julia&gt; gd = groupby(df, :a);

julia&gt; combine(gd, :b, AsTable([:b, :c]) =&gt; ByRow(extrema) =&gt; [:min, :max])
8×4 DataFrame
 Row │ a      b      min    max
     │ Int64  Int64  Int64  Int64
─────┼────────────────────────────
   1 │     1      2      1      2
   2 │     1      2      2      5
   3 │     2      1      1      2
   4 │     2      1      1      6
   5 │     3      2      2      3
   6 │     3      2      2      7
   7 │     4      1      1      4
   8 │     4      1      1      8

julia&gt; combine(gd, [:b, :c] .=&gt; Ref) # preventing vector from being spread across multiple rows
4×3 DataFrame
 Row │ a      b_Ref      c_Ref
     │ Int64  SubArray…  SubArray…
─────┼─────────────────────────────
   1 │     1  [2, 2]     [1, 5]
   2 │     2  [1, 1]     [2, 6]
   3 │     3  [2, 2]     [3, 7]
   4 │     4  [1, 1]     [4, 8]

julia&gt; combine(gd, AsTable(Not(:a)) =&gt; Ref) # protecting result
4×2 DataFrame
 Row │ a      b_c_Ref
     │ Int64  NamedTup…
─────┼─────────────────────────────────
   1 │     1  (b = [2, 2], c = [1, 5])
   2 │     2  (b = [1, 1], c = [2, 6])
   3 │     3  (b = [2, 2], c = [3, 7])
   4 │     4  (b = [1, 1], c = [4, 8])

julia&gt; combine(gd, :, AsTable(Not(:a)) =&gt; sum, renamecols=false)
8×4 DataFrame
 Row │ a      b      c      b_c
     │ Int64  Int64  Int64  Int64
─────┼────────────────────────────
   1 │     1      2      1      3
   2 │     1      2      5      7
   3 │     2      1      2      3
   4 │     2      1      6      7
   5 │     3      2      3      5
   6 │     3      2      7      9
   7 │     4      1      4      5
   8 │     4      1      8      9</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/a1f75b1dd155265e5767e1e3f64d70be824859d7/src/abstractdataframe/selection.jl#L1377-L1654">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFrames.fillcombinations" href="#DataFrames.fillcombinations"><code>DataFrames.fillcombinations</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fillcombinations(df::AbstractDataFrame, indexcols;
                     allowduplicates::Bool=false,
                     fill=missing)</code></pre><p>Generate all combinations of levels of column(s) <code>indexcols</code> in data frame <code>df</code>. Levels and their order are determined by the <code>levels</code> function (i.e. unique values sorted lexicographically by default, or a custom set of levels for e.g. <code>CategoricalArray</code> columns), in addition to <code>missing</code> if present.</p><p>For combinations of <code>indexcols</code> not present in <code>df</code> these columns are filled with the <code>fill</code> value (<code>missing</code> by default).</p><p>If <code>allowduplicates=false</code> (the default) <code>indexcols</code> may only contain unique combinations of <code>indexcols</code> values. If <code>allowduplicates=true</code> duplicates are allowed.</p><p>Metadata: this function preserves table-level and column-level <code>:note</code>-style metadata.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; df = DataFrame(x=1:2, y=&#39;a&#39;:&#39;b&#39;, z=[&quot;x&quot;, &quot;y&quot;])
2×3 DataFrame
 Row │ x      y     z
     │ Int64  Char  String
─────┼─────────────────────
   1 │     1  a     x
   2 │     2  b     y

julia&gt; fillcombinations(df, [:x, :y])
4×3 DataFrame
 Row │ x      y     z
     │ Int64  Char  String?
─────┼──────────────────────
   1 │     1  a     x
   2 │     2  a     missing
   3 │     1  b     missing
   4 │     2  b     y

julia&gt; fillcombinations(df, [:y, :z], fill=0)
4×3 DataFrame
 Row │ x       y     z
     │ Int64?  Char  String
─────┼──────────────────────
   1 │      1  a     x
   2 │      0  b     x
   3 │      0  a     y
   4 │      2  b     y</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/a1f75b1dd155265e5767e1e3f64d70be824859d7/src/abstractdataframe/abstractdataframe.jl#L1376-L1426">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFrames.flatten" href="#DataFrames.flatten"><code>DataFrames.flatten</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">flatten(df::AbstractDataFrame, cols; scalar::Type=Union{})</code></pre><p>When columns <code>cols</code> of data frame <code>df</code> have iterable elements that define <code>length</code> (for example a <code>Vector</code> of <code>Vector</code>s), return a <code>DataFrame</code> where each element of each <code>col</code> in <code>cols</code> is flattened, meaning the column corresponding to <code>col</code> becomes a longer vector where the original entries are concatenated. Elements of row <code>i</code> of <code>df</code> in columns other than <code>cols</code> will be repeated according to the length of <code>df[i, col]</code>. These lengths must therefore be the same for each <code>col</code> in <code>cols</code>, or else an error is raised. Note that these elements are not copied, and thus if they are mutable changing them in the returned <code>DataFrame</code> will affect <code>df</code>.</p><p><code>cols</code> can be any column selector (<code>Symbol</code>, string or integer; <code>:</code>, <code>Cols</code>, <code>All</code>, <code>Between</code>, <code>Not</code>, a regular expression, or a vector of <code>Symbol</code>s, strings or integers).</p><p>If <code>scalar</code> is passed then values that have this type in flattened columns are treated as scalars and broadcasted as many times as is needed to match lengths of values stored in other columns. If all values in a row are scalars, a single row is produced.</p><p>Metadata: this function preserves table-level and column-level <code>:note</code>-style metadata.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; df1 = DataFrame(a=[1, 2], b=[[1, 2], [3, 4]], c=[[5, 6], [7, 8]])
2×3 DataFrame
 Row │ a      b       c
     │ Int64  Array…  Array…
─────┼───────────────────────
   1 │     1  [1, 2]  [5, 6]
   2 │     2  [3, 4]  [7, 8]

julia&gt; flatten(df1, :b)
4×3 DataFrame
 Row │ a      b      c
     │ Int64  Int64  Array…
─────┼──────────────────────
   1 │     1      1  [5, 6]
   2 │     1      2  [5, 6]
   3 │     2      3  [7, 8]
   4 │     2      4  [7, 8]

julia&gt; flatten(df1, [:b, :c])
4×3 DataFrame
 Row │ a      b      c
     │ Int64  Int64  Int64
─────┼─────────────────────
   1 │     1      1      5
   2 │     1      2      6
   3 │     2      3      7
   4 │     2      4      8

julia&gt; df2 = DataFrame(a=[1, 2], b=[(&quot;p&quot;, &quot;q&quot;), (&quot;r&quot;, &quot;s&quot;)])
2×2 DataFrame
 Row │ a      b
     │ Int64  Tuple…
─────┼───────────────────
   1 │     1  (&quot;p&quot;, &quot;q&quot;)
   2 │     2  (&quot;r&quot;, &quot;s&quot;)

julia&gt; flatten(df2, :b)
4×2 DataFrame
 Row │ a      b
     │ Int64  String
─────┼───────────────
   1 │     1  p
   2 │     1  q
   3 │     2  r
   4 │     2  s

julia&gt; df3 = DataFrame(a=[1, 2], b=[[1, 2], [3, 4]], c=[[5, 6], [7]])
2×3 DataFrame
 Row │ a      b       c
     │ Int64  Array…  Array…
─────┼───────────────────────
   1 │     1  [1, 2]  [5, 6]
   2 │     2  [3, 4]  [7]

julia&gt; flatten(df3, [:b, :c])
ERROR: ArgumentError: Lengths of iterables stored in columns :b and :c are not the same in row 2

julia&gt; df4 = DataFrame(a=[1, 2, 3],
                       b=[[1, 2], missing, missing],
                       c=[[5, 6], missing, [7, 8]])
3×3 DataFrame
 Row │ a      b        c
     │ Int64  Array…?  Array…?
─────┼─────────────────────────
   1 │     1  [1, 2]   [5, 6]
   2 │     2  missing  missing
   3 │     3  missing  [7, 8]

julia&gt; flatten(df4, [:b, :c], scalar=Missing)
5×3 DataFrame
 Row │ a      b        c
     │ Int64  Int64?   Int64?
─────┼─────────────────────────
   1 │     1        1        5
   2 │     1        2        6
   3 │     2  missing  missing
   4 │     3  missing        7
   5 │     3  missing        8</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/a1f75b1dd155265e5767e1e3f64d70be824859d7/src/abstractdataframe/abstractdataframe.jl#L2291-L2395">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.hcat" href="#Base.hcat"><code>Base.hcat</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">hcat(df::AbstractDataFrame...;
     makeunique::Bool=false, copycols::Bool=true)</code></pre><p>Horizontally concatenate data frames.</p><p>If <code>makeunique=false</code> (the default) column names of passed objects must be unique. If <code>makeunique=true</code> then duplicate column names will be suffixed with <code>_i</code> (<code>i</code> starting at 1 for the first duplicate).</p><p>If <code>copycols=true</code> (the default) then the <code>DataFrame</code> returned by <code>hcat</code> will contain copied columns from the source data frames. If <code>copycols=false</code> then it will contain columns as they are stored in the source (without copying). This option should be used with caution as mutating either the columns in sources or in the returned <code>DataFrame</code> might lead to the corruption of the other object.</p><p>Metadata: <code>hcat</code> propagates table-level <code>:note</code>-style metadata for keys that are present in all passed data frames and have the same value; it propagates column-level <code>:note</code>-style metadata.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; df1 = DataFrame(A=1:3, B=1:3)
3×2 DataFrame
 Row │ A      B
     │ Int64  Int64
─────┼──────────────
   1 │     1      1
   2 │     2      2
   3 │     3      3

julia&gt; df2 = DataFrame(A=4:6, B=4:6)
3×2 DataFrame
 Row │ A      B
     │ Int64  Int64
─────┼──────────────
   1 │     4      4
   2 │     5      5
   3 │     6      6

julia&gt; df3 = hcat(df1, df2, makeunique=true)
3×4 DataFrame
 Row │ A      B      A_1    B_1
     │ Int64  Int64  Int64  Int64
─────┼────────────────────────────
   1 │     1      1      4      4
   2 │     2      2      5      5
   3 │     3      3      6      6

julia&gt; df3.A === df1.A
false

julia&gt; df3 = hcat(df1, df2, makeunique=true, copycols=false);

julia&gt; df3.A === df1.A
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/a1f75b1dd155265e5767e1e3f64d70be824859d7/src/abstractdataframe/abstractdataframe.jl#L1529-L1587">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.insert!" href="#Base.insert!"><code>Base.insert!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">insert!(df::DataFrame, index::Integer, row::Union{Tuple, AbstractArray}; promote::Bool=false)
insert!(df::DataFrame, index::Integer, row::Union{DataFrameRow, NamedTuple,
                                                  AbstractDict, Tables.AbstractRow};
        cols::Symbol=:setequal, promote::Bool=(cols in [:union, :subset]))</code></pre><p>Add one row to <code>df</code> at position <code>index</code> in-place, taking the values from <code>row</code>. <code>index</code> must be a integer between <code>1</code> and <code>nrow(df)+1</code>.</p><p>Column types of <code>df</code> are preserved, and new values are converted if necessary. An error is thrown if conversion fails.</p><p>If <code>row</code> is neither a <code>DataFrameRow</code>, <code>NamedTuple</code> nor <code>AbstractDict</code> then it must be a <code>Tuple</code> or an <code>AbstractArray</code> and columns are matched by order of appearance. In this case <code>row</code> must contain the same number of elements as the number of columns in <code>df</code>.</p><p>If <code>row</code> is a <code>DataFrameRow</code>, <code>NamedTuple</code>, <code>AbstractDict</code>, or <code>Tables.AbstractRow</code> then values in <code>row</code> are matched to columns in <code>df</code> based on names. The exact behavior depends on the <code>cols</code> argument value in the following way:</p><ul><li>If <code>cols == :setequal</code> (this is the default) then <code>row</code> must contain exactly the same columns as <code>df</code> (but possibly in a different order).</li><li>If <code>cols == :orderequal</code> then <code>row</code> must contain the same columns in the same order (for <code>AbstractDict</code> this option requires that <code>keys(row)</code> matches <code>propertynames(df)</code> to allow for support of ordered dicts; however, if <code>row</code> is a <code>Dict</code> an error is thrown as it is an unordered collection).</li><li>If <code>cols == :intersect</code> then <code>row</code> may contain more columns than <code>df</code>, but all column names that are present in <code>df</code> must be present in <code>row</code> and only they are used to populate a new row in <code>df</code>.</li><li>If <code>cols == :subset</code> then the behavior is like for <code>:intersect</code> but if some column is missing in <code>row</code> then a <code>missing</code> value is pushed to <code>df</code>.</li><li>If <code>cols == :union</code> then columns missing in <code>df</code> that are present in <code>row</code> are added to <code>df</code> (using <code>missing</code> for existing rows) and a <code>missing</code> value is pushed to columns missing in <code>row</code> that are present in <code>df</code>.</li></ul><p>If <code>promote=true</code> and element type of a column present in <code>df</code> does not allow the type of a pushed argument then a new column with a promoted element type allowing it is freshly allocated and stored in <code>df</code>. If <code>promote=false</code> an error is thrown.</p><p>As a special case, if <code>df</code> has no columns and <code>row</code> is a <code>NamedTuple</code>, <code>DataFrameRow</code>, or <code>Tables.AbstractRow</code>, columns are created for all values in <code>row</code>, using their names and order.</p><p>Please note that this function must not be used on a <code>DataFrame</code> that contains columns that are aliases (equal when compared with <code>===</code>).</p><p>Metadata: this function preserves table-level and column-level <code>:note</code>-style metadata.</p><p>See also: <a href="#Base.push!"><code>push!</code></a>, <a href="#Base.pushfirst!"><code>pushfirst!</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; df = DataFrame(A=&#39;a&#39;:&#39;c&#39;, B=1:3)
3×2 DataFrame
 Row │ A     B
     │ Char  Int64
─────┼─────────────
   1 │ a         1
   2 │ b         2
   3 │ c         3

julia&gt; insert!(df, 2, (true, false), promote=true)
4×2 DataFrame
 Row │ A     B
     │ Any   Int64
─────┼─────────────
   1 │ a         1
   2 │ true      0
   3 │ b         2
   4 │ c         3

julia&gt; insert!(df, 5, df[1, :])
5×2 DataFrame
 Row │ A     B
     │ Any   Int64
─────┼─────────────
   1 │ a         1
   2 │ true      0
   3 │ b         2
   4 │ c         3
   5 │ a         1

julia&gt; insert!(df, 1, (C=&quot;something&quot;, A=11, B=12), cols=:intersect)
6×2 DataFrame
 Row │ A     B
     │ Any   Int64
─────┼─────────────
   1 │ 11       12
   2 │ a         1
   3 │ true      0
   4 │ b         2
   5 │ c         3
   6 │ a         1

julia&gt; insert!(df, 7, Dict(:A=&gt;1.0, :C=&gt;1.0), cols=:union)
7×3 DataFrame
 Row │ A     B        C
     │ Any   Int64?   Float64?
─────┼──────────────────────────
   1 │ 11         12  missing
   2 │ a           1  missing
   3 │ true        0  missing
   4 │ b           2  missing
   5 │ c           3  missing
   6 │ a           1  missing
   7 │ 1.0   missing        1.0

julia&gt; insert!(df, 3, NamedTuple(), cols=:subset)
8×3 DataFrame
 Row │ A        B        C
     │ Any      Int64?   Float64?
─────┼─────────────────────────────
   1 │ 11            12  missing
   2 │ a              1  missing
   3 │ missing  missing  missing
   4 │ true           0  missing
   5 │ b              2  missing
   6 │ c              3  missing
   7 │ a              1  missing
   8 │ 1.0      missing        1.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/a1f75b1dd155265e5767e1e3f64d70be824859d7/src/dataframe/insertion.jl#L545-L629">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFrames.insertcols" href="#DataFrames.insertcols"><code>DataFrames.insertcols</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">insertcols(df::AbstractDataFrame[, col], (name=&gt;val)::Pair...;
           after::Bool=false, makeunique::Bool=false, copycols::Bool=true)</code></pre><p>Insert a column into a copy of <code>df</code> data frame using the <a href="#DataFrames.insertcols!"><code>insertcols!</code></a> function and return the newly created data frame.</p><p>If <code>col</code> is omitted it is set to <code>ncol(df)+1</code> (the column is inserted as the last column).</p><p><strong>Arguments</strong></p><ul><li><code>df</code> : the data frame to which we want to add columns</li><li><code>col</code> : a position at which we want to insert a column, passed as an integer or a column name (a string or a <code>Symbol</code>); the column selected with <code>col</code> and columns following it are shifted to the right in <code>df</code> after the operation</li><li><code>name</code> : the name of the new column</li><li><code>val</code> : an <code>AbstractVector</code> giving the contents of the new column or a value of any type other than <code>AbstractArray</code> which will be repeated to fill a new vector; As a particular rule a values stored in a <code>Ref</code> or a <code>0</code>-dimensional <code>AbstractArray</code> are unwrapped and treated in the same way</li><li><code>after</code> : if <code>true</code> columns are inserted after <code>col</code></li><li><code>makeunique</code> : defines what to do if <code>name</code> already exists in <code>df</code>; if it is <code>false</code> an error will be thrown; if it is <code>true</code> a new unique name will be generated by adding a suffix</li><li><code>copycols</code> : whether vectors passed as columns should be copied</li></ul><p>If <code>val</code> is an <code>AbstractRange</code> then the result of <code>collect(val)</code> is inserted.</p><p>If <code>df</code> is a <code>SubDataFrame</code> then it must have been created with <code>:</code> as column selector (otherwise an error is thrown). In this case the <code>copycols</code> keyword argument is ignored (i.e. the added column is always copied) and the parent data frame&#39;s column is filled with <code>missing</code> in rows that are filtered out by <code>df</code>.</p><p>If <code>df</code> isa <code>DataFrame</code> that has no columns and only values other than <code>AbstractVector</code> are passed then it is used to create a one-element column. If <code>df</code> isa <code>DataFrame</code> that has no columns and at least one <code>AbstractVector</code> is passed then its length is used to determine the number of elements in all created columns. In all other cases the number of rows in all created columns must match <code>nrow(df)</code>.</p><p>Metadata: this function preserves table-level and column-level <code>:note</code>-style metadata.</p><p>See also <a href="#DataFrames.insertcols!"><code>insertcols!</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; df = DataFrame(a=1:3)
3×1 DataFrame
 Row │ a
     │ Int64
─────┼───────
   1 │     1
   2 │     2
   3 │     3

julia&gt; insertcols(df, 1, :b =&gt; &#39;a&#39;:&#39;c&#39;)
3×2 DataFrame
 Row │ b     a
     │ Char  Int64
─────┼─────────────
   1 │ a         1
   2 │ b         2
   3 │ c         3

julia&gt; insertcols(df, :c =&gt; 2:4, :c =&gt; 3:5, makeunique=true)
3×3 DataFrame
 Row │ a      c      c_1
     │ Int64  Int64  Int64
─────┼─────────────────────
   1 │     1      2      3
   2 │     2      3      4
   3 │     3      4      5

julia&gt; insertcols(df, :a, :d =&gt; 7:9, after=true)
3×2 DataFrame
 Row │ a      d
     │ Int64  Int64
─────┼──────────────
   1 │     1      7
   2 │     2      8
   3 │     3      9</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/a1f75b1dd155265e5767e1e3f64d70be824859d7/src/abstractdataframe/abstractdataframe.jl#L2884-L2935">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFrames.insertcols!" href="#DataFrames.insertcols!"><code>DataFrames.insertcols!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">insertcols!(df::AbstractDataFrame[, col], (name=&gt;val)::Pair...;
            after::Bool=false, makeunique::Bool=false, copycols::Bool=true)</code></pre><p>Insert a column into a data frame in place. Return the updated data frame.</p><p>If <code>col</code> is omitted it is set to <code>ncol(df)+1</code> (the column is inserted as the last column).</p><p><strong>Arguments</strong></p><ul><li><code>df</code> : the data frame to which we want to add columns</li><li><code>col</code> : a position at which we want to insert a column, passed as an integer or a column name (a string or a <code>Symbol</code>); the column selected with <code>col</code> and columns following it are shifted to the right in <code>df</code> after the operation</li><li><code>name</code> : the name of the new column</li><li><code>val</code> : an <code>AbstractVector</code> giving the contents of the new column or a value of any type other than <code>AbstractArray</code> which will be repeated to fill a new vector; As a particular rule a values stored in a <code>Ref</code> or a <code>0</code>-dimensional <code>AbstractArray</code> are unwrapped and treated in the same way</li><li><code>after</code> : if <code>true</code> columns are inserted after <code>col</code></li><li><code>makeunique</code> : defines what to do if <code>name</code> already exists in <code>df</code>; if it is <code>false</code> an error will be thrown; if it is <code>true</code> a new unique name will be generated by adding a suffix</li><li><code>copycols</code> : whether vectors passed as columns should be copied</li></ul><p>If <code>val</code> is an <code>AbstractRange</code> then the result of <code>collect(val)</code> is inserted.</p><p>If <code>df</code> is a <code>SubDataFrame</code> then it must have been created with <code>:</code> as column selector (otherwise an error is thrown). In this case the <code>copycols</code> keyword argument is ignored (i.e. the added column is always copied) and the parent data frame&#39;s column is filled with <code>missing</code> in rows that are filtered out by <code>df</code>.</p><p>If <code>df</code> isa <code>DataFrame</code> that has no columns and only values other than <code>AbstractVector</code> are passed then it is used to create a one-element column. If <code>df</code> isa <code>DataFrame</code> that has no columns and at least one <code>AbstractVector</code> is passed then its length is used to determine the number of elements in all created columns. In all other cases the number of rows in all created columns must match <code>nrow(df)</code>.</p><p>Metadata: this function preserves table-level and column-level <code>:note</code>-style metadata.</p><p>Metadata having other styles is dropped (from parent data frame when <code>df</code> is a <code>SubDataFrame</code>).</p><p>See also <a href="#DataFrames.insertcols"><code>insertcols</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; df = DataFrame(a=1:3)
3×1 DataFrame
 Row │ a
     │ Int64
─────┼───────
   1 │     1
   2 │     2
   3 │     3

julia&gt; insertcols!(df, 1, :b =&gt; &#39;a&#39;:&#39;c&#39;)
3×2 DataFrame
 Row │ b     a
     │ Char  Int64
─────┼─────────────
   1 │ a         1
   2 │ b         2
   3 │ c         3

julia&gt; insertcols!(df, 2, :c =&gt; 2:4, :c =&gt; 3:5, makeunique=true)
3×4 DataFrame
 Row │ b     c      c_1    a
     │ Char  Int64  Int64  Int64
─────┼───────────────────────────
   1 │ a         2      3      1
   2 │ b         3      4      2
   3 │ c         4      5      3

julia&gt; insertcols!(df, :b, :d =&gt; 7:9, after=true)
3×5 DataFrame
 Row │ b     d      c      c_1    a
     │ Char  Int64  Int64  Int64  Int64
─────┼──────────────────────────────────
   1 │ a         7      2      3      1
   2 │ b         8      3      4      2
   3 │ c         9      4      5      3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/a1f75b1dd155265e5767e1e3f64d70be824859d7/src/abstractdataframe/abstractdataframe.jl#L2941-L2992">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.invpermute!" href="#Base.invpermute!"><code>Base.invpermute!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">invpermute!(df::AbstractDataFrame, p)</code></pre><p>Like <a href="#Base.permute!"><code>permute!</code></a>, but the inverse of the given permutation is applied.</p><p><code>invpermute!</code> will produce a correct result even if some columns of passed data frame or permutation <code>p</code> are identical (checked with <code>===</code>). Otherwise, if two columns share some part of memory but are not identical (e.g. are different views of the same parent vector) then <code>invpermute!</code> result might be incorrect.</p><p>Metadata: this function preserves table-level and column-level <code>:note</code>-style metadata.</p><p>Metadata having other styles is dropped (from parent data frame when <code>df</code> is a <code>SubDataFrame</code>).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; df = DataFrame(a=1:5, b=6:10, c=11:15)
5×3 DataFrame
 Row │ a      b      c
     │ Int64  Int64  Int64
─────┼─────────────────────
   1 │     1      6     11
   2 │     2      7     12
   3 │     3      8     13
   4 │     4      9     14
   5 │     5     10     15

julia&gt; permute!(df, [5, 3, 1, 2, 4])
5×3 DataFrame
 Row │ a      b      c
     │ Int64  Int64  Int64
─────┼─────────────────────
   1 │     5     10     15
   2 │     3      8     13
   3 │     1      6     11
   4 │     2      7     12
   5 │     4      9     14

julia&gt; invpermute!(df, [5, 3, 1, 2, 4])
5×3 DataFrame
 Row │ a      b      c
     │ Int64  Int64  Int64
─────┼─────────────────────
   1 │     1      6     11
   2 │     2      7     12
   3 │     3      8     13
   4 │     4      9     14
   5 │     5     10     15</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/a1f75b1dd155265e5767e1e3f64d70be824859d7/src/abstractdataframe/abstractdataframe.jl#L2723-L2772">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFrames.mapcols" href="#DataFrames.mapcols"><code>DataFrames.mapcols</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">mapcols(f::Union{Function, Type}, df::AbstractDataFrame)</code></pre><p>Return a <code>DataFrame</code> where each column of <code>df</code> is transformed using function <code>f</code>. <code>f</code> must return <code>AbstractVector</code> objects all with the same length or scalars (all values other than <code>AbstractVector</code> are considered to be a scalar).</p><p>Note that <code>mapcols</code> guarantees not to reuse the columns from <code>df</code> in the returned <code>DataFrame</code>. If <code>f</code> returns its argument then it gets copied before being stored.</p><p>Metadata: this function preserves table-level and column-level <code>:note</code>-style metadata.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; df = DataFrame(x=1:4, y=11:14)
4×2 DataFrame
 Row │ x      y
     │ Int64  Int64
─────┼──────────────
   1 │     1     11
   2 │     2     12
   3 │     3     13
   4 │     4     14

julia&gt; mapcols(x -&gt; x.^2, df)
4×2 DataFrame
 Row │ x      y
     │ Int64  Int64
─────┼──────────────
   1 │     1    121
   2 │     4    144
   3 │     9    169
   4 │    16    196</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/a1f75b1dd155265e5767e1e3f64d70be824859d7/src/abstractdataframe/iteration.jl#L410-L444">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFrames.mapcols!" href="#DataFrames.mapcols!"><code>DataFrames.mapcols!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">mapcols!(f::Union{Function, Type}, df::DataFrame)</code></pre><p>Update a <code>DataFrame</code> in-place where each column of <code>df</code> is transformed using function <code>f</code>. <code>f</code> must return <code>AbstractVector</code> objects all with the same length or scalars (all values other than <code>AbstractVector</code> are considered to be a scalar).</p><p>Note that <code>mapcols!</code> reuses the columns from <code>df</code> if they are returned by <code>f</code>.</p><p>Metadata: this function preserves table-level and column-level <code>:note</code>-style metadata.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; df = DataFrame(x=1:4, y=11:14)
4×2 DataFrame
 Row │ x      y
     │ Int64  Int64
─────┼──────────────
   1 │     1     11
   2 │     2     12
   3 │     3     13
   4 │     4     14

julia&gt; mapcols!(x -&gt; x.^2, df);

julia&gt; df
4×2 DataFrame
 Row │ x      y
     │ Int64  Int64
─────┼──────────────
   1 │     1    121
   2 │     4    144
   3 │     9    169
   4 │    16    196</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/a1f75b1dd155265e5767e1e3f64d70be824859d7/src/abstractdataframe/iteration.jl#L472-L507">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.permute!" href="#Base.permute!"><code>Base.permute!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">permute!(df::AbstractDataFrame, p)</code></pre><p>Permute data frame <code>df</code> in-place, according to permutation <code>p</code>. Throws <code>ArgumentError</code> if <code>p</code> is not a permutation.</p><p>To return a new data frame instead of permuting <code>df</code> in-place, use <code>df[p, :]</code>.</p><p><code>permute!</code> will produce a correct result even if some columns of passed data frame or permutation <code>p</code> are identical (checked with <code>===</code>). Otherwise, if two columns share some part of memory but are not identical (e.g. are different views of the same parent vector) then <code>permute!</code> result might be incorrect.</p><p>Metadata: this function preserves table-level and column-level <code>:note</code>-style metadata.</p><p>Metadata having other styles is dropped (from parent data frame when <code>df</code> is a <code>SubDataFrame</code>).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; df = DataFrame(a=1:5, b=6:10, c=11:15)
5×3 DataFrame
 Row │ a      b      c
     │ Int64  Int64  Int64
─────┼─────────────────────
   1 │     1      6     11
   2 │     2      7     12
   3 │     3      8     13
   4 │     4      9     14
   5 │     5     10     15

julia&gt; permute!(df, [5, 3, 1, 2, 4])
5×3 DataFrame
 Row │ a      b      c
     │ Int64  Int64  Int64
─────┼─────────────────────
   1 │     5     10     15
   2 │     3      8     13
   3 │     1      6     11
   4 │     2      7     12
   5 │     4      9     14</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/a1f75b1dd155265e5767e1e3f64d70be824859d7/src/abstractdataframe/abstractdataframe.jl#L2678-L2719">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.prepend!" href="#Base.prepend!"><code>Base.prepend!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">prepend!(df::DataFrame, df2::AbstractDataFrame; cols::Symbol=:setequal,
         promote::Bool=(cols in [:union, :subset]))
prepend!(df::DataFrame, table; cols::Symbol=:setequal,
         promote::Bool=(cols in [:union, :subset]))</code></pre><p>Add the rows of <code>df2</code> to the beginning of <code>df</code>. If the second argument <code>table</code> is not an <code>AbstractDataFrame</code> then it is converted using <code>DataFrame(table, copycols=false)</code> before being prepended.</p><p>The exact behavior of <code>prepend!</code> depends on the <code>cols</code> argument:</p><ul><li>If <code>cols == :setequal</code> (this is the default) then <code>df2</code> must contain exactly the same columns as <code>df</code> (but possibly in a different order).</li><li>If <code>cols == :orderequal</code> then <code>df2</code> must contain the same columns in the same order (for <code>AbstractDict</code> this option requires that <code>keys(row)</code> matches <code>propertynames(df)</code> to allow for support of ordered dicts; however, if <code>df2</code> is a <code>Dict</code> an error is thrown as it is an unordered collection).</li><li>If <code>cols == :intersect</code> then <code>df2</code> may contain more columns than <code>df</code>, but all column names that are present in <code>df</code> must be present in <code>df2</code> and only these are used.</li><li>If <code>cols == :subset</code> then <code>append!</code> behaves like for <code>:intersect</code> but if some column is missing in <code>df2</code> then a <code>missing</code> value is pushed to <code>df</code>.</li><li>If <code>cols == :union</code> then <code>append!</code> adds columns missing in <code>df</code> that are present in <code>df2</code>, for columns present in <code>df</code> but missing in <code>df2</code> a <code>missing</code> value is pushed.</li></ul><p>If <code>promote=true</code> and element type of a column present in <code>df</code> does not allow the type of a pushed argument then a new column with a promoted element type allowing it is freshly allocated and stored in <code>df</code>. If <code>promote=false</code> an error is thrown.</p><p>The above rule has the following exceptions:</p><ul><li>If <code>df</code> has no columns then copies of columns from <code>df2</code> are added to it.</li><li>If <code>df2</code> has no columns then calling <code>prepend!</code> leaves <code>df</code> unchanged.</li></ul><p>Please note that <code>prepend!</code> must not be used on a <code>DataFrame</code> that contains columns that are aliases (equal when compared with <code>===</code>).</p><p>Metadata: table-level <code>:note</code>-style metadata and column-level <code>:note</code>-style metadata for columns present in <code>df</code> are preserved. If new columns are added their <code>:note</code>-style metadata is copied from the appended table. Other metadata is dropped.</p><p>See also: use <a href="#Base.pushfirst!"><code>pushfirst!</code></a> to add individual rows at the beginning of a data frame, <a href="#Base.append!"><code>append!</code></a> to add a table at the end, and <a href="#Base.vcat"><code>vcat</code></a> to vertically concatenate data frames.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; df1 = DataFrame(A=1:3, B=1:3)
3×2 DataFrame
 Row │ A      B
     │ Int64  Int64
─────┼──────────────
   1 │     1      1
   2 │     2      2
   3 │     3      3

julia&gt; df2 = DataFrame(A=4.0:6.0, B=4:6)
3×2 DataFrame
 Row │ A        B
     │ Float64  Int64
─────┼────────────────
   1 │     4.0      4
   2 │     5.0      5
   3 │     6.0      6

julia&gt; prepend!(df1, df2);

julia&gt; df1
6×2 DataFrame
 Row │ A      B
     │ Int64  Int64
─────┼──────────────
   1 │     4      4
   2 │     5      5
   3 │     6      6
   4 │     1      1
   5 │     2      2
   6 │     3      3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/a1f75b1dd155265e5767e1e3f64d70be824859d7/src/dataframe/insertion.jl#L87-L168">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.push!" href="#Base.push!"><code>Base.push!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">push!(df::DataFrame, row::Union{Tuple, AbstractArray}; promote::Bool=false)
push!(df::DataFrame, row::Union{DataFrameRow, NamedTuple, AbstractDict,
                                Tables.AbstractRow};
      cols::Symbol=:setequal, promote::Bool=(cols in [:union, :subset]))</code></pre><p>Add one row at the end of <code>df</code> in-place, taking the values from <code>row</code>.</p><p>Column types of <code>df</code> are preserved, and new values are converted if necessary. An error is thrown if conversion fails.</p><p>If <code>row</code> is neither a <code>DataFrameRow</code>, <code>NamedTuple</code> nor <code>AbstractDict</code> then it must be a <code>Tuple</code> or an <code>AbstractArray</code> and columns are matched by order of appearance. In this case <code>row</code> must contain the same number of elements as the number of columns in <code>df</code>.</p><p>If <code>row</code> is a <code>DataFrameRow</code>, <code>NamedTuple</code>, <code>AbstractDict</code>, or <code>Tables.AbstractRow</code> then values in <code>row</code> are matched to columns in <code>df</code> based on names. The exact behavior depends on the <code>cols</code> argument value in the following way:</p><ul><li>If <code>cols == :setequal</code> (this is the default) then <code>row</code> must contain exactly the same columns as <code>df</code> (but possibly in a different order).</li><li>If <code>cols == :orderequal</code> then <code>row</code> must contain the same columns in the same order (for <code>AbstractDict</code> this option requires that <code>keys(row)</code> matches <code>propertynames(df)</code> to allow for support of ordered dicts; however, if <code>row</code> is a <code>Dict</code> an error is thrown as it is an unordered collection).</li><li>If <code>cols == :intersect</code> then <code>row</code> may contain more columns than <code>df</code>, but all column names that are present in <code>df</code> must be present in <code>row</code> and only they are used to populate a new row in <code>df</code>.</li><li>If <code>cols == :subset</code> then the behavior is like for <code>:intersect</code> but if some column is missing in <code>row</code> then a <code>missing</code> value is pushed to <code>df</code>.</li><li>If <code>cols == :union</code> then columns missing in <code>df</code> that are present in <code>row</code> are added to <code>df</code> (using <code>missing</code> for existing rows) and a <code>missing</code> value is pushed to columns missing in <code>row</code> that are present in <code>df</code>.</li></ul><p>If <code>promote=true</code> and element type of a column present in <code>df</code> does not allow the type of a pushed argument then a new column with a promoted element type allowing it is freshly allocated and stored in <code>df</code>. If <code>promote=false</code> an error is thrown.</p><p>As a special case, if <code>df</code> has no columns and <code>row</code> is a <code>NamedTuple</code>, <code>DataFrameRow</code>, or <code>Tables.AbstractRow</code>, columns are created for all values in <code>row</code>, using their names and order.</p><p>Please note that this function must not be used on a <code>DataFrame</code> that contains columns that are aliases (equal when compared with <code>===</code>).</p><p>Metadata: this function preserves table-level and column-level <code>:note</code>-style metadata.</p><p>See also: <a href="#Base.pushfirst!"><code>pushfirst!</code></a>, <a href="#Base.insert!"><code>insert!</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; df = DataFrame(A=&#39;a&#39;:&#39;c&#39;, B=1:3)
3×2 DataFrame
 Row │ A     B
     │ Char  Int64
─────┼─────────────
   1 │ a         1
   2 │ b         2
   3 │ c         3

julia&gt; push!(df, (true, false), promote=true)
4×2 DataFrame
 Row │ A     B
     │ Any   Int64
─────┼─────────────
   1 │ a         1
   2 │ b         2
   3 │ c         3
   4 │ true      0

julia&gt; push!(df, df[1, :])
5×2 DataFrame
 Row │ A     B
     │ Any   Int64
─────┼─────────────
   1 │ a         1
   2 │ b         2
   3 │ c         3
   4 │ true      0
   5 │ a         1

julia&gt; push!(df, (C=&quot;something&quot;, A=11, B=12), cols=:intersect)
6×2 DataFrame
 Row │ A     B
     │ Any   Int64
─────┼─────────────
   1 │ a         1
   2 │ b         2
   3 │ c         3
   4 │ true      0
   5 │ a         1
   6 │ 11       12

julia&gt; push!(df, Dict(:A=&gt;1.0, :C=&gt;1.0), cols=:union)
7×3 DataFrame
 Row │ A     B        C
     │ Any   Int64?   Float64?
─────┼──────────────────────────
   1 │ a           1  missing
   2 │ b           2  missing
   3 │ c           3  missing
   4 │ true        0  missing
   5 │ a           1  missing
   6 │ 11         12  missing
   7 │ 1.0   missing        1.0

julia&gt; push!(df, NamedTuple(), cols=:subset)
8×3 DataFrame
 Row │ A        B        C
     │ Any      Int64?   Float64?
─────┼─────────────────────────────
   1 │ a              1  missing
   2 │ b              2  missing
   3 │ c              3  missing
   4 │ true           0  missing
   5 │ a              1  missing
   6 │ 11            12  missing
   7 │ 1.0      missing        1.0
   8 │ missing  missing  missing</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/a1f75b1dd155265e5767e1e3f64d70be824859d7/src/dataframe/insertion.jl#L371-L454">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.pushfirst!" href="#Base.pushfirst!"><code>Base.pushfirst!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pushfirst!(df::DataFrame, row::Union{Tuple, AbstractArray}; promote::Bool=false)
pushfirst!(df::DataFrame, row::Union{DataFrameRow, NamedTuple, AbstractDict,
                                     Tables.AbstractRow};
           cols::Symbol=:setequal, promote::Bool=(cols in [:union, :subset]))</code></pre><p>Add one row at the beginning of <code>df</code> in-place, taking the values from <code>row</code>.</p><p>Column types of <code>df</code> are preserved, and new values are converted if necessary. An error is thrown if conversion fails.</p><p>If <code>row</code> is neither a <code>DataFrameRow</code>, <code>NamedTuple</code> nor <code>AbstractDict</code> then it must be a <code>Tuple</code> or an <code>AbstractArray</code> and columns are matched by order of appearance. In this case <code>row</code> must contain the same number of elements as the number of columns in <code>df</code>.</p><p>If <code>row</code> is a <code>DataFrameRow</code>, <code>NamedTuple</code>, <code>AbstractDict</code>, or <code>Tables.AbstractRow</code> then values in <code>row</code> are matched to columns in <code>df</code> based on names. The exact behavior depends on the <code>cols</code> argument value in the following way:</p><ul><li>If <code>cols == :setequal</code> (this is the default) then <code>row</code> must contain exactly the same columns as <code>df</code> (but possibly in a different order).</li><li>If <code>cols == :orderequal</code> then <code>row</code> must contain the same columns in the same order (for <code>AbstractDict</code> this option requires that <code>keys(row)</code> matches <code>propertynames(df)</code> to allow for support of ordered dicts; however, if <code>row</code> is a <code>Dict</code> an error is thrown as it is an unordered collection).</li><li>If <code>cols == :intersect</code> then <code>row</code> may contain more columns than <code>df</code>, but all column names that are present in <code>df</code> must be present in <code>row</code> and only they are used to populate a new row in <code>df</code>.</li><li>If <code>cols == :subset</code> then the behavior is like for <code>:intersect</code> but if some column is missing in <code>row</code> then a <code>missing</code> value is pushed to <code>df</code>.</li><li>If <code>cols == :union</code> then columns missing in <code>df</code> that are present in <code>row</code> are added to <code>df</code> (using <code>missing</code> for existing rows) and a <code>missing</code> value is pushed to columns missing in <code>row</code> that are present in <code>df</code>.</li></ul><p>If <code>promote=true</code> and element type of a column present in <code>df</code> does not allow the type of a pushed argument then a new column with a promoted element type allowing it is freshly allocated and stored in <code>df</code>. If <code>promote=false</code> an error is thrown.</p><p>As a special case, if <code>df</code> has no columns and <code>row</code> is a <code>NamedTuple</code>, <code>DataFrameRow</code>, or <code>Tables.AbstractRow</code>, columns are created for all values in <code>row</code>, using their names and order.</p><p>Please note that this function must not be used on a <code>DataFrame</code> that contains columns that are aliases (equal when compared with <code>===</code>).</p><p>Metadata: this function preserves table-level and column-level <code>:note</code>-style metadata.</p><p>See also: <a href="#Base.push!"><code>push!</code></a>, <a href="#Base.insert!"><code>insert!</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; df = DataFrame(A=&#39;a&#39;:&#39;c&#39;, B=1:3)
3×2 DataFrame
 Row │ A     B
     │ Char  Int64
─────┼─────────────
   1 │ a         1
   2 │ b         2
   3 │ c         3

julia&gt; pushfirst!(df, (true, false), promote=true)
4×2 DataFrame
 Row │ A     B
     │ Any   Int64
─────┼─────────────
   1 │ true      0
   2 │ a         1
   3 │ b         2
   4 │ c         3

julia&gt; pushfirst!(df, df[1, :])
5×2 DataFrame
 Row │ A     B
     │ Any   Int64
─────┼─────────────
   1 │ true      0
   2 │ true      0
   3 │ a         1
   4 │ b         2
   5 │ c         3

julia&gt; pushfirst!(df, (C=&quot;something&quot;, A=11, B=12), cols=:intersect)
6×2 DataFrame
 Row │ A     B
     │ Any   Int64
─────┼─────────────
   1 │ 11       12
   2 │ true      0
   3 │ true      0
   4 │ a         1
   5 │ b         2
   6 │ c         3

julia&gt; pushfirst!(df, Dict(:A=&gt;1.0, :C=&gt;1.0), cols=:union)
7×3 DataFrame
 Row │ A     B        C
     │ Any   Int64?   Float64?
─────┼──────────────────────────
   1 │ 1.0   missing        1.0
   2 │ 11         12  missing
   3 │ true        0  missing
   4 │ true        0  missing
   5 │ a           1  missing
   6 │ b           2  missing
   7 │ c           3  missing

julia&gt; pushfirst!(df, NamedTuple(), cols=:subset)
8×3 DataFrame
 Row │ A        B        C
     │ Any      Int64?   Float64?
─────┼─────────────────────────────
   1 │ missing  missing  missing
   2 │ 1.0      missing        1.0
   3 │ 11            12  missing
   4 │ true           0  missing
   5 │ true           0  missing
   6 │ a              1  missing
   7 │ b              2  missing
   8 │ c              3  missing</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/a1f75b1dd155265e5767e1e3f64d70be824859d7/src/dataframe/insertion.jl#L458-L541">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.reduce" href="#Base.reduce"><code>Base.reduce</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">reduce(::typeof(vcat),
       dfs::Union{AbstractVector{&lt;:AbstractDataFrame},
                  Tuple{AbstractDataFrame, Vararg{AbstractDataFrame}}};
       cols::Union{Symbol, AbstractVector{Symbol},
                   AbstractVector{&lt;:AbstractString}}=:setequal,
       source::Union{Nothing, Symbol, AbstractString,
                     Pair{&lt;:Union{Symbol, AbstractString}, &lt;:AbstractVector}}=nothing,
       init::AbstractDataFrame=DataFrame())</code></pre><p>Efficiently reduce the given vector or tuple of <code>AbstractDataFrame</code>s with <code>vcat</code>.</p><p>See the <a href="#Base.vcat"><code>vcat</code></a> docstring for a description of keyword arguments <code>cols</code> and <code>source</code>.</p><p>The keyword argument <code>init</code> is the initial value to use in the reductions. It must be a data frame that has zero rows. It is not taken into account when computing the value of the <code>source</code> column nor when determining metadata of the produced data frame.</p><p>The column order, names, and types of the resulting <code>DataFrame</code>, and the behavior of <code>cols</code> and <code>source</code> keyword arguments follow the rules specified for <a href="#Base.vcat"><code>vcat</code></a> of <code>AbstractDataFrame</code>s.</p><p>Metadata: <code>vcat</code> propagates table-level <code>:note</code>-style metadata for keys that are present in all passed data frames and have the same value. <code>vcat</code> propagates column-level <code>:note</code>-style metadata for keys that are present in all passed data frames that contain this column and have the same value.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; df1 = DataFrame(A=1:3, B=1:3)
3×2 DataFrame
 Row │ A      B
     │ Int64  Int64
─────┼──────────────
   1 │     1      1
   2 │     2      2
   3 │     3      3

julia&gt; df2 = DataFrame(A=4:6, B=4:6)
3×2 DataFrame
 Row │ A      B
     │ Int64  Int64
─────┼──────────────
   1 │     4      4
   2 │     5      5
   3 │     6      6

julia&gt; df3 = DataFrame(A=7:9, C=7:9)
3×2 DataFrame
 Row │ A      C
     │ Int64  Int64
─────┼──────────────
   1 │     7      7
   2 │     8      8
   3 │     9      9

julia&gt; reduce(vcat, (df1, df2))
6×2 DataFrame
 Row │ A      B
     │ Int64  Int64
─────┼──────────────
   1 │     1      1
   2 │     2      2
   3 │     3      3
   4 │     4      4
   5 │     5      5
   6 │     6      6

julia&gt; reduce(vcat, [df1, df2, df3], cols=:union, source=:source)
9×4 DataFrame
 Row │ A      B        C        source
     │ Int64  Int64?   Int64?   Int64
─────┼─────────────────────────────────
   1 │     1        1  missing       1
   2 │     2        2  missing       1
   3 │     3        3  missing       1
   4 │     4        4  missing       2
   5 │     5        5  missing       2
   6 │     6        6  missing       2
   7 │     7  missing        7       3
   8 │     8  missing        8       3
   9 │     9  missing        9       3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/a1f75b1dd155265e5767e1e3f64d70be824859d7/src/abstractdataframe/abstractdataframe.jl#L1773-L1859">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.repeat" href="#Base.repeat"><code>Base.repeat</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">repeat(df::AbstractDataFrame; inner::Integer = 1, outer::Integer = 1)</code></pre><p>Construct a data frame by repeating rows in <code>df</code>. <code>inner</code> specifies how many times each row is repeated, and <code>outer</code> specifies how many times the full set of rows is repeated.</p><p>Metadata: this function preserves table-level and column-level <code>:note</code>-style metadata.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; df = DataFrame(a=1:2, b=3:4)
2×2 DataFrame
 Row │ a      b
     │ Int64  Int64
─────┼──────────────
   1 │     1      3
   2 │     2      4

julia&gt; repeat(df, inner=2, outer=3)
12×2 DataFrame
 Row │ a      b
     │ Int64  Int64
─────┼──────────────
   1 │     1      3
   2 │     1      3
   3 │     2      4
   4 │     2      4
   5 │     1      3
   6 │     1      3
   7 │     2      4
   8 │     2      4
   9 │     1      3
  10 │     1      3
  11 │     2      4
  12 │     2      4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/a1f75b1dd155265e5767e1e3f64d70be824859d7/src/abstractdataframe/abstractdataframe.jl#L2055-L2092">source</a></section><section><div><pre><code class="nohighlight hljs">repeat(df::AbstractDataFrame, count::Integer)</code></pre><p>Construct a data frame by repeating each row in <code>df</code> the number of times specified by <code>count</code>.</p><p>Metadata: this function preserves table-level and column-level <code>:note</code>-style metadata.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; df = DataFrame(a=1:2, b=3:4)
2×2 DataFrame
 Row │ a      b
     │ Int64  Int64
─────┼──────────────
   1 │     1      3
   2 │     2      4

julia&gt; repeat(df, 2)
4×2 DataFrame
 Row │ a      b
     │ Int64  Int64
─────┼──────────────
   1 │     1      3
   2 │     2      4
   3 │     1      3
   4 │     2      4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/a1f75b1dd155265e5767e1e3f64d70be824859d7/src/abstractdataframe/abstractdataframe.jl#L2099-L2127">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFrames.repeat!" href="#DataFrames.repeat!"><code>DataFrames.repeat!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">repeat!(df::DataFrame; inner::Integer=1, outer::Integer=1)</code></pre><p>Update a data frame <code>df</code> in-place by repeating its rows. <code>inner</code> specifies how many times each row is repeated, and <code>outer</code> specifies how many times the full set of rows is repeated. Columns of <code>df</code> are freshly allocated.</p><p>Metadata: this function preserves table-level and column-level <code>:note</code>-style metadata.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; df = DataFrame(a=1:2, b=3:4)
2×2 DataFrame
 Row │ a      b
     │ Int64  Int64
─────┼──────────────
   1 │     1      3
   2 │     2      4

julia&gt; repeat!(df, inner=2, outer=3);

julia&gt; df
12×2 DataFrame
 Row │ a      b
     │ Int64  Int64
─────┼──────────────
   1 │     1      3
   2 │     1      3
   3 │     2      4
   4 │     2      4
   5 │     1      3
   6 │     1      3
   7 │     2      4
   8 │     2      4
   9 │     1      3
  10 │     1      3
  11 │     2      4
  12 │     2      4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/a1f75b1dd155265e5767e1e3f64d70be824859d7/src/dataframe/dataframe.jl#L1356-L1395">source</a></section><section><div><pre><code class="nohighlight hljs">repeat!(df::DataFrame, count::Integer)</code></pre><p>Update a data frame <code>df</code> in-place by repeating its rows the number of times specified by <code>count</code>. Columns of <code>df</code> are freshly allocated.</p><p>Metadata: this function preserves table-level and column-level <code>:note</code>-style metadata.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; df = DataFrame(a=1:2, b=3:4)
2×2 DataFrame
 Row │ a      b
     │ Int64  Int64
─────┼──────────────
   1 │     1      3
   2 │     2      4

julia&gt; repeat(df, 2)
4×2 DataFrame
 Row │ a      b
     │ Int64  Int64
─────┼──────────────
   1 │     1      3
   2 │     2      4
   3 │     1      3
   4 │     2      4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/a1f75b1dd155265e5767e1e3f64d70be824859d7/src/dataframe/dataframe.jl#L1409-L1437">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.reverse" href="#Base.reverse"><code>Base.reverse</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">reverse(df::AbstractDataFrame, start=1, stop=nrow(df))</code></pre><p>Return a data frame containing the rows in <code>df</code> in reversed order. If <code>start</code> and <code>stop</code> are provided, only rows in the <code>start:stop</code> range are affected.</p><p>Metadata: this function preserves table-level and column-level <code>:note</code>-style metadata.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; df = DataFrame(a=1:5, b=6:10, c=11:15)
5×3 DataFrame
 Row │ a      b      c
     │ Int64  Int64  Int64
─────┼─────────────────────
   1 │     1      6     11
   2 │     2      7     12
   3 │     3      8     13
   4 │     4      9     14
   5 │     5     10     15

julia&gt; reverse(df)
5×3 DataFrame
 Row │ a      b      c
     │ Int64  Int64  Int64
─────┼─────────────────────
   1 │     5     10     15
   2 │     4      9     14
   3 │     3      8     13
   4 │     2      7     12
   5 │     1      6     11

julia&gt; reverse(df, 2, 3)
5×3 DataFrame
 Row │ a      b      c
     │ Int64  Int64  Int64
─────┼─────────────────────
   1 │     1      6     11
   2 │     3      8     13
   3 │     2      7     12
   4 │     4      9     14
   5 │     5     10     15</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/a1f75b1dd155265e5767e1e3f64d70be824859d7/src/abstractdataframe/abstractdataframe.jl#L2478-L2522">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.reverse!" href="#Base.reverse!"><code>Base.reverse!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">reverse!(df::AbstractDataFrame, start=1, stop=nrow(df))</code></pre><p>Mutate data frame in-place to reverse its row order. If <code>start</code> and <code>stop</code> are provided, only rows in the <code>start:stop</code> range are affected.</p><p><code>reverse!</code> will produce a correct result even if some columns of passed data frame are identical (checked with <code>===</code>). Otherwise, if two columns share some part of memory but are not identical (e.g. are different views of the same parent vector) then <code>reverse!</code> result might be incorrect.</p><p>Metadata: this function preserves table-level and column-level <code>:note</code>-style metadata.</p><p>Metadata having other styles is dropped (from parent data frame when <code>df</code> is a <code>SubDataFrame</code>).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; df = DataFrame(a=1:5, b=6:10, c=11:15)
5×3 DataFrame
 Row │ a      b      c
     │ Int64  Int64  Int64
─────┼─────────────────────
   1 │     1      6     11
   2 │     2      7     12
   3 │     3      8     13
   4 │     4      9     14
   5 │     5     10     15

julia&gt; reverse!(df)
5×3 DataFrame
 Row │ a      b      c
     │ Int64  Int64  Int64
─────┼─────────────────────
   1 │     5     10     15
   2 │     4      9     14
   3 │     3      8     13
   4 │     2      7     12
   5 │     1      6     11

julia&gt; reverse!(df, 2, 3)
5×3 DataFrame
 Row │ a      b      c
     │ Int64  Int64  Int64
─────┼─────────────────────
   1 │     5     10     15
   2 │     3      8     13
   3 │     4      9     14
   4 │     2      7     12
   5 │     1      6     11</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/a1f75b1dd155265e5767e1e3f64d70be824859d7/src/abstractdataframe/abstractdataframe.jl#L2526-L2576">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFrames.select" href="#DataFrames.select"><code>DataFrames.select</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">select(df::AbstractDataFrame, args...;
       copycols::Bool=true, renamecols::Bool=true, threads::Bool=true)
select(args::Callable, df::DataFrame;
       renamecols::Bool=true, threads::Bool=true)
select(gd::GroupedDataFrame, args...;
       copycols::Bool=true, keepkeys::Bool=true, ungroup::Bool=true,
       renamecols::Bool=true, threads::Bool=true)
select(f::Base.Callable, gd::GroupedDataFrame;
       copycols::Bool=true, keepkeys::Bool=true, ungroup::Bool=true,
       renamecols::Bool=true, threads::Bool=true)</code></pre><p>Create a new data frame that contains columns from <code>df</code> or <code>gd</code> specified by <code>args</code> and return it. The result is guaranteed to have the same number of rows as <code>df</code>, except when no columns are selected (in which case the result has zero rows).</p><p>Below detailed common rules for all transformation functions supported by DataFrames.jl are explained and compared.</p><p>All these operations are supported both for <code>AbstractDataFrame</code> (when split and combine steps are skipped) and <code>GroupedDataFrame</code>. Technically, <code>AbstractDataFrame</code> is just considered as being grouped on no columns (meaning it has a single group, or zero groups if it is empty). The only difference is that in this case the <code>keepkeys</code> and <code>ungroup</code> keyword arguments (described below) are not supported and a data frame is always returned, as there are no split and combine steps in this case.</p><p>In order to perform operations by groups you first need to create a <code>GroupedDataFrame</code> object from your data frame using the <code>groupby</code> function that takes two arguments: (1) a data frame to be grouped, and (2) a set of columns to group by.</p><p>Operations can then be applied on each group using one of the following functions:</p><ul><li><code>combine</code>: does not put restrictions on number of rows returned per group; the returned values are vertically concatenated following order of groups in <code>GroupedDataFrame</code>; it is typically used to compute summary statistics by group; for <code>GroupedDataFrame</code> if grouping columns are kept they are put as first columns in the result;</li><li><code>select</code>: return a data frame with the number and order of rows exactly the same as the source data frame, including only new calculated columns; <code>select!</code> is an in-place version of <code>select</code>; for <code>GroupedDataFrame</code> if grouping columns are kept they are put as first columns in the result;</li><li><code>transform</code>: return a data frame with the number and order of rows exactly the same as the source data frame, including all columns from the source and new calculated columns; <code>transform!</code> is an in-place version of <code>transform</code>; existing columns in the source data frame are put as first columns in the result;</li></ul><p>As a special case, if a <code>GroupedDataFrame</code> that has zero groups is passed then the result of the operation is determined by performing a single call to the transformation function with a 0-row argument passed to it. The output of this operation is only used to identify the number and type of produced columns, but the result has zero rows.</p><p>All these functions take a specification of one or more functions to apply to each subset of the <code>DataFrame</code>. This specification can be of the following forms:</p><ol><li>standard column selectors (integers, <code>Symbol</code>s, strings, vectors of integers, vectors of <code>Symbol</code>s, vectors of strings, <code>All</code>, <code>Cols</code>, <code>:</code>, <code>Between</code>, <code>Not</code> and regular expressions)</li><li>a <code>cols =&gt; function</code> pair indicating that <code>function</code> should be called with positional arguments holding columns <code>cols</code>, which can be any valid column selector; in this case target column name is automatically generated and it is assumed that <code>function</code> returns a single value or a vector; the generated name is created by concatenating source column name and <code>function</code> name by default (see examples below).</li><li>a <code>cols =&gt; function =&gt; target_cols</code> form additionally explicitly specifying the target column or columns, which must be a single name (as a <code>Symbol</code> or a string), a vector of names or <code>AsTable</code>. Additionally it can be a <code>Function</code> which takes a string or a vector of strings as an argument containing names of columns selected by <code>cols</code>, and returns the target columns names (all accepted types except <code>AsTable</code> are allowed).</li><li>a <code>col =&gt; target_cols</code> pair, which renames the column <code>col</code> to <code>target_cols</code>, which must be single name (as a <code>Symbol</code> or a string), a vector of names or <code>AsTable</code>.</li><li>column-independent operations <code>function =&gt; target_cols</code> or just <code>function</code> for specific <code>function</code>s where the input columns are omitted; without <code>target_cols</code> the new column has the same name as <code>function</code>, otherwise it must be single name (as a <code>Symbol</code> or a string). Supported <code>function</code>s are:<ul><li><code>nrow</code> to efficiently compute the number of rows in each group.</li><li><code>proprow</code> to efficiently compute the proportion of rows in each group.</li><li><code>eachindex</code> to return a vector holding the number of each row within each group.</li><li><code>groupindices</code> to return the group number.</li></ul></li><li>vectors or matrices containing transformations specified by the <code>Pair</code> syntax described in points 2 to 5</li><li>a function which will be called with a <code>SubDataFrame</code> corresponding to each group if a <code>GroupedDataFrame</code> is processed, or with the data frame itself if an <code>AbstractDataFrame</code> is processed; this form should be avoided due to its poor performance unless the number of groups is small or a very large number of columns are processed (in which case <code>SubDataFrame</code> avoids excessive compilation)</li></ol><p>Note! If the expression of the form <code>x =&gt; y</code> is passed then except for the special convenience form <code>nrow =&gt; target_cols</code> it is always interpreted as <code>cols =&gt; function</code>. In particular the following expression <code>function =&gt; target_cols</code> is not a valid transformation specification.</p><p>Note! If <code>cols</code> or <code>target_cols</code> are one of <code>All</code>, <code>Cols</code>, <code>Between</code>, or <code>Not</code>, broadcasting using <code>.=&gt;</code> is supported and is equivalent to broadcasting the result of <code>names(df, cols)</code> or <code>names(df, target_cols)</code>. This behaves as if broadcasting happened after replacing the selector with selected column names within the data frame scope.</p><p>All functions have two types of signatures. One of them takes a <code>GroupedDataFrame</code> as the first argument and an arbitrary number of transformations described above as following arguments. The second type of signature is when a <code>Function</code> or a <code>Type</code> is passed as the first argument and a <code>GroupedDataFrame</code> as the second argument (similar to <code>map</code>).</p><p>As a special rule, with the <code>cols =&gt; function</code> and <code>cols =&gt; function =&gt; target_cols</code> syntaxes, if <code>cols</code> is wrapped in an <code>AsTable</code> object then a <code>NamedTuple</code> containing columns selected by <code>cols</code> is passed to <code>function</code>. The documentation of <a href="#DataFrames.table_transformation"><code>DataFrames.table_transformation</code></a> provides more information about this functionality, in particular covering performance considerations.</p><p>What is allowed for <code>function</code> to return is determined by the <code>target_cols</code> value:</p><ol><li>If both <code>cols</code> and <code>target_cols</code> are omitted (so only a <code>function</code> is passed), then returning a data frame, a matrix, a <code>NamedTuple</code>, or a <code>DataFrameRow</code> will produce multiple columns in the result. Returning any other value produces a single column.</li><li>If <code>target_cols</code> is a <code>Symbol</code> or a string then the function is assumed to return a single column. In this case returning a data frame, a matrix, a <code>NamedTuple</code>, or a <code>DataFrameRow</code> raises an error.</li><li>If <code>target_cols</code> is a vector of <code>Symbol</code>s or strings or <code>AsTable</code> it is assumed that <code>function</code> returns multiple columns. If <code>function</code> returns one of <code>AbstractDataFrame</code>, <code>NamedTuple</code>, <code>DataFrameRow</code>, <code>AbstractMatrix</code> then rules described in point 1 above apply. If <code>function</code> returns an <code>AbstractVector</code> then each element of this vector must support the <code>keys</code> function, which must return a collection of <code>Symbol</code>s, strings or integers; the return value of <code>keys</code> must be identical for all elements. Then as many columns are created as there are elements in the return value of the <code>keys</code> function. If <code>target_cols</code> is <code>AsTable</code> then their names are set to be equal to the key names except if <code>keys</code> returns integers, in which case they are prefixed by <code>x</code> (so the column names are e.g. <code>x1</code>, <code>x2</code>, ...). If <code>target_cols</code> is a vector of <code>Symbol</code>s or strings then column names produced using the rules above are ignored and replaced by <code>target_cols</code> (the number of columns must be the same as the length of <code>target_cols</code> in this case). If <code>fun</code> returns a value of any other type then it is assumed that it is a table conforming to the Tables.jl API and the <code>Tables.columntable</code> function is called on it to get the resulting columns and their names. The names are retained when <code>target_cols</code> is <code>AsTable</code> and are replaced if <code>target_cols</code> is a vector of <code>Symbol</code>s or strings.</li></ol><p>In all of these cases, <code>function</code> can return either a single row or multiple rows. As a particular rule, values wrapped in a <code>Ref</code> or a <code>0</code>-dimensional <code>AbstractArray</code> are unwrapped and then treated as a single row.</p><p><code>select</code>/<code>select!</code> and <code>transform</code>/<code>transform!</code> always return a data frame with the same number and order of rows as the source (even if <code>GroupedDataFrame</code> had its groups reordered), except when selection results in zero columns in the resulting data frame (in which case the result has zero rows).</p><p>For <code>combine</code>, rows in the returned object appear in the order of groups in the <code>GroupedDataFrame</code>. The functions can return an arbitrary number of rows for each group, but the kind of returned object and the number and names of columns must be the same for all groups, except when a <code>DataFrame()</code> or <code>NamedTuple()</code> is returned, in which case a given group is skipped.</p><p>It is allowed to mix single values and vectors if multiple transformations are requested. In this case single value will be repeated to match the length of columns specified by returned vectors.</p><p>To apply <code>function</code> to each row instead of whole columns, it can be wrapped in a <code>ByRow</code> struct. <code>cols</code> can be any column indexing syntax, in which case <code>function</code> will be passed one argument for each of the columns specified by <code>cols</code> or a <code>NamedTuple</code> of them if specified columns are wrapped in <code>AsTable</code>. If <code>ByRow</code> is used it is allowed for <code>cols</code> to select an empty set of columns, in which case <code>function</code> is called for each row without any arguments and an empty <code>NamedTuple</code> is passed if empty set of columns is wrapped in <code>AsTable</code>.</p><p>If a collection of column names is passed then requesting duplicate column names in target data frame are accepted (e.g. <code>select!(df, [:a], :, r&quot;a&quot;)</code> is allowed) and only the first occurrence is used. In particular a syntax to move column <code>:col</code> to the first position in the data frame is <code>select!(df, :col, :)</code>. On the contrary, output column names of renaming, transformation and single column selection operations must be unique, so e.g. <code>select!(df, :a, :a =&gt; :a)</code> or <code>select!(df, :a, :a =&gt; ByRow(sin) =&gt; :a)</code> are not allowed.</p><p>In general columns returned by transformations are stored in the target data frame without copying. An exception to this rule is when columns from the source data frame are reused in the target data frame. This can happen via expressions like: <code>:x1</code>, <code>[:x1, :x2]</code>, <code>:x1 =&gt; :x2</code>, <code>:x1 =&gt; identity =&gt; :x2</code>, or <code>:x1 =&gt; (x -&gt; @view x[inds])</code> (note that in the last case the source column is reused indirectly via a view). In such cases the behavior depends on the value of the <code>copycols</code> keyword argument:</p><ul><li>if <code>copycols=true</code> then results of such transformations always perform a copy of the source column or its view;</li><li>if <code>copycols=false</code> then copies are only performed to avoid storing the same column several times in the target data frame; more precisely, no copy is made the first time a column is used, but each subsequent reuse of a source column (when compared using <code>===</code>, which excludes views of source columns) performs a copy;</li></ul><p>Note that performing <code>transform!</code> or <code>select!</code> assumes that <code>copycols=false</code>.</p><p>If <code>df</code> is a <code>SubDataFrame</code> and <code>copycols=true</code> then a <code>DataFrame</code> is returned and the same copying rules apply as for a <code>DataFrame</code> input: this means in particular that selected columns will be copied. If <code>copycols=false</code>, a <code>SubDataFrame</code> is returned without copying columns and in this case transforming or renaming columns is not allowed.</p><p>If a <code>GroupedDataFrame</code> is passed and <code>threads=true</code> (the default), a separate task is spawned for each specified transformation; each transformation then spawns as many tasks as Julia threads, and splits processing of groups across them (however, currently transformations with optimized implementations like <code>sum</code> and transformations that return multiple rows use a single task for all groups). This allows for parallel operation when Julia was started with more than one thread. Passed transformation functions must therefore not modify global variables (i.e. they must be pure), use locks to control parallel accesses, or <code>threads=false</code> must be passed to disable multithreading. In the future, parallelism may be extended to other cases, so this requirement also holds for <code>DataFrame</code> inputs.</p><p>In order to improve the performance of the operations some transformations invoke optimized implementation, see <a href="#DataFrames.table_transformation"><code>DataFrames.table_transformation</code></a> for details.</p><p><strong>Keyword arguments</strong></p><ul><li><code>copycols::Bool=true</code> : whether columns of the source data frame should be copied if no transformation is applied to them.</li><li><code>renamecols::Bool=true</code> : whether in the <code>cols =&gt; function</code> form automatically generated column names should include the name of transformation functions or not.</li><li><code>keepkeys::Bool=true</code> : whether grouping columns of <code>gd</code> should be kept in the returned data frame.</li><li><code>ungroup::Bool=true</code> : whether the return value of the operation on <code>gd</code> should be a data frame or a <code>GroupedDataFrame</code>.</li><li><code>threads::Bool=true</code> : whether transformations may be run in separate tasks which can execute in parallel (possibly being applied to multiple rows or groups at the same time). Whether or not tasks are actually spawned and their number are determined automatically. Set to <code>false</code> if some transformations require serial execution or are not thread-safe.</li></ul><p>Metadata: this function propagates table-level <code>:note</code>-style metadata. Column-level <code>:note</code>-style metadata is propagated if: a) a single column is transformed to a single column and the name of the column   does not change (this includes all column selection operations), or b) a single column is transformed with <code>identity</code> or <code>copy</code> to a single column    even if column name is changed (this includes column renaming).    As a special case for <code>GroupedDataFrame</code> if the output has the same name    as a grouping column and <code>keepkeys=true</code>, metadata is taken from    original grouping column.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; df = DataFrame(a=1:3, b=4:6)
3×2 DataFrame
 Row │ a      b
     │ Int64  Int64
─────┼──────────────
   1 │     1      4
   2 │     2      5
   3 │     3      6

julia&gt; select(df, 2)
3×1 DataFrame
 Row │ b
     │ Int64
─────┼───────
   1 │     4
   2 │     5
   3 │     6

julia&gt; select(df, :a =&gt; ByRow(sin) =&gt; :c, :b)
3×2 DataFrame
 Row │ c         b
     │ Float64   Int64
─────┼─────────────────
   1 │ 0.841471      4
   2 │ 0.909297      5
   3 │ 0.14112       6

julia&gt; select(df, :, [:a, :b] =&gt; (a, b) -&gt; a .+ b .- sum(b)/length(b))
3×3 DataFrame
 Row │ a      b      a_b_function
     │ Int64  Int64  Float64
─────┼────────────────────────────
   1 │     1      4           0.0
   2 │     2      5           2.0
   3 │     3      6           4.0

julia&gt; select(df, All() .=&gt; [minimum maximum])
3×4 DataFrame
 Row │ a_minimum  b_minimum  a_maximum  b_maximum
     │ Int64      Int64      Int64      Int64
─────┼────────────────────────────────────────────
   1 │         1          4          3          6
   2 │         1          4          3          6
   3 │         1          4          3          6

julia&gt; using Statistics

julia&gt; select(df, AsTable(:) =&gt; ByRow(mean), renamecols=false)
3×1 DataFrame
 Row │ a_b
     │ Float64
─────┼─────────
   1 │     2.5
   2 │     3.5
   3 │     4.5

julia&gt; select(df, AsTable(:) =&gt; ByRow(mean) =&gt; x -&gt; join(x, &quot;_&quot;))
3×1 DataFrame
 Row │ a_b
     │ Float64
─────┼─────────
   1 │     2.5
   2 │     3.5
   3 │     4.5

julia&gt; select(first, df)
3×2 DataFrame
 Row │ a      b
     │ Int64  Int64
─────┼──────────────
   1 │     1      4
   2 │     1      4
   3 │     1      4

julia&gt; df = DataFrame(a=1:3, b=4:6, c=7:9)
3×3 DataFrame
 Row │ a      b      c
     │ Int64  Int64  Int64
─────┼─────────────────────
   1 │     1      4      7
   2 │     2      5      8
   3 │     3      6      9

julia&gt; select(df, AsTable(:) =&gt; ByRow(x -&gt; (mean=mean(x), std=std(x))) =&gt; :stats,
              AsTable(:) =&gt; ByRow(x -&gt; (mean=mean(x), std=std(x))) =&gt; AsTable)
3×3 DataFrame
 Row │ stats                    mean     std
     │ NamedTup…                Float64  Float64
─────┼───────────────────────────────────────────
   1 │ (mean = 4.0, std = 3.0)      4.0      3.0
   2 │ (mean = 5.0, std = 3.0)      5.0      3.0
   3 │ (mean = 6.0, std = 3.0)      6.0      3.0

julia&gt; df = DataFrame(a=[1, 1, 1, 2, 2, 1, 1, 2],
                      b=repeat([2, 1], outer=[4]),
                      c=1:8)
8×3 DataFrame
 Row │ a      b      c
     │ Int64  Int64  Int64
─────┼─────────────────────
   1 │     1      2      1
   2 │     1      1      2
   3 │     1      2      3
   4 │     2      1      4
   5 │     2      2      5
   6 │     1      1      6
   7 │     1      2      7
   8 │     2      1      8

julia&gt; gd = groupby(df, :a)
GroupedDataFrame with 2 groups based on key: a
First Group (5 rows): a = 1
 Row │ a      b      c
     │ Int64  Int64  Int64
─────┼─────────────────────
   1 │     1      2      1
   2 │     1      1      2
   3 │     1      2      3
   4 │     1      1      6
   5 │     1      2      7
⋮
Last Group (3 rows): a = 2
 Row │ a      b      c
     │ Int64  Int64  Int64
─────┼─────────────────────
   1 │     2      1      4
   2 │     2      2      5
   3 │     2      1      8</code></pre><p><strong>specifying a name for target column</strong></p><pre><code class="language-julia-repl hljs">julia&gt; df = DataFrame(a=[1, 1, 1, 2, 2, 1, 1, 2],
                      b=repeat([2, 1], outer=[4]),
                      c=1:8);

julia&gt; gd = groupby(df, :a);

julia&gt; select(gd, :c =&gt; (x -&gt; sum(log, x)) =&gt; :sum_log_c)
8×2 DataFrame
 Row │ a      sum_log_c
     │ Int64  Float64
─────┼──────────────────
   1 │     1    5.52943
   2 │     1    5.52943
   3 │     1    5.52943
   4 │     2    5.07517
   5 │     2    5.07517
   6 │     1    5.52943
   7 │     1    5.52943
   8 │     2    5.07517

julia&gt; select(gd, [:b, :c] .=&gt; sum) # passing a vector of pairs
8×3 DataFrame
 Row │ a      b_sum  c_sum
     │ Int64  Int64  Int64
─────┼─────────────────────
   1 │     1      8     19
   2 │     1      8     19
   3 │     1      8     19
   4 │     2      4     17
   5 │     2      4     17
   6 │     1      8     19
   7 │     1      8     19
   8 │     2      4     17</code></pre><p><strong>multiple arguments, renaming and keepkeys</strong></p><pre><code class="language-julia-repl hljs">julia&gt; df = DataFrame(a=[1, 1, 1, 2, 2, 1, 1, 2],
                      b=repeat([2, 1], outer=[4]),
                      c=1:8);

julia&gt; gd = groupby(df, :a);

julia&gt; select(gd, :b =&gt; :b1, :c =&gt; :c1, [:b, :c] =&gt; +, keepkeys=false)
8×3 DataFrame
 Row │ b1     c1     b_c_+
     │ Int64  Int64  Int64
─────┼─────────────────────
   1 │     2      1      3
   2 │     1      2      3
   3 │     2      3      5
   4 │     1      4      5
   5 │     2      5      7
   6 │     1      6      7
   7 │     2      7      9
   8 │     1      8      9</code></pre><p><strong>broadcasting and column expansion</strong></p><pre><code class="language-julia-repl hljs">julia&gt; df = DataFrame(a=[1, 1, 1, 2, 2, 1, 1, 2],
                      b=repeat([2, 1], outer=[4]),
                      c=1:8);

julia&gt; gd = groupby(df, :a);

julia&gt; select(gd, :b, AsTable([:b, :c]) =&gt; ByRow(extrema) =&gt; [:min, :max])
8×4 DataFrame
 Row │ a      b      min    max
     │ Int64  Int64  Int64  Int64
─────┼────────────────────────────
   1 │     1      2      1      2
   2 │     1      1      1      2
   3 │     1      2      2      3
   4 │     2      1      1      4
   5 │     2      2      2      5
   6 │     1      1      1      6
   7 │     1      2      2      7
   8 │     2      1      1      8

julia&gt; select(gd, :, AsTable(Not(:a)) =&gt; sum, renamecols=false)
8×4 DataFrame
 Row │ a      b      c      b_c
     │ Int64  Int64  Int64  Int64
─────┼────────────────────────────
   1 │     1      2      1      3
   2 │     1      1      2      3
   3 │     1      2      3      5
   4 │     2      1      4      5
   5 │     2      2      5      7
   6 │     1      1      6      7
   7 │     1      2      7      9
   8 │     2      1      8      9</code></pre><p><strong>column-independent operations</strong></p><pre><code class="language-julia-repl hljs">julia&gt; df = DataFrame(a=[1, 1, 1, 2, 2, 1, 1, 2],
                      b=repeat([2, 1], outer=[4]),
                      c=1:8);

julia&gt; gd = groupby(df, :a);

julia&gt; select(gd, nrow, proprow, groupindices, eachindex)
8×5 DataFrame
 Row │ a      nrow   proprow  groupindices  eachindex
     │ Int64  Int64  Float64  Int64         Int64
─────┼────────────────────────────────────────────────
   1 │     1      5    0.625             1          1
   2 │     1      5    0.625             1          2
   3 │     1      5    0.625             1          3
   4 │     2      3    0.375             2          1
   5 │     2      3    0.375             2          2
   6 │     1      5    0.625             1          4
   7 │     1      5    0.625             1          5
   8 │     2      3    0.375             2          3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/a1f75b1dd155265e5767e1e3f64d70be824859d7/src/abstractdataframe/selection.jl#L997-L1283">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFrames.select!" href="#DataFrames.select!"><code>DataFrames.select!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">select!(df::AbstractDataFrame, args...;
        renamecols::Bool=true, threads::Bool=true)
select!(args::Base.Callable, df::DataFrame;
        renamecols::Bool=true, threads::Bool=true)
select!(gd::GroupedDataFrame, args...; ungroup::Bool=true,
        renamecols::Bool=true, threads::Bool=true)
select!(f::Base.Callable, gd::GroupedDataFrame; ungroup::Bool=true,
        renamecols::Bool=true, threads::Bool=true)</code></pre><p>Mutate <code>df</code> or <code>gd</code> in place to retain only columns or transformations specified by <code>args...</code> and return it. The result is guaranteed to have the same number of rows as <code>df</code> or parent of <code>gd</code>, except when no columns are selected (in which case the result has zero rows).</p><p>If a <code>SubDataFrame</code> or <code>GroupedDataFrame{SubDataFrame}</code> is passed, the parent data frame is updated using columns generated by <code>args...</code>, following the same rules as indexing:</p><ul><li>for existing columns filtered-out rows are filled with values present in the old columns</li><li>for new columns (which is only allowed if <code>SubDataFrame</code> was created with <code>:</code> as column selector) filtered-out rows are filled with <code>missing</code></li><li>dropped columns (which are only allowed if <code>SubDataFrame</code> was created with <code>:</code> as column selector) are removed</li><li>if <code>SubDataFrame</code> was not created with <code>:</code> as column selector then <code>select!</code> is only allowed if the transformations keep exactly the same sequence of column names as is in the passed <code>df</code></li></ul><p>If a <code>GroupedDataFrame</code> is passed then it is updated to reflect the new rows of its updated parent. If there are independent <code>GroupedDataFrame</code> objects constructed using the same parent data frame they might get corrupt.</p><p>Below detailed common rules for all transformation functions supported by DataFrames.jl are explained and compared.</p><p>All these operations are supported both for <code>AbstractDataFrame</code> (when split and combine steps are skipped) and <code>GroupedDataFrame</code>. Technically, <code>AbstractDataFrame</code> is just considered as being grouped on no columns (meaning it has a single group, or zero groups if it is empty). The only difference is that in this case the <code>keepkeys</code> and <code>ungroup</code> keyword arguments (described below) are not supported and a data frame is always returned, as there are no split and combine steps in this case.</p><p>In order to perform operations by groups you first need to create a <code>GroupedDataFrame</code> object from your data frame using the <code>groupby</code> function that takes two arguments: (1) a data frame to be grouped, and (2) a set of columns to group by.</p><p>Operations can then be applied on each group using one of the following functions:</p><ul><li><code>combine</code>: does not put restrictions on number of rows returned per group; the returned values are vertically concatenated following order of groups in <code>GroupedDataFrame</code>; it is typically used to compute summary statistics by group; for <code>GroupedDataFrame</code> if grouping columns are kept they are put as first columns in the result;</li><li><code>select</code>: return a data frame with the number and order of rows exactly the same as the source data frame, including only new calculated columns; <code>select!</code> is an in-place version of <code>select</code>; for <code>GroupedDataFrame</code> if grouping columns are kept they are put as first columns in the result;</li><li><code>transform</code>: return a data frame with the number and order of rows exactly the same as the source data frame, including all columns from the source and new calculated columns; <code>transform!</code> is an in-place version of <code>transform</code>; existing columns in the source data frame are put as first columns in the result;</li></ul><p>As a special case, if a <code>GroupedDataFrame</code> that has zero groups is passed then the result of the operation is determined by performing a single call to the transformation function with a 0-row argument passed to it. The output of this operation is only used to identify the number and type of produced columns, but the result has zero rows.</p><p>All these functions take a specification of one or more functions to apply to each subset of the <code>DataFrame</code>. This specification can be of the following forms:</p><ol><li>standard column selectors (integers, <code>Symbol</code>s, strings, vectors of integers, vectors of <code>Symbol</code>s, vectors of strings, <code>All</code>, <code>Cols</code>, <code>:</code>, <code>Between</code>, <code>Not</code> and regular expressions)</li><li>a <code>cols =&gt; function</code> pair indicating that <code>function</code> should be called with positional arguments holding columns <code>cols</code>, which can be any valid column selector; in this case target column name is automatically generated and it is assumed that <code>function</code> returns a single value or a vector; the generated name is created by concatenating source column name and <code>function</code> name by default (see examples below).</li><li>a <code>cols =&gt; function =&gt; target_cols</code> form additionally explicitly specifying the target column or columns, which must be a single name (as a <code>Symbol</code> or a string), a vector of names or <code>AsTable</code>. Additionally it can be a <code>Function</code> which takes a string or a vector of strings as an argument containing names of columns selected by <code>cols</code>, and returns the target columns names (all accepted types except <code>AsTable</code> are allowed).</li><li>a <code>col =&gt; target_cols</code> pair, which renames the column <code>col</code> to <code>target_cols</code>, which must be single name (as a <code>Symbol</code> or a string), a vector of names or <code>AsTable</code>.</li><li>column-independent operations <code>function =&gt; target_cols</code> or just <code>function</code> for specific <code>function</code>s where the input columns are omitted; without <code>target_cols</code> the new column has the same name as <code>function</code>, otherwise it must be single name (as a <code>Symbol</code> or a string). Supported <code>function</code>s are:<ul><li><code>nrow</code> to efficiently compute the number of rows in each group.</li><li><code>proprow</code> to efficiently compute the proportion of rows in each group.</li><li><code>eachindex</code> to return a vector holding the number of each row within each group.</li><li><code>groupindices</code> to return the group number.</li></ul></li><li>vectors or matrices containing transformations specified by the <code>Pair</code> syntax described in points 2 to 5</li><li>a function which will be called with a <code>SubDataFrame</code> corresponding to each group if a <code>GroupedDataFrame</code> is processed, or with the data frame itself if an <code>AbstractDataFrame</code> is processed; this form should be avoided due to its poor performance unless the number of groups is small or a very large number of columns are processed (in which case <code>SubDataFrame</code> avoids excessive compilation)</li></ol><p>Note! If the expression of the form <code>x =&gt; y</code> is passed then except for the special convenience form <code>nrow =&gt; target_cols</code> it is always interpreted as <code>cols =&gt; function</code>. In particular the following expression <code>function =&gt; target_cols</code> is not a valid transformation specification.</p><p>Note! If <code>cols</code> or <code>target_cols</code> are one of <code>All</code>, <code>Cols</code>, <code>Between</code>, or <code>Not</code>, broadcasting using <code>.=&gt;</code> is supported and is equivalent to broadcasting the result of <code>names(df, cols)</code> or <code>names(df, target_cols)</code>. This behaves as if broadcasting happened after replacing the selector with selected column names within the data frame scope.</p><p>All functions have two types of signatures. One of them takes a <code>GroupedDataFrame</code> as the first argument and an arbitrary number of transformations described above as following arguments. The second type of signature is when a <code>Function</code> or a <code>Type</code> is passed as the first argument and a <code>GroupedDataFrame</code> as the second argument (similar to <code>map</code>).</p><p>As a special rule, with the <code>cols =&gt; function</code> and <code>cols =&gt; function =&gt; target_cols</code> syntaxes, if <code>cols</code> is wrapped in an <code>AsTable</code> object then a <code>NamedTuple</code> containing columns selected by <code>cols</code> is passed to <code>function</code>. The documentation of <a href="#DataFrames.table_transformation"><code>DataFrames.table_transformation</code></a> provides more information about this functionality, in particular covering performance considerations.</p><p>What is allowed for <code>function</code> to return is determined by the <code>target_cols</code> value:</p><ol><li>If both <code>cols</code> and <code>target_cols</code> are omitted (so only a <code>function</code> is passed), then returning a data frame, a matrix, a <code>NamedTuple</code>, or a <code>DataFrameRow</code> will produce multiple columns in the result. Returning any other value produces a single column.</li><li>If <code>target_cols</code> is a <code>Symbol</code> or a string then the function is assumed to return a single column. In this case returning a data frame, a matrix, a <code>NamedTuple</code>, or a <code>DataFrameRow</code> raises an error.</li><li>If <code>target_cols</code> is a vector of <code>Symbol</code>s or strings or <code>AsTable</code> it is assumed that <code>function</code> returns multiple columns. If <code>function</code> returns one of <code>AbstractDataFrame</code>, <code>NamedTuple</code>, <code>DataFrameRow</code>, <code>AbstractMatrix</code> then rules described in point 1 above apply. If <code>function</code> returns an <code>AbstractVector</code> then each element of this vector must support the <code>keys</code> function, which must return a collection of <code>Symbol</code>s, strings or integers; the return value of <code>keys</code> must be identical for all elements. Then as many columns are created as there are elements in the return value of the <code>keys</code> function. If <code>target_cols</code> is <code>AsTable</code> then their names are set to be equal to the key names except if <code>keys</code> returns integers, in which case they are prefixed by <code>x</code> (so the column names are e.g. <code>x1</code>, <code>x2</code>, ...). If <code>target_cols</code> is a vector of <code>Symbol</code>s or strings then column names produced using the rules above are ignored and replaced by <code>target_cols</code> (the number of columns must be the same as the length of <code>target_cols</code> in this case). If <code>fun</code> returns a value of any other type then it is assumed that it is a table conforming to the Tables.jl API and the <code>Tables.columntable</code> function is called on it to get the resulting columns and their names. The names are retained when <code>target_cols</code> is <code>AsTable</code> and are replaced if <code>target_cols</code> is a vector of <code>Symbol</code>s or strings.</li></ol><p>In all of these cases, <code>function</code> can return either a single row or multiple rows. As a particular rule, values wrapped in a <code>Ref</code> or a <code>0</code>-dimensional <code>AbstractArray</code> are unwrapped and then treated as a single row.</p><p><code>select</code>/<code>select!</code> and <code>transform</code>/<code>transform!</code> always return a data frame with the same number and order of rows as the source (even if <code>GroupedDataFrame</code> had its groups reordered), except when selection results in zero columns in the resulting data frame (in which case the result has zero rows).</p><p>For <code>combine</code>, rows in the returned object appear in the order of groups in the <code>GroupedDataFrame</code>. The functions can return an arbitrary number of rows for each group, but the kind of returned object and the number and names of columns must be the same for all groups, except when a <code>DataFrame()</code> or <code>NamedTuple()</code> is returned, in which case a given group is skipped.</p><p>It is allowed to mix single values and vectors if multiple transformations are requested. In this case single value will be repeated to match the length of columns specified by returned vectors.</p><p>To apply <code>function</code> to each row instead of whole columns, it can be wrapped in a <code>ByRow</code> struct. <code>cols</code> can be any column indexing syntax, in which case <code>function</code> will be passed one argument for each of the columns specified by <code>cols</code> or a <code>NamedTuple</code> of them if specified columns are wrapped in <code>AsTable</code>. If <code>ByRow</code> is used it is allowed for <code>cols</code> to select an empty set of columns, in which case <code>function</code> is called for each row without any arguments and an empty <code>NamedTuple</code> is passed if empty set of columns is wrapped in <code>AsTable</code>.</p><p>If a collection of column names is passed then requesting duplicate column names in target data frame are accepted (e.g. <code>select!(df, [:a], :, r&quot;a&quot;)</code> is allowed) and only the first occurrence is used. In particular a syntax to move column <code>:col</code> to the first position in the data frame is <code>select!(df, :col, :)</code>. On the contrary, output column names of renaming, transformation and single column selection operations must be unique, so e.g. <code>select!(df, :a, :a =&gt; :a)</code> or <code>select!(df, :a, :a =&gt; ByRow(sin) =&gt; :a)</code> are not allowed.</p><p>In general columns returned by transformations are stored in the target data frame without copying. An exception to this rule is when columns from the source data frame are reused in the target data frame. This can happen via expressions like: <code>:x1</code>, <code>[:x1, :x2]</code>, <code>:x1 =&gt; :x2</code>, <code>:x1 =&gt; identity =&gt; :x2</code>, or <code>:x1 =&gt; (x -&gt; @view x[inds])</code> (note that in the last case the source column is reused indirectly via a view). In such cases the behavior depends on the value of the <code>copycols</code> keyword argument:</p><ul><li>if <code>copycols=true</code> then results of such transformations always perform a copy of the source column or its view;</li><li>if <code>copycols=false</code> then copies are only performed to avoid storing the same column several times in the target data frame; more precisely, no copy is made the first time a column is used, but each subsequent reuse of a source column (when compared using <code>===</code>, which excludes views of source columns) performs a copy;</li></ul><p>Note that performing <code>transform!</code> or <code>select!</code> assumes that <code>copycols=false</code>.</p><p>If <code>df</code> is a <code>SubDataFrame</code> and <code>copycols=true</code> then a <code>DataFrame</code> is returned and the same copying rules apply as for a <code>DataFrame</code> input: this means in particular that selected columns will be copied. If <code>copycols=false</code>, a <code>SubDataFrame</code> is returned without copying columns and in this case transforming or renaming columns is not allowed.</p><p>If a <code>GroupedDataFrame</code> is passed and <code>threads=true</code> (the default), a separate task is spawned for each specified transformation; each transformation then spawns as many tasks as Julia threads, and splits processing of groups across them (however, currently transformations with optimized implementations like <code>sum</code> and transformations that return multiple rows use a single task for all groups). This allows for parallel operation when Julia was started with more than one thread. Passed transformation functions must therefore not modify global variables (i.e. they must be pure), use locks to control parallel accesses, or <code>threads=false</code> must be passed to disable multithreading. In the future, parallelism may be extended to other cases, so this requirement also holds for <code>DataFrame</code> inputs.</p><p>In order to improve the performance of the operations some transformations invoke optimized implementation, see <a href="#DataFrames.table_transformation"><code>DataFrames.table_transformation</code></a> for details.</p><p><strong>Keyword arguments</strong></p><ul><li><code>renamecols::Bool=true</code> : whether in the <code>cols =&gt; function</code> form automatically generated column names should include the name of transformation functions or not.</li><li><code>ungroup::Bool=true</code> : whether the return value of the operation on <code>gd</code> should be a data frame or a <code>GroupedDataFrame</code>.</li><li><code>threads::Bool=true</code> : whether transformations may be run in separate tasks which can execute in parallel (possibly being applied to multiple rows or groups at the same time). Whether or not tasks are actually spawned and their number are determined automatically. Set to <code>false</code> if some transformations require serial execution or are not thread-safe.</li></ul><p>Metadata: this function propagates table-level <code>:note</code>-style metadata. Column-level <code>:note</code>-style metadata is propagated if: a) a single column is transformed to a single column and the name of the column   does not change (this includes all column selection operations), or b) a single column is transformed with <code>identity</code> or <code>copy</code> to a single column    even if column name is changed (this includes column renaming).    As a special case for <code>GroupedDataFrame</code> if the output has the same name    as a grouping column and <code>keepkeys=true</code>, metadata is taken from    original grouping column.</p><p>See <a href="#DataFrames.select"><code>select</code></a> for examples.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/a1f75b1dd155265e5767e1e3f64d70be824859d7/src/abstractdataframe/selection.jl#L884-L930">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Random.shuffle" href="#Random.shuffle"><code>Random.shuffle</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">shuffle([rng=GLOBAL_RNG,] df::AbstractDataFrame)</code></pre><p>Return a copy of <code>df</code> with randomly permuted rows. The optional <code>rng</code> argument specifies a random number generator.</p><p>Metadata: this function preserves table-level and column-level <code>:note</code>-style metadata.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Random

julia&gt; rng = MersenneTwister(1234);

julia&gt; shuffle(rng, DataFrame(a=1:5, b=1:5))
5×2 DataFrame
 Row │ a      b
     │ Int64  Int64
─────┼──────────────
   1 │     2      2
   2 │     1      1
   3 │     4      4
   4 │     3      3
   5 │     5      5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/a1f75b1dd155265e5767e1e3f64d70be824859d7/src/abstractdataframe/abstractdataframe.jl#L2776-L2802">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Random.shuffle!" href="#Random.shuffle!"><code>Random.shuffle!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">shuffle!([rng=GLOBAL_RNG,] df::AbstractDataFrame)</code></pre><p>Randomly permute rows of <code>df</code> in-place. The optional <code>rng</code> argument specifies a random number generator.</p><p><code>shuffle!</code> will produce a correct result even if some columns of passed data frame are identical (checked with <code>===</code>). Otherwise, if two columns share some part of memory but are not identical (e.g. are different views of the same parent vector) then <code>shuffle!</code> result might be incorrect.</p><p>Metadata: this function preserves table-level and column-level <code>:note</code>-style metadata.</p><p>Metadata having other styles is dropped (from parent data frame when <code>df</code> is a <code>SubDataFrame</code>).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Random

julia&gt; rng = MersenneTwister(1234);

julia&gt; shuffle!(rng, DataFrame(a=1:5, b=1:5))
5×2 DataFrame
 Row │ a      b
     │ Int64  Int64
─────┼──────────────
   1 │     2      2
   2 │     1      1
   3 │     4      4
   4 │     3      3
   5 │     5      5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/a1f75b1dd155265e5767e1e3f64d70be824859d7/src/abstractdataframe/abstractdataframe.jl#L2808-L2840">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFrames.table_transformation" href="#DataFrames.table_transformation"><code>DataFrames.table_transformation</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">table_transformation(df_sel::AbstractDataFrame, fun)</code></pre><p>This is the function called when <code>AsTable(...) =&gt; fun</code> is requested. The <code>df_sel</code> argument is a data frame storing columns selected by the <code>AsTable(...)</code> selector.</p><p>By default it calls <code>default_table_transformation</code>. However, it is allowed to add special methods for specific types of <code>fun</code>, as long as the result matches what would be produced by <code>default_table_transformation</code>, except that it is allowed to perform <code>eltype</code> conversion of the resulting vectors or value type promotions that are consistent with <code>promote_type</code>.</p><p>It is guaranteed that <code>df_sel</code> has at least one column.</p><p>The main use of special <code>table_transformation</code> methods is to provide more efficient than the default implementations of requested <code>fun</code> transformation.</p><p>This function might become a part of the public API of DataFrames.jl in the future, currently it should be considered experimental.</p><p>Fast paths are implemented within DataFrames.jl for the following functions <code>fun</code>:</p><ul><li><code>sum</code>, <code>ByRow(sum)</code>, <code>ByRow(sum∘skipmissing)</code></li><li><code>length</code>, <code>ByRow(length)</code>, <code>ByRow(length∘skipmissing)</code></li><li><code>mean</code>, <code>ByRow(mean)</code>, <code>ByRow(mean∘skipmissing)</code></li><li><code>ByRow(var)</code>, <code>ByRow(var∘skipmissing)</code></li><li><code>ByRow(std)</code>, <code>ByRow(std∘skipmissing)</code></li><li><code>ByRow(median)</code>, <code>ByRow(median∘skipmissing)</code></li><li><code>minimum</code>, <code>ByRow(minimum)</code>, <code>ByRow(minimum∘skipmissing)</code></li><li><code>maximum</code>, <code>ByRow(maximum)</code>, <code>ByRow(maximum∘skipmissing)</code></li><li><code>fun∘collect</code> and <code>ByRow(fun∘collect)</code> where <code>fun</code> is any function</li></ul><p>Note that in order to improve the performance <code>ByRow(sum)</code>, <code>ByRow(sum∘skipmissing)</code>, <code>ByRow(mean)</code>, and <code>ByRow(mean∘skipmissing)</code> perform all operations in the target element type. In some very rare cases (like mixing very large <code>Int64</code> values and <code>Float64</code> values) it can lead to a result different from the one that would be obtained by calling the function outside of DataFrames.jl. The way to avoid this precision loss is to use an anonymous function, e.g. instead of <code>ByRow(sum)</code> use <code>ByRow(x -&gt; sum(x))</code>. However, in general for such scenarios even standard aggregation functions should not be considered to provide reliable output, and users are recommended to switch to higher precision calculations. An example of a case when standard <code>sum</code> is affected by the situation discussed is:</p><pre><code class="nohighlight hljs">julia&gt; sum(Any[typemax(Int), typemax(Int), 1.0])
-1.0

julia&gt; sum(Any[1.0, typemax(Int), typemax(Int)])
1.8446744073709552e19</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/a1f75b1dd155265e5767e1e3f64d70be824859d7/src/abstractdataframe/selectionfast.jl#L1-L53">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFrames.transform" href="#DataFrames.transform"><code>DataFrames.transform</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">transform(df::AbstractDataFrame, args...;
          copycols::Bool=true, renamecols::Bool=true, threads::Bool=true)
transform(f::Callable, df::DataFrame;
          renamecols::Bool=true, threads::Bool=true)
transform(gd::GroupedDataFrame, args...;
          copycols::Bool=true, keepkeys::Bool=true, ungroup::Bool=true,
          renamecols::Bool=true, threads::Bool=true)
transform(f::Base.Callable, gd::GroupedDataFrame;
          copycols::Bool=true, keepkeys::Bool=true, ungroup::Bool=true,
          renamecols::Bool=true, threads::Bool=true)</code></pre><p>Create a new data frame that contains columns from <code>df</code> or <code>gd</code> plus columns specified by <code>args</code> and return it. The result is guaranteed to have the same number of rows as <code>df</code>. Equivalent to <code>select(df, :, args...)</code> or <code>select(gd, :, args...)</code>.</p><p>Below detailed common rules for all transformation functions supported by DataFrames.jl are explained and compared.</p><p>All these operations are supported both for <code>AbstractDataFrame</code> (when split and combine steps are skipped) and <code>GroupedDataFrame</code>. Technically, <code>AbstractDataFrame</code> is just considered as being grouped on no columns (meaning it has a single group, or zero groups if it is empty). The only difference is that in this case the <code>keepkeys</code> and <code>ungroup</code> keyword arguments (described below) are not supported and a data frame is always returned, as there are no split and combine steps in this case.</p><p>In order to perform operations by groups you first need to create a <code>GroupedDataFrame</code> object from your data frame using the <code>groupby</code> function that takes two arguments: (1) a data frame to be grouped, and (2) a set of columns to group by.</p><p>Operations can then be applied on each group using one of the following functions:</p><ul><li><code>combine</code>: does not put restrictions on number of rows returned per group; the returned values are vertically concatenated following order of groups in <code>GroupedDataFrame</code>; it is typically used to compute summary statistics by group; for <code>GroupedDataFrame</code> if grouping columns are kept they are put as first columns in the result;</li><li><code>select</code>: return a data frame with the number and order of rows exactly the same as the source data frame, including only new calculated columns; <code>select!</code> is an in-place version of <code>select</code>; for <code>GroupedDataFrame</code> if grouping columns are kept they are put as first columns in the result;</li><li><code>transform</code>: return a data frame with the number and order of rows exactly the same as the source data frame, including all columns from the source and new calculated columns; <code>transform!</code> is an in-place version of <code>transform</code>; existing columns in the source data frame are put as first columns in the result;</li></ul><p>As a special case, if a <code>GroupedDataFrame</code> that has zero groups is passed then the result of the operation is determined by performing a single call to the transformation function with a 0-row argument passed to it. The output of this operation is only used to identify the number and type of produced columns, but the result has zero rows.</p><p>All these functions take a specification of one or more functions to apply to each subset of the <code>DataFrame</code>. This specification can be of the following forms:</p><ol><li>standard column selectors (integers, <code>Symbol</code>s, strings, vectors of integers, vectors of <code>Symbol</code>s, vectors of strings, <code>All</code>, <code>Cols</code>, <code>:</code>, <code>Between</code>, <code>Not</code> and regular expressions)</li><li>a <code>cols =&gt; function</code> pair indicating that <code>function</code> should be called with positional arguments holding columns <code>cols</code>, which can be any valid column selector; in this case target column name is automatically generated and it is assumed that <code>function</code> returns a single value or a vector; the generated name is created by concatenating source column name and <code>function</code> name by default (see examples below).</li><li>a <code>cols =&gt; function =&gt; target_cols</code> form additionally explicitly specifying the target column or columns, which must be a single name (as a <code>Symbol</code> or a string), a vector of names or <code>AsTable</code>. Additionally it can be a <code>Function</code> which takes a string or a vector of strings as an argument containing names of columns selected by <code>cols</code>, and returns the target columns names (all accepted types except <code>AsTable</code> are allowed).</li><li>a <code>col =&gt; target_cols</code> pair, which renames the column <code>col</code> to <code>target_cols</code>, which must be single name (as a <code>Symbol</code> or a string), a vector of names or <code>AsTable</code>.</li><li>column-independent operations <code>function =&gt; target_cols</code> or just <code>function</code> for specific <code>function</code>s where the input columns are omitted; without <code>target_cols</code> the new column has the same name as <code>function</code>, otherwise it must be single name (as a <code>Symbol</code> or a string). Supported <code>function</code>s are:<ul><li><code>nrow</code> to efficiently compute the number of rows in each group.</li><li><code>proprow</code> to efficiently compute the proportion of rows in each group.</li><li><code>eachindex</code> to return a vector holding the number of each row within each group.</li><li><code>groupindices</code> to return the group number.</li></ul></li><li>vectors or matrices containing transformations specified by the <code>Pair</code> syntax described in points 2 to 5</li><li>a function which will be called with a <code>SubDataFrame</code> corresponding to each group if a <code>GroupedDataFrame</code> is processed, or with the data frame itself if an <code>AbstractDataFrame</code> is processed; this form should be avoided due to its poor performance unless the number of groups is small or a very large number of columns are processed (in which case <code>SubDataFrame</code> avoids excessive compilation)</li></ol><p>Note! If the expression of the form <code>x =&gt; y</code> is passed then except for the special convenience form <code>nrow =&gt; target_cols</code> it is always interpreted as <code>cols =&gt; function</code>. In particular the following expression <code>function =&gt; target_cols</code> is not a valid transformation specification.</p><p>Note! If <code>cols</code> or <code>target_cols</code> are one of <code>All</code>, <code>Cols</code>, <code>Between</code>, or <code>Not</code>, broadcasting using <code>.=&gt;</code> is supported and is equivalent to broadcasting the result of <code>names(df, cols)</code> or <code>names(df, target_cols)</code>. This behaves as if broadcasting happened after replacing the selector with selected column names within the data frame scope.</p><p>All functions have two types of signatures. One of them takes a <code>GroupedDataFrame</code> as the first argument and an arbitrary number of transformations described above as following arguments. The second type of signature is when a <code>Function</code> or a <code>Type</code> is passed as the first argument and a <code>GroupedDataFrame</code> as the second argument (similar to <code>map</code>).</p><p>As a special rule, with the <code>cols =&gt; function</code> and <code>cols =&gt; function =&gt; target_cols</code> syntaxes, if <code>cols</code> is wrapped in an <code>AsTable</code> object then a <code>NamedTuple</code> containing columns selected by <code>cols</code> is passed to <code>function</code>. The documentation of <a href="#DataFrames.table_transformation"><code>DataFrames.table_transformation</code></a> provides more information about this functionality, in particular covering performance considerations.</p><p>What is allowed for <code>function</code> to return is determined by the <code>target_cols</code> value:</p><ol><li>If both <code>cols</code> and <code>target_cols</code> are omitted (so only a <code>function</code> is passed), then returning a data frame, a matrix, a <code>NamedTuple</code>, or a <code>DataFrameRow</code> will produce multiple columns in the result. Returning any other value produces a single column.</li><li>If <code>target_cols</code> is a <code>Symbol</code> or a string then the function is assumed to return a single column. In this case returning a data frame, a matrix, a <code>NamedTuple</code>, or a <code>DataFrameRow</code> raises an error.</li><li>If <code>target_cols</code> is a vector of <code>Symbol</code>s or strings or <code>AsTable</code> it is assumed that <code>function</code> returns multiple columns. If <code>function</code> returns one of <code>AbstractDataFrame</code>, <code>NamedTuple</code>, <code>DataFrameRow</code>, <code>AbstractMatrix</code> then rules described in point 1 above apply. If <code>function</code> returns an <code>AbstractVector</code> then each element of this vector must support the <code>keys</code> function, which must return a collection of <code>Symbol</code>s, strings or integers; the return value of <code>keys</code> must be identical for all elements. Then as many columns are created as there are elements in the return value of the <code>keys</code> function. If <code>target_cols</code> is <code>AsTable</code> then their names are set to be equal to the key names except if <code>keys</code> returns integers, in which case they are prefixed by <code>x</code> (so the column names are e.g. <code>x1</code>, <code>x2</code>, ...). If <code>target_cols</code> is a vector of <code>Symbol</code>s or strings then column names produced using the rules above are ignored and replaced by <code>target_cols</code> (the number of columns must be the same as the length of <code>target_cols</code> in this case). If <code>fun</code> returns a value of any other type then it is assumed that it is a table conforming to the Tables.jl API and the <code>Tables.columntable</code> function is called on it to get the resulting columns and their names. The names are retained when <code>target_cols</code> is <code>AsTable</code> and are replaced if <code>target_cols</code> is a vector of <code>Symbol</code>s or strings.</li></ol><p>In all of these cases, <code>function</code> can return either a single row or multiple rows. As a particular rule, values wrapped in a <code>Ref</code> or a <code>0</code>-dimensional <code>AbstractArray</code> are unwrapped and then treated as a single row.</p><p><code>select</code>/<code>select!</code> and <code>transform</code>/<code>transform!</code> always return a data frame with the same number and order of rows as the source (even if <code>GroupedDataFrame</code> had its groups reordered), except when selection results in zero columns in the resulting data frame (in which case the result has zero rows).</p><p>For <code>combine</code>, rows in the returned object appear in the order of groups in the <code>GroupedDataFrame</code>. The functions can return an arbitrary number of rows for each group, but the kind of returned object and the number and names of columns must be the same for all groups, except when a <code>DataFrame()</code> or <code>NamedTuple()</code> is returned, in which case a given group is skipped.</p><p>It is allowed to mix single values and vectors if multiple transformations are requested. In this case single value will be repeated to match the length of columns specified by returned vectors.</p><p>To apply <code>function</code> to each row instead of whole columns, it can be wrapped in a <code>ByRow</code> struct. <code>cols</code> can be any column indexing syntax, in which case <code>function</code> will be passed one argument for each of the columns specified by <code>cols</code> or a <code>NamedTuple</code> of them if specified columns are wrapped in <code>AsTable</code>. If <code>ByRow</code> is used it is allowed for <code>cols</code> to select an empty set of columns, in which case <code>function</code> is called for each row without any arguments and an empty <code>NamedTuple</code> is passed if empty set of columns is wrapped in <code>AsTable</code>.</p><p>If a collection of column names is passed then requesting duplicate column names in target data frame are accepted (e.g. <code>select!(df, [:a], :, r&quot;a&quot;)</code> is allowed) and only the first occurrence is used. In particular a syntax to move column <code>:col</code> to the first position in the data frame is <code>select!(df, :col, :)</code>. On the contrary, output column names of renaming, transformation and single column selection operations must be unique, so e.g. <code>select!(df, :a, :a =&gt; :a)</code> or <code>select!(df, :a, :a =&gt; ByRow(sin) =&gt; :a)</code> are not allowed.</p><p>In general columns returned by transformations are stored in the target data frame without copying. An exception to this rule is when columns from the source data frame are reused in the target data frame. This can happen via expressions like: <code>:x1</code>, <code>[:x1, :x2]</code>, <code>:x1 =&gt; :x2</code>, <code>:x1 =&gt; identity =&gt; :x2</code>, or <code>:x1 =&gt; (x -&gt; @view x[inds])</code> (note that in the last case the source column is reused indirectly via a view). In such cases the behavior depends on the value of the <code>copycols</code> keyword argument:</p><ul><li>if <code>copycols=true</code> then results of such transformations always perform a copy of the source column or its view;</li><li>if <code>copycols=false</code> then copies are only performed to avoid storing the same column several times in the target data frame; more precisely, no copy is made the first time a column is used, but each subsequent reuse of a source column (when compared using <code>===</code>, which excludes views of source columns) performs a copy;</li></ul><p>Note that performing <code>transform!</code> or <code>select!</code> assumes that <code>copycols=false</code>.</p><p>If <code>df</code> is a <code>SubDataFrame</code> and <code>copycols=true</code> then a <code>DataFrame</code> is returned and the same copying rules apply as for a <code>DataFrame</code> input: this means in particular that selected columns will be copied. If <code>copycols=false</code>, a <code>SubDataFrame</code> is returned without copying columns and in this case transforming or renaming columns is not allowed.</p><p>If a <code>GroupedDataFrame</code> is passed and <code>threads=true</code> (the default), a separate task is spawned for each specified transformation; each transformation then spawns as many tasks as Julia threads, and splits processing of groups across them (however, currently transformations with optimized implementations like <code>sum</code> and transformations that return multiple rows use a single task for all groups). This allows for parallel operation when Julia was started with more than one thread. Passed transformation functions must therefore not modify global variables (i.e. they must be pure), use locks to control parallel accesses, or <code>threads=false</code> must be passed to disable multithreading. In the future, parallelism may be extended to other cases, so this requirement also holds for <code>DataFrame</code> inputs.</p><p>In order to improve the performance of the operations some transformations invoke optimized implementation, see <a href="#DataFrames.table_transformation"><code>DataFrames.table_transformation</code></a> for details.</p><p><strong>Keyword arguments</strong></p><ul><li><code>copycols::Bool=true</code> : whether columns of the source data frame should be copied if no transformation is applied to them.</li><li><code>renamecols::Bool=true</code> : whether in the <code>cols =&gt; function</code> form automatically generated column names should include the name of transformation functions or not.</li><li><code>keepkeys::Bool=true</code> : whether grouping columns of <code>gd</code> should be kept in the returned data frame.</li><li><code>ungroup::Bool=true</code> : whether the return value of the operation on <code>gd</code> should be a data frame or a <code>GroupedDataFrame</code>.</li><li><code>threads::Bool=true</code> : whether transformations may be run in separate tasks which can execute in parallel (possibly being applied to multiple rows or groups at the same time). Whether or not tasks are actually spawned and their number are determined automatically. Set to <code>false</code> if some transformations require serial execution or are not thread-safe.</li></ul><p>Note that when the first argument is a <code>GroupedDataFrame</code>, <code>keepkeys=false</code> is needed to be able to return a different value for the grouping column:</p><p>Metadata: this function propagates table-level <code>:note</code>-style metadata. Column-level <code>:note</code>-style metadata is propagated if: a) a single column is transformed to a single column and the name of the column   does not change (this includes all column selection operations), or b) a single column is transformed with <code>identity</code> or <code>copy</code> to a single column    even if column name is changed (this includes column renaming).    As a special case for <code>GroupedDataFrame</code> if the output has the same name    as a grouping column and <code>keepkeys=true</code>, metadata is taken from    original grouping column.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; gdf = groupby(DataFrame(x=1:2), :x)
GroupedDataFrame with 2 groups based on key: x
First Group (1 row): x = 1
 Row │ x
     │ Int64
─────┼───────
   1 │     1
⋮
Last Group (1 row): x = 2
 Row │ x
     │ Int64
─────┼───────
   1 │     2

julia&gt; transform(gdf, x -&gt; (x=10,), keepkeys=false)
2×1 DataFrame
 Row │ x
     │ Int64
─────┼───────
   1 │    10
   2 │    10

julia&gt; transform(gdf, x -&gt; (x=10,), keepkeys=true)
ERROR: ArgumentError: column :x in returned data frame is not equal to grouping key :x</code></pre><p>See <a href="#DataFrames.select"><code>select</code></a> for more examples.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/a1f75b1dd155265e5767e1e3f64d70be824859d7/src/abstractdataframe/selection.jl#L1297-L1363">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFrames.transform!" href="#DataFrames.transform!"><code>DataFrames.transform!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">transform!(df::AbstractDataFrame, args...;
           renamecols::Bool=true, threads::Bool=true)
transform!(args::Callable, df::AbstractDataFrame;
           renamecols::Bool=true, threads::Bool=true)
transform!(gd::GroupedDataFrame, args...;
           ungroup::Bool=true, renamecols::Bool=true, threads::Bool=true)
transform!(f::Base.Callable, gd::GroupedDataFrame;
           ungroup::Bool=true, renamecols::Bool=true, threads::Bool=true)</code></pre><p>Mutate <code>df</code> or <code>gd</code> in place to add columns specified by <code>args...</code> and return it. The result is guaranteed to have the same number of rows as <code>df</code>. Equivalent to <code>select!(df, :, args...)</code> or <code>select!(gd, :, args...)</code>, except that column renaming performs a copy.</p><p>Below detailed common rules for all transformation functions supported by DataFrames.jl are explained and compared.</p><p>All these operations are supported both for <code>AbstractDataFrame</code> (when split and combine steps are skipped) and <code>GroupedDataFrame</code>. Technically, <code>AbstractDataFrame</code> is just considered as being grouped on no columns (meaning it has a single group, or zero groups if it is empty). The only difference is that in this case the <code>keepkeys</code> and <code>ungroup</code> keyword arguments (described below) are not supported and a data frame is always returned, as there are no split and combine steps in this case.</p><p>In order to perform operations by groups you first need to create a <code>GroupedDataFrame</code> object from your data frame using the <code>groupby</code> function that takes two arguments: (1) a data frame to be grouped, and (2) a set of columns to group by.</p><p>Operations can then be applied on each group using one of the following functions:</p><ul><li><code>combine</code>: does not put restrictions on number of rows returned per group; the returned values are vertically concatenated following order of groups in <code>GroupedDataFrame</code>; it is typically used to compute summary statistics by group; for <code>GroupedDataFrame</code> if grouping columns are kept they are put as first columns in the result;</li><li><code>select</code>: return a data frame with the number and order of rows exactly the same as the source data frame, including only new calculated columns; <code>select!</code> is an in-place version of <code>select</code>; for <code>GroupedDataFrame</code> if grouping columns are kept they are put as first columns in the result;</li><li><code>transform</code>: return a data frame with the number and order of rows exactly the same as the source data frame, including all columns from the source and new calculated columns; <code>transform!</code> is an in-place version of <code>transform</code>; existing columns in the source data frame are put as first columns in the result;</li></ul><p>As a special case, if a <code>GroupedDataFrame</code> that has zero groups is passed then the result of the operation is determined by performing a single call to the transformation function with a 0-row argument passed to it. The output of this operation is only used to identify the number and type of produced columns, but the result has zero rows.</p><p>All these functions take a specification of one or more functions to apply to each subset of the <code>DataFrame</code>. This specification can be of the following forms:</p><ol><li>standard column selectors (integers, <code>Symbol</code>s, strings, vectors of integers, vectors of <code>Symbol</code>s, vectors of strings, <code>All</code>, <code>Cols</code>, <code>:</code>, <code>Between</code>, <code>Not</code> and regular expressions)</li><li>a <code>cols =&gt; function</code> pair indicating that <code>function</code> should be called with positional arguments holding columns <code>cols</code>, which can be any valid column selector; in this case target column name is automatically generated and it is assumed that <code>function</code> returns a single value or a vector; the generated name is created by concatenating source column name and <code>function</code> name by default (see examples below).</li><li>a <code>cols =&gt; function =&gt; target_cols</code> form additionally explicitly specifying the target column or columns, which must be a single name (as a <code>Symbol</code> or a string), a vector of names or <code>AsTable</code>. Additionally it can be a <code>Function</code> which takes a string or a vector of strings as an argument containing names of columns selected by <code>cols</code>, and returns the target columns names (all accepted types except <code>AsTable</code> are allowed).</li><li>a <code>col =&gt; target_cols</code> pair, which renames the column <code>col</code> to <code>target_cols</code>, which must be single name (as a <code>Symbol</code> or a string), a vector of names or <code>AsTable</code>.</li><li>column-independent operations <code>function =&gt; target_cols</code> or just <code>function</code> for specific <code>function</code>s where the input columns are omitted; without <code>target_cols</code> the new column has the same name as <code>function</code>, otherwise it must be single name (as a <code>Symbol</code> or a string). Supported <code>function</code>s are:<ul><li><code>nrow</code> to efficiently compute the number of rows in each group.</li><li><code>proprow</code> to efficiently compute the proportion of rows in each group.</li><li><code>eachindex</code> to return a vector holding the number of each row within each group.</li><li><code>groupindices</code> to return the group number.</li></ul></li><li>vectors or matrices containing transformations specified by the <code>Pair</code> syntax described in points 2 to 5</li><li>a function which will be called with a <code>SubDataFrame</code> corresponding to each group if a <code>GroupedDataFrame</code> is processed, or with the data frame itself if an <code>AbstractDataFrame</code> is processed; this form should be avoided due to its poor performance unless the number of groups is small or a very large number of columns are processed (in which case <code>SubDataFrame</code> avoids excessive compilation)</li></ol><p>Note! If the expression of the form <code>x =&gt; y</code> is passed then except for the special convenience form <code>nrow =&gt; target_cols</code> it is always interpreted as <code>cols =&gt; function</code>. In particular the following expression <code>function =&gt; target_cols</code> is not a valid transformation specification.</p><p>Note! If <code>cols</code> or <code>target_cols</code> are one of <code>All</code>, <code>Cols</code>, <code>Between</code>, or <code>Not</code>, broadcasting using <code>.=&gt;</code> is supported and is equivalent to broadcasting the result of <code>names(df, cols)</code> or <code>names(df, target_cols)</code>. This behaves as if broadcasting happened after replacing the selector with selected column names within the data frame scope.</p><p>All functions have two types of signatures. One of them takes a <code>GroupedDataFrame</code> as the first argument and an arbitrary number of transformations described above as following arguments. The second type of signature is when a <code>Function</code> or a <code>Type</code> is passed as the first argument and a <code>GroupedDataFrame</code> as the second argument (similar to <code>map</code>).</p><p>As a special rule, with the <code>cols =&gt; function</code> and <code>cols =&gt; function =&gt; target_cols</code> syntaxes, if <code>cols</code> is wrapped in an <code>AsTable</code> object then a <code>NamedTuple</code> containing columns selected by <code>cols</code> is passed to <code>function</code>. The documentation of <a href="#DataFrames.table_transformation"><code>DataFrames.table_transformation</code></a> provides more information about this functionality, in particular covering performance considerations.</p><p>What is allowed for <code>function</code> to return is determined by the <code>target_cols</code> value:</p><ol><li>If both <code>cols</code> and <code>target_cols</code> are omitted (so only a <code>function</code> is passed), then returning a data frame, a matrix, a <code>NamedTuple</code>, or a <code>DataFrameRow</code> will produce multiple columns in the result. Returning any other value produces a single column.</li><li>If <code>target_cols</code> is a <code>Symbol</code> or a string then the function is assumed to return a single column. In this case returning a data frame, a matrix, a <code>NamedTuple</code>, or a <code>DataFrameRow</code> raises an error.</li><li>If <code>target_cols</code> is a vector of <code>Symbol</code>s or strings or <code>AsTable</code> it is assumed that <code>function</code> returns multiple columns. If <code>function</code> returns one of <code>AbstractDataFrame</code>, <code>NamedTuple</code>, <code>DataFrameRow</code>, <code>AbstractMatrix</code> then rules described in point 1 above apply. If <code>function</code> returns an <code>AbstractVector</code> then each element of this vector must support the <code>keys</code> function, which must return a collection of <code>Symbol</code>s, strings or integers; the return value of <code>keys</code> must be identical for all elements. Then as many columns are created as there are elements in the return value of the <code>keys</code> function. If <code>target_cols</code> is <code>AsTable</code> then their names are set to be equal to the key names except if <code>keys</code> returns integers, in which case they are prefixed by <code>x</code> (so the column names are e.g. <code>x1</code>, <code>x2</code>, ...). If <code>target_cols</code> is a vector of <code>Symbol</code>s or strings then column names produced using the rules above are ignored and replaced by <code>target_cols</code> (the number of columns must be the same as the length of <code>target_cols</code> in this case). If <code>fun</code> returns a value of any other type then it is assumed that it is a table conforming to the Tables.jl API and the <code>Tables.columntable</code> function is called on it to get the resulting columns and their names. The names are retained when <code>target_cols</code> is <code>AsTable</code> and are replaced if <code>target_cols</code> is a vector of <code>Symbol</code>s or strings.</li></ol><p>In all of these cases, <code>function</code> can return either a single row or multiple rows. As a particular rule, values wrapped in a <code>Ref</code> or a <code>0</code>-dimensional <code>AbstractArray</code> are unwrapped and then treated as a single row.</p><p><code>select</code>/<code>select!</code> and <code>transform</code>/<code>transform!</code> always return a data frame with the same number and order of rows as the source (even if <code>GroupedDataFrame</code> had its groups reordered), except when selection results in zero columns in the resulting data frame (in which case the result has zero rows).</p><p>For <code>combine</code>, rows in the returned object appear in the order of groups in the <code>GroupedDataFrame</code>. The functions can return an arbitrary number of rows for each group, but the kind of returned object and the number and names of columns must be the same for all groups, except when a <code>DataFrame()</code> or <code>NamedTuple()</code> is returned, in which case a given group is skipped.</p><p>It is allowed to mix single values and vectors if multiple transformations are requested. In this case single value will be repeated to match the length of columns specified by returned vectors.</p><p>To apply <code>function</code> to each row instead of whole columns, it can be wrapped in a <code>ByRow</code> struct. <code>cols</code> can be any column indexing syntax, in which case <code>function</code> will be passed one argument for each of the columns specified by <code>cols</code> or a <code>NamedTuple</code> of them if specified columns are wrapped in <code>AsTable</code>. If <code>ByRow</code> is used it is allowed for <code>cols</code> to select an empty set of columns, in which case <code>function</code> is called for each row without any arguments and an empty <code>NamedTuple</code> is passed if empty set of columns is wrapped in <code>AsTable</code>.</p><p>If a collection of column names is passed then requesting duplicate column names in target data frame are accepted (e.g. <code>select!(df, [:a], :, r&quot;a&quot;)</code> is allowed) and only the first occurrence is used. In particular a syntax to move column <code>:col</code> to the first position in the data frame is <code>select!(df, :col, :)</code>. On the contrary, output column names of renaming, transformation and single column selection operations must be unique, so e.g. <code>select!(df, :a, :a =&gt; :a)</code> or <code>select!(df, :a, :a =&gt; ByRow(sin) =&gt; :a)</code> are not allowed.</p><p>In general columns returned by transformations are stored in the target data frame without copying. An exception to this rule is when columns from the source data frame are reused in the target data frame. This can happen via expressions like: <code>:x1</code>, <code>[:x1, :x2]</code>, <code>:x1 =&gt; :x2</code>, <code>:x1 =&gt; identity =&gt; :x2</code>, or <code>:x1 =&gt; (x -&gt; @view x[inds])</code> (note that in the last case the source column is reused indirectly via a view). In such cases the behavior depends on the value of the <code>copycols</code> keyword argument:</p><ul><li>if <code>copycols=true</code> then results of such transformations always perform a copy of the source column or its view;</li><li>if <code>copycols=false</code> then copies are only performed to avoid storing the same column several times in the target data frame; more precisely, no copy is made the first time a column is used, but each subsequent reuse of a source column (when compared using <code>===</code>, which excludes views of source columns) performs a copy;</li></ul><p>Note that performing <code>transform!</code> or <code>select!</code> assumes that <code>copycols=false</code>.</p><p>If <code>df</code> is a <code>SubDataFrame</code> and <code>copycols=true</code> then a <code>DataFrame</code> is returned and the same copying rules apply as for a <code>DataFrame</code> input: this means in particular that selected columns will be copied. If <code>copycols=false</code>, a <code>SubDataFrame</code> is returned without copying columns and in this case transforming or renaming columns is not allowed.</p><p>If a <code>GroupedDataFrame</code> is passed and <code>threads=true</code> (the default), a separate task is spawned for each specified transformation; each transformation then spawns as many tasks as Julia threads, and splits processing of groups across them (however, currently transformations with optimized implementations like <code>sum</code> and transformations that return multiple rows use a single task for all groups). This allows for parallel operation when Julia was started with more than one thread. Passed transformation functions must therefore not modify global variables (i.e. they must be pure), use locks to control parallel accesses, or <code>threads=false</code> must be passed to disable multithreading. In the future, parallelism may be extended to other cases, so this requirement also holds for <code>DataFrame</code> inputs.</p><p>In order to improve the performance of the operations some transformations invoke optimized implementation, see <a href="#DataFrames.table_transformation"><code>DataFrames.table_transformation</code></a> for details.</p><p><strong>Keyword arguments</strong></p><ul><li><code>renamecols::Bool=true</code> : whether in the <code>cols =&gt; function</code> form automatically generated column names should include the name of transformation functions or not.</li><li><code>ungroup::Bool=true</code> : whether the return value of the operation on <code>gd</code> should be a data frame or a <code>GroupedDataFrame</code>.</li><li><code>threads::Bool=true</code> : whether transformations may be run in separate tasks which can execute in parallel (possibly being applied to multiple rows or groups at the same time). Whether or not tasks are actually spawned and their number are determined automatically. Set to <code>false</code> if some transformations require serial execution or are not thread-safe.</li></ul><p>Metadata: this function propagates table-level <code>:note</code>-style metadata. Column-level <code>:note</code>-style metadata is propagated if: a) a single column is transformed to a single column and the name of the column   does not change (this includes all column selection operations), or b) a single column is transformed with <code>identity</code> or <code>copy</code> to a single column    even if column name is changed (this includes column renaming).    As a special case for <code>GroupedDataFrame</code> if the output has the same name    as a grouping column and <code>keepkeys=true</code>, metadata is taken from    original grouping column.</p><p>See <a href="#DataFrames.select"><code>select</code></a> for examples.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/a1f75b1dd155265e5767e1e3f64d70be824859d7/src/abstractdataframe/selection.jl#L950-L980">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.vcat" href="#Base.vcat"><code>Base.vcat</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">vcat(dfs::AbstractDataFrame...;
     cols::Union{Symbol, AbstractVector{Symbol},
                 AbstractVector{&lt;:AbstractString}}=:setequal,
     source::Union{Nothing, Symbol, AbstractString,
                   Pair{&lt;:Union{Symbol, AbstractString}, &lt;:AbstractVector}}=nothing)</code></pre><p>Vertically concatenate <code>AbstractDataFrame</code>s.</p><p>The <code>cols</code> keyword argument determines the columns of the returned data frame:</p><ul><li><code>:setequal</code>: require all data frames to have the same column names disregarding order. If they appear in different orders, the order of the first provided data frame is used.</li><li><code>:orderequal</code>: require all data frames to have the same column names and in the same order.</li><li><code>:intersect</code>: only the columns present in <em>all</em> provided data frames are kept. If the intersection is empty, an empty data frame is returned.</li><li><code>:union</code>: columns present in <em>at least one</em> of the provided data frames are kept. Columns not present in some data frames are filled with <code>missing</code> where necessary.</li><li>A vector of <code>Symbol</code>s or strings: only listed columns are kept. Columns not present in some data frames are filled with <code>missing</code> where necessary.</li></ul><p>The <code>source</code> keyword argument, if not <code>nothing</code> (the default), specifies the additional column to be added in the last position in the resulting data frame that will identify the source data frame. It can be a <code>Symbol</code> or an <code>AbstractString</code>, in which case the identifier will be the number of the passed source data frame, or a <code>Pair</code> consisting of a <code>Symbol</code> or an <code>AbstractString</code> and of a vector specifying the data frame identifiers (which do not have to be unique). The name of the source column is not allowed to be present in any source data frame.</p><p>The order of columns is determined by the order they appear in the included data frames, searching through the header of the first data frame, then the second, etc.</p><p>The element types of columns are determined using <code>promote_type</code>, as with <code>vcat</code> for <code>AbstractVector</code>s.</p><p><code>vcat</code> ignores empty data frames when composing the result (except for metadata), making it possible to initialize an empty data frame at the beginning of a loop and <code>vcat</code> onto it.</p><p>Metadata: <code>vcat</code> propagates table-level <code>:note</code>-style metadata for keys that are present in all passed data frames and have the same value. <code>vcat</code> propagates column-level <code>:note</code>-style metadata for keys that are present in all passed data frames that contain this column and have the same value.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; df1 = DataFrame(A=1:3, B=1:3)
3×2 DataFrame
 Row │ A      B
     │ Int64  Int64
─────┼──────────────
   1 │     1      1
   2 │     2      2
   3 │     3      3

julia&gt; df2 = DataFrame(A=4:6, B=4:6)
3×2 DataFrame
 Row │ A      B
     │ Int64  Int64
─────┼──────────────
   1 │     4      4
   2 │     5      5
   3 │     6      6

julia&gt; df3 = DataFrame(A=7:9, C=7:9)
3×2 DataFrame
 Row │ A      C
     │ Int64  Int64
─────┼──────────────
   1 │     7      7
   2 │     8      8
   3 │     9      9

julia&gt; df4 = DataFrame()
0×0 DataFrame

julia&gt; vcat(df1, df2)
6×2 DataFrame
 Row │ A      B
     │ Int64  Int64
─────┼──────────────
   1 │     1      1
   2 │     2      2
   3 │     3      3
   4 │     4      4
   5 │     5      5
   6 │     6      6

julia&gt; vcat(df1, df3, cols=:union)
6×3 DataFrame
 Row │ A      B        C
     │ Int64  Int64?   Int64?
─────┼─────────────────────────
   1 │     1        1  missing
   2 │     2        2  missing
   3 │     3        3  missing
   4 │     7  missing        7
   5 │     8  missing        8
   6 │     9  missing        9

julia&gt; vcat(df1, df3, cols=:intersect)
6×1 DataFrame
 Row │ A
     │ Int64
─────┼───────
   1 │     1
   2 │     2
   3 │     3
   4 │     7
   5 │     8
   6 │     9

julia&gt; vcat(df4, df1)
3×2 DataFrame
 Row │ A      B
     │ Int64  Int64
─────┼──────────────
   1 │     1      1
   2 │     2      2
   3 │     3      3

julia&gt; vcat(df1, df2, df3, df4, cols=:union, source=&quot;source&quot;)
9×4 DataFrame
 Row │ A      B        C        source
     │ Int64  Int64?   Int64?   Int64
─────┼─────────────────────────────────
   1 │     1        1  missing       1
   2 │     2        2  missing       1
   3 │     3        3  missing       1
   4 │     4        4  missing       2
   5 │     5        5  missing       2
   6 │     6        6  missing       2
   7 │     7  missing        7       3
   8 │     8  missing        8       3
   9 │     9  missing        9       3

julia&gt; vcat(df1, df2, df4, df3, cols=:union, source=:source =&gt; &#39;a&#39;:&#39;d&#39;)
9×4 DataFrame
 Row │ A      B        C        source
     │ Int64  Int64?   Int64?   Char
─────┼─────────────────────────────────
   1 │     1        1  missing  a
   2 │     2        2  missing  a
   3 │     3        3  missing  a
   4 │     4        4  missing  b
   5 │     5        5  missing  b
   6 │     6        6  missing  b
   7 │     7  missing        7  d
   8 │     8  missing        8  d
   9 │     9  missing        9  d</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/a1f75b1dd155265e5767e1e3f64d70be824859d7/src/abstractdataframe/abstractdataframe.jl#L1609-L1765">source</a></section></article><h2 id="Reshaping-data-frames-between-tall-and-wide-formats"><a class="docs-heading-anchor" href="#Reshaping-data-frames-between-tall-and-wide-formats">Reshaping data frames between tall and wide formats</a><a id="Reshaping-data-frames-between-tall-and-wide-formats-1"></a><a class="docs-heading-anchor-permalink" href="#Reshaping-data-frames-between-tall-and-wide-formats" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Base.stack" href="#Base.stack"><code>Base.stack</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">stack(df::AbstractDataFrame[, measure_vars[, id_vars] ];
      variable_name=:variable, value_name=:value,
      view::Bool=false, variable_eltype::Type=String)</code></pre><p>Stack a data frame <code>df</code>, i.e. convert it from wide to long format.</p><p>Return the long-format <code>DataFrame</code> with: columns for each of the <code>id_vars</code>, column <code>value_name</code> (<code>:value</code> by default) holding the values of the stacked columns (<code>measure_vars</code>), and column <code>variable_name</code> (<code>:variable</code> by default) a vector holding the name of the corresponding <code>measure_vars</code> variable.</p><p>If <code>view=true</code> then return a stacked view of a data frame (long format). The result is a view because the columns are special <code>AbstractVectors</code> that return views into the original data frame.</p><p><strong>Arguments</strong></p><ul><li><code>df</code> : the AbstractDataFrame to be stacked</li><li><code>measure_vars</code> : the columns to be stacked (the measurement variables), as a column selector (<code>Symbol</code>, string or integer; <code>:</code>, <code>Cols</code>, <code>All</code>, <code>Between</code>, <code>Not</code>, a regular expression, or a vector of <code>Symbol</code>s, strings or integers). If neither <code>measure_vars</code> or <code>id_vars</code> are given, <code>measure_vars</code> defaults to all floating point columns.</li><li><code>id_vars</code> : the identifier columns that are repeated during stacking, as a column selector (<code>Symbol</code>, string or integer; <code>:</code>, <code>Cols</code>, <code>All</code>, <code>Between</code>, <code>Not</code>, a regular expression, or a vector of <code>Symbol</code>s, strings or integers). Defaults to all variables that are not <code>measure_vars</code></li><li><code>variable_name</code> : the name (<code>Symbol</code> or string) of the new stacked column that shall hold the names of each of <code>measure_vars</code></li><li><code>value_name</code> : the name (<code>Symbol</code> or string) of the new stacked column containing the values from each of <code>measure_vars</code></li><li><code>view</code> : whether the stacked data frame should be a view rather than contain freshly allocated vectors.</li><li><code>variable_eltype</code> : determines the element type of column <code>variable_name</code>. By default a <code>PooledArray{String}</code> is created. If <code>variable_eltype=Symbol</code> a <code>PooledVector{Symbol}</code> is created, and if <code>variable_eltype=CategoricalValue{String}</code> a <code>CategoricalArray{String}</code> is produced (call <code>using CategoricalArrays</code> first if needed) Passing any other type <code>T</code> will produce a <code>PooledVector{T}</code> column as long as it supports conversion from <code>String</code>. When <code>view=true</code>, a <code>RepeatedVector{T}</code> is produced.</li></ul><p>Metadata: table-level <code>:note</code>-style metadata and column-level <code>:note</code>-style metadata for identifier columns are preserved.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; df = DataFrame(a=repeat(1:3, inner=2),
                      b=repeat(1:2, inner=3),
                      c=repeat(1:1, inner=6),
                      d=repeat(1:6, inner=1),
                      e=string.(&#39;a&#39;:&#39;f&#39;))
6×5 DataFrame
 Row │ a      b      c      d      e
     │ Int64  Int64  Int64  Int64  String
─────┼────────────────────────────────────
   1 │     1      1      1      1  a
   2 │     1      1      1      2  b
   3 │     2      1      1      3  c
   4 │     2      2      1      4  d
   5 │     3      2      1      5  e
   6 │     3      2      1      6  f

julia&gt; stack(df, [:c, :d])
12×5 DataFrame
 Row │ a      b      e       variable  value
     │ Int64  Int64  String  String    Int64
─────┼───────────────────────────────────────
   1 │     1      1  a       c             1
   2 │     1      1  b       c             1
   3 │     2      1  c       c             1
   4 │     2      2  d       c             1
   5 │     3      2  e       c             1
   6 │     3      2  f       c             1
   7 │     1      1  a       d             1
   8 │     1      1  b       d             2
   9 │     2      1  c       d             3
  10 │     2      2  d       d             4
  11 │     3      2  e       d             5
  12 │     3      2  f       d             6

julia&gt; stack(df, [:c, :d], [:a])
12×3 DataFrame
 Row │ a      variable  value
     │ Int64  String    Int64
─────┼────────────────────────
   1 │     1  c             1
   2 │     1  c             1
   3 │     2  c             1
   4 │     2  c             1
   5 │     3  c             1
   6 │     3  c             1
   7 │     1  d             1
   8 │     1  d             2
   9 │     2  d             3
  10 │     2  d             4
  11 │     3  d             5
  12 │     3  d             6

julia&gt; stack(df, Not([:a, :b, :e]))
12×5 DataFrame
 Row │ a      b      e       variable  value
     │ Int64  Int64  String  String    Int64
─────┼───────────────────────────────────────
   1 │     1      1  a       c             1
   2 │     1      1  b       c             1
   3 │     2      1  c       c             1
   4 │     2      2  d       c             1
   5 │     3      2  e       c             1
   6 │     3      2  f       c             1
   7 │     1      1  a       d             1
   8 │     1      1  b       d             2
   9 │     2      1  c       d             3
  10 │     2      2  d       d             4
  11 │     3      2  e       d             5
  12 │     3      2  f       d             6

julia&gt; stack(df, Not([:a, :b, :e]), variable_name=:somemeasure)
12×5 DataFrame
 Row │ a      b      e       somemeasure  value
     │ Int64  Int64  String  String       Int64
─────┼──────────────────────────────────────────
   1 │     1      1  a       c                1
   2 │     1      1  b       c                1
   3 │     2      1  c       c                1
   4 │     2      2  d       c                1
   5 │     3      2  e       c                1
   6 │     3      2  f       c                1
   7 │     1      1  a       d                1
   8 │     1      1  b       d                2
   9 │     2      1  c       d                3
  10 │     2      2  d       d                4
  11 │     3      2  e       d                5
  12 │     3      2  f       d                6</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/a1f75b1dd155265e5767e1e3f64d70be824859d7/src/abstractdataframe/reshape.jl#L1-L135">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFrames.unstack" href="#DataFrames.unstack"><code>DataFrames.unstack</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">unstack(df::AbstractDataFrame, rowkeys, colkey, value;
        renamecols::Function=identity, allowmissing::Bool=false,
        combine=only, fill=missing, threads::Bool=true)
unstack(df::AbstractDataFrame, colkey, value;
        renamecols::Function=identity, allowmissing::Bool=false,
        combine=only, fill=missing, threads::Bool=true)
unstack(df::AbstractDataFrame;
        renamecols::Function=identity, allowmissing::Bool=false,
        combine=only, fill=missing, threads::Bool=true)</code></pre><p>Unstack data frame <code>df</code>, i.e. convert it from long to wide format.</p><p>Row and column keys are ordered in the order of their first appearance.</p><p><strong>Positional arguments</strong></p><ul><li><code>df</code> : the AbstractDataFrame to be unstacked</li><li><code>rowkeys</code> : the columns with a unique key for each row, if not given, find a key by grouping on anything not a <code>colkey</code> or <code>value</code>. Can be any column selector (<code>Symbol</code>, string or integer; <code>:</code>, <code>Cols</code>, <code>All</code>, <code>Between</code>, <code>Not</code>, a regular expression, or a vector of <code>Symbol</code>s, strings or integers). If <code>rowkeys</code> contains no columns all rows are assumed to have the same key.</li><li><code>colkey</code> : the column (<code>Symbol</code>, string or integer) holding the column names in wide format, defaults to <code>:variable</code></li><li><code>values</code> : the column storing values (<code>Symbol</code>, string or integer), defaults to <code>:value</code></li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>renamecols</code>: a function called on each unique value in <code>colkey</code>; it must return the name of the column to be created (typically as a string or a <code>Symbol</code>). Duplicates in resulting names when converted to <code>Symbol</code> are not allowed. By default no transformation is performed.</li><li><code>allowmissing</code>: if <code>false</code> (the default) then an error is thrown if <code>colkey</code> contains <code>missing</code> values; if <code>true</code> then a column referring to <code>missing</code> value is created.</li><li><code>combine</code>: if <code>only</code> (the default) then an error is thrown if combination of <code>rowkeys</code> and <code>colkey</code> contains duplicate entries. Otherwise the passed value must be a function that is called on a vector view containing all elements for each combination of <code>rowkeys</code> and <code>colkey</code> present in the data.</li><li><code>fill</code>: missing row/column combinations are filled with this value. The default is <code>missing</code>. If the <code>value</code> column is a <code>CategoricalVector</code> and <code>fill</code> is not <code>missing</code> then in order to keep unstacked value columns also <code>CategoricalVector</code> the <code>fill</code> must be passed as <code>CategoricalValue</code></li><li><code>threads</code>: whether <code>combine</code> function may be run in separate tasks which can execute in parallel (possibly being applied to multiple groups at the same time). Whether or not tasks are actually spawned and their number are determined automatically. Set to <code>false</code> if <code>combine</code> requires serial execution or is not thread-safe.</li></ul><p>Metadata: table-level <code>:note</code>-style metadata and column-level <code>:note</code>-style metadata for row keys columns are preserved.</p><p><strong>Deprecations</strong></p><ul><li><code>allowduplicates</code> keyword argument is deprecated; instead use <code>combine</code> keyword argument; an equivalent to <code>allowduplicates=true</code> is <code>combine=last</code> and to <code>allowduplicates=false</code> is <code>combine=only</code> (the default);</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; wide = DataFrame(id=1:6,
                        a=repeat(1:3, inner=2),
                        b=repeat(1.0:2.0, inner=3),
                        c=repeat(1.0:1.0, inner=6),
                        d=repeat(1.0:3.0, inner=2))
6×5 DataFrame
 Row │ id     a      b        c        d
     │ Int64  Int64  Float64  Float64  Float64
─────┼─────────────────────────────────────────
   1 │     1      1      1.0      1.0      1.0
   2 │     2      1      1.0      1.0      1.0
   3 │     3      2      1.0      1.0      2.0
   4 │     4      2      2.0      1.0      2.0
   5 │     5      3      2.0      1.0      3.0
   6 │     6      3      2.0      1.0      3.0

julia&gt; long = stack(wide)
18×4 DataFrame
 Row │ id     a      variable  value
     │ Int64  Int64  String    Float64
─────┼─────────────────────────────────
   1 │     1      1  b             1.0
   2 │     2      1  b             1.0
   3 │     3      2  b             1.0
   4 │     4      2  b             2.0
   5 │     5      3  b             2.0
   6 │     6      3  b             2.0
   7 │     1      1  c             1.0
   8 │     2      1  c             1.0
  ⋮  │   ⋮      ⋮       ⋮         ⋮
  12 │     6      3  c             1.0
  13 │     1      1  d             1.0
  14 │     2      1  d             1.0
  15 │     3      2  d             2.0
  16 │     4      2  d             2.0
  17 │     5      3  d             3.0
  18 │     6      3  d             3.0
                         3 rows omitted

julia&gt; unstack(long)
6×5 DataFrame
 Row │ id     a      b         c         d
     │ Int64  Int64  Float64?  Float64?  Float64?
─────┼────────────────────────────────────────────
   1 │     1      1       1.0       1.0       1.0
   2 │     2      1       1.0       1.0       1.0
   3 │     3      2       1.0       1.0       2.0
   4 │     4      2       2.0       1.0       2.0
   5 │     5      3       2.0       1.0       3.0
   6 │     6      3       2.0       1.0       3.0

julia&gt; unstack(long, :variable, :value)
6×5 DataFrame
 Row │ id     a      b         c         d
     │ Int64  Int64  Float64?  Float64?  Float64?
─────┼────────────────────────────────────────────
   1 │     1      1       1.0       1.0       1.0
   2 │     2      1       1.0       1.0       1.0
   3 │     3      2       1.0       1.0       2.0
   4 │     4      2       2.0       1.0       2.0
   5 │     5      3       2.0       1.0       3.0
   6 │     6      3       2.0       1.0       3.0

julia&gt; unstack(long, :id, :variable, :value)
6×4 DataFrame
 Row │ id     b         c         d
     │ Int64  Float64?  Float64?  Float64?
─────┼─────────────────────────────────────
   1 │     1       1.0       1.0       1.0
   2 │     2       1.0       1.0       1.0
   3 │     3       1.0       1.0       2.0
   4 │     4       2.0       1.0       2.0
   5 │     5       2.0       1.0       3.0
   6 │     6       2.0       1.0       3.0

julia&gt; unstack(long, [:id, :a], :variable, :value)
6×5 DataFrame
 Row │ id     a      b         c         d
     │ Int64  Int64  Float64?  Float64?  Float64?
─────┼────────────────────────────────────────────
   1 │     1      1       1.0       1.0       1.0
   2 │     2      1       1.0       1.0       1.0
   3 │     3      2       1.0       1.0       2.0
   4 │     4      2       2.0       1.0       2.0
   5 │     5      3       2.0       1.0       3.0
   6 │     6      3       2.0       1.0       3.0

julia&gt; unstack(long, :id, :variable, :value, renamecols=x-&gt;Symbol(:_, x))
6×4 DataFrame
 Row │ id     _b        _c        _d
     │ Int64  Float64?  Float64?  Float64?
─────┼─────────────────────────────────────
   1 │     1       1.0       1.0       1.0
   2 │     2       1.0       1.0       1.0
   3 │     3       1.0       1.0       2.0
   4 │     4       2.0       1.0       2.0
   5 │     5       2.0       1.0       3.0
   6 │     6       2.0       1.0       3.0</code></pre><p>Note that there are some differences between the widened results above.</p><pre><code class="language-julia-repl hljs">julia&gt; df = DataFrame(id=[&quot;1&quot;, &quot;1&quot;, &quot;2&quot;],
                      variable=[&quot;Var1&quot;, &quot;Var2&quot;, &quot;Var1&quot;],
                      value=[1, 2, 3])
3×3 DataFrame
 Row │ id      variable  value
     │ String  String    Int64
─────┼─────────────────────────
   1 │ 1       Var1          1
   2 │ 1       Var2          2
   3 │ 2       Var1          3

julia&gt; unstack(df, :variable, :value, fill=0)
2×3 DataFrame
 Row │ id      Var1   Var2
     │ String  Int64  Int64
─────┼──────────────────────
   1 │ 1           1      2
   2 │ 2           3      0

julia&gt; df = DataFrame(cols=[&quot;a&quot;, &quot;a&quot;, &quot;b&quot;], values=[1, 2, 4])
3×2 DataFrame
 Row │ cols    values
     │ String  Int64
─────┼────────────────
   1 │ a            1
   2 │ a            2
   3 │ b            4

julia&gt; unstack(df, :cols, :values, combine=copy)
1×2 DataFrame
 Row │ a        b
     │ Array…?  Array…?
─────┼──────────────────
   1 │ [1, 2]   [4]

julia&gt; unstack(df, :cols, :values, combine=sum)
1×2 DataFrame
 Row │ a       b
     │ Int64?  Int64?
─────┼────────────────
   1 │      3       4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/a1f75b1dd155265e5767e1e3f64d70be824859d7/src/abstractdataframe/reshape.jl#L215-L419">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.permutedims" href="#Base.permutedims"><code>Base.permutedims</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">permutedims(df::AbstractDataFrame,
            [src_namescol::Union{Int, Symbol, AbstractString}],
            [dest_namescol::Union{Symbol, AbstractString}];
            makeunique::Bool=false, strict::Bool=true)</code></pre><p>Turn <code>df</code> on its side such that rows become columns and values in the column indexed by <code>src_namescol</code> become the names of new columns. In the resulting <code>DataFrame</code>, column names of <code>df</code> will become the first column with name specified by <code>dest_namescol</code>.</p><p><strong>Arguments</strong></p><ul><li><code>df</code> : the <code>AbstractDataFrame</code></li><li><code>src_namescol</code> : the column that will become the new header.  If omitted then column names <code>:x1</code>, <code>:x2</code>, ... are generated automatically.</li><li><code>dest_namescol</code> : the name of the first column in the returned <code>DataFrame</code>. Defaults to the same name as <code>src_namescol</code>. Not supported when <code>src_namescol</code> is a vector or is omitted.</li><li><code>makeunique</code> : if <code>false</code> (the default), an error will be raised if duplicate names are found; if <code>true</code>, duplicate names will be suffixed with <code>_i</code> (<code>i</code> starting at 1 for the first duplicate). Not supported when <code>src_namescol</code> is omitted.</li><li><code>strict</code> : if <code>true</code> (the default), an error will be raised if the values contained in the <code>src_namescol</code> are not all <code>Symbol</code> or all <code>AbstractString</code>, or can all be converted to <code>String</code> using <code>convert</code>. If <code>false</code> then any values are accepted and the will be changed to strings using the <code>string</code> function. Not supported when <code>src_namescol</code> is a vector or is omitted.</li></ul><p>Note: The element types of columns in resulting <code>DataFrame</code> (other than the first column if it is created from <code>df</code> column names, which always has element type <code>String</code>) will depend on the element types of <em>all</em> input columns based on the result of <code>promote_type</code>. That is, if the source data frame contains <code>Int</code> and <code>Float64</code> columns, resulting columns will have element type <code>Float64</code>. If the source has <code>Int</code> and <code>String</code> columns, resulting columns will have element type <code>Any</code>.</p><p>Metadata: table-level <code>:note</code>-style metadata is preserved and column-level metadata is dropped.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; df = DataFrame(a=1:2, b=3:4)
2×2 DataFrame
 Row │ a      b
     │ Int64  Int64
─────┼──────────────
   1 │     1      3
   2 │     2      4

julia&gt; permutedims(df)
2×2 DataFrame
 Row │ x1     x2
     │ Int64  Int64
─────┼──────────────
   1 │     1      2
   2 │     3      4

julia&gt; permutedims(df, [:p, :q])
2×2 DataFrame
 Row │ p      q
     │ Int64  Int64
─────┼──────────────
   1 │     1      2
   2 │     3      4

julia&gt; df1 = DataFrame(a=[&quot;x&quot;, &quot;y&quot;], b=[1.0, 2.0], c=[3, 4], d=[true, false])
2×4 DataFrame
 Row │ a       b        c      d
     │ String  Float64  Int64  Bool
─────┼───────────────────────────────
   1 │ x           1.0      3   true
   2 │ y           2.0      4  false

julia&gt; permutedims(df1, 1) # note the column types
3×3 DataFrame
 Row │ a       x        y
     │ String  Float64  Float64
─────┼──────────────────────────
   1 │ b           1.0      2.0
   2 │ c           3.0      4.0
   3 │ d           1.0      0.0

julia&gt; df2 = DataFrame(a=[&quot;x&quot;, &quot;y&quot;], b=[1, &quot;two&quot;], c=[3, 4], d=[true, false])
2×4 DataFrame
 Row │ a       b    c      d
     │ String  Any  Int64  Bool
─────┼───────────────────────────
   1 │ x       1        3   true
   2 │ y       two      4  false

julia&gt; permutedims(df2, 1, &quot;different_name&quot;)
3×3 DataFrame
 Row │ different_name  x     y
     │ String          Any   Any
─────┼─────────────────────────────
   1 │ b               1     two
   2 │ c               3     4
   3 │ d               true  false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/a1f75b1dd155265e5767e1e3f64d70be824859d7/src/abstractdataframe/reshape.jl#L709-L810">source</a></section></article><h2 id="Sorting"><a class="docs-heading-anchor" href="#Sorting">Sorting</a><a id="Sorting-1"></a><a class="docs-heading-anchor-permalink" href="#Sorting" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Base.issorted" href="#Base.issorted"><code>Base.issorted</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">issorted(df::AbstractDataFrame, cols=All();
         lt::Union{Function, AbstractVector{&lt;:Function}}=isless,
         by::Union{Function, AbstractVector{&lt;:Function}}=identity,
         rev::Union{Bool, AbstractVector{Bool}}=false,
         order::Union{Ordering, AbstractVector{&lt;:Ordering}}=Forward,
         checkunique::Bool=false)</code></pre><p>Test whether data frame <code>df</code> sorted by column(s) <code>cols</code>. Checking against multiple columns is done lexicographically.</p><p><code>cols</code> can be any column selector (<code>Symbol</code>, string or integer; <code>:</code>, <code>Cols</code>, <code>All</code>, <code>Between</code>, <code>Not</code>, a regular expression, or a vector of <code>Symbol</code>s, strings or integers). If <code>cols</code> selects no columns, check whether <code>df</code> is sorted on all columns (this behaviour is deprecated and will change in future versions).</p><p>If <code>rev</code> is <code>true</code>, reverse sorting is performed. To enable reverse sorting only for some columns, pass <code>order(c, rev=true)</code> in <code>cols</code>, with <code>c</code> the corresponding column index (see example below).</p><p>Since having repeated elements makes multiple sorting orders valid, the <code>checkunique</code> keyword allows for the situation to be caught. If <code>checkunique</code> is <code>true</code> and duplicate elements are found an error will be thrown. The use of the <code>checkunique</code> keyword is only supported when neither the <code>by</code> nor the <code>lt</code> keywords are being used. Similarly, the use of <code>order(...)</code> clauses that specify either <code>by</code> or <code>lt</code> are not supported, but specifying <code>rev</code> by itself is allowed.</p><p>The <code>by</code> keyword allows providing a function that will be applied to each cell before comparison; the <code>lt</code> keyword allows providing a custom &quot;less than&quot; function. If both <code>by</code> and <code>lt</code> are specified, the <code>lt</code> function is applied to the result of the <code>by</code> function.</p><p>Keyword arguments specifying sorting order (<code>rev</code>, <code>lt</code> or <code>by</code>) can either be a single value, or a vector of length equal to the number of columns the operation is performed on. When a single value is passed, it applies to all columns. When a vector is passed, each entry applies to the column in the corresponding position in <code>cols</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; df = DataFrame(a=[1, 2, 3, 4], b=[4, 3, 2, 1])
4×2 DataFrame
 Row │ a      b
     │ Int64  Int64
─────┼──────────────
   1 │     1      4
   2 │     2      3
   3 │     3      2
   4 │     4      1

julia&gt; issorted(df)
true

julia&gt; issorted(df, :a)
true

julia&gt; issorted(df, :b)
false

julia&gt; issorted(df, :b, rev=true)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/a1f75b1dd155265e5767e1e3f64d70be824859d7/src/abstractdataframe/sort.jl#L367-L408">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFrames.order" href="#DataFrames.order"><code>DataFrames.order</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">order(col::ColumnIndex; kwargs...)</code></pre><p>Specify sorting order for a column <code>col</code> in a data frame. <code>kwargs</code> can be <code>lt</code>, <code>by</code>, <code>rev</code>, and <code>order</code> with values following the rules defined in <a href="#Base.sort!"><code>sort!</code></a>.</p><p>See also: <a href="#Base.sort!"><code>sort!</code></a>, <a href="#Base.sort"><code>sort</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; df = DataFrame(x=[-3, -1, 0, 2, 4], y=1:5)
5×2 DataFrame
 Row │ x      y
     │ Int64  Int64
─────┼──────────────
   1 │    -3      1
   2 │    -1      2
   3 │     0      3
   4 │     2      4
   5 │     4      5

julia&gt; sort(df, order(:x, rev=true))
5×2 DataFrame
 Row │ x      y
     │ Int64  Int64
─────┼──────────────
   1 │     4      5
   2 │     2      4
   3 │     0      3
   4 │    -1      2
   5 │    -3      1

julia&gt; sort(df, order(:x, by=abs))
5×2 DataFrame
 Row │ x      y
     │ Int64  Int64
─────┼──────────────
   1 │     0      3
   2 │    -1      2
   3 │     2      4
   4 │    -3      1
   5 │     4      5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/a1f75b1dd155265e5767e1e3f64d70be824859d7/src/abstractdataframe/sort.jl#L25-L69">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.sort" href="#Base.sort"><code>Base.sort</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">sort(df::AbstractDataFrame, cols=All();
     alg::Union{Algorithm, Nothing}=nothing,
     lt::Union{Function, AbstractVector{&lt;:Function}}=isless,
     by::Union{Function, AbstractVector{&lt;:Function}}=identity,
     rev::Union{Bool, AbstractVector{Bool}}=false,
     order::Union{Ordering, AbstractVector{&lt;:Ordering}}=Forward,
     view::Bool=false,
     checkunique::Bool=false)</code></pre><p>Return a data frame containing the rows in <code>df</code> sorted by column(s) <code>cols</code>. Sorting on multiple columns is done lexicographically.</p><p><code>cols</code> can be any column selector (<code>Symbol</code>, string or integer; <code>:</code>, <code>Cols</code>, <code>All</code>, <code>Between</code>, <code>Not</code>, a regular expression, or a vector of <code>Symbol</code>s, strings or integers). If <code>cols</code> selects no columns, sort <code>df</code> on all columns (this behaviour is deprecated and will change in future versions).</p><p>If <code>rev</code> is <code>true</code>, reverse sorting is performed. To enable reverse sorting only for some columns, pass <code>order(c, rev=true)</code> in <code>cols</code>, with <code>c</code> the corresponding column index (see example below).</p><p>Since having repeated elements makes multiple sorting orders valid, the <code>checkunique</code> keyword allows for the situation to be caught. If <code>checkunique</code> is <code>true</code> and duplicate elements are found an error will be thrown. The use of the <code>checkunique</code> keyword is only supported when neither the <code>by</code> nor the <code>lt</code> keywords are being used. Similarly, the use of <code>order(...)</code> clauses that specify either <code>by</code> or <code>lt</code> are not supported, but specifying <code>rev</code> by itself is allowed.</p><p>The <code>by</code> keyword allows providing a function that will be applied to each cell before comparison; the <code>lt</code> keyword allows providing a custom &quot;less than&quot; function. If both <code>by</code> and <code>lt</code> are specified, the <code>lt</code> function is applied to the result of the <code>by</code> function.</p><p>Keyword arguments specifying sorting order (<code>rev</code>, <code>lt</code> or <code>by</code>) can either be a single value, or a vector of length equal to the number of columns the operation is performed on. When a single value is passed, it applies to all columns. When a vector is passed, each entry applies to the column in the corresponding position in <code>cols</code>.</p><p>If <code>alg</code> is <code>nothing</code> (the default), the most appropriate algorithm is chosen automatically among <code>TimSort</code>, <code>MergeSort</code> and <code>RadixSort</code> depending on the type of the sorting columns and on the number of rows in <code>df</code>.</p><p>If <code>view=false</code> a freshly allocated <code>DataFrame</code> is returned. If <code>view=true</code> then a <code>SubDataFrame</code> view into <code>df</code> is returned.</p><p>Metadata: this function preserves table-level and column-level <code>:note</code>-style metadata.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; df = DataFrame(x=[3, 1, 2, 1], y=[&quot;b&quot;, &quot;c&quot;, &quot;a&quot;, &quot;b&quot;])
4×2 DataFrame
 Row │ x      y
     │ Int64  String
─────┼───────────────
   1 │     3  b
   2 │     1  c
   3 │     2  a
   4 │     1  b

julia&gt; sort(df, :x)
4×2 DataFrame
 Row │ x      y
     │ Int64  String
─────┼───────────────
   1 │     1  c
   2 │     1  b
   3 │     2  a
   4 │     3  b

julia&gt; sort(df, [:x, :y])
4×2 DataFrame
 Row │ x      y
     │ Int64  String
─────┼───────────────
   1 │     1  b
   2 │     1  c
   3 │     2  a
   4 │     3  b

julia&gt; sort(df, [:x, :y], rev=true)
4×2 DataFrame
 Row │ x      y
     │ Int64  String
─────┼───────────────
   1 │     3  b
   2 │     2  a
   3 │     1  c
   4 │     1  b

julia&gt; sort(df, [:x, order(:y, rev=true)])
4×2 DataFrame
 Row │ x      y
     │ Int64  String
─────┼───────────────
   1 │     1  c
   2 │     1  b
   3 │     2  a
   4 │     3  b</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/a1f75b1dd155265e5767e1e3f64d70be824859d7/src/abstractdataframe/sort.jl#L438-L518">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.sort!" href="#Base.sort!"><code>Base.sort!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">sort!(df::AbstractDataFrame, cols=All();
      alg::Union{Algorithm, Nothing}=nothing,
      lt::Union{Function, AbstractVector{&lt;:Function}}=isless,
      by::Union{Function, AbstractVector{&lt;:Function}}=identity,
      rev::Union{Bool, AbstractVector{Bool}}=false,
      order::Union{Ordering, AbstractVector{&lt;:Ordering}}=Forward,
      checkunique::Bool=false)</code></pre><p>Sort data frame <code>df</code> by column(s) <code>cols</code> by permuting its rows in-place. Sorting on multiple columns is done lexicographicallly.</p><p><code>cols</code> can be any column selector (<code>Symbol</code>, string or integer; <code>:</code>, <code>Cols</code>, <code>All</code>, <code>Between</code>, <code>Not</code>, a regular expression, or a vector of <code>Symbol</code>s, strings or integers). If <code>cols</code> selects no columns, sort <code>df</code> on all columns (this behaviour is deprecated and will change in future versions).</p><p>If <code>rev</code> is <code>true</code>, reverse sorting is performed. To enable reverse sorting only for some columns, pass <code>order(c, rev=true)</code> in <code>cols</code>, with <code>c</code> the corresponding column index (see example below).</p><p>Since having repeated elements makes multiple sorting orders valid, the <code>checkunique</code> keyword allows for the situation to be caught. If <code>checkunique</code> is <code>true</code> and duplicate elements are found an error will be thrown. The use of the <code>checkunique</code> keyword is only supported when neither the <code>by</code> nor the <code>lt</code> keywords are being used. Similarly, the use of <code>order(...)</code> clauses that specify either <code>by</code> or <code>lt</code> are not supported, but specifying <code>rev</code> by itself is allowed.</p><p>The <code>by</code> keyword allows providing a function that will be applied to each cell before comparison; the <code>lt</code> keyword allows providing a custom &quot;less than&quot; function. If both <code>by</code> and <code>lt</code> are specified, the <code>lt</code> function is applied to the result of the <code>by</code> function.</p><p>Keyword arguments specifying sorting order (<code>rev</code>, <code>lt</code> or <code>by</code>) can either be a single value, or a vector of length equal to the number of columns the operation is performed on. When a single value is passed, it applies to all columns. When a vector is passed, each entry applies to the column in the corresponding position in <code>cols</code>.</p><p>If <code>alg</code> is <code>nothing</code> (the default), the most appropriate algorithm is chosen automatically among <code>TimSort</code>, <code>MergeSort</code> and <code>RadixSort</code> depending on the type of the sorting columns and on the number of rows in <code>df</code>.</p><p><code>sort!</code> will produce a correct result even if some columns of passed data frame are identical (checked with <code>===</code>). Otherwise, if two columns share some part of memory but are not identical (e.g. are different views of the same parent vector) then <code>sort!</code> result might be incorrect.</p><p>Metadata: this function preserves table-level and column-level <code>:note</code>-style metadata.</p><p>Metadata having other styles is dropped (from parent data frame when <code>df</code> is a <code>SubDataFrame</code>).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; df = DataFrame(x=[3, 1, 2, 1], y=[&quot;b&quot;, &quot;c&quot;, &quot;a&quot;, &quot;b&quot;])
4×2 DataFrame
 Row │ x      y
     │ Int64  String
─────┼───────────────
   1 │     3  b
   2 │     1  c
   3 │     2  a
   4 │     1  b

julia&gt; sort!(df, :x)
4×2 DataFrame
 Row │ x      y
     │ Int64  String
─────┼───────────────
   1 │     1  c
   2 │     1  b
   3 │     2  a
   4 │     3  b

julia&gt; sort!(df, [:x, :y])
4×2 DataFrame
 Row │ x      y
     │ Int64  String
─────┼───────────────
   1 │     1  b
   2 │     1  c
   3 │     2  a
   4 │     3  b

julia&gt; sort!(df, [:x, :y], rev=true)
4×2 DataFrame
 Row │ x      y
     │ Int64  String
─────┼───────────────
   1 │     3  b
   2 │     2  a
   3 │     1  c
   4 │     1  b

julia&gt; sort!(df, [:x, order(:y, rev=true)])
4×2 DataFrame
 Row │ x      y
     │ Int64  String
─────┼───────────────
   1 │     1  c
   2 │     1  b
   3 │     2  a
   4 │     3  b</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/a1f75b1dd155265e5767e1e3f64d70be824859d7/src/abstractdataframe/sort.jl#L619-L701">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.sortperm" href="#Base.sortperm"><code>Base.sortperm</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">sortperm(df::AbstractDataFrame, cols=All();
         alg::Union{Algorithm, Nothing}=nothing,
         lt::Union{Function, AbstractVector{&lt;:Function}}=isless,
         by::Union{Function, AbstractVector{&lt;:Function}}=identity,
         rev::Union{Bool, AbstractVector{Bool}}=false,
         order::Union{Ordering, AbstractVector{&lt;:Ordering}}=Forward,
         checkunique::Bool=false)</code></pre><p>Return a permutation vector of row indices of data frame <code>df</code> that puts them in sorted order according to column(s) <code>cols</code>. Order on multiple columns is computed lexicographically.</p><p><code>cols</code> can be any column selector (<code>Symbol</code>, string or integer; <code>:</code>, <code>Cols</code>, <code>All</code>, <code>Between</code>, <code>Not</code>, a regular expression, or a vector of <code>Symbol</code>s, strings or integers). If <code>cols</code> selects no columns, return permutation vector based on sorting all columns (this behaviour is deprecated and will change in future versions).</p><p>If <code>rev</code> is <code>true</code>, reverse sorting is performed. To enable reverse sorting only for some columns, pass <code>order(c, rev=true)</code> in <code>cols</code>, with <code>c</code> the corresponding column index (see example below).</p><p>Since having repeated elements makes multiple sorting orders valid, the <code>checkunique</code> keyword allows for the situation to be caught. If <code>checkunique</code> is <code>true</code> and duplicate elements are found an error will be thrown. The use of the <code>checkunique</code> keyword is only supported when neither the <code>by</code> nor the <code>lt</code> keywords are being used. Similarly, the use of <code>order(...)</code> clauses that specify either <code>by</code> or <code>lt</code> are not supported, but specifying <code>rev</code> by itself is allowed.</p><p>The <code>by</code> keyword allows providing a function that will be applied to each cell before comparison; the <code>lt</code> keyword allows providing a custom &quot;less than&quot; function. If both <code>by</code> and <code>lt</code> are specified, the <code>lt</code> function is applied to the result of the <code>by</code> function.</p><p>Keyword arguments specifying sorting order (<code>rev</code>, <code>lt</code> or <code>by</code>) can either be a single value, or a vector of length equal to the number of columns the operation is performed on. When a single value is passed, it applies to all columns. When a vector is passed, each entry applies to the column in the corresponding position in <code>cols</code>.</p><p>If <code>alg</code> is <code>nothing</code> (the default), the most appropriate algorithm is chosen automatically among <code>TimSort</code>, <code>MergeSort</code> and <code>RadixSort</code> depending on the type of the sorting columns and on the number of rows in <code>df</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; df = DataFrame(x=[3, 1, 2, 1], y=[&quot;b&quot;, &quot;c&quot;, &quot;a&quot;, &quot;b&quot;])
4×2 DataFrame
 Row │ x      y
     │ Int64  String
─────┼───────────────
   1 │     3  b
   2 │     1  c
   3 │     2  a
   4 │     1  b

julia&gt; sortperm(df, :x)
4-element Vector{Int64}:
 2
 4
 3
 1

julia&gt; sortperm(df, [:x, :y])
4-element Vector{Int64}:
 4
 2
 3
 1

julia&gt; sortperm(df, [:x, :y], rev=true)
4-element Vector{Int64}:
 1
 3
 2
 4

julia&gt; sortperm(df, [:x, order(:y, rev=true)])
4-element Vector{Int64}:
 2
 4
 3
 1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/a1f75b1dd155265e5767e1e3f64d70be824859d7/src/abstractdataframe/sort.jl#L532-L595">source</a></section></article><h2 id="Joining"><a class="docs-heading-anchor" href="#Joining">Joining</a><a id="Joining-1"></a><a class="docs-heading-anchor-permalink" href="#Joining" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="DataAPI.antijoin" href="#DataAPI.antijoin"><code>DataAPI.antijoin</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">antijoin(df1, df2; on, makeunique=false, validate=(false, false), matchmissing=:error)</code></pre><p>Perform an anti join of two data frame objects and return a <code>DataFrame</code> containing the result. An anti join returns the subset of rows of <code>df1</code> that do not match with the keys in <code>df2</code>.</p><p>The order of rows in the result is kept from <code>df1</code>.</p><p><strong>Arguments</strong></p><ul><li><code>df1</code>, <code>df2</code>: the <code>AbstractDataFrames</code> to be joined</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>on</code> : The names of the key columns on which to join the data frames. This can be a single name, or a vector of names (for joining on multiple columns). A <code>left=&gt;right</code> pair of names can be used instead of a name, for the case where a key has different names in <code>df1</code> and <code>df2</code> (it is allowed to mix names and name pairs in a vector). Key values are compared using <code>isequal</code>. <code>on</code> is a required argument.</li><li><code>makeunique</code> : ignored as no columns are added to <code>df1</code> columns (it is provided for consistency with other functions).</li><li><code>validate</code> : whether to check that columns passed as the <code>on</code> argument  define unique keys in each input data frame (according to <code>isequal</code>).  Can be a tuple or a pair, with the first element indicating whether to  run check for <code>df1</code> and the second element for <code>df2</code>.  By default no check is performed.</li><li><code>matchmissing</code> : if equal to <code>:error</code> throw an error if <code>missing</code> is present in <code>on</code> columns; if equal to <code>:equal</code> then <code>missing</code> is allowed and missings are matched; if equal to <code>:notequal</code> then missings are dropped in <code>df2</code> <code>on</code> columns.</li></ul><p>It is not allowed to join on columns that contain <code>NaN</code> or <code>-0.0</code> in real or imaginary part of the number. If you need to perform a join on such values use CategoricalArrays.jl and transform a column containing such values into a <code>CategoricalVector</code>.</p><p>When merging <code>on</code> categorical columns that differ in the ordering of their levels, the ordering of the left data frame takes precedence over the ordering of the right data frame.</p><p>Metadata: table-level and column-level <code>:note</code>-style metadata are taken from <code>df1</code>.</p><p>See also: <a href="#DataAPI.innerjoin"><code>innerjoin</code></a>, <a href="#DataAPI.leftjoin"><code>leftjoin</code></a>, <a href="#DataAPI.rightjoin"><code>rightjoin</code></a>,           <a href="#DataAPI.outerjoin"><code>outerjoin</code></a>, <a href="#DataAPI.semijoin"><code>semijoin</code></a>, <a href="#DataAPI.crossjoin"><code>crossjoin</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; name = DataFrame(ID=[1, 2, 3], Name=[&quot;John Doe&quot;, &quot;Jane Doe&quot;, &quot;Joe Blogs&quot;])
3×2 DataFrame
 Row │ ID     Name
     │ Int64  String
─────┼──────────────────
   1 │     1  John Doe
   2 │     2  Jane Doe
   3 │     3  Joe Blogs

julia&gt; job = DataFrame(ID=[1, 2, 4], Job=[&quot;Lawyer&quot;, &quot;Doctor&quot;, &quot;Farmer&quot;])
3×2 DataFrame
 Row │ ID     Job
     │ Int64  String
─────┼───────────────
   1 │     1  Lawyer
   2 │     2  Doctor
   3 │     4  Farmer

julia&gt; antijoin(name, job, on = :ID)
1×2 DataFrame
 Row │ ID     Name
     │ Int64  String
─────┼──────────────────
   1 │     3  Joe Blogs

julia&gt; job2 = DataFrame(identifier=[1, 2, 4], Job=[&quot;Lawyer&quot;, &quot;Doctor&quot;, &quot;Farmer&quot;])
3×2 DataFrame
 Row │ identifier  Job
     │ Int64       String
─────┼────────────────────
   1 │          1  Lawyer
   2 │          2  Doctor
   3 │          4  Farmer

julia&gt; antijoin(name, job2, on = :ID =&gt; :identifier)
1×2 DataFrame
 Row │ ID     Name
     │ Int64  String
─────┼──────────────────
   1 │     3  Joe Blogs

julia&gt; antijoin(name, job2, on = [:ID =&gt; :identifier])
1×2 DataFrame
 Row │ ID     Name
     │ Int64  String
─────┼──────────────────
   1 │     3  Joe Blogs</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/a1f75b1dd155265e5767e1e3f64d70be824859d7/src/join/composer.jl#L1388-L1482">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataAPI.crossjoin" href="#DataAPI.crossjoin"><code>DataAPI.crossjoin</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">crossjoin(df1::AbstractDataFrame, df2::AbstractDataFrame;
          makeunique::Bool=false, renamecols=identity =&gt; identity)
crossjoin(df1, df2, dfs...; makeunique = false)</code></pre><p>Perform a cross join of two or more data frame objects and return a <code>DataFrame</code> containing the result. A cross join returns the cartesian product of rows from all passed data frames, where the first passed data frame is assigned to the dimension that changes the slowest and the last data frame is assigned to the dimension that changes the fastest.</p><p><strong>Arguments</strong></p><ul><li><code>df1</code>, <code>df2</code>, <code>dfs...</code> : the <code>AbstractDataFrames</code> to be joined</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>makeunique</code> : if <code>false</code> (the default), an error will be raised if duplicate names are found in columns not joined on; if <code>true</code>, duplicate names will be suffixed with <code>_i</code> (<code>i</code> starting at 1 for the first duplicate).</li><li><code>renamecols</code> : a <code>Pair</code> specifying how columns of left and right data frames should be renamed in the resulting data frame. Each element of the pair can be a string or a <code>Symbol</code> can be passed in which case it is appended to the original column name; alternatively a function can be passed in which case it is applied to each column name, which is passed to it as a <code>String</code>.</li></ul><p>If more than two data frames are passed, the join is performed recursively with left associativity.</p><p>Metadata: table-level <code>:note</code>-style metadata is preserved only for keys which are defined in all passed tables and have the same value. Column-level <code>:note</code>-style metadata is preserved from both tables.</p><p>See also: <a href="#DataAPI.innerjoin"><code>innerjoin</code></a>, <a href="#DataAPI.leftjoin"><code>leftjoin</code></a>, <a href="#DataAPI.rightjoin"><code>rightjoin</code></a>,           <a href="#DataAPI.outerjoin"><code>outerjoin</code></a>, <a href="#DataAPI.semijoin"><code>semijoin</code></a>, <a href="#DataAPI.antijoin"><code>antijoin</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; df1 = DataFrame(X=1:3)
3×1 DataFrame
 Row │ X
     │ Int64
─────┼───────
   1 │     1
   2 │     2
   3 │     3

julia&gt; df2 = DataFrame(Y=[&quot;a&quot;, &quot;b&quot;])
2×1 DataFrame
 Row │ Y
     │ String
─────┼────────
   1 │ a
   2 │ b

julia&gt; crossjoin(df1, df2)
6×2 DataFrame
 Row │ X      Y
     │ Int64  String
─────┼───────────────
   1 │     1  a
   2 │     1  b
   3 │     2  a
   4 │     2  b
   5 │     3  a
   6 │     3  b</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/a1f75b1dd155265e5767e1e3f64d70be824859d7/src/join/composer.jl#L1493-L1559">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataAPI.innerjoin" href="#DataAPI.innerjoin"><code>DataAPI.innerjoin</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">innerjoin(df1, df2; on, makeunique=false, validate=(false, false),
          renamecols=(identity =&gt; identity), matchmissing=:error,
          order=:undefined)
innerjoin(df1, df2, dfs...; on, makeunique=false,
          validate=(false, false), matchmissing=:error,
          order=:undefined)</code></pre><p>Perform an inner join of two or more data frame objects and return a <code>DataFrame</code> containing the result. An inner join includes rows with keys that match in all passed data frames.</p><p>In the returned data frame the type of the columns on which the data frames are joined is determined by the type of these columns in <code>df1</code>. This behavior may change in future releases.</p><p><strong>Arguments</strong></p><ul><li><code>df1</code>, <code>df2</code>, <code>dfs...</code>: the <code>AbstractDataFrames</code> to be joined</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>on</code> : The names of the key columns on which to join the data frames. This can be a single name, or a vector of names (for joining on multiple columns). When joining only two data frames, a <code>left=&gt;right</code> pair of names can be used instead of a name, for the case where a key has different names in <code>df1</code> and <code>df2</code> (it is allowed to mix names and name pairs in a vector). Key values are compared using <code>isequal</code>. <code>on</code> is a required argument.</li><li><code>makeunique</code> : if <code>false</code> (the default), an error will be raised if duplicate names are found in columns not joined on; if <code>true</code>, duplicate names will be suffixed with <code>_i</code> (<code>i</code> starting at 1 for the first duplicate).</li><li><code>validate</code> : whether to check that columns passed as the <code>on</code> argument define unique keys in each input data frame (according to <code>isequal</code>). Can be a tuple or a pair, with the first element indicating whether to run check for <code>df1</code> and the second element for <code>df2</code>. By default no check is performed.</li><li><code>renamecols</code> : a <code>Pair</code> specifying how columns of left and right data frames should be renamed in the resulting data frame. Each element of the pair can be a string or a <code>Symbol</code> can be passed in which case it is appended to the original column name; alternatively a function can be passed in which case it is applied to each column name, which is passed to it as a <code>String</code>. Note that <code>renamecols</code> does not affect <code>on</code> columns, whose names are always taken from the left data frame and left unchanged.</li><li><code>matchmissing</code> : if equal to <code>:error</code> throw an error if <code>missing</code> is present in <code>on</code> columns; if equal to <code>:equal</code> then <code>missing</code> is allowed and missings are matched; if equal to <code>:notequal</code> then missings are dropped in <code>df1</code> and <code>df2</code> <code>on</code> columns.</li><li><code>order</code> : if <code>:undefined</code> (the default) the order of rows in the result is  undefined and may change in future releases. If <code>:left</code> then the order of  rows from the left data frame is retained. If <code>:right</code> then the order of rows  from the right data frame is retained.</li></ul><p>It is not allowed to join on columns that contain <code>NaN</code> or <code>-0.0</code> in real or imaginary part of the number. If you need to perform a join on such values use CategoricalArrays.jl and transform a column containing such values into a <code>CategoricalVector</code>.</p><p>When merging <code>on</code> categorical columns that differ in the ordering of their levels, the ordering of the left data frame takes precedence over the ordering of the right data frame.</p><p>If more than two data frames are passed, the join is performed recursively with left associativity. In this case the <code>validate</code> keyword argument is applied recursively with left associativity.</p><p>Metadata: table-level <code>:note</code>-style metadata and column-level <code>:note</code>-style metadata for key columns is preserved only for keys which are defined in all passed tables and have the same value. Column-level <code>:note</code>-style metadata is preserved for all other columns.</p><p>See also: <a href="#DataAPI.leftjoin"><code>leftjoin</code></a>, <a href="#DataAPI.rightjoin"><code>rightjoin</code></a>, <a href="#DataAPI.outerjoin"><code>outerjoin</code></a>,           <a href="#DataAPI.semijoin"><code>semijoin</code></a>, <a href="#DataAPI.antijoin"><code>antijoin</code></a>, <a href="#DataAPI.crossjoin"><code>crossjoin</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; name = DataFrame(ID=[1, 2, 3], Name=[&quot;John Doe&quot;, &quot;Jane Doe&quot;, &quot;Joe Blogs&quot;])
3×2 DataFrame
 Row │ ID     Name
     │ Int64  String
─────┼──────────────────
   1 │     1  John Doe
   2 │     2  Jane Doe
   3 │     3  Joe Blogs

julia&gt; job = DataFrame(ID=[1, 2, 4], Job=[&quot;Lawyer&quot;, &quot;Doctor&quot;, &quot;Farmer&quot;])
3×2 DataFrame
 Row │ ID     Job
     │ Int64  String
─────┼───────────────
   1 │     1  Lawyer
   2 │     2  Doctor
   3 │     4  Farmer

julia&gt; innerjoin(name, job, on = :ID)
2×3 DataFrame
 Row │ ID     Name      Job
     │ Int64  String    String
─────┼─────────────────────────
   1 │     1  John Doe  Lawyer
   2 │     2  Jane Doe  Doctor

julia&gt; job2 = DataFrame(identifier=[1, 2, 4], Job=[&quot;Lawyer&quot;, &quot;Doctor&quot;, &quot;Farmer&quot;])
3×2 DataFrame
 Row │ identifier  Job
     │ Int64       String
─────┼────────────────────
   1 │          1  Lawyer
   2 │          2  Doctor
   3 │          4  Farmer

julia&gt; innerjoin(name, job2, on = :ID =&gt; :identifier, renamecols = &quot;_left&quot; =&gt; &quot;_right&quot;)
2×3 DataFrame
 Row │ ID     Name_left  Job_right
     │ Int64  String     String
─────┼─────────────────────────────
   1 │     1  John Doe   Lawyer
   2 │     2  Jane Doe   Doctor

julia&gt; innerjoin(name, job2, on = [:ID =&gt; :identifier], renamecols = uppercase =&gt; lowercase)
2×3 DataFrame
 Row │ ID     NAME      job
     │ Int64  String    String
─────┼─────────────────────────
   1 │     1  John Doe  Lawyer
   2 │     2  Jane Doe  Doctor</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/a1f75b1dd155265e5767e1e3f64d70be824859d7/src/join/composer.jl#L623-L748">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataAPI.leftjoin" href="#DataAPI.leftjoin"><code>DataAPI.leftjoin</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">leftjoin(df1, df2; on, makeunique=false, source=nothing, validate=(false, false),
         renamecols=(identity =&gt; identity), matchmissing=:error, order=:undefined)</code></pre><p>Perform a left join of two data frame objects and return a <code>DataFrame</code> containing the result. A left join includes all rows from <code>df1</code>.</p><p>In the returned data frame the type of the columns on which the data frames are joined is determined by the type of these columns in <code>df1</code>. This behavior may change in future releases.</p><p><strong>Arguments</strong></p><ul><li><code>df1</code>, <code>df2</code>: the <code>AbstractDataFrames</code> to be joined</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>on</code> : The names of the key columns on which to join the data frames. This can be a single name, or a vector of names (for joining on multiple columns). A <code>left=&gt;right</code> pair of names can be used instead of a name, for the case where a key has different names in <code>df1</code> and <code>df2</code> (it is allowed to mix names and name pairs in a vector). Key values are compared using <code>isequal</code>. <code>on</code> is a required argument.</li><li><code>makeunique</code> : if <code>false</code> (the default), an error will be raised if duplicate names are found in columns not joined on; if <code>true</code>, duplicate names will be suffixed with <code>_i</code> (<code>i</code> starting at 1 for the first duplicate).</li><li><code>source</code> : Default: <code>nothing</code>. If a <code>Symbol</code> or string, adds indicator column with the given name, for whether a row appeared in only <code>df1</code> (<code>&quot;left_only&quot;</code>) or in both (<code>&quot;both&quot;</code>). If the name is already in use, the column name will be modified if <code>makeunique=true</code>.</li><li><code>validate</code> : whether to check that columns passed as the <code>on</code> argument define unique keys in each input data frame (according to <code>isequal</code>). Can be a tuple or a pair, with the first element indicating whether to run check for <code>df1</code> and the second element for <code>df2</code>. By default no check is performed.</li><li><code>renamecols</code> : a <code>Pair</code> specifying how columns of left and right data frames should be renamed in the resulting data frame. Each element of the pair can be a string or a <code>Symbol</code> can be passed in which case it is appended to the original column name; alternatively a function can be passed in which case it is applied to each column name, which is passed to it as a <code>String</code>. Note that <code>renamecols</code> does not affect <code>on</code> columns, whose names are always taken from the left data frame and left unchanged.</li><li><code>matchmissing</code> : if equal to <code>:error</code> throw an error if <code>missing</code> is present in <code>on</code> columns; if equal to <code>:equal</code> then <code>missing</code> is allowed and missings are matched; if equal to <code>:notequal</code> then missings are dropped in <code>df2</code> <code>on</code> columns.</li><li><code>order</code> : if <code>:undefined</code> (the default) the order of rows in the result is  undefined and may change in future releases. If <code>:left</code> then the order of  rows from the left data frame is retained. If <code>:right</code> then the order of rows  from the right data frame is retained (non-matching rows are put at the end).</li></ul><p>All columns of the returned data frame will support missing values.</p><p>It is not allowed to join on columns that contain <code>NaN</code> or <code>-0.0</code> in real or imaginary part of the number. If you need to perform a join on such values use CategoricalArrays.jl and transform a column containing such values into a <code>CategoricalVector</code>.</p><p>When merging <code>on</code> categorical columns that differ in the ordering of their levels, the ordering of the left data frame takes precedence over the ordering of the right data frame.</p><p>Metadata: table-level and column-level <code>:note</code>-style metadata is taken from <code>df1</code> (including key columns), except for columns added to it from <code>df2</code>, whose column-level <code>:note</code>-style metadata is taken from <code>df2</code>.</p><p>See also: <a href="#DataAPI.innerjoin"><code>innerjoin</code></a>, <a href="#DataAPI.rightjoin"><code>rightjoin</code></a>, <a href="#DataAPI.outerjoin"><code>outerjoin</code></a>,           <a href="#DataAPI.semijoin"><code>semijoin</code></a>, <a href="#DataAPI.antijoin"><code>antijoin</code></a>, <a href="#DataAPI.crossjoin"><code>crossjoin</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; name = DataFrame(ID=[1, 2, 3], Name=[&quot;John Doe&quot;, &quot;Jane Doe&quot;, &quot;Joe Blogs&quot;])
3×2 DataFrame
 Row │ ID     Name
     │ Int64  String
─────┼──────────────────
   1 │     1  John Doe
   2 │     2  Jane Doe
   3 │     3  Joe Blogs

julia&gt; job = DataFrame(ID=[1, 2, 4], Job=[&quot;Lawyer&quot;, &quot;Doctor&quot;, &quot;Farmer&quot;])
3×2 DataFrame
 Row │ ID     Job
     │ Int64  String
─────┼───────────────
   1 │     1  Lawyer
   2 │     2  Doctor
   3 │     4  Farmer

julia&gt; leftjoin(name, job, on = :ID)
3×3 DataFrame
 Row │ ID     Name       Job
     │ Int64  String     String?
─────┼───────────────────────────
   1 │     1  John Doe   Lawyer
   2 │     2  Jane Doe   Doctor
   3 │     3  Joe Blogs  missing

julia&gt; job2 = DataFrame(identifier=[1, 2, 4], Job=[&quot;Lawyer&quot;, &quot;Doctor&quot;, &quot;Farmer&quot;])
3×2 DataFrame
 Row │ identifier  Job
     │ Int64       String
─────┼────────────────────
   1 │          1  Lawyer
   2 │          2  Doctor
   3 │          4  Farmer

julia&gt; leftjoin(name, job2, on = :ID =&gt; :identifier, renamecols = &quot;_left&quot; =&gt; &quot;_right&quot;)
3×3 DataFrame
 Row │ ID     Name_left  Job_right
     │ Int64  String     String?
─────┼─────────────────────────────
   1 │     1  John Doe   Lawyer
   2 │     2  Jane Doe   Doctor
   3 │     3  Joe Blogs  missing

julia&gt; leftjoin(name, job2, on = [:ID =&gt; :identifier], renamecols = uppercase =&gt; lowercase)
3×3 DataFrame
 Row │ ID     NAME       job
     │ Int64  String     String?
─────┼───────────────────────────
   1 │     1  John Doe   Lawyer
   2 │     2  Jane Doe   Doctor
   3 │     3  Joe Blogs  missing</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/a1f75b1dd155265e5767e1e3f64d70be824859d7/src/join/composer.jl#L786-L909">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFrames.leftjoin!" href="#DataFrames.leftjoin!"><code>DataFrames.leftjoin!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">leftjoin!(df1, df2; on, makeunique=false, source=nothing,
          matchmissing=:error)</code></pre><p>Perform a left join of two data frame objects by updating the <code>df1</code> with the joined columns from <code>df2</code>.</p><p>A left join includes all rows from <code>df1</code> and leaves all rows and columns from <code>df1</code> untouched. Note that each row in <code>df1</code> must have at most one match in <code>df2</code>. Otherwise, this function would not be able to execute the join in-place since new rows would need to be added to <code>df1</code>.</p><p><strong>Arguments</strong></p><ul><li><code>df1</code>, <code>df2</code>: the <code>AbstractDataFrames</code> to be joined</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>on</code> : The names of the key columns on which to join the data frames. This can be a single name, or a vector of names (for joining on multiple columns). A <code>left=&gt;right</code> pair of names can be used instead of a name, for the case where a key has different names in <code>df1</code> and <code>df2</code> (it is allowed to mix names and name pairs in a vector). Key values are compared using <code>isequal</code>. <code>on</code> is a required argument.</li><li><code>makeunique</code> : if <code>false</code> (the default), an error will be raised if duplicate names are found in columns not joined on; if <code>true</code>, duplicate names will be suffixed with <code>_i</code> (<code>i</code> starting at 1 for the first duplicate).</li><li><code>source</code> : Default: <code>nothing</code>. If a <code>Symbol</code> or string, adds indicator column with the given name, for whether a row appeared in only <code>df1</code> (<code>&quot;left_only&quot;</code>) or in both (<code>&quot;both&quot;</code>). If the name is already in use, the column name will be modified if <code>makeunique=true</code>.</li><li><code>matchmissing</code> : if equal to <code>:error</code> throw an error if <code>missing</code> is present in <code>on</code> columns; if equal to <code>:equal</code> then <code>missing</code> is allowed and missings are matched; if equal to <code>:notequal</code> then missings are dropped in <code>df2</code> <code>on</code> columns.</li></ul><p>The columns added to <code>df1</code> from <code>df2</code> will support missing values.</p><p>It is not allowed to join on columns that contain <code>NaN</code> or <code>-0.0</code> in real or imaginary part of the number. If you need to perform a join on such values use CategoricalArrays.jl and transform a column containing such values into a <code>CategoricalVector</code>.</p><p>Metadata: table-level and column-level <code>:note</code>-style metadata are taken from <code>df1</code> (including key columns), except for columns added to it from <code>df2</code>, whose column-level <code>:note</code>-style metadata is taken from <code>df2</code>.</p><p>See also: <a href="#DataAPI.leftjoin"><code>leftjoin</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; name = DataFrame(ID=[1, 2, 3], Name=[&quot;John Doe&quot;, &quot;Jane Doe&quot;, &quot;Joe Blogs&quot;])
3×2 DataFrame
 Row │ ID     Name
     │ Int64  String
─────┼──────────────────
   1 │     1  John Doe
   2 │     2  Jane Doe
   3 │     3  Joe Blogs

julia&gt; job = DataFrame(ID=[1, 2, 4], Job=[&quot;Lawyer&quot;, &quot;Doctor&quot;, &quot;Farmer&quot;])
3×2 DataFrame
 Row │ ID     Job
     │ Int64  String
─────┼───────────────
   1 │     1  Lawyer
   2 │     2  Doctor
   3 │     4  Farmer

julia&gt; leftjoin!(name, job, on = :ID)
3×3 DataFrame
 Row │ ID     Name       Job
     │ Int64  String     String?
─────┼───────────────────────────
   1 │     1  John Doe   Lawyer
   2 │     2  Jane Doe   Doctor
   3 │     3  Joe Blogs  missing

julia&gt; job2 = DataFrame(identifier=[1, 2, 4], Job=[&quot;Lawyer&quot;, &quot;Doctor&quot;, &quot;Farmer&quot;])
3×2 DataFrame
 Row │ identifier  Job
     │ Int64       String
─────┼────────────────────
   1 │          1  Lawyer
   2 │          2  Doctor
   3 │          4  Farmer

julia&gt; leftjoin!(name, job2, on = :ID =&gt; :identifier, makeunique=true, source=:source)
3×5 DataFrame
 Row │ ID     Name       Job      Job_1    source
     │ Int64  String     String?  String?  String
─────┼───────────────────────────────────────────────
   1 │     1  John Doe   Lawyer   Lawyer   both
   2 │     2  Jane Doe   Doctor   Doctor   both
   3 │     3  Joe Blogs  missing  missing  left_only</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/a1f75b1dd155265e5767e1e3f64d70be824859d7/src/join/inplace.jl#L1-L96">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataAPI.outerjoin" href="#DataAPI.outerjoin"><code>DataAPI.outerjoin</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">outerjoin(df1, df2; on, makeunique=false, source=nothing, validate=(false, false),
          renamecols=(identity =&gt; identity), matchmissing=:error, order=:undefined)
outerjoin(df1, df2, dfs...; on, makeunique = false,
          validate = (false, false), matchmissing=:error, order=:undefined)</code></pre><p>Perform an outer join of two or more data frame objects and return a <code>DataFrame</code> containing the result. An outer join includes rows with keys that appear in any of the passed data frames.</p><p>The order of rows in the result is undefined and may change in future releases.</p><p>In the returned data frame the type of the columns on which the data frames are joined is determined by the element type of these columns both <code>df1</code> and <code>df2</code>. This behavior may change in future releases.</p><p><strong>Arguments</strong></p><ul><li><code>df1</code>, <code>df2</code>, <code>dfs...</code> : the <code>AbstractDataFrames</code> to be joined</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>on</code> : The names of the key columns on which to join the data frames. This can be a single name, or a vector of names (for joining on multiple columns). When joining only two data frames, a <code>left=&gt;right</code> pair of names can be used instead of a name, for the case where a key has different names in <code>df1</code> and <code>df2</code> (it is allowed to mix names and name pairs in a vector). Key values are compared using <code>isequal</code>. <code>on</code> is a required argument.</li><li><code>makeunique</code> : if <code>false</code> (the default), an error will be raised if duplicate names are found in columns not joined on; if <code>true</code>, duplicate names will be suffixed with <code>_i</code> (<code>i</code> starting at 1 for the first duplicate).</li><li><code>source</code> : Default: <code>nothing</code>. If a <code>Symbol</code> or string, adds indicator column with the given name for whether a row appeared in only <code>df1</code> (<code>&quot;left_only&quot;</code>), only <code>df2</code> (<code>&quot;right_only&quot;</code>) or in both (<code>&quot;both&quot;</code>). If the name is already in use, the column name will be modified if <code>makeunique=true</code>. This argument is only supported when joining exactly two data frames.</li><li><code>validate</code> : whether to check that columns passed as the <code>on</code> argument define unique keys in each input data frame (according to <code>isequal</code>). Can be a tuple or a pair, with the first element indicating whether to run check for <code>df1</code> and the second element for <code>df2</code>. By default no check is performed.</li><li><code>renamecols</code> : a <code>Pair</code> specifying how columns of left and right data frames should be renamed in the resulting data frame. Each element of the pair can be a string or a <code>Symbol</code> can be passed in which case it is appended to the original column name; alternatively a function can be passed in which case it is applied to each column name, which is passed to it as a <code>String</code>. Note that <code>renamecols</code> does not affect <code>on</code> columns, whose names are always taken from the left data frame and left unchanged.</li><li><code>matchmissing</code> : if equal to <code>:error</code> throw an error if <code>missing</code> is present in <code>on</code> columns; if equal to <code>:equal</code> then <code>missing</code> is allowed and missings are matched.</li><li><code>order</code> : if <code>:undefined</code> (the default) the order of rows in the result is  undefined and may change in future releases. If <code>:left</code> then the order of  rows from the left data frame is retained (non-matching rows are put at the end).  If <code>:right</code> then the order of rows from the right data frame is retained  (non-matching rows are put at the end).</li></ul><p>All columns of the returned data frame will support missing values.</p><p>It is not allowed to join on columns that contain <code>NaN</code> or <code>-0.0</code> in real or imaginary part of the number. If you need to perform a join on such values use CategoricalArrays.jl and transform a column containing such values into a <code>CategoricalVector</code>.</p><p>When merging <code>on</code> categorical columns that differ in the ordering of their levels, the ordering of the left data frame takes precedence over the ordering of the right data frame.</p><p>If more than two data frames are passed, the join is performed recursively with left associativity. In this case the <code>indicator</code> keyword argument is not supported and <code>validate</code> keyword argument is applied recursively with left associativity.</p><p>Metadata: table-level <code>:note</code>-style metadata and column-level <code>:note</code>-style metadata for key columns is preserved only for keys which are defined in all passed tables and have the same value. Column-level <code>:note</code>-style metadata is preserved for all other columns.</p><p>See also: <a href="#DataAPI.innerjoin"><code>innerjoin</code></a>, <a href="#DataAPI.leftjoin"><code>leftjoin</code></a>, <a href="#DataAPI.rightjoin"><code>rightjoin</code></a>,           <a href="#DataAPI.semijoin"><code>semijoin</code></a>, <a href="#DataAPI.antijoin"><code>antijoin</code></a>, <a href="#DataAPI.crossjoin"><code>crossjoin</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; name = DataFrame(ID=[1, 2, 3], Name=[&quot;John Doe&quot;, &quot;Jane Doe&quot;, &quot;Joe Blogs&quot;])
3×2 DataFrame
 Row │ ID     Name
     │ Int64  String
─────┼──────────────────
   1 │     1  John Doe
   2 │     2  Jane Doe
   3 │     3  Joe Blogs

julia&gt; job = DataFrame(ID=[1, 2, 4], Job=[&quot;Lawyer&quot;, &quot;Doctor&quot;, &quot;Farmer&quot;])
3×2 DataFrame
 Row │ ID     Job
     │ Int64  String
─────┼───────────────
   1 │     1  Lawyer
   2 │     2  Doctor
   3 │     4  Farmer

julia&gt; outerjoin(name, job, on = :ID)
4×3 DataFrame
 Row │ ID     Name       Job
     │ Int64  String?    String?
─────┼───────────────────────────
   1 │     1  John Doe   Lawyer
   2 │     2  Jane Doe   Doctor
   3 │     3  Joe Blogs  missing
   4 │     4  missing    Farmer

julia&gt; job2 = DataFrame(identifier=[1, 2, 4], Job=[&quot;Lawyer&quot;, &quot;Doctor&quot;, &quot;Farmer&quot;])
3×2 DataFrame
 Row │ identifier  Job
     │ Int64       String
─────┼────────────────────
   1 │          1  Lawyer
   2 │          2  Doctor
   3 │          4  Farmer

julia&gt; outerjoin(name, job2, on = :ID =&gt; :identifier, renamecols = &quot;_left&quot; =&gt; &quot;_right&quot;)
4×3 DataFrame
 Row │ ID     Name_left  Job_right
     │ Int64  String?    String?
─────┼─────────────────────────────
   1 │     1  John Doe   Lawyer
   2 │     2  Jane Doe   Doctor
   3 │     3  Joe Blogs  missing
   4 │     4  missing    Farmer

julia&gt; outerjoin(name, job2, on = [:ID =&gt; :identifier], renamecols = uppercase =&gt; lowercase)
4×3 DataFrame
 Row │ ID     NAME       job
     │ Int64  String?    String?
─────┼───────────────────────────
   1 │     1  John Doe   Lawyer
   2 │     2  Jane Doe   Doctor
   3 │     3  Joe Blogs  missing
   4 │     4  missing    Farmer</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/a1f75b1dd155265e5767e1e3f64d70be824859d7/src/join/composer.jl#L1095-L1234">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataAPI.rightjoin" href="#DataAPI.rightjoin"><code>DataAPI.rightjoin</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">rightjoin(df1, df2; on, makeunique=false, source=nothing,
          validate=(false, false), renamecols=(identity =&gt; identity),
          matchmissing=:error, order=:undefined)</code></pre><p>Perform a right join on two data frame objects and return a <code>DataFrame</code> containing the result. A right join includes all rows from <code>df2</code>.</p><p>The order of rows in the result is undefined and may change in future releases.</p><p>In the returned data frame the type of the columns on which the data frames are joined is determined by the type of these columns in <code>df2</code>. This behavior may change in future releases.</p><p><strong>Arguments</strong></p><ul><li><code>df1</code>, <code>df2</code>: the <code>AbstractDataFrames</code> to be joined</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>on</code> : The names of the key columns on which to join the data frames. This can be a single name, or a vector of names (for joining on multiple columns). A <code>left=&gt;right</code> pair of names can be used instead of a name, for the case where a key has different names in <code>df1</code> and <code>df2</code> (it is allowed to mix names and name pairs in a vector). Key values are compared using <code>isequal</code>. <code>on</code> is a required argument.</li><li><code>makeunique</code> : if <code>false</code> (the default), an error will be raised if duplicate names are found in columns not joined on; if <code>true</code>, duplicate names will be suffixed with <code>_i</code> (<code>i</code> starting at 1 for the first duplicate).</li><li><code>source</code> : Default: <code>nothing</code>. If a <code>Symbol</code> or string, adds indicator column with the given name for whether a row appeared in only <code>df2</code> (<code>&quot;right_only&quot;</code>) or in both (<code>&quot;both&quot;</code>). If the name is already in use, the column name will be modified if <code>makeunique=true</code>.</li><li><code>validate</code> : whether to check that columns passed as the <code>on</code> argument define unique keys in each input data frame (according to <code>isequal</code>). Can be a tuple or a pair, with the first element indicating whether to run check for <code>df1</code> and the second element for <code>df2</code>. By default no check is performed.</li><li><code>renamecols</code> : a <code>Pair</code> specifying how columns of left and right data frames should be renamed in the resulting data frame. Each element of the pair can be a string or a <code>Symbol</code> can be passed in which case it is appended to the original column name; alternatively a function can be passed in which case it is applied to each column name, which is passed to it as a <code>String</code>. Note that <code>renamecols</code> does not affect <code>on</code> columns, whose names are always taken from the left data frame and left unchanged.</li><li><code>matchmissing</code> : if equal to <code>:error</code> throw an error if <code>missing</code> is present in <code>on</code> columns; if equal to <code>:equal</code> then <code>missing</code> is allowed and missings are matched; if equal to <code>:notequal</code> then missings are dropped in <code>df1</code> <code>on</code> columns.</li><li><code>order</code> : if <code>:undefined</code> (the default) the order of rows in the result is  undefined and may change in future releases. If <code>:left</code> then the order of  rows from the left data frame is retained (non-matching rows are put at the end).  If <code>:right</code> then the order of rows from the right data frame is retained.</li></ul><p>All columns of the returned data frame will support missing values.</p><p>It is not allowed to join on columns that contain <code>NaN</code> or <code>-0.0</code> in real or imaginary part of the number. If you need to perform a join on such values use CategoricalArrays.jl and transform a column containing such values into a <code>CategoricalVector</code>.</p><p>When merging <code>on</code> categorical columns that differ in the ordering of their levels, the ordering of the left data frame takes precedence over the ordering of the right data frame.</p><p>Metadata: table-level and column-level <code>:note</code>-style metadata is taken from <code>df2</code> (including key columns), except for columns added to it from <code>df1</code>, whose column-level <code>:note</code>-style metadata is taken from <code>df1</code>.</p><p>See also: <a href="#DataAPI.innerjoin"><code>innerjoin</code></a>, <a href="#DataAPI.leftjoin"><code>leftjoin</code></a>, <a href="#DataAPI.outerjoin"><code>outerjoin</code></a>,           <a href="#DataAPI.semijoin"><code>semijoin</code></a>, <a href="#DataAPI.antijoin"><code>antijoin</code></a>, <a href="#DataAPI.crossjoin"><code>crossjoin</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; name = DataFrame(ID=[1, 2, 3], Name=[&quot;John Doe&quot;, &quot;Jane Doe&quot;, &quot;Joe Blogs&quot;])
3×2 DataFrame
 Row │ ID     Name
     │ Int64  String
─────┼──────────────────
   1 │     1  John Doe
   2 │     2  Jane Doe
   3 │     3  Joe Blogs

julia&gt; job = DataFrame(ID=[1, 2, 4], Job=[&quot;Lawyer&quot;, &quot;Doctor&quot;, &quot;Farmer&quot;])
3×2 DataFrame
 Row │ ID     Job
     │ Int64  String
─────┼───────────────
   1 │     1  Lawyer
   2 │     2  Doctor
   3 │     4  Farmer

julia&gt; rightjoin(name, job, on = :ID)
3×3 DataFrame
 Row │ ID     Name      Job
     │ Int64  String?   String
─────┼─────────────────────────
   1 │     1  John Doe  Lawyer
   2 │     2  Jane Doe  Doctor
   3 │     4  missing   Farmer

julia&gt; job2 = DataFrame(identifier=[1, 2, 4], Job=[&quot;Lawyer&quot;, &quot;Doctor&quot;, &quot;Farmer&quot;])
3×2 DataFrame
 Row │ identifier  Job
     │ Int64       String
─────┼────────────────────
   1 │          1  Lawyer
   2 │          2  Doctor
   3 │          4  Farmer

julia&gt; rightjoin(name, job2, on = :ID =&gt; :identifier, renamecols = &quot;_left&quot; =&gt; &quot;_right&quot;)
3×3 DataFrame
 Row │ ID     Name_left  Job_right
     │ Int64  String?    String
─────┼─────────────────────────────
   1 │     1  John Doe   Lawyer
   2 │     2  Jane Doe   Doctor
   3 │     4  missing    Farmer

julia&gt; rightjoin(name, job2, on = [:ID =&gt; :identifier], renamecols = uppercase =&gt; lowercase)
3×3 DataFrame
 Row │ ID     NAME      job
     │ Int64  String?   String
─────┼─────────────────────────
   1 │     1  John Doe  Lawyer
   2 │     2  Jane Doe  Doctor
   3 │     4  missing   Farmer</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/a1f75b1dd155265e5767e1e3f64d70be824859d7/src/join/composer.jl#L939-L1065">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataAPI.semijoin" href="#DataAPI.semijoin"><code>DataAPI.semijoin</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">semijoin(df1, df2; on, makeunique=false, validate=(false, false), matchmissing=:error)</code></pre><p>Perform a semi join of two data frame objects and return a <code>DataFrame</code> containing the result. A semi join returns the subset of rows of <code>df1</code> that match with the keys in <code>df2</code>.</p><p>The order of rows in the result is kept from <code>df1</code>.</p><p><strong>Arguments</strong></p><ul><li><code>df1</code>, <code>df2</code>: the <code>AbstractDataFrames</code> to be joined</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>on</code> : The names of the key columns on which to join the data frames. This can be a single name, or a vector of names (for joining on multiple columns). A <code>left=&gt;right</code> pair of names can be used instead of a name, for the case where a key has different names in <code>df1</code> and <code>df2</code> (it is allowed to mix names and name pairs in a vector). Key values are compared using <code>isequal</code>. <code>on</code> is a required argument.</li><li><code>makeunique</code> : ignored as no columns are added to <code>df1</code> columns (it is provided for consistency with other functions).</li><li><code>indicator</code> : Default: <code>nothing</code>. If a <code>Symbol</code> or string, adds categorical indicator  column with the given name for whether a row appeared in only <code>df1</code> (<code>&quot;left_only&quot;</code>),  only <code>df2</code> (<code>&quot;right_only&quot;</code>) or in both (<code>&quot;both&quot;</code>). If the name is already in use,  the column name will be modified if <code>makeunique=true</code>.</li><li><code>validate</code> : whether to check that columns passed as the <code>on</code> argument  define unique keys in each input data frame (according to <code>isequal</code>).  Can be a tuple or a pair, with the first element indicating whether to  run check for <code>df1</code> and the second element for <code>df2</code>.  By default no check is performed.</li><li><code>matchmissing</code> : if equal to <code>:error</code> throw an error if <code>missing</code> is present in <code>on</code> columns; if equal to <code>:equal</code> then <code>missing</code> is allowed and missings are matched; if equal to <code>:notequal</code> then missings are dropped in <code>df2</code> <code>on</code> columns.</li></ul><p>It is not allowed to join on columns that contain <code>NaN</code> or <code>-0.0</code> in real or imaginary part of the number. If you need to perform a join on such values use CategoricalArrays.jl and transform a column containing such values into a <code>CategoricalVector</code>.</p><p>When merging <code>on</code> categorical columns that differ in the ordering of their levels, the ordering of the left data frame takes precedence over the ordering of the right data frame.</p><p>Metadata: table-level and column-level <code>:note</code>-style metadata are taken from <code>df1</code>.</p><p>See also: <a href="#DataAPI.innerjoin"><code>innerjoin</code></a>, <a href="#DataAPI.leftjoin"><code>leftjoin</code></a>, <a href="#DataAPI.rightjoin"><code>rightjoin</code></a>,           <a href="#DataAPI.outerjoin"><code>outerjoin</code></a>, <a href="#DataAPI.antijoin"><code>antijoin</code></a>, <a href="#DataAPI.crossjoin"><code>crossjoin</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; name = DataFrame(ID=[1, 2, 3], Name=[&quot;John Doe&quot;, &quot;Jane Doe&quot;, &quot;Joe Blogs&quot;])
3×2 DataFrame
 Row │ ID     Name
     │ Int64  String
─────┼──────────────────
   1 │     1  John Doe
   2 │     2  Jane Doe
   3 │     3  Joe Blogs

julia&gt; job = DataFrame(ID=[1, 2, 4], Job=[&quot;Lawyer&quot;, &quot;Doctor&quot;, &quot;Farmer&quot;])
3×2 DataFrame
 Row │ ID     Job
     │ Int64  String
─────┼───────────────
   1 │     1  Lawyer
   2 │     2  Doctor
   3 │     4  Farmer

julia&gt; semijoin(name, job, on = :ID)
2×2 DataFrame
 Row │ ID     Name
     │ Int64  String
─────┼─────────────────
   1 │     1  John Doe
   2 │     2  Jane Doe

julia&gt; job2 = DataFrame(identifier=[1, 2, 4], Job=[&quot;Lawyer&quot;, &quot;Doctor&quot;, &quot;Farmer&quot;])
3×2 DataFrame
 Row │ identifier  Job
     │ Int64       String
─────┼────────────────────
   1 │          1  Lawyer
   2 │          2  Doctor
   3 │          4  Farmer

julia&gt; semijoin(name, job2, on = :ID =&gt; :identifier)
2×2 DataFrame
 Row │ ID     Name
     │ Int64  String
─────┼─────────────────
   1 │     1  John Doe
   2 │     2  Jane Doe

julia&gt; semijoin(name, job2, on = [:ID =&gt; :identifier])
2×2 DataFrame
 Row │ ID     Name
     │ Int64  String
─────┼─────────────────
   1 │     1  John Doe
   2 │     2  Jane Doe</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/a1f75b1dd155265e5767e1e3f64d70be824859d7/src/join/composer.jl#L1277-L1378">source</a></section></article><h2 id="Grouping"><a class="docs-heading-anchor" href="#Grouping">Grouping</a><a id="Grouping-1"></a><a class="docs-heading-anchor-permalink" href="#Grouping" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Base.get" href="#Base.get"><code>Base.get</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get(gd::GroupedDataFrame, key, default)</code></pre><p>Get a group based on the values of the grouping columns.</p><p><code>key</code> may be a <code>GroupKey</code>, <code>NamedTuple</code> or <code>Tuple</code> of grouping column values (in the same order as the <code>cols</code> argument to <code>groupby</code>). It may also be an <code>AbstractDict</code>, in which case the order of the arguments does not matter.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; df = DataFrame(a=repeat([:foo, :bar, :baz], outer=[2]),
                      b=repeat([2, 1], outer=[3]),
                      c=1:6);

julia&gt; gd = groupby(df, :a)
GroupedDataFrame with 3 groups based on key: a
First Group (2 rows): a = :foo
 Row │ a       b      c
     │ Symbol  Int64  Int64
─────┼──────────────────────
   1 │ foo         2      1
   2 │ foo         1      4
⋮
Last Group (2 rows): a = :baz
 Row │ a       b      c
     │ Symbol  Int64  Int64
─────┼──────────────────────
   1 │ baz         2      3
   2 │ baz         1      6

julia&gt; get(gd, (a=:bar,), nothing)
2×3 SubDataFrame
 Row │ a       b      c
     │ Symbol  Int64  Int64
─────┼──────────────────────
   1 │ bar         1      2
   2 │ bar         2      5

julia&gt; get(gd, (:baz,), nothing)
2×3 SubDataFrame
 Row │ a       b      c
     │ Symbol  Int64  Int64
─────┼──────────────────────
   1 │ baz         2      3
   2 │ baz         1      6

julia&gt; get(gd, (:qux,), nothing)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/a1f75b1dd155265e5767e1e3f64d70be824859d7/src/groupeddataframe/groupeddataframe.jl#L1055-L1105">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFrames.groupby" href="#DataFrames.groupby"><code>DataFrames.groupby</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">groupby(d::AbstractDataFrame, cols;
        sort::Union{Bool, Nothing, NamedTuple}=nothing,
        skipmissing::Bool=false)</code></pre><p>Return a <code>GroupedDataFrame</code> representing a view of an <code>AbstractDataFrame</code> split into row groups.</p><p><strong>Arguments</strong></p><ul><li><code>df</code> : an <code>AbstractDataFrame</code> to split</li><li><code>cols</code> : data frame columns to group by. Can be any column selector (<code>Symbol</code>, string or integer; <code>:</code>, <code>Cols</code>, <code>All</code>, <code>Between</code>, <code>Not</code>, a regular expression, or a vector of <code>Symbol</code>s, strings or integers). In particular if the selector picks no columns then a single-group <code>GroupedDataFrame</code> is created. As a special case, if <code>cols</code> is a single column or a vector of columns then it can contain columns wrapped in <a href="#DataFrames.order"><code>order</code></a> that will be used to determine the order of groups if <code>sort</code> is <code>true</code> or a <code>NamedTuple</code> (if <code>sort</code> is <code>false</code>, then passing <code>order</code> is an error; if <code>sort</code> is <code>nothing</code> then it is set to <code>true</code> when <code>order</code> is passed).</li><li><code>sort</code> : if <code>sort=true</code> sort groups according to the values of the grouping columns <code>cols</code>; if <code>sort=false</code> groups are created in their order of appearance in <code>df</code>; if <code>sort=nothing</code> (the default) then the fastest available grouping algorithm is picked and in consequence the order of groups in the result is undefined and may change in future releases; below a description of the current implementation is provided. Additionally <code>sort</code> can be a <code>NamedTuple</code> having some or all of <code>alg</code>, <code>lt</code>, <code>by</code>, <code>rev</code>, and <code>order</code> fields. In this case the groups are sorted and their order follows the <a href="#Base.sortperm"><code>sortperm</code></a> order.</li><li><code>skipmissing</code> : whether to skip groups with <code>missing</code> values in one of the grouping columns <code>cols</code></li></ul><p><strong>Details</strong></p><p>An iterator over a <code>GroupedDataFrame</code> returns a <code>SubDataFrame</code> view for each grouping into <code>df</code>. Within each group, the order of rows in <code>df</code> is preserved.</p><p>A <code>GroupedDataFrame</code> also supports indexing by groups, <code>select</code>, <code>transform</code>, and <code>combine</code> (which applies a function to each group and combines the result into a data frame).</p><p><code>GroupedDataFrame</code> also supports the dictionary interface. The keys are <a href="../types/#DataFrames.GroupKey"><code>GroupKey</code></a> objects returned by <a href="#Base.keys"><code>keys(::GroupedDataFrame)</code></a>, which can also be used to get the values of the grouping columns for each group. <code>Tuples</code> and <code>NamedTuple</code>s containing the values of the grouping columns (in the same order as the <code>cols</code> argument) are also accepted as indices. Finally, an <code>AbstractDict</code> can be used to index into a grouped data frame where the keys are column names of the data frame. The order of the keys does not matter in this case.</p><p>In the current implementation if <code>sort=nothing</code> groups are ordered following the order of appearance of values in the grouping columns, except when all grouping columns provide non-<code>nothing</code> <code>DataAPI.refpool</code>, in which case the order of groups follows the order of values returned by <code>DataAPI.refpool</code>. As a particular application of this rule if all <code>cols</code> are <code>CategoricalVector</code>s then groups are always sorted. Integer columns with a narrow range also use this this optimization, so to the order of groups when grouping on integer columns is undefined. A column is considered to be an integer column when deciding on the grouping algorithm choice if its <code>eltype</code> is a subtype of <code>Union{Missing, Real}</code>, all its elements are either <code>missing</code> or pass <code>isinteger</code> test, and none of them is equal to <code>-0.0</code>.</p><p><strong>See also</strong></p><p><a href="#DataFrames.combine"><code>combine</code></a>, <a href="#DataFrames.select"><code>select</code></a>, <a href="#DataFrames.select!"><code>select!</code></a>, <a href="#DataFrames.transform"><code>transform</code></a>, <a href="#DataFrames.transform!"><code>transform!</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; df = DataFrame(a=repeat([1, 2, 3, 4], outer=[2]),
                      b=repeat([2, 1], outer=[4]),
                      c=1:8);

julia&gt; gd = groupby(df, :a)
GroupedDataFrame with 4 groups based on key: a
First Group (2 rows): a = 1
 Row │ a      b      c
     │ Int64  Int64  Int64
─────┼─────────────────────
   1 │     1      2      1
   2 │     1      2      5
⋮
Last Group (2 rows): a = 4
 Row │ a      b      c
     │ Int64  Int64  Int64
─────┼─────────────────────
   1 │     4      1      4
   2 │     4      1      8

julia&gt; gd[1]
2×3 SubDataFrame
 Row │ a      b      c
     │ Int64  Int64  Int64
─────┼─────────────────────
   1 │     1      2      1
   2 │     1      2      5

julia&gt; last(gd)
2×3 SubDataFrame
 Row │ a      b      c
     │ Int64  Int64  Int64
─────┼─────────────────────
   1 │     4      1      4
   2 │     4      1      8

julia&gt; gd[(a=3,)]
2×3 SubDataFrame
 Row │ a      b      c
     │ Int64  Int64  Int64
─────┼─────────────────────
   1 │     3      2      3
   2 │     3      2      7

julia&gt; gd[Dict(&quot;a&quot; =&gt; 3)]
2×3 SubDataFrame
 Row │ a      b      c
     │ Int64  Int64  Int64
─────┼─────────────────────
   1 │     3      2      3
   2 │     3      2      7

julia&gt; gd[(3,)]
2×3 SubDataFrame
 Row │ a      b      c
     │ Int64  Int64  Int64
─────┼─────────────────────
   1 │     3      2      3
   2 │     3      2      7

julia&gt; k = first(keys(gd))
GroupKey: (a = 1,)

julia&gt; gd[k]
2×3 SubDataFrame
 Row │ a      b      c
     │ Int64  Int64  Int64
─────┼─────────────────────
   1 │     1      2      1
   2 │     1      2      5

julia&gt; for g in gd
           println(g)
       end
2×3 SubDataFrame
 Row │ a      b      c
     │ Int64  Int64  Int64
─────┼─────────────────────
   1 │     1      2      1
   2 │     1      2      5
2×3 SubDataFrame
 Row │ a      b      c
     │ Int64  Int64  Int64
─────┼─────────────────────
   1 │     2      1      2
   2 │     2      1      6
2×3 SubDataFrame
 Row │ a      b      c
     │ Int64  Int64  Int64
─────┼─────────────────────
   1 │     3      2      3
   2 │     3      2      7
2×3 SubDataFrame
 Row │ a      b      c
     │ Int64  Int64  Int64
─────┼─────────────────────
   1 │     4      1      4
   2 │     4      1      8</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/a1f75b1dd155265e5767e1e3f64d70be824859d7/src/groupeddataframe/groupeddataframe.jl#L50-L217">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFrames.groupcols" href="#DataFrames.groupcols"><code>DataFrames.groupcols</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">groupcols(gd::GroupedDataFrame)</code></pre><p>Return a vector of <code>Symbol</code> column names in <code>parent(gd)</code> used for grouping.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/a1f75b1dd155265e5767e1e3f64d70be824859d7/src/groupeddataframe/groupeddataframe.jl#L493-L497">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFrames.groupindices" href="#DataFrames.groupindices"><code>DataFrames.groupindices</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">groupindices(gd::GroupedDataFrame)</code></pre><p>Return a vector of group indices for each row of <code>parent(gd)</code>.</p><p>Rows appearing in group <code>gd[i]</code> are attributed index <code>i</code>. Rows not present in any group are attributed <code>missing</code> (this can happen if <code>skipmissing=true</code> was passed when creating <code>gd</code>, or if <code>gd</code> is a subset from a larger <a href="../types/#DataFrames.GroupedDataFrame"><code>GroupedDataFrame</code></a>).</p><p>The <code>groupindices =&gt; target_col_name</code> syntax (or just <code>groupindices</code> without specifying the target column name) is also supported in the transformation mini-language when passing a <code>GroupedDataFrame</code> to transformation functions (<a href="#DataFrames.combine"><code>combine</code></a>, <a href="#DataFrames.select"><code>select</code></a>, etc.).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; df = DataFrame(id=[&quot;a&quot;, &quot;c&quot;, &quot;b&quot;, &quot;b&quot;, &quot;a&quot;])
5×1 DataFrame
 Row │ id
     │ String
─────┼────────
   1 │ a
   2 │ c
   3 │ b
   4 │ b
   5 │ a

julia&gt; gdf = groupby(df, :id);

julia&gt; combine(gdf, groupindices)
3×2 DataFrame
 Row │ id      groupindices
     │ String  Int64
─────┼──────────────────────
   1 │ a                  1
   2 │ c                  2
   3 │ b                  3

julia&gt; select(gdf, groupindices =&gt; :gid)
5×2 DataFrame
 Row │ id      gid
     │ String  Int64
─────┼───────────────
   1 │ a           1
   2 │ c           2
   3 │ b           3
   4 │ b           3
   5 │ a           1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/a1f75b1dd155265e5767e1e3f64d70be824859d7/src/groupeddataframe/groupeddataframe.jl#L379-L430">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.keys" href="#Base.keys"><code>Base.keys</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">keys(gd::GroupedDataFrame)</code></pre><p>Get the set of keys for each group of the <code>GroupedDataFrame</code> <code>gd</code> as a <a href="../types/#DataFrames.GroupKeys"><code>GroupKeys</code></a> object. Each key is a <a href="../types/#DataFrames.GroupKey"><code>GroupKey</code></a>, which behaves like a <code>NamedTuple</code> holding the values of the grouping columns for a given group. Unlike the equivalent <code>Tuple</code>, <code>NamedTuple</code>, and <code>AbstractDict</code>, these keys can be used to index into <code>gd</code> efficiently. The ordering of the keys is identical to the ordering of the groups of <code>gd</code> under iteration and integer indexing.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; df = DataFrame(a=repeat([:foo, :bar, :baz], outer=[4]),
                      b=repeat([2, 1], outer=[6]),
                      c=1:12);

julia&gt; gd = groupby(df, [:a, :b])
GroupedDataFrame with 6 groups based on keys: a, b
First Group (2 rows): a = :foo, b = 2
 Row │ a       b      c
     │ Symbol  Int64  Int64
─────┼──────────────────────
   1 │ foo         2      1
   2 │ foo         2      7
⋮
Last Group (2 rows): a = :baz, b = 1
 Row │ a       b      c
     │ Symbol  Int64  Int64
─────┼──────────────────────
   1 │ baz         1      6
   2 │ baz         1     12

julia&gt; keys(gd)
6-element DataFrames.GroupKeys{GroupedDataFrame{DataFrame}}:
 GroupKey: (a = :foo, b = 2)
 GroupKey: (a = :bar, b = 1)
 GroupKey: (a = :baz, b = 2)
 GroupKey: (a = :foo, b = 1)
 GroupKey: (a = :bar, b = 2)
 GroupKey: (a = :baz, b = 1)

julia&gt; k = keys(gd)[1]
GroupKey: (a = :foo, b = 2)

julia&gt; keys(k)
2-element Vector{Symbol}:
 :a
 :b

julia&gt; values(k)  # Same as Tuple(k)
(:foo, 2)

julia&gt; NamedTuple(k)
(a = :foo, b = 2)

julia&gt; k.a
:foo

julia&gt; k[:a]
:foo

julia&gt; k[1]
:foo</code></pre><p>Keys can be used as indices to retrieve the corresponding group from their <code>GroupedDataFrame</code>:</p><pre><code class="language-julia-repl hljs">julia&gt; gd[k]
2×3 SubDataFrame
 Row │ a       b      c
     │ Symbol  Int64  Int64
─────┼──────────────────────
   1 │ foo         2      1
   2 │ foo         2      7

julia&gt; gd[keys(gd)[1]] == gd[1]
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/a1f75b1dd155265e5767e1e3f64d70be824859d7/src/groupeddataframe/groupeddataframe.jl#L929-L1010">source</a></section><section><div><pre><code class="nohighlight hljs">keys(dfc::DataFrameColumns)</code></pre><p>Get a vector of column names of <code>dfc</code> as <code>Symbol</code>s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/a1f75b1dd155265e5767e1e3f64d70be824859d7/src/abstractdataframe/iteration.jl#L287-L291">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.parent" href="#Base.parent"><code>Base.parent</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">parent(gd::GroupedDataFrame)</code></pre><p>Return the parent data frame of <code>gd</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/a1f75b1dd155265e5767e1e3f64d70be824859d7/src/groupeddataframe/groupeddataframe.jl#L329-L333">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFrames.proprow" href="#DataFrames.proprow"><code>DataFrames.proprow</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">proprow</code></pre><p>Compute the proportion of rows which belong to each group, i.e. its number of rows divided by the total number of rows in a <code>GroupedDataFrame</code>.</p><p>This function can only be used in the transformation mini-language via the <code>proprow =&gt; target_col_name</code> syntax (or just <code>proprow</code> without specifying the target column name), when passing a <code>GroupedDataFrame</code> to transformation functions (<a href="#DataFrames.combine"><code>combine</code></a>, <a href="#DataFrames.select"><code>select</code></a>, etc.).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; df = DataFrame(id=[&quot;a&quot;, &quot;c&quot;, &quot;b&quot;, &quot;b&quot;, &quot;a&quot;, &quot;b&quot;])
6×1 DataFrame
 Row │ id
     │ String
─────┼────────
   1 │ a
   2 │ c
   3 │ b
   4 │ b
   5 │ a
   6 │ b

julia&gt; gdf = groupby(df, :id);

julia&gt; combine(gdf, proprow)
3×2 DataFrame
 Row │ id      proprow
     │ String  Float64
─────┼──────────────────
   1 │ a       0.333333
   2 │ c       0.166667
   3 │ b       0.5

julia&gt; select(gdf, proprow =&gt; :frac)
6×2 DataFrame
 Row │ id      frac
     │ String  Float64
─────┼──────────────────
   1 │ a       0.333333
   2 │ c       0.166667
   3 │ b       0.5
   4 │ b       0.5
   5 │ a       0.333333
   6 │ b       0.5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/a1f75b1dd155265e5767e1e3f64d70be824859d7/src/groupeddataframe/groupeddataframe.jl#L438-L487">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFrames.valuecols" href="#DataFrames.valuecols"><code>DataFrames.valuecols</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">valuecols(gd::GroupedDataFrame)</code></pre><p>Return a vector of <code>Symbol</code> column names in <code>parent(gd)</code> not used for grouping.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/a1f75b1dd155265e5767e1e3f64d70be824859d7/src/groupeddataframe/groupeddataframe.jl#L504-L508">source</a></section></article><h2 id="Filtering-rows"><a class="docs-heading-anchor" href="#Filtering-rows">Filtering rows</a><a id="Filtering-rows-1"></a><a class="docs-heading-anchor-permalink" href="#Filtering-rows" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Base.allunique" href="#Base.allunique"><code>Base.allunique</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">allunique(df::AbstractDataFrame, cols=:)</code></pre><p>Return <code>true</code> if none of the rows of <code>df</code> are duplicated. Two rows are duplicates if all their columns contain equal values (according to <code>isequal</code>) for all columns in <code>cols</code> (by default, all columns).</p><p><strong>Arguments</strong></p><ul><li><code>df</code> : <code>AbstractDataFrame</code></li><li><code>cols</code> : a selector specifying the column(s) or their transformations to compare. Can be any column selector or transformation accepted by <a href="#DataFrames.select"><code>select</code></a>.</li></ul><p>See also <a href="#Base.unique"><code>unique</code></a> and <a href="#DataFrames.nonunique"><code>nonunique</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; df = DataFrame(i=1:4, x=[1, 2, 1, 2])
4×2 DataFrame
 Row │ i      x
     │ Int64  Int64
─────┼──────────────
   1 │     1      1
   2 │     2      2
   3 │     3      1
   4 │     4      2

julia&gt; allunique(df)
true

julia&gt; allunique(df, :x)
false

julia&gt; allunique(df, :i =&gt; ByRow(isodd))
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/a1f75b1dd155265e5767e1e3f64d70be824859d7/src/abstractdataframe/unique.jl#L165-L202">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.deleteat!" href="#Base.deleteat!"><code>Base.deleteat!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">deleteat!(df::DataFrame, inds)</code></pre><p>Delete rows specified by <code>inds</code> from a <code>DataFrame</code> <code>df</code> in place and return it.</p><p>Internally <code>deleteat!</code> is called for all columns so <code>inds</code> must be: a vector of sorted and unique integers, a boolean vector, an integer, or <code>Not</code> wrapping any valid selector.</p><p>Metadata: this function preserves table-level and column-level <code>:note</code>-style metadata.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; df = DataFrame(a=1:3, b=4:6)
3×2 DataFrame
 Row │ a      b
     │ Int64  Int64
─────┼──────────────
   1 │     1      4
   2 │     2      5
   3 │     3      6

julia&gt; deleteat!(df, 2)
2×2 DataFrame
 Row │ a      b
     │ Int64  Int64
─────┼──────────────
   1 │     1      4
   2 │     3      6</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/a1f75b1dd155265e5767e1e3f64d70be824859d7/src/dataframe/dataframe.jl#L823-L853">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.empty" href="#Base.empty"><code>Base.empty</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">empty(df::AbstractDataFrame)</code></pre><p>Create a new <code>DataFrame</code> with the same column names and column element types as <code>df</code> but with zero rows.</p><p>Metadata: this function preserves table-level and column-level <code>:note</code>-style metadata.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/a1f75b1dd155265e5767e1e3f64d70be824859d7/src/abstractdataframe/abstractdataframe.jl#L458-L465">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.empty!" href="#Base.empty!"><code>Base.empty!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">empty!(df::DataFrame)</code></pre><p>Remove all rows from <code>df</code>, making each of its columns empty.</p><p>Metadata: this function preserves table-level and column-level <code>:note</code>-style metadata.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; df = DataFrame(a=1:3, b=4:6)
3×2 DataFrame
 Row │ a      b
     │ Int64  Int64
─────┼──────────────
   1 │     1      4
   2 │     2      5
   3 │     3      6

julia&gt; empty!(df)
0×2 DataFrame
 Row │ a      b
     │ Int64  Int64
─────┴──────────────

julia&gt; df.a, df.b
(Int64[], Int64[])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/a1f75b1dd155265e5767e1e3f64d70be824859d7/src/dataframe/dataframe.jl#L1011-L1039">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.filter" href="#Base.filter"><code>Base.filter</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">filter(fun, df::AbstractDataFrame; view::Bool=false)
filter(cols =&gt; fun, df::AbstractDataFrame; view::Bool=false)</code></pre><p>Return a data frame containing only rows from <code>df</code> for which <code>fun</code> returns <code>true</code>.</p><p>If <code>cols</code> is not specified then the predicate <code>fun</code> is passed <code>DataFrameRow</code>s. Elements of a <code>DataFrameRow</code> may be accessed with dot syntax or column indexing inside <code>fun</code>.</p><p>If <code>cols</code> is specified then the predicate <code>fun</code> is passed elements of the corresponding columns as separate positional arguments, unless <code>cols</code> is an <code>AsTable</code> selector, in which case a <code>NamedTuple</code> of these arguments is passed. <code>cols</code> can be any column selector (<code>Symbol</code>, string or integer; <code>:</code>, <code>Cols</code>, <code>All</code>, <code>Between</code>, <code>Not</code>, a regular expression, or a vector of <code>Symbol</code>s, strings or integers), and column duplicates are allowed if a vector of <code>Symbol</code>s, strings, or integers is passed.</p><p>If <code>view=false</code> a freshly allocated <code>DataFrame</code> is returned. If <code>view=true</code> then a <code>SubDataFrame</code> view into <code>df</code> is returned.</p><p>Passing <code>cols</code> leads to a more efficient execution of the operation for large data frames.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>This method is defined so that DataFrames.jl implements the Julia API for collections, but it is generally recommended to use the <a href="#DataFrames.subset"><code>subset</code></a> function instead as it is consistent with other DataFrames.jl functions (as opposed to <code>filter</code>).</p></div></div><p>Metadata: this function preserves table-level and column-level <code>:note</code>-style metadata.</p><p>See also: <a href="#Base.filter!"><code>filter!</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; df = DataFrame(x=[3, 1, 2, 1], y=[&quot;b&quot;, &quot;c&quot;, &quot;a&quot;, &quot;b&quot;])
4×2 DataFrame
 Row │ x      y
     │ Int64  String
─────┼───────────────
   1 │     3  b
   2 │     1  c
   3 │     2  a
   4 │     1  b

julia&gt; filter(row -&gt; row.x &gt; 1, df)
2×2 DataFrame
 Row │ x      y
     │ Int64  String
─────┼───────────────
   1 │     3  b
   2 │     2  a

julia&gt; filter(row -&gt; row[&quot;x&quot;] &gt; 1, df)
2×2 DataFrame
 Row │ x      y
     │ Int64  String
─────┼───────────────
   1 │     3  b
   2 │     2  a

julia&gt; filter(:x =&gt; x -&gt; x &gt; 1, df)
2×2 DataFrame
 Row │ x      y
     │ Int64  String
─────┼───────────────
   1 │     3  b
   2 │     2  a

julia&gt; filter([:x, :y] =&gt; (x, y) -&gt; x == 1 || y == &quot;b&quot;, df)
3×2 DataFrame
 Row │ x      y
     │ Int64  String
─────┼───────────────
   1 │     3  b
   2 │     1  c
   3 │     1  b

julia&gt; filter(AsTable(:) =&gt; nt -&gt; nt.x == 1 || nt.y == &quot;b&quot;, df)
3×2 DataFrame
 Row │ x      y
     │ Int64  String
─────┼───────────────
   1 │     3  b
   2 │     1  c
   3 │     1  b</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/a1f75b1dd155265e5767e1e3f64d70be824859d7/src/abstractdataframe/abstractdataframe.jl#L1090-L1179">source</a></section><section><div><pre><code class="nohighlight hljs">filter(fun, gdf::GroupedDataFrame; ungroup::Bool=false)
filter(cols =&gt; fun, gdf::GroupedDataFrame; ungroup::Bool=false)</code></pre><p>Return only groups in <code>gd</code> for which <code>fun</code> returns <code>true</code> as a <code>GroupedDataFrame</code> if <code>ungroup=false</code> (the default), or as a data frame if <code>ungroup=true</code>.</p><p>If <code>cols</code> is not specified then the predicate <code>fun</code> is called with a <code>SubDataFrame</code> for each group.</p><p>If <code>cols</code> is specified then the predicate <code>fun</code> is called for each group with views of the corresponding columns as separate positional arguments, unless <code>cols</code> is an <code>AsTable</code> selector, in which case a <code>NamedTuple</code> of these arguments is passed. <code>cols</code> can be any column selector (<code>Symbol</code>, string or integer; <code>:</code>, <code>Cols</code>, <code>All</code>, <code>Between</code>, <code>Not</code>, a regular expression, or a vector of <code>Symbol</code>s, strings or integers), and column duplicates are allowed if a vector of <code>Symbol</code>s, strings, or integers is passed.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>This method is defined so that DataFrames.jl implements the Julia API for collections, but it is generally recommended to use the <a href="#DataFrames.subset"><code>subset</code></a> function instead as it is consistent with other DataFrames.jl functions (as opposed to <code>filter</code>).</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; df = DataFrame(g=[1, 2], x=[&#39;a&#39;, &#39;b&#39;]);

julia&gt; gd = groupby(df, :g)
GroupedDataFrame with 2 groups based on key: g
First Group (1 row): g = 1
 Row │ g      x
     │ Int64  Char
─────┼─────────────
   1 │     1  a
⋮
Last Group (1 row): g = 2
 Row │ g      x
     │ Int64  Char
─────┼─────────────
   1 │     2  b

julia&gt; filter(x -&gt; x.x[1] == &#39;a&#39;, gd)
GroupedDataFrame with 1 group based on key: g
First Group (1 row): g = 1
 Row │ g      x
     │ Int64  Char
─────┼─────────────
   1 │     1  a

julia&gt; filter(:x =&gt; x -&gt; x[1] == &#39;a&#39;, gd)
GroupedDataFrame with 1 group based on key: g
First Group (1 row): g = 1
 Row │ g      x
     │ Int64  Char
─────┼─────────────
   1 │     1  a

julia&gt; filter(:x =&gt; x -&gt; x[1] == &#39;a&#39;, gd, ungroup=true)
1×2 DataFrame
 Row │ g      x
     │ Int64  Char
─────┼─────────────
   1 │     1  a</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/a1f75b1dd155265e5767e1e3f64d70be824859d7/src/groupeddataframe/groupeddataframe.jl#L1114-L1180">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.filter!" href="#Base.filter!"><code>Base.filter!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">filter!(fun, df::AbstractDataFrame)
filter!(cols =&gt; fun, df::AbstractDataFrame)</code></pre><p>Remove rows from data frame <code>df</code> for which <code>fun</code> returns <code>false</code>.</p><p>If <code>cols</code> is not specified then the predicate <code>fun</code> is passed <code>DataFrameRow</code>s. Elements of a <code>DataFrameRow</code> may be accessed with dot syntax or column indexing inside <code>fun</code>.</p><p>If <code>cols</code> is specified then the predicate <code>fun</code> is passed elements of the corresponding columns as separate positional arguments, unless <code>cols</code> is an <code>AsTable</code> selector, in which case a <code>NamedTuple</code> of these arguments is passed. <code>cols</code> can be any column selector (<code>Symbol</code>, string or integer; <code>:</code>, <code>Cols</code>, <code>All</code>, <code>Between</code>, <code>Not</code>, a regular expression, or a vector of <code>Symbol</code>s, strings or integers), and column duplicates are allowed if a vector of <code>Symbol</code>s, strings, or integers is passed.</p><p>Passing <code>cols</code> leads to a more efficient execution of the operation for large data frames.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>This method is defined so that DataFrames.jl implements the Julia API for collections, but it is generally recommended to use the <a href="#DataFrames.subset!"><code>subset!</code></a> function instead as it is consistent with other DataFrames.jl functions (as opposed to <code>filter!</code>).</p></div></div><p>Metadata: this function preserves table-level and column-level <code>:note</code>-style metadata.</p><p>See also: <a href="#Base.filter"><code>filter</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; df = DataFrame(x=[3, 1, 2, 1], y=[&quot;b&quot;, &quot;c&quot;, &quot;a&quot;, &quot;b&quot;])
4×2 DataFrame
 Row │ x      y
     │ Int64  String
─────┼───────────────
   1 │     3  b
   2 │     1  c
   3 │     2  a
   4 │     1  b

julia&gt; filter!(row -&gt; row.x &gt; 1, df)
2×2 DataFrame
 Row │ x      y
     │ Int64  String
─────┼───────────────
   1 │     3  b
   2 │     2  a

julia&gt; filter!(row -&gt; row[&quot;x&quot;] &gt; 1, df)
2×2 DataFrame
 Row │ x      y
     │ Int64  String
─────┼───────────────
   1 │     3  b
   2 │     2  a

julia&gt; filter!(:x =&gt; x -&gt; x == 3, df)
1×2 DataFrame
 Row │ x      y
     │ Int64  String
─────┼───────────────
   1 │     3  b

julia&gt; df = DataFrame(x=[3, 1, 2, 1], y=[&quot;b&quot;, &quot;c&quot;, &quot;a&quot;, &quot;b&quot;]);

julia&gt; filter!([:x, :y] =&gt; (x, y) -&gt; x == 1 || y == &quot;b&quot;, df)
3×2 DataFrame
 Row │ x      y
     │ Int64  String
─────┼───────────────
   1 │     3  b
   2 │     1  c
   3 │     1  b

julia&gt; df = DataFrame(x=[3, 1, 2, 1], y=[&quot;b&quot;, &quot;c&quot;, &quot;a&quot;, &quot;b&quot;]);

julia&gt; filter!(AsTable(:) =&gt; nt -&gt; nt.x == 1 || nt.y == &quot;b&quot;, df)
3×2 DataFrame
 Row │ x      y
     │ Int64  String
─────┼───────────────
   1 │     3  b
   2 │     1  c
   3 │     1  b</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/a1f75b1dd155265e5767e1e3f64d70be824859d7/src/abstractdataframe/abstractdataframe.jl#L1224-L1312">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.keepat!" href="#Base.keepat!"><code>Base.keepat!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">keepat!(df::DataFrame, inds)</code></pre><p>Delete rows at all indices not specified by <code>inds</code> from a <code>DataFrame</code> <code>df</code> in place and return it.</p><p>Internally <code>deleteat!</code> is called for all columns so <code>inds</code> must be: a vector of sorted and unique integers, a boolean vector, an integer, or <code>Not</code> wrapping any valid selector.</p><p>Metadata: this function preserves table-level and column-level <code>:note</code>-style metadata.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; df = DataFrame(a=1:3, b=4:6)
3×2 DataFrame
 Row │ a      b
     │ Int64  Int64
─────┼──────────────
   1 │     1      4
   2 │     2      5
   3 │     3      6

julia&gt; keepat!(df, [1, 3])
2×2 DataFrame
 Row │ a      b
     │ Int64  Int64
─────┼──────────────
   1 │     1      4
   2 │     3      6</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/a1f75b1dd155265e5767e1e3f64d70be824859d7/src/dataframe/dataframe.jl#L945-L976">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.first" href="#Base.first"><code>Base.first</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">first(df::AbstractDataFrame)</code></pre><p>Get the first row of <code>df</code> as a <code>DataFrameRow</code>.</p><p>Metadata: this function preserves table-level and column-level <code>:note</code>-style metadata.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/a1f75b1dd155265e5767e1e3f64d70be824859d7/src/abstractdataframe/abstractdataframe.jl#L524-L530">source</a></section><section><div><pre><code class="nohighlight hljs">first(df::AbstractDataFrame, n::Integer; view::Bool=false)</code></pre><p>Get a data frame with the <code>n</code> first rows of <code>df</code>.</p><p>If <code>view=false</code> a freshly allocated <code>DataFrame</code> is returned. If <code>view=true</code> then a <code>SubDataFrame</code> view into <code>df</code> is returned.</p><p>Metadata: this function preserves table-level and column-level <code>:note</code>-style metadata.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/a1f75b1dd155265e5767e1e3f64d70be824859d7/src/abstractdataframe/abstractdataframe.jl#L533-L542">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.last" href="#Base.last"><code>Base.last</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">last(df::AbstractDataFrame)</code></pre><p>Get the last row of <code>df</code> as a <code>DataFrameRow</code>.</p><p>Metadata: this function preserves table-level and column-level <code>:note</code>-style metadata.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/a1f75b1dd155265e5767e1e3f64d70be824859d7/src/abstractdataframe/abstractdataframe.jl#L546-L552">source</a></section><section><div><pre><code class="nohighlight hljs">last(df::AbstractDataFrame, n::Integer; view::Bool=false)</code></pre><p>Get a data frame with the <code>n</code> last rows of <code>df</code>.</p><p>If <code>view=false</code> a freshly allocated <code>DataFrame</code> is returned. If <code>view=true</code> then a <code>SubDataFrame</code> view into <code>df</code> is returned.</p><p>Metadata: this function preserves table-level and column-level <code>:note</code>-style metadata.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/a1f75b1dd155265e5767e1e3f64d70be824859d7/src/abstractdataframe/abstractdataframe.jl#L555-L564">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFrames.nonunique" href="#DataFrames.nonunique"><code>DataFrames.nonunique</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">nonunique(df::AbstractDataFrame; keep::Symbol=:first)
nonunique(df::AbstractDataFrame, cols; keep::Symbol=:first)</code></pre><p>Return a <code>Vector{Bool}</code> in which <code>true</code> entries indicate duplicate rows.</p><p>Duplicate rows are those for which at least another row contains equal values (according to <code>isequal</code>) for all columns in <code>cols</code> (by default, all columns). If <code>keep=:first</code> (the default), only the first occurrence of a set of duplicate rows is indicated with a <code>false</code> entry. If <code>keep=:last</code>, only the last occurrence of a set of duplicate rows is indicated with a <code>false</code> entry. If <code>keep=:noduplicates</code>, only rows without any duplicates are indicated with a <code>false</code> entry.</p><p><strong>Arguments</strong></p><ul><li><code>df</code> : <code>AbstractDataFrame</code></li><li><code>cols</code> : a selector specifying the column(s) or their transformations to compare. Can be any column selector or transformation accepted by <a href="#DataFrames.select"><code>select</code></a> that returns at least one column if <code>df</code> has at least one column.</li></ul><p>See also <a href="#Base.unique"><code>unique</code></a> and <a href="#Base.unique!"><code>unique!</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; df = DataFrame(i=1:4, x=[1, 2, 1, 2])
4×2 DataFrame
 Row │ i      x
     │ Int64  Int64
─────┼──────────────
   1 │     1      1
   2 │     2      2
   3 │     3      1
   4 │     4      2

julia&gt; df = vcat(df, df)
8×2 DataFrame
 Row │ i      x
     │ Int64  Int64
─────┼──────────────
   1 │     1      1
   2 │     2      2
   3 │     3      1
   4 │     4      2
   5 │     1      1
   6 │     2      2
   7 │     3      1
   8 │     4      2

julia&gt; nonunique(df)
8-element Vector{Bool}:
 0
 0
 0
 0
 1
 1
 1
 1

julia&gt; nonunique(df, keep=:last)
8-element Vector{Bool}:
 1
 1
 1
 1
 0
 0
 0
 0

julia&gt; nonunique(df, 2)
8-element Vector{Bool}:
 0
 0
 1
 1
 1
 1
 1
 1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/a1f75b1dd155265e5767e1e3f64d70be824859d7/src/abstractdataframe/unique.jl#L1-L85">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.Iterators.only" href="#Base.Iterators.only"><code>Base.Iterators.only</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">only(df::AbstractDataFrame)</code></pre><p>If <code>df</code> has a single row return it as a <code>DataFrameRow</code>; otherwise throw <code>ArgumentError</code>.</p><p>Metadata: this function preserves table-level and column-level <code>:note</code>-style metadata.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/a1f75b1dd155265e5767e1e3f64d70be824859d7/src/abstractdataframe/abstractdataframe.jl#L512-L518">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.pop!" href="#Base.pop!"><code>Base.pop!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pop!(df::DataFrame)</code></pre><p>Remove the last row from <code>df</code> and return a <code>NamedTuple</code> created from this row.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Using this method for very wide data frames may lead to expensive compilation.</p></div></div><p>Metadata: this function preserves table-level and column-level <code>:note</code>-style metadata.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; df = DataFrame(a=1:3, b=4:6)
3×2 DataFrame
 Row │ a      b
     │ Int64  Int64
─────┼──────────────
   1 │     1      4
   2 │     2      5
   3 │     3      6

julia&gt; pop!(df)
(a = 3, b = 6)

julia&gt; df
2×2 DataFrame
 Row │ a      b
     │ Int64  Int64
─────┼──────────────
   1 │     1      4
   2 │     2      5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/a1f75b1dd155265e5767e1e3f64d70be824859d7/src/dataframe/dataframe.jl#L1083-L1117">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.popat!" href="#Base.popat!"><code>Base.popat!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">popat!(df::DataFrame, i::Integer)</code></pre><p>Remove the <code>i</code>-th row from <code>df</code> and return a <code>NamedTuple</code> created from this row.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Using this method for very wide data frames may lead to expensive compilation.</p></div></div><p>Metadata: this function preserves table-level and column-level <code>:note</code>-style metadata.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; df = DataFrame(a=1:3, b=4:6)
3×2 DataFrame
 Row │ a      b
     │ Int64  Int64
─────┼──────────────
   1 │     1      4
   2 │     2      5
   3 │     3      6

julia&gt; popat!(df, 2)
(a = 2, b = 5)

julia&gt; df
2×2 DataFrame
 Row │ a      b
     │ Int64  Int64
─────┼──────────────
   1 │     1      4
   2 │     3      6</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/a1f75b1dd155265e5767e1e3f64d70be824859d7/src/dataframe/dataframe.jl#L1156-L1189">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.popfirst!" href="#Base.popfirst!"><code>Base.popfirst!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">popfirst!(df::DataFrame)</code></pre><p>Remove the first row from <code>df</code> and return a <code>NamedTuple</code> created from this row.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Using this method for very wide data frames may lead to expensive compilation.</p></div></div><p>Metadata: this function preserves table-level and column-level <code>:note</code>-style metadata.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; df = DataFrame(a=1:3, b=4:6)
3×2 DataFrame
 Row │ a      b
     │ Int64  Int64
─────┼──────────────
   1 │     1      4
   2 │     2      5
   3 │     3      6

julia&gt; popfirst!(df)
(a = 1, b = 4)

julia&gt; df
2×2 DataFrame
 Row │ a      b
     │ Int64  Int64
─────┼──────────────
   1 │     2      5
   2 │     3      6</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/a1f75b1dd155265e5767e1e3f64d70be824859d7/src/dataframe/dataframe.jl#L1120-L1153">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.resize!" href="#Base.resize!"><code>Base.resize!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">resize!(df::DataFrame, n::Integer)</code></pre><p>Resize <code>df</code> to have <code>n</code> rows by calling <code>resize!</code> on all columns of <code>df</code>.</p><p>Metadata: this function preserves table-level and column-level <code>:note</code>-style metadata.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; df = DataFrame(a=1:3, b=4:6)
3×2 DataFrame
 Row │ a      b
     │ Int64  Int64
─────┼──────────────
   1 │     1      4
   2 │     2      5
   3 │     3      6

julia&gt; resize!(df, 2)
2×2 DataFrame
 Row │ a      b
     │ Int64  Int64
─────┼──────────────
   1 │     1      4
   2 │     2      5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/a1f75b1dd155265e5767e1e3f64d70be824859d7/src/dataframe/dataframe.jl#L1046-L1072">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFrames.subset" href="#DataFrames.subset"><code>DataFrames.subset</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">subset(df::AbstractDataFrame, args...;
       skipmissing::Bool=false, view::Bool=false, threads::Bool=true)
subset(gdf::GroupedDataFrame, args...;
       skipmissing::Bool=false, view::Bool=false,
       ungroup::Bool=true, threads::Bool=true)</code></pre><p>Return a copy of data frame <code>df</code> or parent of <code>gdf</code> containing only rows for which all values produced by transformation(s) <code>args</code> for a given row are <code>true</code>. All transformations must produce vectors containing <code>true</code> or <code>false</code>. When the first argument is a <code>GroupedDataFrame</code>, transformations are also allowed to return a single <code>true</code> or <code>false</code> value, which results in including or excluding a whole group.</p><p>If <code>skipmissing=false</code> (the default) <code>args</code> are required to produce results containing only <code>Bool</code> values. If <code>skipmissing=true</code>, additionally <code>missing</code> is allowed and it is treated as <code>false</code> (i.e. rows for which one of the conditions returns <code>missing</code> are skipped).</p><p>Each argument passed in <code>args</code> can be any specifier following the rules described for <a href="#DataFrames.select"><code>select</code></a> with the restriction that:</p><ul><li>specifying target column name is not allowed as <code>subset</code> does not create new columns;</li><li>every passed transformation must return a scalar or a vector (returning <code>AbstractDataFrame</code>, <code>NamedTuple</code>, <code>DataFrameRow</code> or <code>AbstractMatrix</code> is not supported).</li></ul><p>If <code>view=true</code> a <code>SubDataFrame</code> view  is returned instead of a <code>DataFrame</code>.</p><p>If <code>ungroup=false</code> the resulting data frame is re-grouped based on the same grouping columns as <code>gdf</code> and a <code>GroupedDataFrame</code> is returned (preserving the order of groups from <code>gdf</code>).</p><p>If <code>threads=true</code> (the default) transformations may be run in separate tasks which can execute in parallel (possibly being applied to multiple rows or groups at the same time). Whether or not tasks are actually spawned and their number are determined automatically. Set to <code>false</code> if some transformations require serial execution or are not thread-safe.</p><p>If a <code>GroupedDataFrame</code> is passed then it must include all groups present in the <code>parent</code> data frame, like in <a href="#DataFrames.select!"><code>select!</code></a>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Note that as the <code>subset</code> function works in exactly the same way as other transformation functions defined in DataFrames.jl this is the preferred way to subset rows of a data frame or grouped data frame. In particular it uses a different set of rules for specifying transformations than <a href="#Base.filter"><code>filter</code></a> which is implemented in DataFrames.jl to ensure support for the standard Julia API for collections.</p></div></div><p>Metadata: this function preserves table-level and column-level <code>:note</code>-style metadata.</p><p>See also: <a href="#DataFrames.subset!"><code>subset!</code></a>, <a href="#Base.filter"><code>filter</code></a>, <a href="#DataFrames.select"><code>select</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; df = DataFrame(id=1:4, x=[true, false, true, false],
                      y=[true, true, false, false],
                      z=[true, true, missing, missing], v=[1, 2, 11, 12])
4×5 DataFrame
 Row │ id     x      y      z        v
     │ Int64  Bool   Bool   Bool?    Int64
─────┼─────────────────────────────────────
   1 │     1   true   true     true      1
   2 │     2  false   true     true      2
   3 │     3   true  false  missing     11
   4 │     4  false  false  missing     12

julia&gt; subset(df, :x)
2×5 DataFrame
 Row │ id     x     y      z        v
     │ Int64  Bool  Bool   Bool?    Int64
─────┼────────────────────────────────────
   1 │     1  true   true     true      1
   2 │     3  true  false  missing     11

julia&gt; subset(df, :v =&gt; x -&gt; x .&gt; 3)
2×5 DataFrame
 Row │ id     x      y      z        v
     │ Int64  Bool   Bool   Bool?    Int64
─────┼─────────────────────────────────────
   1 │     3   true  false  missing     11
   2 │     4  false  false  missing     12

julia&gt; subset(df, :x, :y =&gt; ByRow(!))
1×5 DataFrame
 Row │ id     x     y      z        v
     │ Int64  Bool  Bool   Bool?    Int64
─────┼────────────────────────────────────
   1 │     3  true  false  missing     11

julia&gt; subset(df, :x, :z, skipmissing=true)
1×5 DataFrame
 Row │ id     x     y     z      v
     │ Int64  Bool  Bool  Bool?  Int64
─────┼─────────────────────────────────
   1 │     1  true  true   true      1

julia&gt; subset(df, :x, :z)
ERROR: ArgumentError: missing was returned in condition number 2 but only true or false are allowed; pass skipmissing=true to skip missing values

julia&gt; subset(groupby(df, :y), :v =&gt; x -&gt; x .&gt; minimum(x))
2×5 DataFrame
 Row │ id     x      y      z        v
     │ Int64  Bool   Bool   Bool?    Int64
─────┼─────────────────────────────────────
   1 │     2  false   true     true      2
   2 │     4  false  false  missing     12

julia&gt; subset(groupby(df, :y), :v =&gt; x -&gt; minimum(x) &gt; 5)
2×5 DataFrame
 Row │ id     x      y      z        v
     │ Int64  Bool   Bool   Bool?    Int64
─────┼─────────────────────────────────────
   1 │     3   true  false  missing     11
   2 │     4  false  false  missing     12</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/a1f75b1dd155265e5767e1e3f64d70be824859d7/src/abstractdataframe/subset.jl#L159-L277">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFrames.subset!" href="#DataFrames.subset!"><code>DataFrames.subset!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">subset!(df::AbstractDataFrame, args...;
        skipmissing::Bool=false, threads::Bool=true)
subset!(gdf::GroupedDataFrame{DataFrame}, args...;
        skipmissing::Bool=false, ungroup::Bool=true, threads::Bool=true)</code></pre><p>Update data frame <code>df</code> or the parent of <code>gdf</code> in place to contain only rows for which all values produced by transformation(s) <code>args</code> for a given row is <code>true</code>. All transformations must produce vectors containing <code>true</code> or <code>false</code>. When the first argument is a <code>GroupedDataFrame</code>, transformations are also allowed to return a single <code>true</code> or <code>false</code> value, which results in including or excluding a whole group.</p><p>If <code>skipmissing=false</code> (the default) <code>args</code> are required to produce results containing only <code>Bool</code> values. If <code>skipmissing=true</code>, additionally <code>missing</code> is allowed and it is treated as <code>false</code> (i.e. rows for which one of the conditions returns <code>missing</code> are skipped).</p><p>Each argument passed in <code>args</code> can be any specifier following the rules described for <a href="#DataFrames.select"><code>select</code></a> with the restriction that:</p><ul><li>specifying target column name is not allowed as <code>subset!</code> does not create new columns;</li><li>every passed transformation must return a scalar or a vector (returning <code>AbstractDataFrame</code>, <code>NamedTuple</code>, <code>DataFrameRow</code> or <code>AbstractMatrix</code> is not supported).</li></ul><p>If <code>ungroup=false</code> the passed <code>GroupedDataFrame</code> <code>gdf</code> is updated (preserving the order of its groups) and returned.</p><p>If <code>threads=true</code> (the default) transformations may be run in separate tasks which can execute in parallel (possibly being applied to multiple rows or groups at the same time). Whether or not tasks are actually spawned and their number are determined automatically. Set to <code>false</code> if some transformations require serial execution or are not thread-safe.</p><p>If <code>GroupedDataFrame</code> is subsetted then it must include all groups present in the <code>parent</code> data frame, like in <a href="#DataFrames.select!"><code>select!</code></a>. In this case the passed <code>GroupedDataFrame</code> is updated to have correct groups after its parent is updated.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Note that as the <code>subset!</code> function works in exactly the same way as other transformation functions defined in DataFrames.jl this is the preferred way to subset rows of a data frame or grouped data frame. In particular it uses a different set of rules for specifying transformations than <a href="#Base.filter!"><code>filter!</code></a> which is implemented in DataFrames.jl to ensure support for the standard Julia API for collections.</p></div></div><p>Metadata: this function preserves table-level and column-level <code>:note</code>-style metadata.</p><p>See also: <a href="#DataFrames.subset"><code>subset</code></a>, <a href="#Base.filter!"><code>filter!</code></a>, <a href="#DataFrames.select!"><code>select!</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; df = DataFrame(id=1:4, x=[true, false, true, false], y=[true, true, false, false])
4×3 DataFrame
 Row │ id     x      y
     │ Int64  Bool   Bool
─────┼─────────────────────
   1 │     1   true   true
   2 │     2  false   true
   3 │     3   true  false
   4 │     4  false  false

julia&gt; subset!(df, :x, :y =&gt; ByRow(!));

julia&gt; df
1×3 DataFrame
 Row │ id     x     y
     │ Int64  Bool  Bool
─────┼────────────────────
   1 │     3  true  false

julia&gt; df = DataFrame(id=1:4, y=[true, true, false, false], v=[1, 2, 11, 12]);

julia&gt; subset!(groupby(df, :y), :v =&gt; x -&gt; x .&gt; minimum(x));

julia&gt; df
2×3 DataFrame
 Row │ id     y      v
     │ Int64  Bool   Int64
─────┼─────────────────────
   1 │     2   true      2
   2 │     4  false     12

julia&gt; df = DataFrame(id=1:4, x=[true, false, true, false],
                      z=[true, true, missing, missing], v=1:4)
4×4 DataFrame
 Row │ id     x      z        v
     │ Int64  Bool   Bool?    Int64
─────┼──────────────────────────────
   1 │     1   true     true      1
   2 │     2  false     true      2
   3 │     3   true  missing      3
   4 │     4  false  missing      4

julia&gt; subset!(df, :x, :z)
ERROR: ArgumentError: missing was returned in condition number 2 but only true or false are allowed; pass skipmissing=true to skip missing values

julia&gt; subset!(df, :x, :z, skipmissing=true);

julia&gt; df
1×4 DataFrame
 Row │ id     x     z      v
     │ Int64  Bool  Bool?  Int64
─────┼───────────────────────────
   1 │     1  true   true      1

julia&gt; df = DataFrame(id=1:4, x=[true, false, true, false], y=[true, true, false, false],
                      z=[true, true, missing, missing], v=[1, 2, 11, 12]);

julia&gt; subset!(groupby(df, :y), :v =&gt; x -&gt; x .&gt; minimum(x));

julia&gt; df
2×5 DataFrame
 Row │ id     x      y      z        v
     │ Int64  Bool   Bool   Bool?    Int64
─────┼─────────────────────────────────────
   1 │     2  false   true     true      2
   2 │     4  false  false  missing     12

julia&gt; df = DataFrame(id=1:4, x=[true, false, true, false], y=[true, true, false, false],
                      z=[true, true, missing, missing], v=[1, 2, 11, 12]);

julia&gt; subset!(groupby(df, :y), :v =&gt; x -&gt; minimum(x) &gt; 5);

julia&gt; df
2×5 DataFrame
 Row │ id     x      y      z        v
     │ Int64  Bool   Bool   Bool?    Int64
─────┼─────────────────────────────────────
   1 │     3   true  false  missing     11
   2 │     4  false  false  missing     12</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/a1f75b1dd155265e5767e1e3f64d70be824859d7/src/abstractdataframe/subset.jl#L336-L471">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.unique" href="#Base.unique"><code>Base.unique</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">unique(df::AbstractDataFrame; view::Bool=false, keep::Symbol=:first)
unique(df::AbstractDataFrame, cols; view::Bool=false, keep::Symbol=:first)</code></pre><p>Return a data frame containing only unique rows in <code>df</code>.</p><p>Non-unique (duplicate) rows are those for which at least another row contains equal values (according to <code>isequal</code>) for all columns in <code>cols</code> (by default, all columns). If <code>keep=:first</code> (the default), only the first occurrence of a set of duplicate rows is kept. If <code>keep=:last</code>, only the last occurrence of a set of duplicate rows is kept. If <code>keep=:noduplicates</code>, only rows without any duplicates are kept.</p><p>If <code>view=false</code> a freshly allocated <code>DataFrame</code> is returned, and if <code>view=true</code> then a <code>SubDataFrame</code> view into <code>df</code> is returned.</p><p><strong>Arguments</strong></p><ul><li><code>df</code> : the AbstractDataFrame</li><li><code>cols</code> : a selector specifying the column(s) or their transformations to compare. Can be any column selector or transformation accepted by <a href="#DataFrames.select"><code>select</code></a> that returns at least one column if <code>df</code> has at least one column.</li></ul><p>Metadata: this function preserves table-level and column-level <code>:note</code>-style metadata.</p><p>See also: <a href="#Base.unique!"><code>unique!</code></a>, <a href="#DataFrames.nonunique"><code>nonunique</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; df = DataFrame(i=1:4, x=[1, 2, 1, 2])
4×2 DataFrame
 Row │ i      x
     │ Int64  Int64
─────┼──────────────
   1 │     1      1
   2 │     2      2
   3 │     3      1
   4 │     4      2

julia&gt; df = vcat(df, df)
8×2 DataFrame
 Row │ i      x
     │ Int64  Int64
─────┼──────────────
   1 │     1      1
   2 │     2      2
   3 │     3      1
   4 │     4      2
   5 │     1      1
   6 │     2      2
   7 │     3      1
   8 │     4      2

julia&gt; unique(df)   # doesn&#39;t modify df
4×2 DataFrame
 Row │ i      x
     │ Int64  Int64
─────┼──────────────
   1 │     1      1
   2 │     2      2
   3 │     3      1
   4 │     4      2

julia&gt; unique(df, 2)
2×2 DataFrame
 Row │ i      x
     │ Int64  Int64
─────┼──────────────
   1 │     1      1
   2 │     2      2

julia&gt; unique(df, keep=:noduplicates)
0×2 DataFrame
 Row │ i      x
     │ Int64  Int64
─────┴──────────────</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/a1f75b1dd155265e5767e1e3f64d70be824859d7/src/abstractdataframe/unique.jl#L210-L289">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.unique!" href="#Base.unique!"><code>Base.unique!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">unique!(df::AbstractDataFrame; keep::Symbol=:first)
unique!(df::AbstractDataFrame, cols; keep::Symbol=:first)</code></pre><p>Update <code>df</code> in-place to containi only unique rows.</p><p>Non-unique (duplicate) rows are those for which at least another row contains equal values (according to <code>isequal</code>) for all columns in <code>cols</code> (by default, all columns). If <code>keep=:first</code> (the default), only the first occurrence of a set of duplicate rows is kept. If <code>keep=:last</code>, only the last occurrence of a set of duplicate rows is kept. If <code>keep=:noduplicates</code>, only rows without any duplicates are kept.</p><p><strong>Arguments</strong></p><ul><li><code>df</code> : the AbstractDataFrame</li><li><code>cols</code> :  column indicator (<code>Symbol</code>, <code>Int</code>, <code>Vector{Symbol}</code>, <code>Regex</code>, etc.) specifying the column(s) to compare. Can be any column selector or transformation accepted by <a href="#DataFrames.select"><code>select</code></a> that returns at least one column if <code>df</code> has at least one column.</li></ul><p>Metadata: this function preserves table-level and column-level <code>:note</code>-style metadata.</p><p>See also: <a href="#Base.unique!"><code>unique!</code></a>, <a href="#DataFrames.nonunique"><code>nonunique</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; df = DataFrame(i=1:4, x=[1, 2, 1, 2])
4×2 DataFrame
 Row │ i      x
     │ Int64  Int64
─────┼──────────────
   1 │     1      1
   2 │     2      2
   3 │     3      1
   4 │     4      2

julia&gt; df = vcat(df, df)
8×2 DataFrame
 Row │ i      x
     │ Int64  Int64
─────┼──────────────
   1 │     1      1
   2 │     2      2
   3 │     3      1
   4 │     4      2
   5 │     1      1
   6 │     2      2
   7 │     3      1
   8 │     4      2

julia&gt; unique!(copy(df))  # modifies df
4×2 DataFrame
 Row │ i      x
     │ Int64  Int64
─────┼──────────────
   1 │     1      1
   2 │     2      2
   3 │     3      1
   4 │     4      2

julia&gt; unique(df, keep=:noduplicates)
0×2 DataFrame
 Row │ i      x
     │ Int64  Int64
─────┴──────────────</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/a1f75b1dd155265e5767e1e3f64d70be824859d7/src/abstractdataframe/unique.jl#L302-L370">source</a></section></article><h2 id="Working-with-missing-values"><a class="docs-heading-anchor" href="#Working-with-missing-values">Working with missing values</a><a id="Working-with-missing-values-1"></a><a class="docs-heading-anchor-permalink" href="#Working-with-missing-values" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Missings.allowmissing" href="#Missings.allowmissing"><code>Missings.allowmissing</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">allowmissing(df::AbstractDataFrame, cols=:)</code></pre><p>Return a copy of data frame <code>df</code> with columns <code>cols</code> converted to element type <code>Union{T, Missing}</code> from <code>T</code> to allow support for missing values.</p><p><code>cols</code> can be any column selector (<code>Symbol</code>, string or integer; <code>:</code>, <code>Cols</code>, <code>All</code>, <code>Between</code>, <code>Not</code>, a regular expression, or a vector of <code>Symbol</code>s, strings or integers).</p><p>If <code>cols</code> is omitted all columns in the data frame are converted.</p><p>Metadata: this function preserves table-level and column-level <code>:note</code>-style metadata.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; df = DataFrame(a=[1, 2])
2×1 DataFrame
 Row │ a
     │ Int64
─────┼───────
   1 │     1
   2 │     2

julia&gt; allowmissing(df)
2×1 DataFrame
 Row │ a
     │ Int64?
─────┼────────
   1 │      1
   2 │      2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/a1f75b1dd155265e5767e1e3f64d70be824859d7/src/abstractdataframe/abstractdataframe.jl#L2240-L2271">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFrames.allowmissing!" href="#DataFrames.allowmissing!"><code>DataFrames.allowmissing!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">allowmissing!(df::DataFrame, cols=:)</code></pre><p>Convert columns <code>cols</code> of data frame <code>df</code> from element type <code>T</code> to <code>Union{T, Missing}</code> to support missing values.</p><p><code>cols</code> can be any column selector (<code>Symbol</code>, string or integer; <code>:</code>, <code>Cols</code>, <code>All</code>, <code>Between</code>, <code>Not</code>, a regular expression, or a vector of <code>Symbol</code>s, strings or integers).</p><p>If <code>cols</code> is omitted all columns in the data frame are converted.</p><p>Metadata: this function preserves table-level and column-level <code>:note</code>-style metadata.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/a1f75b1dd155265e5767e1e3f64d70be824859d7/src/dataframe/dataframe.jl#L1251-L1262">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFrames.completecases" href="#DataFrames.completecases"><code>DataFrames.completecases</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">completecases(df::AbstractDataFrame, cols=:)</code></pre><p>Return a Boolean vector with <code>true</code> entries indicating rows without missing values (complete cases) in data frame <code>df</code>.</p><p>If <code>cols</code> is provided, only missing values in the corresponding columns are considered. <code>cols</code> can be any column selector (<code>Symbol</code>, string or integer; <code>:</code>, <code>Cols</code>, <code>All</code>, <code>Between</code>, <code>Not</code>, a regular expression, or a vector of <code>Symbol</code>s, strings or integers) that returns at least one column if <code>df</code> has at least one column.</p><p>See also: <a href="#DataFrames.dropmissing"><code>dropmissing</code></a> and <a href="#DataFrames.dropmissing!"><code>dropmissing!</code></a>. Use <code>findall(completecases(df))</code> to get the indices of the rows.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; df = DataFrame(i=1:5,
                      x=[missing, 4, missing, 2, 1],
                      y=[missing, missing, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;])
5×3 DataFrame
 Row │ i      x        y
     │ Int64  Int64?   String?
─────┼─────────────────────────
   1 │     1  missing  missing
   2 │     2        4  missing
   3 │     3  missing  c
   4 │     4        2  d
   5 │     5        1  e

julia&gt; completecases(df)
5-element BitVector:
 0
 0
 0
 1
 1

julia&gt; completecases(df, :x)
5-element BitVector:
 0
 1
 0
 1
 1

julia&gt; completecases(df, [:x, :y])
5-element BitVector:
 0
 0
 0
 1
 1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/a1f75b1dd155265e5767e1e3f64d70be824859d7/src/abstractdataframe/abstractdataframe.jl#L816-L869">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Missings.disallowmissing" href="#Missings.disallowmissing"><code>Missings.disallowmissing</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">disallowmissing(df::AbstractDataFrame, cols=:; error::Bool=true)</code></pre><p>Return a copy of data frame <code>df</code> with columns <code>cols</code> converted from element type <code>Union{T, Missing}</code> to <code>T</code> to drop support for missing values.</p><p><code>cols</code> can be any column selector (<code>Symbol</code>, string or integer; <code>:</code>, <code>Cols</code>, <code>All</code>, <code>Between</code>, <code>Not</code>, a regular expression, or a vector of <code>Symbol</code>s, strings or integers).</p><p>If <code>cols</code> is omitted all columns in the data frame are converted.</p><p>If <code>error=false</code> then columns containing a <code>missing</code> value will be skipped instead of throwing an error.</p><p>Metadata: this function preserves table-level and column-level <code>:note</code>-style metadata.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; df = DataFrame(a=Union{Int, Missing}[1, 2])
2×1 DataFrame
 Row │ a
     │ Int64?
─────┼────────
   1 │      1
   2 │      2

julia&gt; disallowmissing(df)
2×1 DataFrame
 Row │ a
     │ Int64
─────┼───────
   1 │     1
   2 │     2

julia&gt; df = DataFrame(a=[1, missing])
2×1 DataFrame
 Row │ a
     │ Int64?
─────┼─────────
   1 │       1
   2 │ missing

julia&gt; disallowmissing(df, error=false)
2×1 DataFrame
 Row │ a
     │ Int64?
─────┼─────────
   1 │       1
   2 │ missing</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/a1f75b1dd155265e5767e1e3f64d70be824859d7/src/abstractdataframe/abstractdataframe.jl#L2153-L2203">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFrames.disallowmissing!" href="#DataFrames.disallowmissing!"><code>DataFrames.disallowmissing!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">disallowmissing!(df::DataFrame, cols=:; error::Bool=true)</code></pre><p>Convert columns <code>cols</code> of data frame <code>df</code> from element type <code>Union{T, Missing}</code> to <code>T</code> to drop support for missing values.</p><p><code>cols</code> can be any column selector (<code>Symbol</code>, string or integer; <code>:</code>, <code>Cols</code>, <code>All</code>, <code>Between</code>, <code>Not</code>, a regular expression, or a vector of <code>Symbol</code>s, strings or integers).</p><p>If <code>cols</code> is omitted all columns in the data frame are converted.</p><p>If <code>error=false</code> then columns containing a <code>missing</code> value will be skipped instead of throwing an error.</p><p>Metadata: this function preserves table-level and column-level <code>:note</code>-style metadata.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/a1f75b1dd155265e5767e1e3f64d70be824859d7/src/dataframe/dataframe.jl#L1293-L1307">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFrames.dropmissing" href="#DataFrames.dropmissing"><code>DataFrames.dropmissing</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">dropmissing(df::AbstractDataFrame, cols=:; view::Bool=false, disallowmissing::Bool=!view)</code></pre><p>Return a data frame excluding rows with missing values in <code>df</code>.</p><p>If <code>cols</code> is provided, only missing values in the corresponding columns are considered. <code>cols</code> can be any column selector (<code>Symbol</code>, string or integer; <code>:</code>, <code>Cols</code>, <code>All</code>, <code>Between</code>, <code>Not</code>, a regular expression, or a vector of <code>Symbol</code>s, strings or integers).</p><p>If <code>view=false</code> a freshly allocated <code>DataFrame</code> is returned. If <code>view=true</code> then a <code>SubDataFrame</code> view into <code>df</code> is returned. In this case <code>disallowmissing</code> must be <code>false</code>.</p><p>If <code>disallowmissing</code> is <code>true</code> (the default when <code>view</code> is <code>false</code>) then columns specified in <code>cols</code> will be converted so as not to allow for missing values using <a href="#DataFrames.disallowmissing!"><code>disallowmissing!</code></a>.</p><p>See also: <a href="#DataFrames.completecases"><code>completecases</code></a> and <a href="#DataFrames.dropmissing!"><code>dropmissing!</code></a>.</p><p>Metadata: this function preserves table-level and column-level <code>:note</code>-style metadata.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; df = DataFrame(i=1:5,
                      x=[missing, 4, missing, 2, 1],
                      y=[missing, missing, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;])
5×3 DataFrame
 Row │ i      x        y
     │ Int64  Int64?   String?
─────┼─────────────────────────
   1 │     1  missing  missing
   2 │     2        4  missing
   3 │     3  missing  c
   4 │     4        2  d
   5 │     5        1  e

julia&gt; dropmissing(df)
2×3 DataFrame
 Row │ i      x      y
     │ Int64  Int64  String
─────┼──────────────────────
   1 │     4      2  d
   2 │     5      1  e

julia&gt; dropmissing(df, disallowmissing=false)
2×3 DataFrame
 Row │ i      x       y
     │ Int64  Int64?  String?
─────┼────────────────────────
   1 │     4       2  d
   2 │     5       1  e

julia&gt; dropmissing(df, :x)
3×3 DataFrame
 Row │ i      x      y
     │ Int64  Int64  String?
─────┼───────────────────────
   1 │     2      4  missing
   2 │     4      2  d
   3 │     5      1  e

julia&gt; dropmissing(df, [:x, :y])
2×3 DataFrame
 Row │ i      x      y
     │ Int64  Int64  String
─────┼──────────────────────
   1 │     4      2  d
   2 │     5      1  e</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/a1f75b1dd155265e5767e1e3f64d70be824859d7/src/abstractdataframe/abstractdataframe.jl#L904-L973">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFrames.dropmissing!" href="#DataFrames.dropmissing!"><code>DataFrames.dropmissing!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">dropmissing!(df::AbstractDataFrame, cols=:; disallowmissing::Bool=true)</code></pre><p>Remove rows with missing values from data frame <code>df</code> and return it.</p><p>If <code>cols</code> is provided, only missing values in the corresponding columns are considered. <code>cols</code> can be any column selector (<code>Symbol</code>, string or integer; <code>:</code>, <code>Cols</code>, <code>All</code>, <code>Between</code>, <code>Not</code>, a regular expression, or a vector of <code>Symbol</code>s, strings or integers).</p><p>If <code>disallowmissing</code> is <code>true</code> (the default) then the <code>cols</code> columns will get converted using <a href="#DataFrames.disallowmissing!"><code>disallowmissing!</code></a>.</p><p>Metadata: this function preserves table-level and column-level <code>:note</code>-style metadata.</p><p>See also: <a href="#DataFrames.dropmissing"><code>dropmissing</code></a> and <a href="#DataFrames.completecases"><code>completecases</code></a>.</p><pre><code class="language-julia-repl hljs">julia&gt; df = DataFrame(i=1:5,
                      x=[missing, 4, missing, 2, 1],
                      y=[missing, missing, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;])
5×3 DataFrame
 Row │ i      x        y
     │ Int64  Int64?   String?
─────┼─────────────────────────
   1 │     1  missing  missing
   2 │     2        4  missing
   3 │     3  missing  c
   4 │     4        2  d
   5 │     5        1  e

julia&gt; dropmissing!(copy(df))
2×3 DataFrame
 Row │ i      x      y
     │ Int64  Int64  String
─────┼──────────────────────
   1 │     4      2  d
   2 │     5      1  e

julia&gt; dropmissing!(copy(df), disallowmissing=false)
2×3 DataFrame
 Row │ i      x       y
     │ Int64  Int64?  String?
─────┼────────────────────────
   1 │     4       2  d
   2 │     5       1  e

julia&gt; dropmissing!(copy(df), :x)
3×3 DataFrame
 Row │ i      x      y
     │ Int64  Int64  String?
─────┼───────────────────────
   1 │     2      4  missing
   2 │     4      2  d
   3 │     5      1  e

julia&gt; dropmissing!(df, [:x, :y])
2×3 DataFrame
 Row │ i      x      y
     │ Int64  Int64  String
─────┼──────────────────────
   1 │     4      2  d
   2 │     5      1  e</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/a1f75b1dd155265e5767e1e3f64d70be824859d7/src/abstractdataframe/abstractdataframe.jl#L1017-L1079">source</a></section></article><h2 id="Iteration"><a class="docs-heading-anchor" href="#Iteration">Iteration</a><a id="Iteration-1"></a><a class="docs-heading-anchor-permalink" href="#Iteration" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Base.eachcol" href="#Base.eachcol"><code>Base.eachcol</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">eachcol(df::AbstractDataFrame)</code></pre><p>Return a <code>DataFrameColumns</code> object that is a vector-like that allows iterating an <code>AbstractDataFrame</code> column by column.</p><p>Indexing into <code>DataFrameColumns</code> objects using integer, <code>Symbol</code> or string returns the corresponding column (without copying). Indexing into <code>DataFrameColumns</code> objects using a multiple column selector returns a subsetted <code>DataFrameColumns</code> object with a new parent containing only the selected columns (without copying).</p><p><code>DataFrameColumns</code> supports most of the <code>AbstractVector</code> API. The key differences are that it is read-only and that the <code>keys</code> function returns a vector of <code>Symbol</code>s (and not integers as for normal vectors).</p><p>In particular <code>findnext</code>, <code>findprev</code>, <code>findfirst</code>, <code>findlast</code>, and <code>findall</code> functions are supported, and in <code>findnext</code> and <code>findprev</code> functions it is allowed to pass an integer, string, or <code>Symbol</code> as a reference index.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; df = DataFrame(x=1:4, y=11:14)
4×2 DataFrame
 Row │ x      y
     │ Int64  Int64
─────┼──────────────
   1 │     1     11
   2 │     2     12
   3 │     3     13
   4 │     4     14

julia&gt; eachcol(df)
4×2 DataFrameColumns
 Row │ x      y
     │ Int64  Int64
─────┼──────────────
   1 │     1     11
   2 │     2     12
   3 │     3     13
   4 │     4     14

julia&gt; collect(eachcol(df))
2-element Vector{AbstractVector}:
 [1, 2, 3, 4]
 [11, 12, 13, 14]

julia&gt; map(eachcol(df)) do col
           maximum(col) - minimum(col)
       end
2-element Vector{Int64}:
 3
 3

julia&gt; sum.(eachcol(df))
2-element Vector{Int64}:
 10
 50</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/a1f75b1dd155265e5767e1e3f64d70be824859d7/src/abstractdataframe/iteration.jl#L190-L237">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.eachrow" href="#Base.eachrow"><code>Base.eachrow</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">eachrow(df::AbstractDataFrame)</code></pre><p>Return a <code>DataFrameRows</code> that iterates a data frame row by row, with each row represented as a <code>DataFrameRow</code>.</p><p>Because <code>DataFrameRow</code>s have an <code>eltype</code> of <code>Any</code>, use <code>copy(dfr::DataFrameRow)</code> to obtain a named tuple, which supports iteration and property access like a <code>DataFrameRow</code>, but also passes information on the <code>eltypes</code> of the columns of <code>df</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; df = DataFrame(x=1:4, y=11:14)
4×2 DataFrame
 Row │ x      y
     │ Int64  Int64
─────┼──────────────
   1 │     1     11
   2 │     2     12
   3 │     3     13
   4 │     4     14

julia&gt; eachrow(df)
4×2 DataFrameRows
 Row │ x      y
     │ Int64  Int64
─────┼──────────────
   1 │     1     11
   2 │     2     12
   3 │     3     13
   4 │     4     14

julia&gt; copy.(eachrow(df))
4-element Vector{NamedTuple{(:x, :y), Tuple{Int64, Int64}}}:
 (x = 1, y = 11)
 (x = 2, y = 12)
 (x = 3, y = 13)
 (x = 4, y = 14)

julia&gt; eachrow(view(df, [4, 3], [2, 1]))
2×2 DataFrameRows
 Row │ y      x
     │ Int64  Int64
─────┼──────────────
   1 │    14      4
   2 │    13      3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/a1f75b1dd155265e5767e1e3f64d70be824859d7/src/abstractdataframe/iteration.jl#L27-L74">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.values" href="#Base.values"><code>Base.values</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">values(dfc::DataFrameColumns)</code></pre><p>Get a vector of columns from <code>dfc</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/a1f75b1dd155265e5767e1e3f64d70be824859d7/src/abstractdataframe/iteration.jl#L294-L298">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.pairs" href="#Base.pairs"><code>Base.pairs</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pairs(dfc::DataFrameColumns)</code></pre><p>Return an iterator of pairs associating the name of each column of <code>dfc</code> with the corresponding column vector, i.e. <code>name =&gt; col</code> where <code>name</code> is the column name of the column <code>col</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/a1f75b1dd155265e5767e1e3f64d70be824859d7/src/abstractdataframe/iteration.jl#L301-L307">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.Iterators.partition" href="#Base.Iterators.partition"><code>Base.Iterators.partition</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Iterators.partition(df::AbstractDataFrame, n::Integer)</code></pre><p>Iterate over <code>df</code> data frame <code>n</code> rows at a time, returning each block as a <code>SubDataFrame</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; collect(Iterators.partition(DataFrame(x=1:5), 2))
3-element Vector{SubDataFrame{DataFrame, DataFrames.Index, UnitRange{Int64}}}:
 2×1 SubDataFrame
 Row │ x
     │ Int64
─────┼───────
   1 │     1
   2 │     2
 2×1 SubDataFrame
 Row │ x
     │ Int64
─────┼───────
   1 │     3
   2 │     4
 1×1 SubDataFrame
 Row │ x
     │ Int64
─────┼───────
   1 │     5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/a1f75b1dd155265e5767e1e3f64d70be824859d7/src/abstractdataframe/abstractdataframe.jl#L3173-L3202">source</a></section><section><div><pre><code class="nohighlight hljs">Iterators.partition(dfr::DataFrameRows, n::Integer)</code></pre><p>Iterate over <code>DataFrameRows</code> <code>dfr</code> <code>n</code> rows at a time, returning each block as a <code>DataFrameRows</code> over a view of rows of parent of <code>dfr</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; collect(Iterators.partition(eachrow(DataFrame(x=1:5)), 2))
3-element Vector{DataFrames.DataFrameRows{SubDataFrame{DataFrame, DataFrames.Index, UnitRange{Int64}}}}:
 2×1 DataFrameRows
 Row │ x     
     │ Int64 
─────┼───────
   1 │     1
   2 │     2
 2×1 DataFrameRows
 Row │ x     
     │ Int64 
─────┼───────
   1 │     3
   2 │     4
 1×1 DataFrameRows
 Row │ x     
     │ Int64 
─────┼───────
   1 │     5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/a1f75b1dd155265e5767e1e3f64d70be824859d7/src/abstractdataframe/iteration.jl#L98-L127">source</a></section></article><h2 id="Equality"><a class="docs-heading-anchor" href="#Equality">Equality</a><a id="Equality-1"></a><a class="docs-heading-anchor-permalink" href="#Equality" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Base.isapprox" href="#Base.isapprox"><code>Base.isapprox</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">isapprox(df1::AbstractDataFrame, df2::AbstractDataFrame;
         rtol::Real=atol&gt;0 ? 0 : √eps, atol::Real=0,
         nans::Bool=false, norm::Function=norm)</code></pre><p>Inexact equality comparison. <code>df1</code> and <code>df2</code> must have the same size and column names. Return  <code>true</code> if <code>isapprox</code> with given keyword arguments applied to all pairs of columns stored in <code>df1</code> and <code>df2</code> returns <code>true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/a1f75b1dd155265e5767e1e3f64d70be824859d7/src/abstractdataframe/abstractdataframe.jl#L490-L498">source</a></section></article><h2 id="Metadata"><a class="docs-heading-anchor" href="#Metadata">Metadata</a><a id="Metadata-1"></a><a class="docs-heading-anchor-permalink" href="#Metadata" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="DataAPI.metadata" href="#DataAPI.metadata"><code>DataAPI.metadata</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">metadata(df::AbstractDataFrame, key::AbstractString, [default]; style::Bool=false)
metadata(dfr::DataFrameRow, key::AbstractString, [default]; style::Bool=false)
metadata(dfc::DataFrameColumns, key::AbstractString, [default]; style::Bool=false)
metadata(dfr::DataFrameRows, key::AbstractString, [default]; style::Bool=false)</code></pre><p>Return table-level metadata value associated with <code>df</code> for key <code>key</code>. If <code>style=true</code> return a tuple of metadata value and metadata style.</p><p><code>SubDataFrame</code> and <code>DataFrameRow</code> expose only <code>:note</code>-style metadata of their parent.</p><p>If <code>default</code> is passed then return it if <code>key</code> does not exist; if <code>style=true</code> return <code>(default, :default)</code>.</p><p>See also: <a href="#DataAPI.metadatakeys"><code>metadatakeys</code></a>, <a href="#DataAPI.metadata!"><code>metadata!</code></a>, <a href="#DataAPI.deletemetadata!"><code>deletemetadata!</code></a>, <a href="#DataAPI.emptymetadata!"><code>emptymetadata!</code></a>, <a href="#DataAPI.colmetadata"><code>colmetadata</code></a>, <a href="#DataAPI.colmetadatakeys"><code>colmetadatakeys</code></a>, <a href="#DataAPI.colmetadata!"><code>colmetadata!</code></a>, <a href="#DataAPI.deletecolmetadata!"><code>deletecolmetadata!</code></a>, <a href="#DataAPI.emptycolmetadata!"><code>emptycolmetadata!</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; df = DataFrame(a=1, b=2);

julia&gt; metadatakeys(df)
()

julia&gt; metadata!(df, &quot;name&quot;, &quot;example&quot;, style=:note);

julia&gt; metadatakeys(df)
KeySet for a Dict{String, Tuple{Any, Any}} with 1 entry. Keys:
  &quot;name&quot;

julia&gt; metadata(df, &quot;name&quot;)
&quot;example&quot;

julia&gt; metadata(df, &quot;name&quot;, style=true)
(&quot;example&quot;, :note)

julia&gt; deletemetadata!(df, &quot;name&quot;);

julia&gt; metadatakeys(df)
()</code></pre><p>```</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/a1f75b1dd155265e5767e1e3f64d70be824859d7/src/other/metadata.jl#L79-L101">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataAPI.metadatakeys" href="#DataAPI.metadatakeys"><code>DataAPI.metadatakeys</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">metadatakeys(df::AbstractDataFrame)
metadatakeys(dfr::DataFrameRow)
metadatakeys(dfc::DataFrameColumns)
metadatakeys(dfr::DataFrameRows)</code></pre><p>Return an iterator of table-level metadata keys which are set in the object.</p><p>Values can be accessed using <a href="#DataAPI.metadata"><code>metadata(df, key)</code></a>.</p><p><code>SubDataFrame</code> and <code>DataFrameRow</code> expose only <code>:note</code>-style metadata keys of their parent.</p><p>See also: <a href="#DataAPI.metadata"><code>metadata</code></a>, <a href="#DataAPI.metadata!"><code>metadata!</code></a>, <a href="#DataAPI.deletemetadata!"><code>deletemetadata!</code></a>, <a href="#DataAPI.emptymetadata!"><code>emptymetadata!</code></a>, <a href="#DataAPI.colmetadata"><code>colmetadata</code></a>, <a href="#DataAPI.colmetadatakeys"><code>colmetadatakeys</code></a>, <a href="#DataAPI.colmetadata!"><code>colmetadata!</code></a>, <a href="#DataAPI.deletecolmetadata!"><code>deletecolmetadata!</code></a>, <a href="#DataAPI.emptycolmetadata!"><code>emptycolmetadata!</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; df = DataFrame(a=1, b=2);

julia&gt; metadatakeys(df)
()

julia&gt; metadata!(df, &quot;name&quot;, &quot;example&quot;, style=:note);

julia&gt; metadatakeys(df)
KeySet for a Dict{String, Tuple{Any, Any}} with 1 entry. Keys:
  &quot;name&quot;

julia&gt; metadata(df, &quot;name&quot;)
&quot;example&quot;

julia&gt; metadata(df, &quot;name&quot;, style=true)
(&quot;example&quot;, :note)

julia&gt; deletemetadata!(df, &quot;name&quot;);

julia&gt; metadatakeys(df)
()</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/a1f75b1dd155265e5767e1e3f64d70be824859d7/src/other/metadata.jl#L131-L150">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataAPI.metadata!" href="#DataAPI.metadata!"><code>DataAPI.metadata!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">metadata!(df::AbstractDataFrame, key::AbstractString, value; style::Symbol=:default)
metadata!(dfr::DataFrameRow, key::AbstractString, value; style::Symbol=:default)
metadata!(dfc::DataFrameColumns, key::AbstractString, value; style::Symbol=:default)
metadata!(dfr::DataFrameRows, key::AbstractString, value; style::Symbol=:default)</code></pre><p>Set table-level metadata for object <code>df</code> for key <code>key</code> to have value <code>value</code> and style <code>style</code> (<code>:default</code> by default) and return <code>df</code>.</p><p>For <code>SubDataFrame</code> and <code>DataFrameRow</code> only <code>:note</code>-style is allowed. Trying to set a key-value pair for which the key already exists in the parent data frame with another style throws an error.</p><p>See also: <a href="#DataAPI.metadata"><code>metadata</code></a>, <a href="#DataAPI.metadatakeys"><code>metadatakeys</code></a>, <a href="#DataAPI.deletemetadata!"><code>deletemetadata!</code></a>, <a href="#DataAPI.emptymetadata!"><code>emptymetadata!</code></a>, <a href="#DataAPI.colmetadata"><code>colmetadata</code></a>, <a href="#DataAPI.colmetadatakeys"><code>colmetadatakeys</code></a>, <a href="#DataAPI.colmetadata!"><code>colmetadata!</code></a>, <a href="#DataAPI.deletecolmetadata!"><code>deletecolmetadata!</code></a>, <a href="#DataAPI.emptycolmetadata!"><code>emptycolmetadata!</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; df = DataFrame(a=1, b=2);

julia&gt; metadatakeys(df)
()

julia&gt; metadata!(df, &quot;name&quot;, &quot;example&quot;, style=:note);

julia&gt; metadatakeys(df)
KeySet for a Dict{String, Tuple{Any, Any}} with 1 entry. Keys:
  &quot;name&quot;

julia&gt; metadata(df, &quot;name&quot;)
&quot;example&quot;

julia&gt; metadata(df, &quot;name&quot;, style=true)
(&quot;example&quot;, :note)

julia&gt; deletemetadata!(df, &quot;name&quot;);

julia&gt; metadatakeys(df)
()</code></pre><p>```</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/a1f75b1dd155265e5767e1e3f64d70be824859d7/src/other/metadata.jl#L170-L190">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataAPI.deletemetadata!" href="#DataAPI.deletemetadata!"><code>DataAPI.deletemetadata!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">deletemetadata!(df::AbstractDataFrame, key::AbstractString)
deletemetadata!(dfr::DataFrameRow, key::AbstractString)
deletemetadata!(dfc::DataFrameColumns, key::AbstractString)
deletemetadata!(dfr::DataFrameRows, key::AbstractString)</code></pre><p>Delete table-level metadata from object <code>df</code> for key <code>key</code> and return <code>df</code>. If key does not exist, return <code>df</code> without modification.</p><p>For <code>SubDataFrame</code> and <code>DataFrameRow</code> only <code>:note</code>-style metadata from their parent can be deleted (as other styles are not propagated to views).</p><p>See also: <a href="#DataAPI.metadata"><code>metadata</code></a>, <a href="#DataAPI.metadatakeys"><code>metadatakeys</code></a>, <a href="#DataAPI.metadata!"><code>metadata!</code></a>, <a href="#DataAPI.emptymetadata!"><code>emptymetadata!</code></a>, <a href="#DataAPI.colmetadata"><code>colmetadata</code></a>, <a href="#DataAPI.colmetadatakeys"><code>colmetadatakeys</code></a>, <a href="#DataAPI.colmetadata!"><code>colmetadata!</code></a>, <a href="#DataAPI.deletecolmetadata!"><code>deletecolmetadata!</code></a>, <a href="#DataAPI.emptycolmetadata!"><code>emptycolmetadata!</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; df = DataFrame(a=1, b=2);

julia&gt; metadatakeys(df)
()

julia&gt; metadata!(df, &quot;name&quot;, &quot;example&quot;, style=:note);

julia&gt; metadatakeys(df)
KeySet for a Dict{String, Tuple{Any, Any}} with 1 entry. Keys:
  &quot;name&quot;

julia&gt; metadata(df, &quot;name&quot;)
&quot;example&quot;

julia&gt; metadata(df, &quot;name&quot;, style=true)
(&quot;example&quot;, :note)

julia&gt; deletemetadata!(df, &quot;name&quot;);

julia&gt; metadatakeys(df)
()</code></pre><p>```</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/a1f75b1dd155265e5767e1e3f64d70be824859d7/src/other/metadata.jl#L230-L249">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataAPI.emptymetadata!" href="#DataAPI.emptymetadata!"><code>DataAPI.emptymetadata!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">emptymetadata!(df::AbstractDataFrame)
emptymetadata!(dfr::DataFrameRow)
emptymetadata!(dfc::DataFrameColumns)
emptymetadata!(dfr::DataFrameRows)</code></pre><p>Delete all table-level metadata from object <code>df</code>.</p><p>For <code>SubDataFrame</code> and <code>DataFrameRow</code> only <code>:note</code>-style metadata from their parent can be deleted (as other styles are not propagated to views).</p><p>See also: <a href="#DataAPI.metadata"><code>metadata</code></a>, <a href="#DataAPI.metadatakeys"><code>metadatakeys</code></a>, <a href="#DataAPI.metadata!"><code>metadata!</code></a>, <a href="#DataAPI.deletemetadata!"><code>deletemetadata!</code></a>, <a href="#DataAPI.colmetadata"><code>colmetadata</code></a>, <a href="#DataAPI.colmetadatakeys"><code>colmetadatakeys</code></a>, <a href="#DataAPI.colmetadata!"><code>colmetadata!</code></a>, <a href="#DataAPI.deletecolmetadata!"><code>deletecolmetadata!</code></a>, <a href="#DataAPI.emptycolmetadata!"><code>emptycolmetadata!</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; df = DataFrame(a=1, b=2);

julia&gt; metadatakeys(df)
()

julia&gt; metadata!(df, &quot;name&quot;, &quot;example&quot;, style=:note);

julia&gt; metadatakeys(df)
KeySet for a Dict{String, Tuple{Any, Any}} with 1 entry. Keys:
  &quot;name&quot;

julia&gt; metadata(df, &quot;name&quot;)
&quot;example&quot;

julia&gt; metadata(df, &quot;name&quot;, style=true)
(&quot;example&quot;, :note)

julia&gt; emptymetadata!(df);

julia&gt; metadatakeys(df)
()</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/a1f75b1dd155265e5767e1e3f64d70be824859d7/src/other/metadata.jl#L277-L318">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataAPI.colmetadata" href="#DataAPI.colmetadata"><code>DataAPI.colmetadata</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">colmetadata(df::AbstractDataFrame, col::ColumnIndex, key::AbstractString, [default]; style::Bool=false)
colmetadata(dfr::DataFrameRow, col::ColumnIndex, key::AbstractString, [default]; style::Bool=false)
colmetadata(dfc::DataFrameColumns, col::ColumnIndex, key::AbstractString, [default]; style::Bool=false)
colmetadata(dfr::DataFrameRows, col::ColumnIndex, key::AbstractString, [default]; style::Bool=false)</code></pre><p>Return column-level metadata value associated with <code>df</code> for column <code>col</code> and key <code>key</code>.</p><p><code>SubDataFrame</code> and <code>DataFrameRow</code> expose only <code>:note</code>-style metadata of their parent.</p><p>If <code>default</code> is passed then return it if <code>key</code> does not exist for column <code>col</code>; if <code>style=true</code> return <code>(default, :default)</code>. If <code>col</code> does not exist in <code>df</code> always throw an error.</p><p>See also: <a href="#DataAPI.metadata"><code>metadata</code></a>, <a href="#DataAPI.metadatakeys"><code>metadatakeys</code></a>, <a href="#DataAPI.metadata!"><code>metadata!</code></a>, <a href="#DataAPI.deletemetadata!"><code>deletemetadata!</code></a>, <a href="#DataAPI.emptymetadata!"><code>emptymetadata!</code></a>, <a href="#DataAPI.colmetadatakeys"><code>colmetadatakeys</code></a>, <a href="#DataAPI.colmetadata!"><code>colmetadata!</code></a>, <a href="#DataAPI.deletecolmetadata!"><code>deletecolmetadata!</code></a>, <a href="#DataAPI.emptycolmetadata!"><code>emptycolmetadata!</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; df = DataFrame(a=1, b=2);

julia&gt; colmetadatakeys(df)
()

julia&gt; colmetadata!(df, :a, &quot;name&quot;, &quot;example&quot;, style=:note);

julia&gt; collect(colmetadatakeys(df))
1-element Vector{Pair{Symbol, Base.KeySet{String, Dict{String, Tuple{Any, Any}}}}}:
 :a =&gt; [&quot;name&quot;]

julia&gt; colmetadatakeys(df, :a)
KeySet for a Dict{String, Tuple{Any, Any}} with 1 entry. Keys:
  &quot;name&quot;

julia&gt; colmetadata(df, :a, &quot;name&quot;)
&quot;example&quot;

julia&gt; colmetadata(df, :a, &quot;name&quot;, style=true)
(&quot;example&quot;, :note)

julia&gt; deletecolmetadata!(df, :a, &quot;name&quot;);

julia&gt; colmetadatakeys(df)
()</code></pre><p>```</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/a1f75b1dd155265e5767e1e3f64d70be824859d7/src/other/metadata.jl#L338-L359">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataAPI.colmetadatakeys" href="#DataAPI.colmetadatakeys"><code>DataAPI.colmetadatakeys</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">colmetadatakeys(df::AbstractDataFrame, [col::ColumnIndex])
colmetadatakeys(dfr::DataFrameRow, [col::ColumnIndex])
colmetadatakeys(dfc::DataFrameColumns, [col::ColumnIndex])
colmetadatakeys(dfr::DataFrameRows, [col::ColumnIndex])</code></pre><p>If <code>col</code> is passed return an iterator of column-level metadata keys which are set for column <code>col</code>. If <code>col</code> is not passed return an iterator of <code>col =&gt; colmetadatakeys(x, col)</code> pairs for all columns that have metadata, where <code>col</code> are <code>Symbol</code>.</p><p>Values can be accessed using <a href="#DataAPI.colmetadata"><code>colmetadata(df, col, key)</code></a>.</p><p><code>SubDataFrame</code> and <code>DataFrameRow</code> expose only <code>:note</code>-style metadata of their parent.</p><p>See also: <a href="#DataAPI.metadata"><code>metadata</code></a>, <a href="#DataAPI.metadatakeys"><code>metadatakeys</code></a>, <a href="#DataAPI.metadata!"><code>metadata!</code></a>, <a href="#DataAPI.deletemetadata!"><code>deletemetadata!</code></a>, <a href="#DataAPI.emptymetadata!"><code>emptymetadata!</code></a>, <a href="#DataAPI.colmetadata"><code>colmetadata</code></a>, <a href="#DataAPI.colmetadata!"><code>colmetadata!</code></a>, <a href="#DataAPI.deletecolmetadata!"><code>deletecolmetadata!</code></a>, <a href="#DataAPI.emptycolmetadata!"><code>emptycolmetadata!</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; df = DataFrame(a=1, b=2);

julia&gt; colmetadatakeys(df)
()

julia&gt; colmetadata!(df, :a, &quot;name&quot;, &quot;example&quot;, style=:note);

julia&gt; collect(colmetadatakeys(df))
1-element Vector{Pair{Symbol, Base.KeySet{String, Dict{String, Tuple{Any, Any}}}}}:
 :a =&gt; [&quot;name&quot;]

julia&gt; colmetadatakeys(df, :a)
KeySet for a Dict{String, Tuple{Any, Any}} with 1 entry. Keys:
  &quot;name&quot;

julia&gt; colmetadata(df, :a, &quot;name&quot;)
&quot;example&quot;

julia&gt; colmetadata(df, :a, &quot;name&quot;, style=true)
(&quot;example&quot;, :note)

julia&gt; deletecolmetadata!(df, :a, &quot;name&quot;);

julia&gt; colmetadatakeys(df)
()</code></pre><p>```</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/a1f75b1dd155265e5767e1e3f64d70be824859d7/src/other/metadata.jl#L403-L425">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataAPI.colmetadata!" href="#DataAPI.colmetadata!"><code>DataAPI.colmetadata!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">colmetadata!(df::AbstractDataFrame, col::ColumnIndex, key::AbstractString, value; style::Symbol=:default)
colmetadata!(dfr::DataFrameRow, col::ColumnIndex, key::AbstractString, value; style::Symbol=:default)
colmetadata!(dfc::DataFrameColumns, col::ColumnIndex, key::AbstractString, value; style::Symbol=:default)
colmetadata!(dfr::DataFrameRows, col::ColumnIndex, key::AbstractString, value; style::Symbol=:default)</code></pre><p>Set column-level metadata in <code>df</code> for column <code>col</code> and key <code>key</code> to have value <code>value</code> and style <code>style</code> (<code>:default</code> by default) and return <code>df</code>.</p><p>For <code>SubDataFrame</code> and <code>DataFrameRow</code> only <code>:note</code> style is allowed. Trying to set a key-value pair for which the key already exists in the parent data frame with another style throws an error.</p><p>See also: <a href="#DataAPI.metadata"><code>metadata</code></a>, <a href="#DataAPI.metadatakeys"><code>metadatakeys</code></a>, <a href="#DataAPI.metadata!"><code>metadata!</code></a>, <a href="#DataAPI.deletemetadata!"><code>deletemetadata!</code></a>, <a href="#DataAPI.emptymetadata!"><code>emptymetadata!</code></a>, <a href="#DataAPI.colmetadata"><code>colmetadata</code></a>, <a href="#DataAPI.colmetadatakeys"><code>colmetadatakeys</code></a>, <a href="#DataAPI.deletecolmetadata!"><code>deletecolmetadata!</code></a>, <a href="#DataAPI.emptycolmetadata!"><code>emptycolmetadata!</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; df = DataFrame(a=1, b=2);

julia&gt; colmetadatakeys(df)
()

julia&gt; colmetadata!(df, :a, &quot;name&quot;, &quot;example&quot;, style=:note);

julia&gt; collect(colmetadatakeys(df))
1-element Vector{Pair{Symbol, Base.KeySet{String, Dict{String, Tuple{Any, Any}}}}}:
 :a =&gt; [&quot;name&quot;]

julia&gt; colmetadatakeys(df, :a)
KeySet for a Dict{String, Tuple{Any, Any}} with 1 entry. Keys:
  &quot;name&quot;

julia&gt; colmetadata(df, :a, &quot;name&quot;)
&quot;example&quot;

julia&gt; colmetadata(df, :a, &quot;name&quot;, style=true)
(&quot;example&quot;, :note)

julia&gt; deletecolmetadata!(df, :a, &quot;name&quot;);

julia&gt; colmetadatakeys(df)
()</code></pre><p>```</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/a1f75b1dd155265e5767e1e3f64d70be824859d7/src/other/metadata.jl#L467-L487">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataAPI.deletecolmetadata!" href="#DataAPI.deletecolmetadata!"><code>DataAPI.deletecolmetadata!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">deletecolmetadata!(df::AbstractDataFrame, col::ColumnIndex, key::AbstractString)
deletecolmetadata!(dfr::DataFrameRow, col::ColumnIndex, key::AbstractString)
deletecolmetadata!(dfc::DataFrameColumns, col::ColumnIndex, key::AbstractString)
deletecolmetadata!(dfr::DataFrameRows, col::ColumnIndex, key::AbstractString)</code></pre><p>Delete column-level metadata set in <code>df</code> for column <code>col</code> and key <code>key</code> and return <code>df</code>.</p><p>For <code>SubDataFrame</code> and <code>DataFrameRow</code> only <code>:note</code>-style metadata from their parent can be deleted (as other styles are not propagated to views).</p><p>See also: <a href="#DataAPI.metadata"><code>metadata</code></a>, <a href="#DataAPI.metadatakeys"><code>metadatakeys</code></a>, <a href="#DataAPI.metadata!"><code>metadata!</code></a>, <a href="#DataAPI.deletemetadata!"><code>deletemetadata!</code></a>, <a href="#DataAPI.emptymetadata!"><code>emptymetadata!</code></a>, <a href="#DataAPI.colmetadata"><code>colmetadata</code></a>, <a href="#DataAPI.colmetadatakeys"><code>colmetadatakeys</code></a>, <a href="#DataAPI.colmetadata!"><code>colmetadata!</code></a>, <a href="#DataAPI.emptycolmetadata!"><code>emptycolmetadata!</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; df = DataFrame(a=1, b=2);

julia&gt; colmetadatakeys(df)
()

julia&gt; colmetadata!(df, :a, &quot;name&quot;, &quot;example&quot;, style=:note);

julia&gt; collect(colmetadatakeys(df))
1-element Vector{Pair{Symbol, Base.KeySet{String, Dict{String, Tuple{Any, Any}}}}}:
 :a =&gt; [&quot;name&quot;]

julia&gt; colmetadatakeys(df, :a)
KeySet for a Dict{String, Tuple{Any, Any}} with 1 entry. Keys:
  &quot;name&quot;

julia&gt; colmetadata(df, :a, &quot;name&quot;)
&quot;example&quot;

julia&gt; colmetadata(df, :a, &quot;name&quot;, style=true)
(&quot;example&quot;, :note)

julia&gt; deletecolmetadata!(df, :a, &quot;name&quot;);

julia&gt; colmetadatakeys(df)
()</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/a1f75b1dd155265e5767e1e3f64d70be824859d7/src/other/metadata.jl#L534-L551">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataAPI.emptycolmetadata!" href="#DataAPI.emptycolmetadata!"><code>DataAPI.emptycolmetadata!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">emptycolmetadata!(df::AbstractDataFrame, [col::ColumnIndex])
emptycolmetadata!(dfr::DataFrameRow, [col::ColumnIndex])
emptycolmetadata!(dfc::DataFrameColumns, [col::ColumnIndex])
emptycolmetadata!(dfr::DataFrameRows, [col::ColumnIndex])</code></pre><p>Delete column-level metadata set in <code>df</code> for column <code>col</code> and key <code>key</code> and return <code>df</code>.</p><p>For <code>SubDataFrame</code> and <code>DataFrameRow</code> only <code>:note</code>-style metadata from their parent can be deleted (as other styles are not propagated to views).</p><p>See also: <a href="#DataAPI.metadata"><code>metadata</code></a>, <a href="#DataAPI.metadatakeys"><code>metadatakeys</code></a>, <a href="#DataAPI.metadata!"><code>metadata!</code></a>, <a href="#DataAPI.deletemetadata!"><code>deletemetadata!</code></a>, <a href="#DataAPI.emptymetadata!"><code>emptymetadata!</code></a>, <a href="#DataAPI.colmetadata"><code>colmetadata</code></a>, <a href="#DataAPI.colmetadatakeys"><code>colmetadatakeys</code></a>, <a href="#DataAPI.colmetadata!"><code>colmetadata!</code></a>, <a href="#DataAPI.deletecolmetadata!"><code>deletecolmetadata!</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; df = DataFrame(a=1, b=2);

julia&gt; colmetadata!(df, :a, &quot;name&quot;, &quot;example&quot;, style=:note);

julia&gt; collect(colmetadatakeys(df))
1-element Vector{Pair{Symbol, Base.KeySet{String, Dict{String, Tuple{Any, Any}}}}}:
 :a =&gt; [&quot;name&quot;]

julia&gt; colmetadatakeys(df, :a)
KeySet for a Dict{String, Tuple{Any, Any}} with 1 entry. Keys:
  &quot;name&quot;

julia&gt; colmetadata(df, :a, &quot;name&quot;)
&quot;example&quot;

julia&gt; colmetadata(df, :a, &quot;name&quot;, style=true)
(&quot;example&quot;, :note)

julia&gt; emptycolmetadata!(df, :a);

julia&gt; colmetadatakeys(df)
()</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/a1f75b1dd155265e5767e1e3f64d70be824859d7/src/other/metadata.jl#L586-L628">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../types/">« Types</a><a class="docs-footer-nextpage" href="../indexing/">Indexing »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Sunday 25 June 2023 08:38">Sunday 25 June 2023</span>. Using Julia version 1.9.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
