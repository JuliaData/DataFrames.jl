<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Metadata · DataFrames.jl</title><meta name="title" content="Metadata · DataFrames.jl"/><meta property="og:title" content="Metadata · DataFrames.jl"/><meta property="twitter:title" content="Metadata · DataFrames.jl"/><meta name="description" content="Documentation for DataFrames.jl."/><meta property="og:description" content="Documentation for DataFrames.jl."/><meta property="twitter:description" content="Documentation for DataFrames.jl."/><meta property="og:url" content="https://juliadata.github.io/DataFrames.jl/stable/lib/metadata/"/><meta property="twitter:url" content="https://juliadata.github.io/DataFrames.jl/stable/lib/metadata/"/><link rel="canonical" href="https://juliadata.github.io/DataFrames.jl/stable/lib/metadata/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="DataFrames.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">DataFrames.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><a class="tocitem" href="../../man/basics/">First Steps with DataFrames.jl</a></li><li><span class="tocitem">User Guide</span><ul><li><a class="tocitem" href="../../man/getting_started/">Getting Started</a></li><li><a class="tocitem" href="../../man/working_with_dataframes/">Working with DataFrames</a></li><li><a class="tocitem" href="../../man/importing_and_exporting/">Importing and Exporting Data (I/O)</a></li><li><a class="tocitem" href="../../man/joins/">Joins</a></li><li><a class="tocitem" href="../../man/split_apply_combine/">Split-apply-combine</a></li><li><a class="tocitem" href="../../man/reshaping_and_pivoting/">Reshaping</a></li><li><a class="tocitem" href="../../man/sorting/">Sorting</a></li><li><a class="tocitem" href="../../man/categorical/">Categorical Data</a></li><li><a class="tocitem" href="../../man/missing/">Missing Data</a></li><li><a class="tocitem" href="../../man/querying_frameworks/">Data manipulation frameworks</a></li><li><a class="tocitem" href="../../man/comparisons/">Comparison with Python/R/Stata</a></li></ul></li><li><span class="tocitem">API</span><ul><li><a class="tocitem" href="../types/">Types</a></li><li><a class="tocitem" href="../functions/">Functions</a></li><li><a class="tocitem" href="../indexing/">Indexing</a></li><li class="is-active"><a class="tocitem" href>Metadata</a><ul class="internal"><li><a class="tocitem" href="#Design-of-metadata-support"><span>Design of metadata support</span></a></li><li><a class="tocitem" href="#Examples"><span>Examples</span></a></li><li><a class="tocitem" href="#Propagation-of-:note-style-metadata"><span>Propagation of <code>:note</code>-style metadata</span></a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">API</a></li><li class="is-active"><a href>Metadata</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Metadata</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaData/DataFrames.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaData/DataFrames.jl/blob/main/docs/src/lib/metadata.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Metadata"><a class="docs-heading-anchor" href="#Metadata">Metadata</a><a id="Metadata-1"></a><a class="docs-heading-anchor-permalink" href="#Metadata" title="Permalink"></a></h1><h2 id="Design-of-metadata-support"><a class="docs-heading-anchor" href="#Design-of-metadata-support">Design of metadata support</a><a id="Design-of-metadata-support-1"></a><a class="docs-heading-anchor-permalink" href="#Design-of-metadata-support" title="Permalink"></a></h2><p>DataFrames.jl allows you to store and retrieve metadata on table and column level. This is supported using the functions defined by the DataAPI.jl interface:</p><ul><li>for table-level metadata: <a href="../functions/#DataAPI.metadata"><code>metadata</code></a>, <a href="../functions/#DataAPI.metadatakeys"><code>metadatakeys</code></a>, <a href="../functions/#DataAPI.metadata!"><code>metadata!</code></a>, <a href="../functions/#DataAPI.deletemetadata!"><code>deletemetadata!</code></a>, <a href="../functions/#DataAPI.emptymetadata!"><code>emptymetadata!</code></a>;</li><li>for column-level metadata: <a href="../functions/#DataAPI.colmetadata"><code>colmetadata</code></a>, <a href="../functions/#DataAPI.colmetadatakeys"><code>colmetadatakeys</code></a>, <a href="../functions/#DataAPI.colmetadata!"><code>colmetadata!</code></a>, <a href="../functions/#DataAPI.deletecolmetadata!"><code>deletecolmetadata!</code></a>, <a href="../functions/#DataAPI.emptycolmetadata!"><code>emptycolmetadata!</code></a>.</li></ul><p>Additionally you might find the <a href="https://github.com/JuliaData/TableMetadataTools.jl">TableMetadataTools.jl</a> package useful. This package defines several convenience functions for performing typical metadata operations.</p><p>Assume that we work with a data frame-like object <code>df</code> that has a column <code>col</code> (referred to either via a <code>Symbol</code>, a string or an integer index).</p><p>Table-level metadata are key-value pairs that are attached to <code>df</code>. Column-level metadata are key-value pairs that are attached to a specific column <code>col</code> of <code>df</code> data frame.</p><p>To check whether some key <code>key</code> is present in table-level metadata of data frame <code>df</code> you can write <code>key in metadatakeys(df)</code>. Similarly to check whether key <code>key</code> is present in column-level metadata of data frame <code>df</code> for column <code>col</code> write <code>key in colmetadatakeys(df, col)</code>.</p><p>Additionally each metadata key-value pair has a style information attached to it. In DataFrames.jl the metadata style influences how metadata is propagated when <code>df</code> is transformed. The following metadata styles are supported:</p><ul><li><code>:default</code>: Metadata having this style is considered to be attached to a concrete state of <code>df</code>. This means that any operation on this data frame invalidates such metadata and it is dropped in the result of such operation. Note that this happens even if the operation eventually does not change the data frame: the rule is that calling a function that might alter a data frame drops such metadata; in this way it is possible to statically determine whether metadata of styles other than <code>:note</code> is dropped after a function call. Only two functions are exceptions that keep non-<code>:note</code>-style metadata, as these operations are specifically designed to create an identical copy of the source data frame:<ul><li><a href="../types/#DataFrames.DataFrame"><code>DataFrame</code></a> constructor;</li><li><a href="../functions/#Base.copy"><code>copy</code></a> of a data frame;</li></ul></li><li><code>:note</code>: Metadata having this style is considered to be an annotation of a table or a column that should be propagated under transformations (exact propagation rules of such metadata are described below).</li><li>All other metadata styles are allowed but they are currently treated as having <code>:default</code>-style (this might change in the future if other standard metadata styles are defined).</li></ul><p>All DataAPI.jl metadata functions work with <a href="../types/#DataFrames.DataFrame"><code>DataFrame</code></a>, <a href="../types/#DataFrames.SubDataFrame"><code>SubDataFrame</code></a>, <a href="../types/#DataFrames.DataFrameRow"><code>DataFrameRow</code></a> objects, and objects returned by <a href="../functions/#Base.eachrow"><code>eachrow</code></a> and <a href="../functions/#Base.eachcol"><code>eachcol</code></a> functions. In this section collectively these objects will be called <em>data frame-like</em>, and follow the rules:</p><ul><li>objects returned by <a href="../functions/#Base.eachrow"><code>eachrow</code></a> and <a href="../functions/#Base.eachcol"><code>eachcol</code></a> functions have the same metadata as their parent <code>AbstractDataFrame</code>;</li><li><a href="../types/#DataFrames.SubDataFrame"><code>SubDataFrame</code></a> and <a href="../types/#DataFrames.DataFrameRow"><code>DataFrameRow</code></a> only expose metadata from their parent <code>DataFrame</code> whose style is <code>:note</code>.</li></ul><p>Notably, metadata is not supported for <a href="../types/#DataFrames.GroupedDataFrame"><code>GroupedDataFrame</code></a> and you can&#39;t add, modify, nor view metadata through the <a href="../types/#DataFrames.GroupedDataFrame"><code>GroupedDataFrame</code></a> itself. It is possible only through its <code>parent</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>DataFrames.jl allows users to extract out columns of a data frame and perform operations on them. Such operations will not affect metadata. Therefore, even if some metadata has <code>:default</code> style it might no longer correctly describe the column&#39;s contents if the user mutates columns directly.</p></div></div><h3 id="DataFrames.jl-specific-design-principles-for-use-of-metadata"><a class="docs-heading-anchor" href="#DataFrames.jl-specific-design-principles-for-use-of-metadata">DataFrames.jl-specific design principles for use of metadata</a><a id="DataFrames.jl-specific-design-principles-for-use-of-metadata-1"></a><a class="docs-heading-anchor-permalink" href="#DataFrames.jl-specific-design-principles-for-use-of-metadata" title="Permalink"></a></h3><p>DataFrames.jl supports storing any object as metadata values. However, it is recommended to use strings as values of the metadata, as some storage formats, like for example Apache Arrow, only support strings.</p><p>For all functions that operate on column-level metadata, an <code>ArgumentError</code> is thrown if passed column is not present in a data frame.</p><p>If <a href="../functions/#DataAPI.metadata!"><code>metadata!</code></a> or <a href="../functions/#DataAPI.colmetadata!"><code>colmetadata!</code></a> is used to add metadata to a <a href="../types/#DataFrames.SubDataFrame"><code>SubDataFrame</code></a> or a <a href="../types/#DataFrames.DataFrameRow"><code>DataFrameRow</code></a> then:</p><ul><li>using metadata that has style other than <code>:note</code> throws an error;</li><li>trying to add key-value pair for which a mapping for key already exists with style other than <code>:note</code> in the parent data frame throws an error.</li></ul><p>DataFrames.jl is designed so that there is no performance overhead due to metadata support when there is no metadata in a data frame. Therefore if you need maximum performance of operations that do not rely on metadata call <code>emptymetadata!</code> and <code>emptycolmetadata!</code> before running these operations.</p><p>Processing metadata for <code>SubDataFrame</code> and <code>DataFrameRow</code> has more overhead than for other types defined in DataFrames.jl that support metadata, because they have a more complex logic of handling it (they support only <code>:note</code>-style metadata, which means that other metadata needs to be filtered-out).</p><h2 id="Examples"><a class="docs-heading-anchor" href="#Examples">Examples</a><a id="Examples-1"></a><a class="docs-heading-anchor-permalink" href="#Examples" title="Permalink"></a></h2><p>Here is a simple example how you can work with metadata in DataFrames.jl:</p><pre><code class="language-julia-repl hljs">julia&gt; using DataFrames

julia&gt; df = DataFrame(name=[&quot;Jan Krzysztof Duda&quot;, &quot;Jan Krzysztof Duda&quot;,
                            &quot;Radosław Wojtaszek&quot;, &quot;Radosław Wojtaszek&quot;],
                      date=[&quot;2022-Jun&quot;, &quot;2021-Jun&quot;, &quot;2022-Jun&quot;, &quot;2021-Jun&quot;],
                      rating=[2750, 2729, 2708, 2687])
4×3 DataFrame
 Row │ name                date      rating
     │ String              String    Int64
─────┼──────────────────────────────────────
   1 │ Jan Krzysztof Duda  2022-Jun    2750
   2 │ Jan Krzysztof Duda  2021-Jun    2729
   3 │ Radosław Wojtaszek  2022-Jun    2708
   4 │ Radosław Wojtaszek  2021-Jun    2687

julia&gt; metadatakeys(df)
()

julia&gt; metadata!(df, &quot;caption&quot;, &quot;ELO ratings of chess players&quot;, style=:note);

julia&gt; collect(metadatakeys(df))
1-element Vector{String}:
 &quot;caption&quot;

julia&gt; &quot;caption&quot; in metadatakeys(df)
true

julia&gt; metadata(df, &quot;caption&quot;)
&quot;ELO ratings of chess players&quot;

julia&gt; metadata(df, &quot;caption&quot;, style=true)
(&quot;ELO ratings of chess players&quot;, :note)

julia&gt; emptymetadata!(df);

julia&gt; metadatakeys(df)
()

julia&gt; colmetadatakeys(df)
()

julia&gt; colmetadata!(df, :name, &quot;label&quot;, &quot;First and last name of a player&quot;, style=:note);

julia&gt; colmetadata!(df, :date, &quot;label&quot;, &quot;Rating date in yyyy-u format&quot;, style=:note);

julia&gt; colmetadata!(df, :rating, &quot;label&quot;, &quot;ELO rating in classical time control&quot;, style=:note);

julia&gt; &quot;label&quot; in colmetadatakeys(df, :rating)
true

julia&gt; colmetadata(df, :rating, &quot;label&quot;)
&quot;ELO rating in classical time control&quot;

julia&gt; colmetadata(df, :rating, &quot;label&quot;, style=true)
(&quot;ELO rating in classical time control&quot;, :note)

julia&gt; collect(colmetadatakeys(df))
3-element Vector{Pair{Symbol, Base.KeySet{String, Dict{String, Tuple{Any, Any}}}}}:
   :date =&gt; [&quot;label&quot;]
 :rating =&gt; [&quot;label&quot;]
   :name =&gt; [&quot;label&quot;]

julia&gt; [only(names(df, col)) =&gt;
        [key =&gt; colmetadata(df, col, key) for key in metakeys] for
        (col, metakeys) in colmetadatakeys(df)]
3-element Vector{Pair{String, Vector{Pair{String, String}}}}:
   &quot;date&quot; =&gt; [&quot;label&quot; =&gt; &quot;Rating date in yyyy-u format&quot;]
 &quot;rating&quot; =&gt; [&quot;label&quot; =&gt; &quot;ELO rating in classical time control&quot;]
   &quot;name&quot; =&gt; [&quot;label&quot; =&gt; &quot;First and last name of a player&quot;]

julia&gt; emptycolmetadata!(df);

julia&gt; colmetadatakeys(df)
()</code></pre><h2 id="Propagation-of-:note-style-metadata"><a class="docs-heading-anchor" href="#Propagation-of-:note-style-metadata">Propagation of <code>:note</code>-style metadata</a><a id="Propagation-of-:note-style-metadata-1"></a><a class="docs-heading-anchor-permalink" href="#Propagation-of-:note-style-metadata" title="Permalink"></a></h2><p>An important design feature of <code>:note</code>-style metadata is how it is handled when data frames are transformed.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The provided rules might slightly change in the future. Any change to <code>:note</code>-style metadata propagation rules will not be considered as breaking and can be done in any minor release of DataFrames.jl. Such changes might be made based on users&#39; feedback about what metadata propagation rules are most convenient in practice.</p></div></div><p>The general design rules for propagation of <code>:note</code>-style metadata are as follows.</p><p>For operations that take a single data frame as an input:</p><ul><li>Table level metadata is propagated to the returned data frame object.</li><li>For column-level metadata:<ul><li>in all cases when a single column is transformed to a single column and the name of the column does not change (or is automatically changed e.g. to de-duplicate column names or via column renaming in joins) column-level metadata is preserved (example operations of this kind are <code>getindex</code>, <code>subset</code>, joins, <code>mapcols</code>).</li><li>in all cases when a single column is transformed with <code>identity</code> or <code>copy</code> to a single column, column-level metadata is preserved even if column name is changed (example operations of this kind are <code>rename</code>, or the <code>:x =&gt; :y</code> or <code>:x =&gt; copy =&gt; :y</code> operation specification in <code>select</code>).</li></ul></li></ul><p>For operations that take multiple data frames as their input two cases are distinguished:</p><ul><li>When there is a natural main table in the operation (<code>append!</code>, <code>prepend!</code>, <code>leftjoin</code>, <code>leftjoin!</code>, <code>rightjoin</code>, <code>semijoin</code>, <code>antijoin</code>, <code>setindex!</code>):<ul><li>table-level metadata is taken from the main table;</li><li>column-level metadata for columns from the main table is taken from main table;</li><li>column-level metadata for columns from the non-main table is taken only for columns not present in the main table.</li></ul></li><li>When all tables are equivalent (<code>hcat</code>, <code>vcat</code>, <code>innerjoin</code>, <code>outerjoin</code>):<ul><li>table-level metadata is preserved only for keys which are defined in all passed tables and have the same value;</li><li>column-level metadata is preserved only for keys which are defined in all passed tables that contain this column and have the same value.</li></ul></li></ul><p>In all these operations when metadata is preserved the values in the key-value pairs are not copied (this is relevant in case of mutable values).</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The rules for column-level <code>:note</code>-style metadata propagation are designed to make the right decision in common cases. In particular, they assume that if source and target column name is the same then the metadata for the column is not changed. While this is valid for many operations, it is not always true in general. For example the <code>:x =&gt; ByRow(log) =&gt; :x</code> transformation might invalidate metadata if it contained unit of measure of the variable. In such cases user must either use a different name for the output column, set metadata style to <code>:default</code> before the operation, or manually drop or update such metadata from the <code>:x</code> column after the transformation.</p></div></div><h3 id="Operations-that-preserve-:note-style-metadata"><a class="docs-heading-anchor" href="#Operations-that-preserve-:note-style-metadata">Operations that preserve <code>:note</code>-style metadata</a><a id="Operations-that-preserve-:note-style-metadata-1"></a><a class="docs-heading-anchor-permalink" href="#Operations-that-preserve-:note-style-metadata" title="Permalink"></a></h3><p>Most of the functions in DataFrames.jl only preserve table and column metadata whose style is <code>:note</code>. Some functions use a more complex logic, even if they follow the general rules described above (in particular under any transformation all non-<code>:note</code>-style metadata is always dropped). These are:</p><ul><li><a href="../functions/#DataAPI.describe"><code>describe</code></a> drops all metadata.</li><li><a href="../functions/#Base.hcat"><code>hcat</code></a>: propagates table-level metadata only for keys which are defined in all passed tables and have the same value; column-level metadata is preserved.</li><li><a href="../functions/#Base.vcat"><code>vcat</code></a>: propagates table-level metadata only for keys which are defined in all passed tables and have the same value; column-level metadata is preserved only for keys which are defined in all passed tables that contain this column and have the same value;</li><li><a href="../functions/#Base.stack"><code>stack</code></a>: propagates table-level metadata and column-level metadata for identifier columns.</li><li><a href="../functions/#DataFrames.unstack"><code>unstack</code></a>: propagates table-level metadata and column-level metadata for row keys columns.</li><li><a href="../functions/#Base.permutedims"><code>permutedims</code></a>: propagates table-level metadata and drops column-level  metadata.</li><li>broadcasted assignment does not change target metadata; under Julia earlier than 1.7 operation of kind <code>df.a .= s</code> does not drop non-<code>:note</code>-style metadata; under Julia 1.7 or later this operation preserves only <code>:note</code>-style metadata</li><li>broadcasting propagates table-level metadata if some key is present in all passed data frames and value associated with it is identical in all passed data frames; column-level metadata is propagated for columns if some key for a given column is present in all passed data frames and value associated with it is identical in all passed data frames.</li><li><code>getindex</code> preserves table-level metadata and column-level metadata for selected columns</li><li><code>setindex!</code> does not affect table-level and column-level metadata</li><li><a href="../functions/#Base.push!"><code>push!</code></a>, <a href="../functions/#Base.pushfirst!"><code>pushfirst!</code></a>, <a href="../functions/#Base.insert!"><code>insert!</code></a> do not affect table-level nor column-level metadata (even if they add new columns and pushed row is a <code>DataFrameRow</code> or other value supporting metadata interface)</li><li><a href="../functions/#Base.append!"><code>append!</code></a> and <a href="../functions/#Base.prepend!"><code>prepend!</code></a> do not change table and column-level metadata of the destination data frame, except that if new columns are added and these columns have metadata in the appended/prepended table then this metadata is preserved.</li><li><a href="../functions/#DataFrames.leftjoin!"><code>leftjoin!</code></a>, <a href="../functions/#DataAPI.leftjoin"><code>leftjoin</code></a>: table and column-level metadata is taken from the left table except for non-key columns from right table for which metadata is taken from right table;</li><li><a href="../functions/#DataAPI.rightjoin"><code>rightjoin</code></a>: table and column-level metadata is taken from the right table except for non-key columns from left table for which metadata is taken from left table;</li><li><a href="../functions/#DataAPI.innerjoin"><code>innerjoin</code></a>, <a href="../functions/#DataAPI.outerjoin"><code>outerjoin</code></a>: propagates table-level metadata only for keys that are defined in all passed data frames and have the same value; column-level metadata is propagated for all columns except for key columns, for which it is propagated only for keys that are defined in all passed data frames and have the same value.</li><li><a href="../functions/#DataAPI.semijoin"><code>semijoin</code></a>, <a href="../functions/#DataAPI.antijoin"><code>antijoin</code></a>: table and column-level metadata is taken from the left table.</li><li><a href="../functions/#DataAPI.crossjoin"><code>crossjoin</code></a>: propagates table-level metadata only for keys that are defined in both passed data frames and have the same value; propagates column-level metadata from both passed data frames.</li><li><a href="../functions/#DataFrames.select"><code>select</code></a>, <a href="../functions/#DataFrames.select!"><code>select!</code></a>, <a href="../functions/#DataFrames.transform"><code>transform</code></a>, <a href="../functions/#DataFrames.transform!"><code>transform!</code></a>, <a href="../functions/#DataFrames.combine"><code>combine</code></a>: propagate table-level metadata; column-level metadata is propagated if: a) a single column is transformed to a single column and the name of the column does not change    (this includes all column selection operations), or b) a single column is transformed with <code>identity</code> or <code>copy</code> to a single column    even if column name is changed (this includes column renaming).</li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../indexing/">« Indexing</a><a class="docs-footer-nextpage" href="../internals/">Internals »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.2.1 on <span class="colophon-date" title="Saturday 20 January 2024 22:33">Saturday 20 January 2024</span>. Using Julia version 1.10.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
