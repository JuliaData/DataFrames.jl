<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Types · DataFrames.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link rel="canonical" href="https://juliadata.github.io/DataFrames.jl/stable/lib/types/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.044/juliamono.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="DataFrames.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">DataFrames.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><a class="tocitem" href="../../man/basics/">First Steps with DataFrames.jl</a></li><li><span class="tocitem">User Guide</span><ul><li><a class="tocitem" href="../../man/getting_started/">Getting Started</a></li><li><a class="tocitem" href="../../man/working_with_dataframes/">Working with DataFrames</a></li><li><a class="tocitem" href="../../man/importing_and_exporting/">Importing and Exporting Data (I/O)</a></li><li><a class="tocitem" href="../../man/joins/">Joins</a></li><li><a class="tocitem" href="../../man/split_apply_combine/">Split-apply-combine</a></li><li><a class="tocitem" href="../../man/reshaping_and_pivoting/">Reshaping</a></li><li><a class="tocitem" href="../../man/sorting/">Sorting</a></li><li><a class="tocitem" href="../../man/categorical/">Categorical Data</a></li><li><a class="tocitem" href="../../man/missing/">Missing Data</a></li><li><a class="tocitem" href="../../man/querying_frameworks/">Data manipulation frameworks</a></li><li><a class="tocitem" href="../../man/comparisons/">Comparison with Python/R/Stata</a></li></ul></li><li><span class="tocitem">API</span><ul><li class="is-active"><a class="tocitem" href>Types</a><ul class="internal"><li><a class="tocitem" href="#Type-hierarchy-design"><span>Type hierarchy design</span></a></li><li><a class="tocitem" href="#man-columnhandling"><span>The design of handling of columns of a <code>DataFrame</code></span></a></li><li><a class="tocitem" href="#Types-specification"><span>Types specification</span></a></li></ul></li><li><a class="tocitem" href="../functions/">Functions</a></li><li><a class="tocitem" href="../indexing/">Indexing</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">API</a></li><li class="is-active"><a href>Types</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Types</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaData/DataFrames.jl/blob/main/docs/src/lib/types.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Types"><a class="docs-heading-anchor" href="#Types">Types</a><a id="Types-1"></a><a class="docs-heading-anchor-permalink" href="#Types" title="Permalink"></a></h1><ul><li><a href="#DataFrames.AbstractDataFrame"><code>DataFrames.AbstractDataFrame</code></a></li><li><a href="#DataFrames.AsTable"><code>DataFrames.AsTable</code></a></li><li><a href="#DataFrames.ByRow"><code>DataFrames.ByRow</code></a></li><li><a href="#DataFrames.DataFrame"><code>DataFrames.DataFrame</code></a></li><li><a href="#DataFrames.DataFrameColumns"><code>DataFrames.DataFrameColumns</code></a></li><li><a href="#DataFrames.DataFrameRow"><code>DataFrames.DataFrameRow</code></a></li><li><a href="#DataFrames.DataFrameRows"><code>DataFrames.DataFrameRows</code></a></li><li><a href="#DataFrames.GroupKey"><code>DataFrames.GroupKey</code></a></li><li><a href="#DataFrames.GroupKeys"><code>DataFrames.GroupKeys</code></a></li><li><a href="#DataFrames.GroupedDataFrame"><code>DataFrames.GroupedDataFrame</code></a></li><li><a href="#DataFrames.RepeatedVector"><code>DataFrames.RepeatedVector</code></a></li><li><a href="#DataFrames.StackedVector"><code>DataFrames.StackedVector</code></a></li><li><a href="#DataFrames.SubDataFrame"><code>DataFrames.SubDataFrame</code></a></li></ul><h2 id="Type-hierarchy-design"><a class="docs-heading-anchor" href="#Type-hierarchy-design">Type hierarchy design</a><a id="Type-hierarchy-design-1"></a><a class="docs-heading-anchor-permalink" href="#Type-hierarchy-design" title="Permalink"></a></h2><p><code>AbstractDataFrame</code> is an abstract type that provides an interface for data frame types. It is not intended as a fully generic interface for working with tabular data, which is the role of interfaces defined by <a href="https://github.com/JuliaData/Tables.jl/">Tables.jl</a> instead.</p><p><code>DataFrame</code> is the most fundamental subtype of <code>AbstractDataFrame</code>, which stores a set of columns as <code>AbstractVector</code> objects. Indexing of all stored columns must be 1-based. Also, all functions exposed by DataFrames.jl API make sure to <code>collect</code> passed <code>AbstractRange</code> source columns before storing them in a <code>DataFrame</code>.</p><p><code>SubDataFrame</code> is an <code>AbstractDataFrame</code> subtype representing a view into a <code>DataFrame</code>. It stores only a reference to the parent <code>DataFrame</code> and information about which rows and columns from the parent are selected (both as integer indices referring to the parent). Typically it is created using the <code>view</code> function or is returned by indexing into a <code>GroupedDataFrame</code> object.</p><p><code>GroupedDataFrame</code> is a type that stores the result of a  grouping operation performed on an <code>AbstractDataFrame</code>. It is intended to be created as a result of a call to the <code>groupby</code> function.</p><p><code>DataFrameRow</code> is a view into a single row of an <code>AbstractDataFrame</code>. It stores only a reference to a parent <code>DataFrame</code> and information about which row and columns from the parent are selected (both as integer indices referring to the parent). The <code>DataFrameRow</code> type supports iteration over columns of the row and is similar in functionality to the <code>NamedTuple</code> type, but allows for modification of data stored in the parent <code>DataFrame</code> and reflects changes done to the parent after the creation of the view. Typically objects of the <code>DataFrameRow</code> type are encountered when returned by the <code>eachrow</code> function, or when accessing a single row of a <code>DataFrame</code> or <code>SubDataFrame</code> via <code>getindex</code> or <code>view</code>.</p><p>The <code>eachrow</code> function returns a value of the <code>DataFrameRows</code> type, which serves as an iterator over rows of an <code>AbstractDataFrame</code>, returning <code>DataFrameRow</code> objects. The <code>DataFrameRows</code> is a subtype of <code>AbstractVector</code> and supports its interface with the exception that it is read-only.</p><p>Similarly, the <code>eachcol</code> function returns a value of the <code>DataFrameColumns</code> type, which is not an <code>AbstractVector</code>, but supports most of its API. The key differences are that it is read-only and that the <code>keys</code> function returns a vector of <code>Symbol</code>s (and not integers as for normal vectors).</p><p>Note that <code>DataFrameRows</code> and <code>DataFrameColumns</code> are not exported and should not be constructed directly, but using the <code>eachrow</code> and <code>eachcol</code> functions.</p><p>The <code>RepeatedVector</code> and <code>StackedVector</code> types are subtypes of <code>AbstractVector</code> and support its interface with the exception that they are read only. Note that they are not exported and should not be constructed directly, but they are columns of a <code>DataFrame</code> returned by <code>stack</code> with <code>view=true</code>.</p><p>The <code>ByRow</code> type is a special type used for selection operations to signal that the wrapped function should be applied to each element (row) of the selection.</p><p>The <code>AsTable</code> type is a special type used for selection operations to signal that the columns selected by a wrapped selector should be passed as a <code>NamedTuple</code> to the function or to signal that it is requested to expand the return value of a transformation into multiple columns.</p><h2 id="man-columnhandling"><a class="docs-heading-anchor" href="#man-columnhandling">The design of handling of columns of a <code>DataFrame</code></a><a id="man-columnhandling-1"></a><a class="docs-heading-anchor-permalink" href="#man-columnhandling" title="Permalink"></a></h2><p>When a <code>DataFrame</code> is constructed columns are copied by default. You can disable this behavior by setting <code>copycols</code> keyword argument to <code>false</code>. The exception is if an <code>AbstractRange</code> is passed as a column, then it is always collected to a <code>Vector</code>.</p><p>Also functions that transform a <code>DataFrame</code> to produce a new <code>DataFrame</code> perform a copy of the columns, unless they are passed <code>copycols=false</code> (available only for functions that could perform a transformation without copying the columns). Examples of such functions are <a href="../functions/#Base.vcat"><code>vcat</code></a>, <a href="../functions/#Base.hcat"><code>hcat</code></a>, <a href="../functions/#Base.filter"><code>filter</code></a>, <a href="../functions/#DataFrames.dropmissing"><code>dropmissing</code></a>, <code>getindex</code>, <a href="../functions/#Base.copy"><code>copy</code></a> or the <a href="#DataFrames.DataFrame"><code>DataFrame</code></a> constructor mentioned above.</p><p>The generic single-argument constructor <code>DataFrame(table)</code> has <code>copycols=nothing</code> by default, meaning that columns are copied unless <code>table</code> signals that a copy of columns doesn&#39;t need to be made (this is done by wrapping the source table in <code>Tables.CopiedColumns</code>). <a href="https://csv.juliadata.org/stable">CSV.jl</a> does this when <code>CSV.read(file, DataFrame)</code> is called, since columns are built only for the purpose of use in a <code>DataFrame</code> constructor. Another example is <a href="https://arrow.juliadata.org/dev/manual/#Arrow.Table"><code>Arrow.Table</code></a>, where arrow data is inherently immutable so columns can&#39;t be accidentally mutated anyway. To be able to mutate arrow data, columns must be materialized, which can be accomplished via <code>DataFrame(arrow_table, copycols=true)</code>.</p><p>On the contrary, functions that create a view of a <code>DataFrame</code> <em>do not</em> by definition make copies of the columns, and therefore require particular caution. This includes <code>view</code>, which returns a <code>SubDataFrame</code> or a <code>DataFrameRow</code>, and <code>groupby</code>, which returns a <code>GroupedDataFrame</code>.</p><p>A partial exception to this rule is the <a href="../functions/#DataFrames.stack"><code>stack</code></a> function with <code>view=true</code> which creates a <code>DataFrame</code> that contains views of the columns from the source <code>DataFrame</code>.</p><p>In-place functions whose names end with <code>!</code> (like <code>sort!</code> or <a href="../functions/#DataFrames.dropmissing!"><code>dropmissing!</code></a>, <code>setindex!</code>, <code>push!</code>, <code>append!</code>) may mutate the column vectors of the <code>DataFrame</code> they take as an argument. These functions are safe to call due to the rules described above, <em>except</em> when a view of the <code>DataFrame</code> is in use (via a <code>SubDataFrame</code>, a <code>DataFrameRow</code> or a <code>GroupedDataFrame</code>). In the latter case, calling such a function on the parent might corrupt the view, which make trigger errors, silently return invalid data or even cause Julia to crash. The same caution applies when <code>DataFrame</code> was created using columns of another <code>DataFrame</code> without copying (for instance when <code>copycols=false</code> in functions such as <code>DataFrame</code> or <code>hcat</code>).</p><p>It is possible to have a direct access to a column <code>col</code> of a <code>DataFrame</code> <code>df</code> (e.g. this can be useful in performance critical code to avoid copying), using one of the following methods:</p><ul><li>via the <code>getproperty</code> function using the syntax <code>df.col</code>;</li><li>via the <code>getindex</code> function using the syntax <code>df[!, :col]</code> (note this is in contrast to <code>df[:, :col]</code> which copies);</li><li>by creating a <code>DataFrameColumns</code> object using the <a href="../functions/#Base.eachcol"><code>eachcol</code></a> function;</li><li>by calling the <code>parent</code> function on a view of a column of the <code>DataFrame</code>, e.g. <code>parent(@view df[:, :col])</code>;</li><li>by storing the reference to the column before creating a <code>DataFrame</code> with <code>copycols=false</code>;</li></ul><p>A column obtained from a <code>DataFrame</code> using one of the above methods should not be mutated without caution because:</p><ul><li>resizing a column vector will corrupt its parent <code>DataFrame</code> and any associated views as methods only check the length of the column when it is added to the <code>DataFrame</code> and later assume that all columns have the same length;</li><li>reordering values in a column vector (e.g. using <code>sort!</code>) will break the consistency of rows with other columns, which will also affect views (if any);</li><li>changing values contained in a column vector is acceptable as long as it is not used as a grouping column in a <code>GroupedDataFrame</code> created based on the <code>DataFrame</code>.</li></ul><h2 id="Types-specification"><a class="docs-heading-anchor" href="#Types-specification">Types specification</a><a id="Types-specification-1"></a><a class="docs-heading-anchor-permalink" href="#Types-specification" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="DataFrames.AbstractDataFrame" href="#DataFrames.AbstractDataFrame"><code>DataFrames.AbstractDataFrame</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractDataFrame</code></pre><p>An abstract type for which all concrete types expose an interface for working with tabular data.</p><p>An <code>AbstractDataFrame</code> is a two-dimensional table with <code>Symbol</code>s or strings for column names.</p><p>DataFrames.jl defines two types that are subtypes of <code>AbstractDataFrame</code>: <a href="#DataFrames.DataFrame"><code>DataFrame</code></a> and <a href="#DataFrames.SubDataFrame"><code>SubDataFrame</code></a>.</p><p><strong>Indexing and broadcasting</strong></p><p><code>AbstractDataFrame</code> can be indexed by passing two indices specifying row and column selectors. The allowed indices are a superset of indices that can be used for standard arrays. You can also access a single column of an <code>AbstractDataFrame</code> using <code>getproperty</code> and <code>setproperty!</code> functions. Columns can be selected using integers, <code>Symbol</code>s, or strings. In broadcasting <code>AbstractDataFrame</code> behavior is similar to a <code>Matrix</code>.</p><p>A detailed description of <code>getindex</code>, <code>setindex!</code>, <code>getproperty</code>, <code>setproperty!</code>, broadcasting and broadcasting assignment for data frames is given in the <a href="https://juliadata.github.io/DataFrames.jl/stable/lib/indexing/">&quot;Indexing&quot; section</a> of the manual.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/7fcc3d2104ffc3ec87c700d5996aed4f630832b7/src/abstractdataframe/abstractdataframe.jl#L1-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFrames.AsTable" href="#DataFrames.AsTable"><code>DataFrames.AsTable</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AsTable(cols)</code></pre><p>A type having a special meaning in <code>source =&gt; transformation =&gt; destination</code> selection operations supported by <a href="../functions/#DataFrames.combine"><code>combine</code></a>, <a href="../functions/#DataFrames.select"><code>select</code></a>, <a href="../functions/#DataFrames.select!"><code>select!</code></a>, <a href="../functions/#DataFrames.transform"><code>transform</code></a>, <a href="../functions/#DataFrames.transform!"><code>transform!</code></a>, <a href="../functions/#DataFrames.subset"><code>subset</code></a>, and <a href="../functions/#DataFrames.subset!"><code>subset!</code></a>.</p><p>If <code>AsTable(cols)</code> is used in <code>source</code> position it signals that the columns selected by the wrapped selector <code>cols</code> should be passed as a <code>NamedTuple</code> to the function.</p><p>If <code>AsTable</code> is used in <code>destination</code> position it means that the result of the <code>transformation</code> operation is a vector of containers (or a single container if <code>ByRow(transformation)</code> is used) that should be expanded  into multiple columns using <code>keys</code> to get column names.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; df1 = DataFrame(a=1:3, b=11:13)
3×2 DataFrame
 Row │ a      b
     │ Int64  Int64
─────┼──────────────
   1 │     1     11
   2 │     2     12
   3 │     3     13

julia&gt; df2 = select(df1, AsTable([:a, :b]) =&gt; ByRow(identity))
3×1 DataFrame
 Row │ a_b_identity
     │ NamedTuple…
─────┼─────────────────
   1 │ (a = 1, b = 11)
   2 │ (a = 2, b = 12)
   3 │ (a = 3, b = 13)

julia&gt; select(df2, :a_b_identity =&gt; AsTable)
3×2 DataFrame
 Row │ a      b
     │ Int64  Int64
─────┼──────────────
   1 │     1     11
   2 │     2     12
   3 │     3     13

julia&gt; select(df1, AsTable([:a, :b]) =&gt; ByRow(nt -&gt; map(x -&gt; x^2, nt)) =&gt; AsTable)
3×2 DataFrame
 Row │ a      b
     │ Int64  Int64
─────┼──────────────
   1 │     1    121
   2 │     4    144
   3 │     9    169</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/7fcc3d2104ffc3ec87c700d5996aed4f630832b7/src/other/utils.jl#L1-L54">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFrames.ByRow" href="#DataFrames.ByRow"><code>DataFrames.ByRow</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ByRow</code></pre><p>A type used for selection operations to signal that the wrapped function should be applied to each element (row) of the selection.</p><p>The wrapped function is called exactly once for each element. This differs from <code>map</code> and <code>broadcast</code>, which assume for some types of source vectors (e.g. <code>SparseVector</code>) that the wrapped function is pure, allowing them to call the function only once for multiple equal values. When using such types, for maximal performance with pure functions which are relatively costly, use <code>x -&gt; map(f, x)</code> instead of <code>ByRow(f)</code>.</p><p>Note that <code>ByRow</code> always collects values returned by <code>fun</code> in a vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/7fcc3d2104ffc3ec87c700d5996aed4f630832b7/src/abstractdataframe/selection.jl#L312-L326">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFrames.DataFrame" href="#DataFrames.DataFrame"><code>DataFrames.DataFrame</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DataFrame &lt;: AbstractDataFrame</code></pre><p>An <code>AbstractDataFrame</code> that stores a set of named columns</p><p>The columns are normally <code>AbstractVector</code>s stored in memory, particularly a <code>Vector</code>, <code>PooledVector</code> or <code>CategoricalVector</code>.</p><p><strong>Constructors</strong></p><pre><code class="language-julia hljs">DataFrame(pairs::Pair...; makeunique::Bool=false, copycols::Bool=true)
DataFrame(pairs::AbstractVector{&lt;:Pair}; makeunique::Bool=false, copycols::Bool=true)
DataFrame(ds::AbstractDict; copycols::Bool=true)
DataFrame(; kwargs..., copycols::Bool=true)

DataFrame(columns::AbstractVecOrMat,
          names::AbstractVector;
          makeunique::Bool=false, copycols::Bool=true)

DataFrame(table; copycols::Union{Bool, Nothing}=nothing)
DataFrame(::DataFrameRow)
DataFrame(::GroupedDataFrame; keepkeys::Bool=true)</code></pre><p><strong>Keyword arguments</strong></p><ul><li><code>copycols</code> : whether vectors passed as columns should be copied; by default set to <code>true</code> and the vectors are copied; if set to <code>false</code> then the constructor will still copy the passed columns if it is not possible to construct a <code>DataFrame</code> without materializing new columns. Note the <code>copycols=nothing</code> default in the Tables.jl compatible constructor; it is provided as certain input table types may have already made a copy of columns or the columns may otherwise be immutable, in which case columns are not copied by default. To force a copy in such cases, or to get mutable columns from an immutable input table (like <code>Arrow.Table</code>), pass <code>copycols=true</code> explicitly.</li><li><code>makeunique</code> : if <code>false</code> (the default), an error will be raised</li></ul><p>(note that not all constructors support these keyword arguments)</p><p><strong>Details on behavior of different constructors</strong></p><p>It is allowed to pass a vector of <code>Pair</code>s, a list of <code>Pair</code>s as positional arguments, or a list of keyword arguments. In this case each pair is considered to represent a column name to column value mapping and column name must be a <code>Symbol</code> or string. Alternatively a dictionary can be passed to the constructor in which case its entries are considered to define the column name and column value pairs. If the dictionary is a <code>Dict</code> then column names will be sorted in the returned <code>DataFrame</code>.</p><p>In all the constructors described above column value can be a vector which is consumed as is or an object of any other type (except <code>AbstractArray</code>). In the latter case the passed value is automatically repeated to fill a new vector of the appropriate length. As a particular rule values stored in a <code>Ref</code> or a <code>0</code>-dimensional <code>AbstractArray</code> are unwrapped and treated in the same way.</p><p>It is also allowed to pass a vector of vectors or a matrix as as the first argument. In this case the second argument must be a vector of <code>Symbol</code>s or strings specifying column names, or the symbol <code>:auto</code> to generate column names <code>x1</code>, <code>x2</code>, ... automatically. Note that in this case if the first argument is a matrix and <code>copycols=false</code> the columns of the created <code>DataFrame</code> will be views of columns the source matrix.</p><p>If a single positional argument is passed to a <code>DataFrame</code> constructor then it is assumed to be of type that implements the <a href="https://github.com/JuliaData/Tables.jl">Tables.jl</a> interface using which the returned <code>DataFrame</code> is materialized.</p><p>Finally it is allowed to construct a <code>DataFrame</code> from a <code>DataFrameRow</code> or a <code>GroupedDataFrame</code>. In the latter case the <code>keepkeys</code> keyword argument specifies whether the resulting <code>DataFrame</code> should contain the grouping columns of the passed <code>GroupedDataFrame</code> and the order of rows in the result follows the order of groups in the <code>GroupedDataFrame</code> passed.</p><p><strong>Notes</strong></p><p>The <code>DataFrame</code> constructor by default copies all columns vectors passed to it. Pass the <code>copycols=false</code> keyword argument (where supported) to reuse vectors without copying them.</p><p>By default an error will be raised if duplicates in column names are found. Pass <code>makeunique=true</code> keyword argument (where supported) to accept duplicate names, in which case they will be suffixed with <code>_i</code> (<code>i</code> starting at 1 for the first duplicate).</p><p>If an <code>AbstractRange</code> is passed to a <code>DataFrame</code> constructor as a column it is always collected to a <code>Vector</code> (even if <code>copycols=false</code>). As a general rule <code>AbstractRange</code> values are always materialized to a <code>Vector</code> by all functions in DataFrames.jl before being stored in a <code>DataFrame</code>.</p><p><code>DataFrame</code> can store only columns that use 1-based indexing. Attempting to store a vector using non-standard indexing raises an error.</p><p>The <code>DataFrame</code> type is designed to allow column types to vary and to be dynamically changed also after it is constructed. Therefore <code>DataFrame</code>s are not type stable. For performance-critical code that requires type-stability either use the functionality provided by <code>select</code>/<code>transform</code>/<code>combine</code> functions, use <code>Tables.columntable</code> and <code>Tables.namedtupleiterator</code> functions, use barrier functions, or provide type assertions to the variables that hold columns extracted from a <code>DataFrame</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; DataFrame((a=[1, 2], b=[3, 4])) # Tables.jl table constructor
2×2 DataFrame
 Row │ a      b
     │ Int64  Int64
─────┼──────────────
   1 │     1      3
   2 │     2      4

julia&gt; DataFrame([(a=1, b=0), (a=2, b=0)]) # Tables.jl table constructor
2×2 DataFrame
 Row │ a      b
     │ Int64  Int64
─────┼──────────────
   1 │     1      0
   2 │     2      0

julia&gt; DataFrame(&quot;a&quot; =&gt; 1:2, &quot;b&quot; =&gt; 0) # Pair constructor
2×2 DataFrame
 Row │ a      b
     │ Int64  Int64
─────┼──────────────
   1 │     1      0
   2 │     2      0

julia&gt; DataFrame([:a =&gt; 1:2, :b =&gt; 0]) # vector of Pairs constructor
2×2 DataFrame
 Row │ a      b
     │ Int64  Int64
─────┼──────────────
   1 │     1      0
   2 │     2      0

julia&gt; DataFrame(Dict(:a =&gt; 1:2, :b =&gt; 0)) # dictionary constructor
2×2 DataFrame
 Row │ a      b
     │ Int64  Int64
─────┼──────────────
   1 │     1      0
   2 │     2      0

julia&gt; DataFrame(a=1:2, b=0) # keyword argument constructor
2×2 DataFrame
 Row │ a      b
     │ Int64  Int64
─────┼──────────────
   1 │     1      0
   2 │     2      0

julia&gt; DataFrame([[1, 2], [0, 0]], [:a, :b]) # vector of vectors constructor
2×2 DataFrame
 Row │ a      b
     │ Int64  Int64
─────┼──────────────
   1 │     1      0
   2 │     2      0

julia&gt; DataFrame([1 0; 2 0], :auto) # matrix constructor
2×2 DataFrame
 Row │ x1     x2
     │ Int64  Int64
─────┼──────────────
   1 │     1      0
   2 │     2      0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/7fcc3d2104ffc3ec87c700d5996aed4f630832b7/src/dataframe/dataframe.jl#L1-L167">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFrames.DataFrameRow" href="#DataFrames.DataFrameRow"><code>DataFrames.DataFrameRow</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DataFrameRow{&lt;:AbstractDataFrame, &lt;:AbstractIndex}</code></pre><p>A view of one row of an <code>AbstractDataFrame</code>.</p><p>A <code>DataFrameRow</code> is returned by <code>getindex</code> or <code>view</code> functions when one row and a selection of columns are requested, or when iterating the result of the call to the <a href="../functions/#Base.eachrow"><code>eachrow</code></a> function.</p><p>The <code>DataFrameRow</code> constructor can also be called directly:</p><pre><code class="nohighlight hljs">DataFrameRow(parent::AbstractDataFrame, row::Integer, cols=:)</code></pre><p>A <code>DataFrameRow</code> supports the iteration interface and can therefore be passed to functions that expect a collection as an argument. Its element type is always <code>Any</code>.</p><p>Indexing is one-dimensional like specifying a column of a <code>DataFrame</code>. You can also access the data in a <code>DataFrameRow</code> using the <code>getproperty</code> and <code>setproperty!</code> functions and convert it to a <code>Tuple</code>, <code>NamedTuple</code>, or <code>Vector</code> using the corresponding functions.</p><p>If the selection of columns in a parent data frame is passed as <code>:</code> (a colon) then <code>DataFrameRow</code> will always have all columns from the parent, even if they are added or removed after its creation.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; df = DataFrame(a=repeat([1, 2], outer=[2]),
                      b=repeat([&quot;a&quot;, &quot;b&quot;], inner=[2]),
                      c=1:4)
4×3 DataFrame
 Row │ a      b       c
     │ Int64  String  Int64
─────┼──────────────────────
   1 │     1  a           1
   2 │     2  a           2
   3 │     1  b           3
   4 │     2  b           4

julia&gt; df[1, :]
DataFrameRow
 Row │ a      b       c
     │ Int64  String  Int64
─────┼──────────────────────
   1 │     1  a           1

julia&gt; @view df[end, [:a]]
DataFrameRow
 Row │ a
     │ Int64
─────┼───────
   4 │     2

julia&gt; eachrow(df)[1]
DataFrameRow
 Row │ a      b       c
     │ Int64  String  Int64
─────┼──────────────────────
   1 │     1  a           1

julia&gt; Tuple(df[1, :])
(1, &quot;a&quot;, 1)

julia&gt; NamedTuple(df[1, :])
(a = 1, b = &quot;a&quot;, c = 1)

julia&gt; Vector(df[1, :])
3-element Vector{Any}:
 1
  &quot;a&quot;
 1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/7fcc3d2104ffc3ec87c700d5996aed4f630832b7/src/dataframerow/dataframerow.jl#L1-L75">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFrames.GroupedDataFrame" href="#DataFrames.GroupedDataFrame"><code>DataFrames.GroupedDataFrame</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GroupedDataFrame</code></pre><p>The result of a <a href="../functions/#DataFrames.groupby"><code>groupby</code></a> operation on an <code>AbstractDataFrame</code>; a view into the <code>AbstractDataFrame</code> grouped by rows.</p><p>Not meant to be constructed directly, see <a href="../functions/#DataFrames.groupby"><code>groupby</code></a>.</p><p>One can get the names of columns used to create <code>GroupedDataFrame</code> using the <a href="../functions/#DataFrames.groupcols"><code>groupcols</code></a> function. Similarly the <a href="../functions/#DataFrames.groupindices"><code>groupindices</code></a> function returns a vector of group indices for each row of the parent data frame.</p><p>After its creation, a <code>GroupedDataFrame</code> reflects the grouping of rows that was valid at the its creation time. Therefore grouping columns of its parent data frame must not be mutated, and rows must not be added nor removed from it. To safeguard the user against such cases, if the number of rows in the parent data frame changes then trying to use <code>GroupedDataFrame</code> will throw an error. However, one can add or remove columns to the parent data frame without invalidating the <code>GroupedDataFrame</code> provided that columns used for grouping are not changed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/7fcc3d2104ffc3ec87c700d5996aed4f630832b7/src/groupeddataframe/groupeddataframe.jl#L15-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFrames.GroupKey" href="#DataFrames.GroupKey"><code>DataFrames.GroupKey</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GroupKey{T&lt;:GroupedDataFrame}</code></pre><p>Key for one of the groups of a <a href="#DataFrames.GroupedDataFrame"><code>GroupedDataFrame</code></a>. Contains the values of the corresponding grouping columns and behaves similarly to a <code>NamedTuple</code>, but using it to index its <code>GroupedDataFrame</code> is more efficient than using the equivalent <code>Tuple</code> and <code>NamedTuple</code>, and much more efficient than using the equivalent <code>AbstractDict</code>.</p><p>Instances of this type are returned by <code>keys(::GroupedDataFrame)</code> and are not meant to be constructed directly.</p><p>Indexing fields of <code>GroupKey</code> is allowed using an integer, a <code>Symbol</code>, or a string. It is also possible to access the data in a <code>GroupKey</code> using the <code>getproperty</code> function. A <code>GroupKey</code> can be converted to a <code>Tuple</code>, <code>NamedTuple</code>, a <code>Vector</code>, or a <code>Dict</code>. When converted to a <code>Dict</code>, the keys of the <code>Dict</code> are <code>Symbol</code>s.</p><p>See <a href="../functions/#Base.keys"><code>keys(::GroupedDataFrame)</code></a> for more information.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/7fcc3d2104ffc3ec87c700d5996aed4f630832b7/src/groupeddataframe/groupeddataframe.jl#L586-L604">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFrames.GroupKeys" href="#DataFrames.GroupKeys"><code>DataFrames.GroupKeys</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GroupKeys{T&lt;:GroupedDataFrame} &lt;: AbstractVector{GroupKey{T}}</code></pre><p>A vector containing all <a href="#DataFrames.GroupKey"><code>GroupKey</code></a> objects for a given <a href="#DataFrames.GroupedDataFrame"><code>GroupedDataFrame</code></a>.</p><p>See <a href="../functions/#Base.keys"><code>keys(::GroupedDataFrame)</code></a> for more information.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/7fcc3d2104ffc3ec87c700d5996aed4f630832b7/src/groupeddataframe/groupeddataframe.jl#L738-L745">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFrames.SubDataFrame" href="#DataFrames.SubDataFrame"><code>DataFrames.SubDataFrame</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SubDataFrame{&lt;:AbstractDataFrame, &lt;:AbstractIndex, &lt;:AbstractVector{Int}} &lt;: AbstractDataFrame</code></pre><p>A view of an <code>AbstractDataFrame</code>. It is returned by a call to the <code>view</code> function on an <code>AbstractDataFrame</code> if a collections of rows and columns are specified.</p><p>A <code>SubDataFrame</code> is an <code>AbstractDataFrame</code>, so expect that most DataFrame functions should work. Such methods include <code>describe</code>, <code>summary</code>, <code>nrow</code>, <code>size</code>, <code>by</code>, <code>stack</code>, and <code>join</code>.</p><p>If the selection of columns in a parent data frame is passed as <code>:</code> (a colon) then <code>SubDataFrame</code> will always have all columns from the parent, even if they are added or removed after its creation.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; df = DataFrame(a=repeat([1, 2, 3, 4], outer=[2]),
                      b=repeat([2, 1], outer=[4]),
                      c=1:8)
8×3 DataFrame
 Row │ a      b      c
     │ Int64  Int64  Int64
─────┼─────────────────────
   1 │     1      2      1
   2 │     2      1      2
   3 │     3      2      3
   4 │     4      1      4
   5 │     1      2      5
   6 │     2      1      6
   7 │     3      2      7
   8 │     4      1      8

julia&gt; sdf1 = view(df, :, 2:3) # column subsetting
8×2 SubDataFrame
 Row │ b      c
     │ Int64  Int64
─────┼──────────────
   1 │     2      1
   2 │     1      2
   3 │     2      3
   4 │     1      4
   5 │     2      5
   6 │     1      6
   7 │     2      7
   8 │     1      8

julia&gt; sdf2 = @view df[end:-1:1, [1, 3]]  # row and column subsetting
8×2 SubDataFrame
 Row │ a      c
     │ Int64  Int64
─────┼──────────────
   1 │     4      8
   2 │     3      7
   3 │     2      6
   4 │     1      5
   5 │     4      4
   6 │     3      3
   7 │     2      2
   8 │     1      1

julia&gt; sdf3 = groupby(df, :a)[1]  # indexing a GroupedDataFrame returns a SubDataFrame
2×3 SubDataFrame
 Row │ a      b      c
     │ Int64  Int64  Int64
─────┼─────────────────────
   1 │     1      2      1
   2 │     1      2      5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/7fcc3d2104ffc3ec87c700d5996aed4f630832b7/src/subdataframe/subdataframe.jl#L1-L69">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFrames.DataFrameRows" href="#DataFrames.DataFrameRows"><code>DataFrames.DataFrameRows</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DataFrameRows{D&lt;:AbstractDataFrame} &lt;: AbstractVector{DataFrameRow}</code></pre><p>Iterator over rows of an <code>AbstractDataFrame</code>, with each row represented as a <code>DataFrameRow</code>.</p><p>A value of this type is returned by the <a href="../functions/#Base.eachrow"><code>eachrow</code></a> function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/7fcc3d2104ffc3ec87c700d5996aed4f630832b7/src/abstractdataframe/iteration.jl#L8-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFrames.DataFrameColumns" href="#DataFrames.DataFrameColumns"><code>DataFrames.DataFrameColumns</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DataFrameColumns{&lt;:AbstractDataFrame}</code></pre><p>A vector-like object that allows iteration over columns of an <code>AbstractDataFrame</code>.</p><p>Indexing into <code>DataFrameColumns</code> objects using integer, <code>Symbol</code> or string returns the corresponding column (without copying). Indexing into <code>DataFrameColumns</code> objects using a multiple column selector returns a subsetted <code>DataFrameColumns</code> object with a new parent containing only the selected columns (without copying).</p><p><code>DataFrameColumns</code> supports most of the <code>AbstractVector</code> API. The key differences are that it is read-only and that the <code>keys</code> function returns a vector of <code>Symbol</code>s (and not integers as for normal vectors).</p><p>In particular <code>findnext</code>, <code>findprev</code>, <code>findfirst</code>, <code>findlast</code>, and <code>findall</code> functions are supported, and in <code>findnext</code> and <code>findprev</code> functions it is allowed to pass an integer, string, or <code>Symbol</code> as a reference index.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/7fcc3d2104ffc3ec87c700d5996aed4f630832b7/src/abstractdataframe/iteration.jl#L113-L119">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFrames.RepeatedVector" href="#DataFrames.RepeatedVector"><code>DataFrames.RepeatedVector</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RepeatedVector{T} &lt;: AbstractVector{T}</code></pre><p>An AbstractVector that is a view into another AbstractVector with repeated elements</p><p>NOTE: Not exported.</p><p><strong>Constructor</strong></p><pre><code class="language-julia hljs">RepeatedVector(parent::AbstractVector, inner::Int, outer::Int)</code></pre><p><strong>Arguments</strong></p><ul><li><code>parent</code> : the AbstractVector that&#39;s repeated</li><li><code>inner</code> : the numer of times each element is repeated</li><li><code>outer</code> : the numer of times the whole vector is repeated after expanded by <code>inner</code></li></ul><p><code>inner</code> and <code>outer</code> have the same meaning as similarly named arguments to <code>repeat</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">RepeatedVector([1, 2], 3, 1)   # [1, 1, 1, 2, 2, 2]
RepeatedVector([1, 2], 1, 3)   # [1, 2, 1, 2, 1, 2]
RepeatedVector([1, 2], 2, 2)   # [1, 2, 1, 2, 1, 2, 1, 2]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/7fcc3d2104ffc3ec87c700d5996aed4f630832b7/src/abstractdataframe/reshape.jl#L618-L646">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFrames.StackedVector" href="#DataFrames.StackedVector"><code>DataFrames.StackedVector</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">StackedVector &lt;: AbstractVector</code></pre><p>An <code>AbstractVector</code> that is a linear, concatenated view into another set of AbstractVectors</p><p>NOTE: Not exported.</p><p><strong>Constructor</strong></p><pre><code class="language-julia hljs">StackedVector(d::AbstractVector)</code></pre><p><strong>Arguments</strong></p><ul><li><code>d...</code> : one or more AbstractVectors</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">StackedVector(Any[[1, 2], [9, 10], [11, 12]])  # [1, 2, 9, 10, 11, 12]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/7fcc3d2104ffc3ec87c700d5996aed4f630832b7/src/abstractdataframe/reshape.jl#L569-L589">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../man/comparisons/">« Comparison with Python/R/Stata</a><a class="docs-footer-nextpage" href="../functions/">Functions »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.19 on <span class="colophon-date" title="Sunday 26 June 2022 16:12">Sunday 26 June 2022</span>. Using Julia version 1.7.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
