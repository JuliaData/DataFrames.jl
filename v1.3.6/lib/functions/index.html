<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Functions · DataFrames.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link rel="canonical" href="https://juliadata.github.io/DataFrames.jl/stable/lib/functions/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="DataFrames.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">DataFrames.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><a class="tocitem" href="../../man/basics/">First Steps with DataFrames.jl</a></li><li><span class="tocitem">User Guide</span><ul><li><a class="tocitem" href="../../man/getting_started/">Getting Started</a></li><li><a class="tocitem" href="../../man/working_with_dataframes/">Working with DataFrames</a></li><li><a class="tocitem" href="../../man/importing_and_exporting/">Importing and Exporting Data (I/O)</a></li><li><a class="tocitem" href="../../man/joins/">Joins</a></li><li><a class="tocitem" href="../../man/split_apply_combine/">Split-apply-combine</a></li><li><a class="tocitem" href="../../man/reshaping_and_pivoting/">Reshaping</a></li><li><a class="tocitem" href="../../man/sorting/">Sorting</a></li><li><a class="tocitem" href="../../man/categorical/">Categorical Data</a></li><li><a class="tocitem" href="../../man/missing/">Missing Data</a></li><li><a class="tocitem" href="../../man/querying_frameworks/">Data manipulation frameworks</a></li><li><a class="tocitem" href="../../man/comparisons/">Comparison with Python/R/Stata</a></li></ul></li><li><span class="tocitem">API</span><ul><li><a class="tocitem" href="../types/">Types</a></li><li class="is-active"><a class="tocitem" href>Functions</a><ul class="internal"><li><a class="tocitem" href="#Multi-threading-support"><span>Multi-threading support</span></a></li><li><a class="tocitem" href="#Index"><span>Index</span></a></li><li><a class="tocitem" href="#Constructing-data-frames"><span>Constructing data frames</span></a></li><li><a class="tocitem" href="#Summary-information"><span>Summary information</span></a></li><li><a class="tocitem" href="#Working-with-column-names"><span>Working with column names</span></a></li><li><a class="tocitem" href="#Mutating-and-transforming-data-frames-and-grouped-data-frames"><span>Mutating and transforming data frames and grouped data frames</span></a></li><li><a class="tocitem" href="#Reshaping-data-frames-between-tall-and-wide-formats"><span>Reshaping data frames between tall and wide formats</span></a></li><li><a class="tocitem" href="#Sorting"><span>Sorting</span></a></li><li><a class="tocitem" href="#Joining"><span>Joining</span></a></li><li><a class="tocitem" href="#Grouping"><span>Grouping</span></a></li><li><a class="tocitem" href="#Filtering-rows"><span>Filtering rows</span></a></li><li><a class="tocitem" href="#Working-with-missing-values"><span>Working with missing values</span></a></li><li><a class="tocitem" href="#Iteration"><span>Iteration</span></a></li><li><a class="tocitem" href="#Equality"><span>Equality</span></a></li></ul></li><li><a class="tocitem" href="../indexing/">Indexing</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">API</a></li><li class="is-active"><a href>Functions</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Functions</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaData/DataFrames.jl/blob/main/docs/src/lib/functions.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Functions"><a class="docs-heading-anchor" href="#Functions">Functions</a><a id="Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Functions" title="Permalink"></a></h1><h2 id="Multi-threading-support"><a class="docs-heading-anchor" href="#Multi-threading-support">Multi-threading support</a><a id="Multi-threading-support-1"></a><a class="docs-heading-anchor-permalink" href="#Multi-threading-support" title="Permalink"></a></h2><p>Selected operations in DataFrames.jl automatically use multiple threads when available. It is task-based and implemented using the <code>@spawn</code> macro from Julia Base.</p><p>This is a list of operations that currently make use of multi-threading:</p><ul><li><code>DataFrame</code> constructor with <code>copycols=true</code>; also recursively all functions that call this constructor, e.g. <code>copy</code>.</li><li><code>getindex</code> when multiple columns are selected.</li><li><code>groupby</code> (both when hashing is required and when fast path using <code>DataAPI.refpool</code> is used).</li><li><code>join*</code> functions for composing output data frame (but currently not for finding matching rows in joined data frames).</li><li><code>combine</code>, <code>select[!]</code>, and <code>transform[!]</code> on <code>GroupedDataFrame</code> when either of the conditions below is met:<ul><li>multiple transformations are performed (each transformation is spawned in a separate task)</li><li>a transformation produces one row per group and the passed transformation is a custom function (i.e. not for standard reductions, which use optimized single-threaded methods).</li></ul></li></ul><p>In general at least Julia 1.4 is required to ensure that multi-threading is used and the Julia process must be started with more than one thread. Some operations turn on multi-threading only if enough rows in the processed data frame are present (the exact threshold when multi-threading is enabled is considered to be undefined and might change in the future).</p><p>Except for the list above, where multi-threading is used automatically, all functions provided by DataFrames.jl that update a data frame are not thread safe. This means that while they can be called from any thread, the caller is responsible for ensuring that a given <code>DataFrame</code> object is never modified by one thread while others are using it (either for reading or writing). Using the same <code>DataFrame</code> at the same time from different threads is safe as long as it is not modified.</p><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="#Base.Iterators.only"><code>Base.Iterators.only</code></a></li><li><a href="#Base.append!"><code>Base.append!</code></a></li><li><a href="#Base.copy"><code>Base.copy</code></a></li><li><a href="#Base.deleteat!"><code>Base.deleteat!</code></a></li><li><a href="#Base.eachcol"><code>Base.eachcol</code></a></li><li><a href="#Base.eachrow"><code>Base.eachrow</code></a></li><li><a href="#Base.empty"><code>Base.empty</code></a></li><li><a href="#Base.empty!"><code>Base.empty!</code></a></li><li><a href="#Base.filter"><code>Base.filter</code></a></li><li><a href="#Base.filter!"><code>Base.filter!</code></a></li><li><a href="#Base.first"><code>Base.first</code></a></li><li><a href="#Base.get"><code>Base.get</code></a></li><li><a href="#Base.hcat"><code>Base.hcat</code></a></li><li><a href="#Base.isapprox"><code>Base.isapprox</code></a></li><li><a href="#Base.issorted"><code>Base.issorted</code></a></li><li><a href="#Base.keys"><code>Base.keys</code></a></li><li><a href="#Base.last"><code>Base.last</code></a></li><li><a href="#Base.length"><code>Base.length</code></a></li><li><a href="#Base.names"><code>Base.names</code></a></li><li><a href="#Base.ndims"><code>Base.ndims</code></a></li><li><a href="#Base.pairs"><code>Base.pairs</code></a></li><li><a href="#Base.parent"><code>Base.parent</code></a></li><li><a href="#Base.permutedims"><code>Base.permutedims</code></a></li><li><a href="#Base.propertynames"><code>Base.propertynames</code></a></li><li><a href="#Base.push!"><code>Base.push!</code></a></li><li><a href="#Base.reduce"><code>Base.reduce</code></a></li><li><a href="#Base.repeat"><code>Base.repeat</code></a></li><li><a href="#Base.reverse"><code>Base.reverse</code></a></li><li><a href="#Base.show"><code>Base.show</code></a></li><li><a href="#Base.similar"><code>Base.similar</code></a></li><li><a href="#Base.size"><code>Base.size</code></a></li><li><a href="#Base.sort"><code>Base.sort</code></a></li><li><a href="#Base.sort!"><code>Base.sort!</code></a></li><li><a href="#Base.sortperm"><code>Base.sortperm</code></a></li><li><a href="#Base.unique"><code>Base.unique</code></a></li><li><a href="#Base.unique!"><code>Base.unique!</code></a></li><li><a href="#Base.values"><code>Base.values</code></a></li><li><a href="#Base.vcat"><code>Base.vcat</code></a></li><li><a href="#DataAPI.antijoin"><code>DataAPI.antijoin</code></a></li><li><a href="#DataAPI.crossjoin"><code>DataAPI.crossjoin</code></a></li><li><a href="#DataAPI.describe"><code>DataAPI.describe</code></a></li><li><a href="#DataAPI.innerjoin"><code>DataAPI.innerjoin</code></a></li><li><a href="#DataAPI.leftjoin"><code>DataAPI.leftjoin</code></a></li><li><a href="#DataAPI.ncol"><code>DataAPI.ncol</code></a></li><li><a href="#DataAPI.nrow"><code>DataAPI.nrow</code></a></li><li><a href="#DataAPI.outerjoin"><code>DataAPI.outerjoin</code></a></li><li><a href="#DataAPI.rightjoin"><code>DataAPI.rightjoin</code></a></li><li><a href="#DataAPI.semijoin"><code>DataAPI.semijoin</code></a></li><li><a href="#DataFrames.allowmissing!"><code>DataFrames.allowmissing!</code></a></li><li><a href="#DataFrames.combine"><code>DataFrames.combine</code></a></li><li><a href="#DataFrames.completecases"><code>DataFrames.completecases</code></a></li><li><a href="#DataFrames.disallowmissing!"><code>DataFrames.disallowmissing!</code></a></li><li><a href="#DataFrames.dropmissing"><code>DataFrames.dropmissing</code></a></li><li><a href="#DataFrames.dropmissing!"><code>DataFrames.dropmissing!</code></a></li><li><a href="#DataFrames.flatten"><code>DataFrames.flatten</code></a></li><li><a href="#DataFrames.groupby"><code>DataFrames.groupby</code></a></li><li><a href="#DataFrames.groupcols"><code>DataFrames.groupcols</code></a></li><li><a href="#DataFrames.groupindices"><code>DataFrames.groupindices</code></a></li><li><a href="#DataFrames.insertcols!"><code>DataFrames.insertcols!</code></a></li><li><a href="#DataFrames.leftjoin!"><code>DataFrames.leftjoin!</code></a></li><li><a href="#DataFrames.mapcols"><code>DataFrames.mapcols</code></a></li><li><a href="#DataFrames.mapcols!"><code>DataFrames.mapcols!</code></a></li><li><a href="#DataFrames.nonunique"><code>DataFrames.nonunique</code></a></li><li><a href="#DataFrames.order"><code>DataFrames.order</code></a></li><li><a href="#DataFrames.rename"><code>DataFrames.rename</code></a></li><li><a href="#DataFrames.rename!"><code>DataFrames.rename!</code></a></li><li><a href="#DataFrames.repeat!"><code>DataFrames.repeat!</code></a></li><li><a href="#DataFrames.rownumber"><code>DataFrames.rownumber</code></a></li><li><a href="#DataFrames.select"><code>DataFrames.select</code></a></li><li><a href="#DataFrames.select!"><code>DataFrames.select!</code></a></li><li><a href="#DataFrames.stack"><code>DataFrames.stack</code></a></li><li><a href="#DataFrames.subset"><code>DataFrames.subset</code></a></li><li><a href="#DataFrames.subset!"><code>DataFrames.subset!</code></a></li><li><a href="#DataFrames.transform"><code>DataFrames.transform</code></a></li><li><a href="#DataFrames.transform!"><code>DataFrames.transform!</code></a></li><li><a href="#DataFrames.unstack"><code>DataFrames.unstack</code></a></li><li><a href="#DataFrames.valuecols"><code>DataFrames.valuecols</code></a></li><li><a href="#Missings.allowmissing"><code>Missings.allowmissing</code></a></li><li><a href="#Missings.disallowmissing"><code>Missings.disallowmissing</code></a></li></ul><h2 id="Constructing-data-frames"><a class="docs-heading-anchor" href="#Constructing-data-frames">Constructing data frames</a><a id="Constructing-data-frames-1"></a><a class="docs-heading-anchor-permalink" href="#Constructing-data-frames" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Base.copy" href="#Base.copy"><code>Base.copy</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">copy(df::DataFrame; copycols::Bool=true)</code></pre><p>Copy data frame <code>df</code>. If <code>copycols=true</code> (the default), return a new  <code>DataFrame</code> holding copies of column vectors in <code>df</code>. If <code>copycols=false</code>, return a new <code>DataFrame</code> sharing column vectors with <code>df</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/10c5b5e9e7f916024b2f102d040fdd9d4e6bd371/src/dataframe/dataframe.jl#L989-L996">source</a></section><section><div><pre><code class="nohighlight hljs">copy(dfr::DataFrameRow)</code></pre><p>Construct a <code>NamedTuple</code> with the same contents as the <a href="../types/#DataFrames.DataFrameRow"><code>DataFrameRow</code></a>. This method returns a <code>NamedTuple</code> so that the returned object is not affected by changes to the parent data frame of which <code>dfr</code> is a view.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/10c5b5e9e7f916024b2f102d040fdd9d4e6bd371/src/dataframerow/dataframerow.jl#L436-L443">source</a></section><section><div><pre><code class="nohighlight hljs">copy(key::GroupKey)</code></pre><p>Construct a <code>NamedTuple</code> with the same contents as the <a href="../types/#DataFrames.GroupKey"><code>GroupKey</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/10c5b5e9e7f916024b2f102d040fdd9d4e6bd371/src/groupeddataframe/groupeddataframe.jl#L608-L612">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.similar" href="#Base.similar"><code>Base.similar</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">similar(df::AbstractDataFrame, rows::Integer=nrow(df))</code></pre><p>Create a new <code>DataFrame</code> with the same column names and column element types as <code>df</code>. An optional second argument can be provided to request a number of rows that is different than the number of rows present in <code>df</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/10c5b5e9e7f916024b2f102d040fdd9d4e6bd371/src/abstractdataframe/abstractdataframe.jl#L395-L401">source</a></section></article><h2 id="Summary-information"><a class="docs-heading-anchor" href="#Summary-information">Summary information</a><a id="Summary-information-1"></a><a class="docs-heading-anchor-permalink" href="#Summary-information" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="DataAPI.describe" href="#DataAPI.describe"><code>DataAPI.describe</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">describe(df::AbstractDataFrame; cols=:)
describe(df::AbstractDataFrame, stats::Union{Symbol, Pair}...; cols=:)</code></pre><p>Return descriptive statistics for a data frame as a new <code>DataFrame</code> where each row represents a variable and each column a summary statistic.</p><p><strong>Arguments</strong></p><ul><li><code>df</code> : the <code>AbstractDataFrame</code></li><li><code>stats::Union{Symbol, Pair}...</code> : the summary statistics to report. Arguments can be:<ul><li>A symbol from the list <code>:mean</code>, <code>:std</code>, <code>:min</code>, <code>:q25</code>, <code>:median</code>, <code>:q75</code>, <code>:max</code>, <code>:eltype</code>, <code>:nunique</code>, <code>:first</code>, <code>:last</code>, and <code>:nmissing</code>. The default statistics used are <code>:mean</code>, <code>:min</code>, <code>:median</code>, <code>:max</code>, <code>:nmissing</code>, and <code>:eltype</code>.</li><li><code>:detailed</code> as the only <code>Symbol</code> argument to return all statistics except <code>first</code> and <code>last</code>.</li><li><code>:all</code> as the only <code>Symbol</code> argument to return all statistics.</li><li>A <code>function =&gt; name</code> pair where <code>name</code> is a <code>Symbol</code> or string. This will create a column of summary statistics with the provided name.</li></ul></li><li><code>cols</code> : a keyword argument allowing to select only a subset or transformation of columns from <code>df</code> to describe. Can be any column selector or transformation accepted by <a href="#DataFrames.select"><code>select</code></a>.</li></ul><p><strong>Details</strong></p><p>For <code>Real</code> columns, compute the mean, standard deviation, minimum, first quantile, median, third quantile, and maximum. If a column does not derive from <code>Real</code>, <code>describe</code> will attempt to calculate all statistics, using <code>nothing</code> as a fall-back in the case of an error.</p><p>When <code>stats</code> contains <code>:nunique</code>, <code>describe</code> will report the number of unique values in a column. If a column&#39;s base type derives from <code>Real</code>, <code>:nunique</code> will return <code>nothing</code>s.</p><p>Missing values are filtered in the calculation of all statistics, however the column <code>:nmissing</code> will report the number of missing values of that variable.</p><p>If custom functions are provided, they are called repeatedly with the vector corresponding to each column as the only argument. For columns allowing for missing values, the vector is wrapped in a call to <code>skipmissing</code>: custom functions must therefore support such objects (and not only vectors), and cannot access missing values.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; df = DataFrame(i=1:10, x=0.1:0.1:1.0, y=&#39;a&#39;:&#39;j&#39;);

julia&gt; describe(df)
3×7 DataFrame
 Row │ variable  mean    min  median  max  nmissing  eltype
     │ Symbol    Union…  Any  Union…  Any  Int64     DataType
─────┼────────────────────────────────────────────────────────
   1 │ i         5.5     1    5.5     10          0  Int64
   2 │ x         0.55    0.1  0.55    1.0         0  Float64
   3 │ y                 a            j           0  Char

julia&gt; describe(df, :min, :max)
3×3 DataFrame
 Row │ variable  min  max
     │ Symbol    Any  Any
─────┼────────────────────
   1 │ i         1    10
   2 │ x         0.1  1.0
   3 │ y         a    j

julia&gt; describe(df, :min, sum =&gt; :sum)
3×3 DataFrame
 Row │ variable  min  sum
     │ Symbol    Any  Union…
─────┼───────────────────────
   1 │ i         1    55
   2 │ x         0.1  5.5
   3 │ y         a

julia&gt; describe(df, :min, sum =&gt; :sum, cols=:x)
1×3 DataFrame
 Row │ variable  min      sum
     │ Symbol    Float64  Float64
─────┼────────────────────────────
   1 │ x             0.1      5.5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/10c5b5e9e7f916024b2f102d040fdd9d4e6bd371/src/abstractdataframe/abstractdataframe.jl#L518-L599">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.length" href="#Base.length"><code>Base.length</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">length(dfr::DataFrameRow)</code></pre><p>Return the number of elements of <code>dfr</code>.</p><p>See also: <a href="#Base.size"><code>size</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; dfr = DataFrame(a=1:3, b=&#39;a&#39;:&#39;c&#39;)[1, :]
DataFrameRow
 Row │ a      b
     │ Int64  Char
─────┼─────────────
   1 │     1  a

julia&gt; length(dfr)
2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/10c5b5e9e7f916024b2f102d040fdd9d4e6bd371/src/dataframerow/dataframerow.jl#L354-L373">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataAPI.ncol" href="#DataAPI.ncol"><code>DataAPI.ncol</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">nrow(df::AbstractDataFrame)
ncol(df::AbstractDataFrame)</code></pre><p>Return the number of rows or columns in an <code>AbstractDataFrame</code> <code>df</code>.</p><p>See also <a href="#Base.size"><code>size</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; df = DataFrame(i=1:10, x=rand(10), y=rand([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;], 10));

julia&gt; size(df)
(10, 3)

julia&gt; nrow(df)
10

julia&gt; ncol(df)
3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/10c5b5e9e7f916024b2f102d040fdd9d4e6bd371/src/abstractdataframe/abstractdataframe.jl#L1980-L2003">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.ndims" href="#Base.ndims"><code>Base.ndims</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">ndims(::AbstractDataFrame)
ndims(::Type{&lt;:AbstractDataFrame})</code></pre><p>Return the number of dimensions of a data frame, which is always <code>2</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/10c5b5e9e7f916024b2f102d040fdd9d4e6bd371/src/abstractdataframe/abstractdataframe.jl#L368-L373">source</a></section><section><div><pre><code class="nohighlight hljs">ndims(::DataFrameRow)
ndims(::Type{&lt;:DataFrameRow})</code></pre><p>Return the number of dimensions of a data frame row, which is always <code>1</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/10c5b5e9e7f916024b2f102d040fdd9d4e6bd371/src/dataframerow/dataframerow.jl#L376-L381">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataAPI.nrow" href="#DataAPI.nrow"><code>DataAPI.nrow</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">nrow(df::AbstractDataFrame)
ncol(df::AbstractDataFrame)</code></pre><p>Return the number of rows or columns in an <code>AbstractDataFrame</code> <code>df</code>.</p><p>See also <a href="#Base.size"><code>size</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; df = DataFrame(i=1:10, x=rand(10), y=rand([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;], 10));

julia&gt; size(df)
(10, 3)

julia&gt; nrow(df)
10

julia&gt; ncol(df)
3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/10c5b5e9e7f916024b2f102d040fdd9d4e6bd371/src/abstractdataframe/abstractdataframe.jl#L1980-L2003">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFrames.rownumber" href="#DataFrames.rownumber"><code>DataFrames.rownumber</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">rownumber(dfr::DataFrameRow)</code></pre><p>Return a row number in the <code>AbstractDataFrame</code> that <code>dfr</code> was created from.</p><p>Note that this differs from the first element in the tuple returned by <code>parentindices</code>. The latter gives the row number in the <code>parent(dfr)</code>, which is the source <code>DataFrame</code> where data that <code>dfr</code> gives access to is stored.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; df = DataFrame(reshape(1:12, 3, 4), :auto)
3×4 DataFrame
 Row │ x1     x2     x3     x4
     │ Int64  Int64  Int64  Int64
─────┼────────────────────────────
   1 │     1      4      7     10
   2 │     2      5      8     11
   3 │     3      6      9     12

julia&gt; dfr = df[2, :]
DataFrameRow
 Row │ x1     x2     x3     x4
     │ Int64  Int64  Int64  Int64
─────┼────────────────────────────
   2 │     2      5      8     11

julia&gt; rownumber(dfr)
2

julia&gt; parentindices(dfr)
(2, Base.OneTo(4))

julia&gt; parent(dfr)
3×4 DataFrame
 Row │ x1     x2     x3     x4
     │ Int64  Int64  Int64  Int64
─────┼────────────────────────────
   1 │     1      4      7     10
   2 │     2      5      8     11
   3 │     3      6      9     12

julia&gt; dfv = @view df[2:3, 1:3]
2×3 SubDataFrame
 Row │ x1     x2     x3
     │ Int64  Int64  Int64
─────┼─────────────────────
   1 │     2      5      8
   2 │     3      6      9

julia&gt; dfrv = dfv[2, :]
DataFrameRow
 Row │ x1     x2     x3
     │ Int64  Int64  Int64
─────┼─────────────────────
   3 │     3      6      9

julia&gt; rownumber(dfrv)
2

julia&gt; parentindices(dfrv)
(3, 1:3)

julia&gt; parent(dfrv)
3×4 DataFrame
 Row │ x1     x2     x3     x4
     │ Int64  Int64  Int64  Int64
─────┼────────────────────────────
   1 │     1      4      7     10
   2 │     2      5      8     11
   3 │     3      6      9     12</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/10c5b5e9e7f916024b2f102d040fdd9d4e6bd371/src/dataframerow/dataframerow.jl#L121-L193">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.show" href="#Base.show"><code>Base.show</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">show([io::IO, ]df::AbstractDataFrame;
     allrows::Bool = !get(io, :limit, false),
     allcols::Bool = !get(io, :limit, false),
     allgroups::Bool = !get(io, :limit, false),
     rowlabel::Symbol = :Row,
     summary::Bool = true,
     eltypes::Bool = true,
     truncate::Int = 32,
     kwargs...)</code></pre><p>Render a data frame to an I/O stream. The specific visual representation chosen depends on the width of the display.</p><p>If <code>io</code> is omitted, the result is printed to <code>stdout</code>, and <code>allrows</code>, <code>allcols</code> and <code>allgroups</code> default to <code>false</code>.</p><p><strong>Arguments</strong></p><ul><li><code>io::IO</code>: The I/O stream to which <code>df</code> will be printed.</li><li><code>df::AbstractDataFrame</code>: The data frame to print.</li><li><code>allrows::Bool</code>: Whether to print all rows, rather than a subset that fits the device height. By default this is the case only if <code>io</code> does not have the <code>IOContext</code> property <code>limit</code> set.</li><li><code>allcols::Bool</code>: Whether to print all columns, rather than a subset that fits the device width. By default this is the case only if <code>io</code> does not have the <code>IOContext</code> property <code>limit</code> set.</li><li><code>allgroups::Bool</code>: Whether to print all groups rather than the first and last, when <code>df</code> is a <code>GroupedDataFrame</code>. By default this is the case only if <code>io</code> does not have the <code>IOContext</code> property <code>limit</code> set.</li><li><code>rowlabel::Symbol = :Row</code>: The label to use for the column containing row numbers.</li><li><code>summary::Bool = true</code>: Whether to print a brief string summary of the data frame.</li><li><code>eltypes::Bool = true</code>: Whether to print the column types under column names.</li><li><code>truncate::Int = 32</code>: the maximal display width the output can use before being truncated (in the <code>textwidth</code> sense, excluding <code>…</code>). If <code>truncate</code> is 0 or less, no truncation is applied.</li><li><code>kwargs...</code>: Any keyword argument supported by the function <code>pretty_table</code> of PrettyTables.jl can be passed here to customize the output.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using DataFrames

julia&gt; df = DataFrame(A=1:3, B=[&quot;x&quot;, &quot;y&quot;, &quot;z&quot;]);

julia&gt; show(df, show_row_number=false)
3×2 DataFrame
 A      B
 Int64  String
───────────────
     1  x
     2  y
     3  z</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/10c5b5e9e7f916024b2f102d040fdd9d4e6bd371/src/abstractdataframe/show.jl#L290-L344">source</a></section><section><div><pre><code class="nohighlight hljs">show(io::IO, mime::MIME, df::AbstractDataFrame)</code></pre><p>Render a data frame to an I/O stream in MIME type <code>mime</code>.</p><p><strong>Arguments</strong></p><ul><li><code>io::IO</code>: The I/O stream to which <code>df</code> will be printed.</li><li><code>mime::MIME</code>: supported MIME types are: <code>&quot;text/plain&quot;</code>, <code>&quot;text/html&quot;</code>, <code>&quot;text/latex&quot;</code>, <code>&quot;text/csv&quot;</code>, <code>&quot;text/tab-separated-values&quot;</code> (the last two MIME types do not support  showing <code>#undef</code> values)</li><li><code>df::AbstractDataFrame</code>: The data frame to print.</li></ul><p>Additionally selected MIME types support passing the following keyword arguments:</p><ul><li>MIME type <code>&quot;text/plain&quot;</code> accepts all listed keyword arguments and therir behavior is identical as for <code>show(::IO, ::AbstractDataFrame)</code></li><li>MIME type <code>&quot;text/html&quot;</code> accepts <code>summary</code> keyword argument which allows to choose whether to print a brief string summary of the data frame.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; show(stdout, MIME(&quot;text/latex&quot;), DataFrame(A=1:3, B=[&quot;x&quot;, &quot;y&quot;, &quot;z&quot;]))
\begin{tabular}{r|cc}
	&amp; A &amp; B\\
	\hline
	&amp; Int64 &amp; String\\
	\hline
	1 &amp; 1 &amp; x \\
	2 &amp; 2 &amp; y \\
	3 &amp; 3 &amp; z \\
\end{tabular}
14

julia&gt; show(stdout, MIME(&quot;text/csv&quot;), DataFrame(A=1:3, B=[&quot;x&quot;, &quot;y&quot;, &quot;z&quot;]))
&quot;A&quot;,&quot;B&quot;
1,&quot;x&quot;
2,&quot;y&quot;
3,&quot;z&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/10c5b5e9e7f916024b2f102d040fdd9d4e6bd371/src/abstractdataframe/io.jl#L89-L127">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.size" href="#Base.size"><code>Base.size</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">size(df::AbstractDataFrame[, dim])</code></pre><p>Return a tuple containing the number of rows and columns of <code>df</code>. Optionally a dimension <code>dim</code> can be specified, where <code>1</code> corresponds to rows and <code>2</code> corresponds to columns.</p><p>See also: <a href="#DataAPI.nrow"><code>nrow</code></a>, <a href="#DataAPI.ncol"><code>ncol</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; df = DataFrame(a=1:3, b=&#39;a&#39;:&#39;c&#39;);

julia&gt; size(df)
(3, 2)

julia&gt; size(df, 1)
3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/10c5b5e9e7f916024b2f102d040fdd9d4e6bd371/src/abstractdataframe/abstractdataframe.jl#L329-L348">source</a></section><section><div><pre><code class="nohighlight hljs">size(dfr::DataFrameRow[, dim])</code></pre><p>Return a 1-tuple containing the number of elements of <code>dfr</code>. If an optional dimension <code>dim</code> is specified, it must be <code>1</code>, and the number of elements is returned directly as a number.</p><p>See also: <a href="#Base.length"><code>length</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; dfr = DataFrame(a=1:3, b=&#39;a&#39;:&#39;c&#39;)[1, :]
DataFrameRow
 Row │ a      b
     │ Int64  Char
─────┼─────────────
   1 │     1  a

julia&gt; size(dfr)
(2,)

julia&gt; size(dfr, 1)
2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/10c5b5e9e7f916024b2f102d040fdd9d4e6bd371/src/dataframerow/dataframerow.jl#L326-L350">source</a></section></article><h2 id="Working-with-column-names"><a class="docs-heading-anchor" href="#Working-with-column-names">Working with column names</a><a id="Working-with-column-names-1"></a><a class="docs-heading-anchor-permalink" href="#Working-with-column-names" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Base.names" href="#Base.names"><code>Base.names</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">names(df::AbstractDataFrame, cols=:)
names(df::DataFrameRow, cols=:)
names(df::GroupedDataFrame, cols=:)
names(df::DataFrameRows, cols=:)
names(df::DataFrameColumns, cols=:)
names(df::GroupKey)</code></pre><p>Return a freshly allocated <code>Vector{String}</code> of names of columns contained in <code>df</code>.</p><p>If <code>cols</code> is passed then restrict returned column names to those matching the selector (this is useful in particular with regular expressions, <code>Cols</code>, <code>Not</code>, and <code>Between</code>). <code>cols</code> can be:</p><ul><li>any column selector (<code>Symbol</code>, string or integer; <code>:</code>, <code>Cols</code>, <code>All</code>, <code>Between</code>, <code>Not</code>, a regular expression, or a vector of <code>Symbol</code>s, strings or integers)</li><li>a <code>Type</code>, in which case names of columns whose <code>eltype</code> is a subtype of <code>T</code> are returned</li><li>a <code>Function</code> predicate taking the column name as a string and returning <code>true</code> for columns that should be kept</li></ul><p>See also <a href="#Base.propertynames"><code>propertynames</code></a> which returns a <code>Vector{Symbol}</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; df = DataFrame(x1=[1, missing, missing], x2=[3, 2, 4], x3=[3, missing, 2], x4=Union{Int, Missing}[2, 4, 4])
3×4 DataFrame
 Row │ x1       x2     x3       x4
     │ Int64?   Int64  Int64?   Int64?
─────┼─────────────────────────────────
   1 │       1      3        3       2
   2 │ missing      2  missing       4
   3 │ missing      4        2       4

julia&gt; names(df)
4-element Vector{String}:
 &quot;x1&quot;
 &quot;x2&quot;
 &quot;x3&quot;
 &quot;x4&quot;

julia&gt; names(df, Int) # pick columns whose element type is Int
1-element Vector{String}:
 &quot;x2&quot;

julia&gt; names(df, x -&gt; x[end] == &#39;2&#39;) # pick columns for which last character in their name is &#39;2&#39;
1-element Vector{String}:
 &quot;x2&quot;

julia&gt; fun(col) = sum(skipmissing(col)) &gt;= 10
fun (generic function with 1 method)

julia&gt; names(df, fun.(eachcol(df))) # pick columns for which sum of their elements is at least 10
1-element Vector{String}:
 &quot;x4&quot;

julia&gt; names(df, eltype.(eachcol(df)) .&gt;: Missing) # pick columns that allow missing values
3-element Vector{String}:
 &quot;x1&quot;
 &quot;x3&quot;
 &quot;x4&quot;

julia&gt; names(df, any.(ismissing, eachcol(df))) # pick columns that contain missing values
2-element Vector{String}:
 &quot;x1&quot;
 &quot;x3&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/10c5b5e9e7f916024b2f102d040fdd9d4e6bd371/src/abstractdataframe/abstractdataframe.jl#L36-L101">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.propertynames" href="#Base.propertynames"><code>Base.propertynames</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">propertynames(df::AbstractDataFrame)</code></pre><p>Return a freshly allocated <code>Vector{Symbol}</code> of names of columns contained in <code>df</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/10c5b5e9e7f916024b2f102d040fdd9d4e6bd371/src/abstractdataframe/abstractdataframe.jl#L382-L386">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFrames.rename" href="#DataFrames.rename"><code>DataFrames.rename</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">rename(df::AbstractDataFrame, vals::AbstractVector{Symbol};
       makeunique::Bool=false)
rename(df::AbstractDataFrame, vals::AbstractVector{&lt;:AbstractString};
       makeunique::Bool=false)
rename(df::AbstractDataFrame, (from =&gt; to)::Pair...)
rename(df::AbstractDataFrame, d::AbstractDict)
rename(df::AbstractDataFrame, d::AbstractVector{&lt;:Pair})
rename(f::Function, df::AbstractDataFrame)</code></pre><p>Create a new data frame that is a copy of <code>df</code> with changed column names. Each name is changed at most once. Permutation of names is allowed.</p><p><strong>Arguments</strong></p><ul><li><code>df</code> : the <code>AbstractDataFrame</code>; if it is a <code>SubDataFrame</code> then renaming is only allowed if it was created using <code>:</code> as a column selector.</li><li><code>d</code> : an <code>AbstractDict</code> or an <code>AbstractVector</code> of <code>Pair</code>s that maps the original names or column numbers to new names</li><li><code>f</code> : a function which for each column takes the old name as a <code>String</code> and returns the new name that gets converted to a <code>Symbol</code></li><li><code>vals</code> : new column names as a vector of <code>Symbol</code>s or <code>AbstractString</code>s of the same length as the number of columns in <code>df</code></li><li><code>makeunique</code> : if <code>false</code> (the default), an error will be raised if duplicate names are found; if <code>true</code>, duplicate names will be suffixed with <code>_i</code> (<code>i</code> starting at 1 for the first duplicate).</li></ul><p>If pairs are passed to <code>rename</code> (as positional arguments or in a dictionary or a vector) then:</p><ul><li><code>from</code> value can be a <code>Symbol</code>, an <code>AbstractString</code> or an <code>Integer</code>;</li><li><code>to</code> value can be a <code>Symbol</code> or an <code>AbstractString</code>.</li></ul><p>Mixing symbols and strings in <code>to</code> and <code>from</code> is not allowed.</p><p>See also: <a href="#DataFrames.rename!"><code>rename!</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; df = DataFrame(i=1, x=2, y=3)
1×3 DataFrame
 Row │ i      x      y
     │ Int64  Int64  Int64
─────┼─────────────────────
   1 │     1      2      3

julia&gt; rename(df, :i =&gt; :A, :x =&gt; :X)
1×3 DataFrame
 Row │ A      X      y
     │ Int64  Int64  Int64
─────┼─────────────────────
   1 │     1      2      3

julia&gt; rename(df, :x =&gt; :y, :y =&gt; :x)
1×3 DataFrame
 Row │ i      y      x
     │ Int64  Int64  Int64
─────┼─────────────────────
   1 │     1      2      3

julia&gt; rename(df, [1 =&gt; :A, 2 =&gt; :X])
1×3 DataFrame
 Row │ A      X      y
     │ Int64  Int64  Int64
─────┼─────────────────────
   1 │     1      2      3

julia&gt; rename(df, Dict(&quot;i&quot; =&gt; &quot;A&quot;, &quot;x&quot; =&gt; &quot;X&quot;))
1×3 DataFrame
 Row │ A      X      y
     │ Int64  Int64  Int64
─────┼─────────────────────
   1 │     1      2      3

julia&gt; rename(uppercase, df)
1×3 DataFrame
 Row │ I      X      Y
     │ Int64  Int64  Int64
─────┼─────────────────────
   1 │     1      2      3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/10c5b5e9e7f916024b2f102d040fdd9d4e6bd371/src/abstractdataframe/abstractdataframe.jl#L242-L321">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFrames.rename!" href="#DataFrames.rename!"><code>DataFrames.rename!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">rename!(df::AbstractDataFrame, vals::AbstractVector{Symbol};
        makeunique::Bool=false)
rename!(df::AbstractDataFrame, vals::AbstractVector{&lt;:AbstractString};
        makeunique::Bool=false)
rename!(df::AbstractDataFrame, (from =&gt; to)::Pair...)
rename!(df::AbstractDataFrame, d::AbstractDict)
rename!(df::AbstractDataFrame, d::AbstractVector{&lt;:Pair})
rename!(f::Function, df::AbstractDataFrame)</code></pre><p>Rename columns of <code>df</code> in-place. Each name is changed at most once. Permutation of names is allowed.</p><p><strong>Arguments</strong></p><ul><li><code>df</code> : the <code>AbstractDataFrame</code></li><li><code>d</code> : an <code>AbstractDict</code> or an <code>AbstractVector</code> of <code>Pair</code>s that maps the original names or column numbers to new names</li><li><code>f</code> : a function which for each column takes the old name as a <code>String</code> and returns the new name that gets converted to a <code>Symbol</code></li><li><code>vals</code> : new column names as a vector of <code>Symbol</code>s or <code>AbstractString</code>s of the same length as the number of columns in <code>df</code></li><li><code>makeunique</code> : if <code>false</code> (the default), an error will be raised if duplicate names are found; if <code>true</code>, duplicate names will be suffixed with <code>_i</code> (<code>i</code> starting at 1 for the first duplicate).</li></ul><p>If pairs are passed to <code>rename!</code> (as positional arguments or in a dictionary or a vector) then:</p><ul><li><code>from</code> value can be a <code>Symbol</code>, an <code>AbstractString</code> or an <code>Integer</code>;</li><li><code>to</code> value can be a <code>Symbol</code> or an <code>AbstractString</code>.</li></ul><p>Mixing symbols and strings in <code>to</code> and <code>from</code> is not allowed.</p><p>See also: <a href="#DataFrames.rename"><code>rename</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; df = DataFrame(i=1, x=2, y=3)
1×3 DataFrame
 Row │ i      x      y
     │ Int64  Int64  Int64
─────┼─────────────────────
   1 │     1      2      3

julia&gt; rename!(df, Dict(:i =&gt; &quot;A&quot;, :x =&gt; &quot;X&quot;))
1×3 DataFrame
 Row │ A      X      y
     │ Int64  Int64  Int64
─────┼─────────────────────
   1 │     1      2      3

julia&gt; rename!(df, [:a, :b, :c])
1×3 DataFrame
 Row │ a      b      c
     │ Int64  Int64  Int64
─────┼─────────────────────
   1 │     1      2      3

julia&gt; rename!(df, [:a, :b, :a])
ERROR: ArgumentError: Duplicate variable names: :a. Pass makeunique=true to make them unique using a suffix automatically.

julia&gt; rename!(df, [:a, :b, :a], makeunique=true)
1×3 DataFrame
 Row │ a      b      a_1
     │ Int64  Int64  Int64
─────┼─────────────────────
   1 │     1      2      3

julia&gt; rename!(uppercase, df)
1×3 DataFrame
 Row │ A      B      A_1
     │ Int64  Int64  Int64
─────┼─────────────────────
   1 │     1      2      3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/10c5b5e9e7f916024b2f102d040fdd9d4e6bd371/src/abstractdataframe/abstractdataframe.jl#L122-L196">source</a></section></article><h2 id="Mutating-and-transforming-data-frames-and-grouped-data-frames"><a class="docs-heading-anchor" href="#Mutating-and-transforming-data-frames-and-grouped-data-frames">Mutating and transforming data frames and grouped data frames</a><a id="Mutating-and-transforming-data-frames-and-grouped-data-frames-1"></a><a class="docs-heading-anchor-permalink" href="#Mutating-and-transforming-data-frames-and-grouped-data-frames" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Base.append!" href="#Base.append!"><code>Base.append!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">append!(df::DataFrame, df2::AbstractDataFrame; cols::Symbol=:setequal,
        promote::Bool=(cols in [:union, :subset]))
append!(df::DataFrame, table; cols::Symbol=:setequal,
        promote::Bool=(cols in [:union, :subset]))</code></pre><p>Add the rows of <code>df2</code> to the end of <code>df</code>. If the second argument <code>table</code> is not an <code>AbstractDataFrame</code> then it is converted using <code>DataFrame(table, copycols=false)</code> before being appended.</p><p>The exact behavior of <code>append!</code> depends on the <code>cols</code> argument:</p><ul><li>If <code>cols == :setequal</code> (this is the default) then <code>df2</code> must contain exactly the same columns as <code>df</code> (but possibly in a different order).</li><li>If <code>cols == :orderequal</code> then <code>df2</code> must contain the same columns in the same order (for <code>AbstractDict</code> this option requires that <code>keys(row)</code> matches <code>propertynames(df)</code> to allow for support of ordered dicts; however, if <code>df2</code> is a <code>Dict</code> an error is thrown as it is an unordered collection).</li><li>If <code>cols == :intersect</code> then <code>df2</code> may contain more columns than <code>df</code>, but all column names that are present in <code>df</code> must be present in <code>df2</code> and only these are used.</li><li>If <code>cols == :subset</code> then <code>append!</code> behaves like for <code>:intersect</code> but if some column is missing in <code>df2</code> then a <code>missing</code> value is pushed to <code>df</code>.</li><li>If <code>cols == :union</code> then <code>append!</code> adds columns missing in <code>df</code> that are present in <code>df2</code>, for columns present in <code>df</code> but missing in <code>df2</code> a <code>missing</code> value is pushed.</li></ul><p>If <code>promote=true</code> and element type of a column present in <code>df</code> does not allow the type of a pushed argument then a new column with a promoted element type allowing it is freshly allocated and stored in <code>df</code>. If <code>promote=false</code> an error is thrown.</p><p>The above rule has the following exceptions:</p><ul><li>If <code>df</code> has no columns then copies of columns from <code>df2</code> are added to it.</li><li>If <code>df2</code> has no columns then calling <code>append!</code> leaves <code>df</code> unchanged.</li></ul><p>Please note that <code>append!</code> must not be used on a <code>DataFrame</code> that contains columns that are aliases (equal when compared with <code>===</code>).</p><p><strong>See also</strong></p><p>Use <a href="#Base.push!"><code>push!</code></a> to add individual rows to a data frame and <a href="#Base.vcat"><code>vcat</code></a> to vertically concatenate data frames.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; df1 = DataFrame(A=1:3, B=1:3)
3×2 DataFrame
 Row │ A      B
     │ Int64  Int64
─────┼──────────────
   1 │     1      1
   2 │     2      2
   3 │     3      3

julia&gt; df2 = DataFrame(A=4.0:6.0, B=4:6)
3×2 DataFrame
 Row │ A        B
     │ Float64  Int64
─────┼────────────────
   1 │     4.0      4
   2 │     5.0      5
   3 │     6.0      6

julia&gt; append!(df1, df2);

julia&gt; df1
6×2 DataFrame
 Row │ A      B
     │ Int64  Int64
─────┼──────────────
   1 │     1      1
   2 │     2      2
   3 │     3      3
   4 │     4      4
   5 │     5      5
   6 │     6      6</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/10c5b5e9e7f916024b2f102d040fdd9d4e6bd371/src/dataframe/dataframe.jl#L1234-L1312">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFrames.combine" href="#DataFrames.combine"><code>DataFrames.combine</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">combine(df::AbstractDataFrame, args...; renamecols::Bool=true)
combine(f::Callable, df::AbstractDataFrame; renamecols::Bool=true)
combine(gd::GroupedDataFrame, args...;
        keepkeys::Bool=true, ungroup::Bool=true, renamecols::Bool=true)
combine(f::Base.Callable, gd::GroupedDataFrame;
        keepkeys::Bool=true, ungroup::Bool=true, renamecols::Bool=true)</code></pre><p>Create a new data frame that contains columns from <code>df</code> or <code>gd</code> specified by <code>args</code> and return it. The result can have any number of rows that is determined by the values returned by passed transformations.</p><p>Below detailed common rules for all transformation functions supported by DataFrames.jl are explained and compared.</p><p>All these operations are supported both for <code>AbstractDataFrame</code> (when split and combine steps are skipped) and <code>GroupedDataFrame</code>. Technically, <code>AbstractDataFrame</code> is just considered as being grouped on no columns (meaning it has a single group, or zero groups if it is empty). The only difference is that in this case the <code>keepkeys</code> and <code>ungroup</code> keyword arguments (described below) are not supported and a data frame is always returned, as there are no split and combine steps in this case.</p><p>In order to perform operations by groups you first need to create a <code>GroupedDataFrame</code> object from your data frame using the <code>groupby</code> function that takes two arguments: (1) a data frame to be grouped, and (2) a set of columns to group by.</p><p>Operations can then be applied on each group using one of the following functions:</p><ul><li><code>combine</code>: does not put restrictions on number of rows returned, the order of rows is specified by the order of groups in <code>GroupedDataFrame</code>; it is typically used to compute summary statistics by group;</li><li><code>select</code>: return a data frame with the number and order of rows exactly the same as the source data frame, including only new calculated columns; <code>select!</code> is an in-place version of <code>select</code>;</li><li><code>transform</code>: return a data frame with the number and order of rows exactly the same as the source data frame, including all columns from the source and new calculated columns; <code>transform!</code> is an in-place version of <code>transform</code>.</li></ul><p>All these functions take a specification of one or more functions to apply to each subset of the <code>DataFrame</code>. This specification can be of the following forms:</p><ol><li>standard column selectors (integers, <code>Symbol</code>s, strings, vectors of integers, vectors of <code>Symbol</code>s, vectors of strings, <code>All</code>, <code>Cols</code>, <code>:</code>, <code>Between</code>, <code>Not</code> and regular expressions)</li><li>a <code>cols =&gt; function</code> pair indicating that <code>function</code> should be called with positional arguments holding columns <code>cols</code>, which can be any valid column selector; in this case target column name is automatically generated and it is assumed that <code>function</code> returns a single value or a vector; the generated name is created by concatenating source column name and <code>function</code> name by default (see examples below).</li><li>a <code>cols =&gt; function =&gt; target_cols</code> form additionally explicitly specifying the target column or columns, which must be a single name (as a <code>Symbol</code> or a string), a vector of names or <code>AsTable</code>. Additionally it can be a <code>Function</code> which takes a string or a vector of strings as an argument containing names of columns selected by <code>cols</code>, and returns the target columns names (all accepted types except <code>AsTable</code> are allowed).</li><li>a <code>col =&gt; target_cols</code> pair, which renames the column <code>col</code> to <code>target_cols</code>, which must be single name (as a <code>Symbol</code> or a string), a vector of names or <code>AsTable</code>.</li><li>a <code>nrow</code> or <code>nrow =&gt; target_cols</code> form which efficiently computes the number of rows in a group; without <code>target_cols</code> the new column is called <code>:nrow</code>, otherwise it must be single name (as a <code>Symbol</code> or a string).</li><li>vectors or matrices containing transformations specified by the <code>Pair</code> syntax described in points 2 to 5</li><li>a function which will be called with a <code>SubDataFrame</code> corresponding to each group if a <code>GroupedDataFrame</code> is processed, or with the data frame itself if an <code>AbstractDataFrame</code> is processed; this form should be avoided due to its poor performance unless the number of groups is small or a very large number of columns are processed (in which case <code>SubDataFrame</code> avoids excessive compilation)</li></ol><p>Note! If the expression of the form <code>x =&gt; y</code> is passed then except for the special convenience form <code>nrow =&gt; target_cols</code> it is always interpreted as <code>cols =&gt; function</code>. In particular the following expression <code>function =&gt; target_cols</code> is not a valid transformation specification.</p><p>Note! If <code>cols</code> or <code>target_cols</code> are one of <code>All</code>, <code>Cols</code>, <code>Between</code>, or <code>Not</code>, broadcasting using <code>.=&gt;</code> is supported and is equivalent to broadcasting the result of <code>names(df, cols)</code> or <code>names(df, target_cols)</code>. This behaves as if broadcasting happened after replacing the selector with selected column names within the data frame scope.</p><p>All functions have two types of signatures. One of them takes a <code>GroupedDataFrame</code> as the first argument and an arbitrary number of transformations described above as following arguments. The second type of signature is when a <code>Function</code> or a <code>Type</code> is passed as the first argument and a <code>GroupedDataFrame</code> as the second argument (similar to <code>map</code>).</p><p>As a special rule, with the <code>cols =&gt; function</code> and <code>cols =&gt; function =&gt; target_cols</code> syntaxes, if <code>cols</code> is wrapped in an <code>AsTable</code> object then a <code>NamedTuple</code> containing columns selected by <code>cols</code> is passed to <code>function</code>.</p><p>What is allowed for <code>function</code> to return is determined by the <code>target_cols</code> value:</p><ol><li>If both <code>cols</code> and <code>target_cols</code> are omitted (so only a <code>function</code> is passed), then returning a data frame, a matrix, a <code>NamedTuple</code>, or a <code>DataFrameRow</code> will produce multiple columns in the result. Returning any other value produces a single column.</li><li>If <code>target_cols</code> is a <code>Symbol</code> or a string then the function is assumed to return a single column. In this case returning a data frame, a matrix, a <code>NamedTuple</code>, or a <code>DataFrameRow</code> raises an error.</li><li>If <code>target_cols</code> is a vector of <code>Symbol</code>s or strings or <code>AsTable</code> it is assumed that <code>function</code> returns multiple columns. If <code>function</code> returns one of <code>AbstractDataFrame</code>, <code>NamedTuple</code>, <code>DataFrameRow</code>, <code>AbstractMatrix</code> then rules described in point 1 above apply. If <code>function</code> returns an <code>AbstractVector</code> then each element of this vector must support the <code>keys</code> function, which must return a collection of <code>Symbol</code>s, strings or integers; the return value of <code>keys</code> must be identical for all elements. Then as many columns are created as there are elements in the return value of the <code>keys</code> function. If <code>target_cols</code> is <code>AsTable</code> then their names are set to be equal to the key names except if <code>keys</code> returns integers, in which case they are prefixed by <code>x</code> (so the column names are e.g. <code>x1</code>, <code>x2</code>, ...). If <code>target_cols</code> is a vector of <code>Symbol</code>s or strings then column names produced using the rules above are ignored and replaced by <code>target_cols</code> (the number of columns must be the same as the length of <code>target_cols</code> in this case). If <code>fun</code> returns a value of any other type then it is assumed that it is a table conforming to the Tables.jl API and the <code>Tables.columntable</code> function is called on it to get the resulting columns and their names. The names are retained when <code>target_cols</code> is <code>AsTable</code> and are replaced if <code>target_cols</code> is a vector of <code>Symbol</code>s or strings.</li></ol><p>In all of these cases, <code>function</code> can return either a single row or multiple rows. As a particular rule, values wrapped in a <code>Ref</code> or a <code>0</code>-dimensional <code>AbstractArray</code> are unwrapped and then treated as a single row.</p><p><code>select</code>/<code>select!</code> and <code>transform</code>/<code>transform!</code> always return a data frame with the same number and order of rows as the source (even if <code>GroupedDataFrame</code> had its groups reordered), except when selection results in zero columns in the resulting data frame (in which case the result has zero rows).</p><p>For <code>combine</code>, rows in the returned object appear in the order of groups in the <code>GroupedDataFrame</code>. The functions can return an arbitrary number of rows for each group, but the kind of returned object and the number and names of columns must be the same for all groups, except when a <code>DataFrame()</code> or <code>NamedTuple()</code> is returned, in which case a given group is skipped.</p><p>It is allowed to mix single values and vectors if multiple transformations are requested. In this case single value will be repeated to match the length of columns specified by returned vectors.</p><p>To apply <code>function</code> to each row instead of whole columns, it can be wrapped in a <code>ByRow</code> struct. <code>cols</code> can be any column indexing syntax, in which case <code>function</code> will be passed one argument for each of the columns specified by <code>cols</code> or a <code>NamedTuple</code> of them if specified columns are wrapped in <code>AsTable</code>. If <code>ByRow</code> is used it is allowed for <code>cols</code> to select an empty set of columns, in which case <code>function</code> is called for each row without any arguments and an empty <code>NamedTuple</code> is passed if empty set of columns is wrapped in <code>AsTable</code>.</p><p>If a collection of column names is passed then requesting duplicate column names in target data frame are accepted (e.g. <code>select!(df, [:a], :, r&quot;a&quot;)</code> is allowed) and only the first occurrence is used. In particular a syntax to move column <code>:col</code> to the first position in the data frame is <code>select!(df, :col, :)</code>. On the contrary, output column names of renaming, transformation and single column selection operations must be unique, so e.g. <code>select!(df, :a, :a =&gt; :a)</code> or <code>select!(df, :a, :a =&gt; ByRow(sin) =&gt; :a)</code> are not allowed.</p><p>In general columns returned by transformations are stored in the target data frame without copying. An exception to this rule is when columns from the source data frame are reused in the target data frame. This can happen via expressions like: <code>:x1</code>, <code>[:x1, :x2]</code>, <code>:x1 =&gt; :x2</code>, <code>:x1 =&gt; identity =&gt; :x2</code>, or <code>:x1 =&gt; (x -&gt; @view x[inds])</code> (note that in the last case the source column is reused indirectly via a view). In such cases the behavior depends on the value of the <code>copycols</code> keyword argument:</p><ul><li>if <code>copycols=true</code> then results of such transformations always perform a copy of the source column or its view;</li><li>if <code>copycols=false</code> then copies are only performed to avoid storing the same column several times in the target data frame; more precisely, no copy is made the first time a column is used, but each subsequent reuse of a source column (when compared using <code>===</code>, which excludes views of source columns) performs a copy;</li></ul><p>Note that performing <code>transform!</code> or <code>select!</code> assumes that <code>copycols=false</code>.</p><p>If <code>df</code> is a <code>SubDataFrame</code> and <code>copycols=true</code> then a <code>DataFrame</code> is returned and the same copying rules apply as for a <code>DataFrame</code> input: this means in particular that selected columns will be copied. If <code>copycols=false</code>, a <code>SubDataFrame</code> is returned without copying columns and in this case transforming or renaming columns is not allowed.</p><p>If a <code>GroupedDataFrame</code> is passed, a separate task is spawned for each specified transformation; each transformation then spawns as many tasks as Julia threads, and splits processing of groups across them (however, currently transformations with optimized implementations like <code>sum</code> and transformations that return multiple rows use a single task for all groups). This allows for parallel operation when Julia was started with more than one thread. Passed transformation functions should therefore not modify global variables (i.e. they should be pure), or use locks to control parallel accesses. In the future, parallelism may be extended to other cases, so this requirement also holds for <code>DataFrame</code> inputs.</p><p>In order to improve the performance of the operations some transformations invoke optimized implementation, see <a href="../internals/#DataFrames.table_transformation"><code>table_transformation</code></a> for details.</p><p><strong>Keyword arguments</strong></p><ul><li><code>renamecols::Bool=true</code> : whether in the <code>cols =&gt; function</code> form automatically generated column names should include the name of transformation functions or not.</li><li><code>keepkeys::Bool=true</code> : whether grouping columns of <code>gd</code> should be kept in the returned data frame.</li><li><code>ungroup::Bool=true</code> : whether the return value of the operation on <code>gd</code> should be a data frame or a <code>GroupedDataFrame</code>.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; df = DataFrame(a=1:3, b=4:6)
3×2 DataFrame
 Row │ a      b
     │ Int64  Int64
─────┼──────────────
   1 │     1      4
   2 │     2      5
   3 │     3      6

julia&gt; combine(df, :a =&gt; sum, nrow, renamecols=false)
1×2 DataFrame
 Row │ a      nrow
     │ Int64  Int64
─────┼──────────────
   1 │     6      3

julia&gt; combine(df, :a =&gt; ByRow(sin) =&gt; :c, :b)
3×2 DataFrame
 Row │ c         b
     │ Float64   Int64
─────┼─────────────────
   1 │ 0.841471      4
   2 │ 0.909297      5
   3 │ 0.14112       6

julia&gt; combine(df, :, [:a, :b] =&gt; (a, b) -&gt; a .+ b .- sum(b)/length(b))
3×3 DataFrame
 Row │ a      b      a_b_function
     │ Int64  Int64  Float64
─────┼────────────────────────────
   1 │     1      4           0.0
   2 │     2      5           2.0
   3 │     3      6           4.0

julia&gt; combine(df, All() .=&gt; [minimum maximum])
1×4 DataFrame
 Row │ a_minimum  b_minimum  a_maximum  b_maximum
     │ Int64      Int64      Int64      Int64
─────┼────────────────────────────────────────────
   1 │         1          4          3          6

julia&gt; using Statistics

julia&gt; combine(df, AsTable(:) =&gt; ByRow(mean), renamecols=false)
3×1 DataFrame
 Row │ a_b
     │ Float64
─────┼─────────
   1 │     2.5
   2 │     3.5
   3 │     4.5

julia&gt; combine(df, AsTable(:) =&gt; ByRow(mean) =&gt; x -&gt; join(x, &quot;_&quot;))
3×1 DataFrame
 Row │ a_b
     │ Float64
─────┼─────────
   1 │     2.5
   2 │     3.5
   3 │     4.5

julia&gt; combine(first, df)
1×2 DataFrame
 Row │ a      b
     │ Int64  Int64
─────┼──────────────
   1 │     1      4

julia&gt; df = DataFrame(a=1:3, b=4:6, c=7:9)
3×3 DataFrame
 Row │ a      b      c
     │ Int64  Int64  Int64
─────┼─────────────────────
   1 │     1      4      7
   2 │     2      5      8
   3 │     3      6      9

julia&gt; combine(df, AsTable(:) =&gt; ByRow(x -&gt; (mean=mean(x), std=std(x))) =&gt; :stats,
               AsTable(:) =&gt; ByRow(x -&gt; (mean=mean(x), std=std(x))) =&gt; AsTable)
3×3 DataFrame
 Row │ stats                    mean     std
     │ NamedTup…                Float64  Float64
─────┼───────────────────────────────────────────
   1 │ (mean = 4.0, std = 3.0)      4.0      3.0
   2 │ (mean = 5.0, std = 3.0)      5.0      3.0
   3 │ (mean = 6.0, std = 3.0)      6.0      3.0

julia&gt; df = DataFrame(a=repeat([1, 2, 3, 4], outer=[2]),
                      b=repeat([2, 1], outer=[4]),
                      c=1:8);

julia&gt; gd = groupby(df, :a);

julia&gt; combine(gd, :c =&gt; sum, nrow)
4×3 DataFrame
 Row │ a      c_sum  nrow
     │ Int64  Int64  Int64
─────┼─────────────────────
   1 │     1      6      2
   2 │     2      8      2
   3 │     3     10      2
   4 │     4     12      2

julia&gt; combine(gd, :c =&gt; sum, nrow, ungroup=false)
GroupedDataFrame with 4 groups based on key: a
First Group (1 row): a = 1
 Row │ a      c_sum  nrow
     │ Int64  Int64  Int64
─────┼─────────────────────
   1 │     1      6      2
⋮
Last Group (1 row): a = 4
 Row │ a      c_sum  nrow
     │ Int64  Int64  Int64
─────┼─────────────────────
   1 │     4     12      2

julia&gt; combine(gd) do d # do syntax for the slower variant
           sum(d.c)
       end
4×2 DataFrame
 Row │ a      x1
     │ Int64  Int64
─────┼──────────────
   1 │     1      6
   2 │     2      8
   3 │     3     10
   4 │     4     12

julia&gt; combine(gd, :c =&gt; (x -&gt; sum(log, x)) =&gt; :sum_log_c) # specifying a name for target column
4×2 DataFrame
 Row │ a      sum_log_c
     │ Int64  Float64
─────┼──────────────────
   1 │     1    1.60944
   2 │     2    2.48491
   3 │     3    3.04452
   4 │     4    3.46574

julia&gt; combine(gd, [:b, :c] .=&gt; sum) # passing a vector of pairs
4×3 DataFrame
 Row │ a      b_sum  c_sum
     │ Int64  Int64  Int64
─────┼─────────────────────
   1 │     1      4      6
   2 │     2      2      8
   3 │     3      4     10
   4 │     4      2     12

julia&gt; combine(gd) do sdf # dropping group when DataFrame() is returned
          sdf.c[1] != 1 ? sdf : DataFrame()
       end
6×3 DataFrame
 Row │ a      b      c
     │ Int64  Int64  Int64
─────┼─────────────────────
   1 │     2      1      2
   2 │     2      1      6
   3 │     3      2      3
   4 │     3      2      7
   5 │     4      1      4
   6 │     4      1      8</code></pre><p><strong>auto-splatting, renaming and keepkeys</strong></p><pre><code class="language-julia-repl hljs">julia&gt; df = DataFrame(a=repeat([1, 2, 3, 4], outer=[2]),
                      b=repeat([2, 1], outer=[4]),
                      c=1:8);

julia&gt; gd = groupby(df, :a);

julia&gt; combine(gd, :b =&gt; :b1, :c =&gt; :c1, [:b, :c] =&gt; +, keepkeys=false)
8×3 DataFrame
 Row │ b1     c1     b_c_+
     │ Int64  Int64  Int64
─────┼─────────────────────
   1 │     2      1      3
   2 │     2      5      7
   3 │     1      2      3
   4 │     1      6      7
   5 │     2      3      5
   6 │     2      7      9
   7 │     1      4      5
   8 │     1      8      9</code></pre><p><strong>broadcasting and column expansion</strong></p><pre><code class="language-julia-repl hljs">julia&gt; df = DataFrame(a=repeat([1, 2, 3, 4], outer=[2]),
                      b=repeat([2, 1], outer=[4]),
                      c=1:8);

julia&gt; gd = groupby(df, :a);

julia&gt; combine(gd, :b, AsTable([:b, :c]) =&gt; ByRow(extrema) =&gt; [:min, :max])
8×4 DataFrame
 Row │ a      b      min    max
     │ Int64  Int64  Int64  Int64
─────┼────────────────────────────
   1 │     1      2      1      2
   2 │     1      2      2      5
   3 │     2      1      1      2
   4 │     2      1      1      6
   5 │     3      2      2      3
   6 │     3      2      2      7
   7 │     4      1      1      4
   8 │     4      1      1      8

julia&gt; combine(gd, [:b, :c] .=&gt; Ref) # preventing vector from being spread across multiple rows
4×3 DataFrame
 Row │ a      b_Ref      c_Ref
     │ Int64  SubArray…  SubArray…
─────┼─────────────────────────────
   1 │     1  [2, 2]     [1, 5]
   2 │     2  [1, 1]     [2, 6]
   3 │     3  [2, 2]     [3, 7]
   4 │     4  [1, 1]     [4, 8]

julia&gt; combine(gd, AsTable(Not(:a)) =&gt; Ref) # protecting result
4×2 DataFrame
 Row │ a      b_c_Ref
     │ Int64  NamedTup…
─────┼─────────────────────────────────
   1 │     1  (b = [2, 2], c = [1, 5])
   2 │     2  (b = [1, 1], c = [2, 6])
   3 │     3  (b = [2, 2], c = [3, 7])
   4 │     4  (b = [1, 1], c = [4, 8])

julia&gt; combine(gd, :, AsTable(Not(:a)) =&gt; sum, renamecols=false)
8×4 DataFrame
 Row │ a      b      c      b_c
     │ Int64  Int64  Int64  Int64
─────┼────────────────────────────
   1 │     1      2      1      3
   2 │     1      2      5      7
   3 │     2      1      2      3
   4 │     2      1      6      7
   5 │     3      2      3      5
   6 │     3      2      7      9
   7 │     4      1      4      5
   8 │     4      1      8      9</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/10c5b5e9e7f916024b2f102d040fdd9d4e6bd371/src/abstractdataframe/selection.jl#L1248-L1515">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFrames.flatten" href="#DataFrames.flatten"><code>DataFrames.flatten</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">flatten(df::AbstractDataFrame, cols)</code></pre><p>When columns <code>cols</code> of data frame <code>df</code> have iterable elements that define <code>length</code> (for example a <code>Vector</code> of <code>Vector</code>s), return a <code>DataFrame</code> where each element of each <code>col</code> in <code>cols</code> is flattened, meaning the column corresponding to <code>col</code> becomes a longer vector where the original entries are concatenated. Elements of row <code>i</code> of <code>df</code> in columns other than <code>cols</code> will be repeated according to the length of <code>df[i, col]</code>. These lengths must therefore be the same for each <code>col</code> in <code>cols</code>, or else an error is raised. Note that these elements are not copied, and thus if they are mutable changing them in the returned <code>DataFrame</code> will affect <code>df</code>.</p><p><code>cols</code> can be any column selector (<code>Symbol</code>, string or integer; <code>:</code>, <code>Cols</code>, <code>All</code>, <code>Between</code>, <code>Not</code>, a regular expression, or a vector of <code>Symbol</code>s, strings or integers).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; df1 = DataFrame(a=[1, 2], b=[[1, 2], [3, 4]], c=[[5, 6], [7, 8]])
2×3 DataFrame
 Row │ a      b       c
     │ Int64  Array…  Array…
─────┼───────────────────────
   1 │     1  [1, 2]  [5, 6]
   2 │     2  [3, 4]  [7, 8]

julia&gt; flatten(df1, :b)
4×3 DataFrame
 Row │ a      b      c
     │ Int64  Int64  Array…
─────┼──────────────────────
   1 │     1      1  [5, 6]
   2 │     1      2  [5, 6]
   3 │     2      3  [7, 8]
   4 │     2      4  [7, 8]

julia&gt; flatten(df1, [:b, :c])
4×3 DataFrame
 Row │ a      b      c
     │ Int64  Int64  Int64
─────┼─────────────────────
   1 │     1      1      5
   2 │     1      2      6
   3 │     2      3      7
   4 │     2      4      8

julia&gt; df2 = DataFrame(a=[1, 2], b=[(&quot;p&quot;, &quot;q&quot;), (&quot;r&quot;, &quot;s&quot;)])
2×2 DataFrame
 Row │ a      b
     │ Int64  Tuple…
─────┼───────────────────
   1 │     1  (&quot;p&quot;, &quot;q&quot;)
   2 │     2  (&quot;r&quot;, &quot;s&quot;)

julia&gt; flatten(df2, :b)
4×2 DataFrame
 Row │ a      b
     │ Int64  String
─────┼───────────────
   1 │     1  p
   2 │     1  q
   3 │     2  r
   4 │     2  s

julia&gt; df3 = DataFrame(a=[1, 2], b=[[1, 2], [3, 4]], c=[[5, 6], [7]])
2×3 DataFrame
 Row │ a      b       c
     │ Int64  Array…  Array…
─────┼───────────────────────
   1 │     1  [1, 2]  [5, 6]
   2 │     2  [3, 4]  [7]

julia&gt; flatten(df3, [:b, :c])
ERROR: ArgumentError: Lengths of iterables stored in columns :b and :c are not the same in row 2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/10c5b5e9e7f916024b2f102d040fdd9d4e6bd371/src/abstractdataframe/abstractdataframe.jl#L2134-L2209">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.hcat" href="#Base.hcat"><code>Base.hcat</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">hcat(df::AbstractDataFrame...;
     makeunique::Bool=false, copycols::Bool=true)</code></pre><p>Horizontally concatenate data frames.</p><p>If <code>makeunique=false</code> (the default) column names of passed objects must be unique. If <code>makeunique=true</code> then duplicate column names will be suffixed with <code>_i</code> (<code>i</code> starting at 1 for the first duplicate).</p><p>If <code>copycols=true</code> (the default) then the <code>DataFrame</code> returned by <code>hcat</code> will contain copied columns from the source data frames. If <code>copycols=false</code> then it will contain columns as they are stored in the source (without copying). This option should be used with caution as mutating either the columns in sources or in the returned <code>DataFrame</code> might lead to the corruption of the other object.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; df1 = DataFrame(A=1:3, B=1:3)
3×2 DataFrame
 Row │ A      B
     │ Int64  Int64
─────┼──────────────
   1 │     1      1
   2 │     2      2
   3 │     3      3

julia&gt; df2 = DataFrame(A=4:6, B=4:6)
3×2 DataFrame
 Row │ A      B
     │ Int64  Int64
─────┼──────────────
   1 │     4      4
   2 │     5      5
   3 │     6      6

julia&gt; df3 = hcat(df1, df2, makeunique=true)
3×4 DataFrame
 Row │ A      B      A_1    B_1
     │ Int64  Int64  Int64  Int64
─────┼────────────────────────────
   1 │     1      1      4      4
   2 │     2      2      5      5
   3 │     3      3      6      6

julia&gt; df3.A === df1.A
false

julia&gt; df3 = hcat(df1, df2, makeunique=true, copycols=false);

julia&gt; df3.A === df1.A
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/10c5b5e9e7f916024b2f102d040fdd9d4e6bd371/src/abstractdataframe/abstractdataframe.jl#L1453-L1507">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFrames.insertcols!" href="#DataFrames.insertcols!"><code>DataFrames.insertcols!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">insertcols!(df::AbstractDataFrame[, col], (name=&gt;val)::Pair...;
            after::Bool=false, makeunique::Bool=false, copycols::Bool=true)</code></pre><p>Insert a column into a data frame in place. Return the updated data frame. If <code>col</code> is omitted it is set to <code>ncol(df)+1</code> (the column is inserted as the last column).</p><p><strong>Arguments</strong></p><ul><li><code>df</code> : the data frame to which we want to add columns</li><li><code>col</code> : a position at which we want to insert a column, passed as an integer or a column name (a string or a <code>Symbol</code>); the column selected with <code>col</code> and columns following it are shifted to the right in <code>df</code> after the operation</li><li><code>name</code> : the name of the new column</li><li><code>val</code> : an <code>AbstractVector</code> giving the contents of the new column or a value of any type other than <code>AbstractArray</code> which will be repeated to fill a new vector; As a particular rule a values stored in a <code>Ref</code> or a <code>0</code>-dimensional <code>AbstractArray</code> are unwrapped and treated in the same way</li><li><code>after</code> : if <code>true</code> columns are inserted after <code>col</code></li><li><code>makeunique</code> : defines what to do if <code>name</code> already exists in <code>df</code>; if it is <code>false</code> an error will be thrown; if it is <code>true</code> a new unique name will be generated by adding a suffix</li><li><code>copycols</code> : whether vectors passed as columns should be copied</li></ul><p>If <code>val</code> is an <code>AbstractRange</code> then the result of <code>collect(val)</code> is inserted.</p><p>If <code>df</code> is a <code>SubDataFrame</code> then it must have been created with <code>:</code> as column selector (otherwise an error is thrown). In this case the <code>copycols</code> keyword argument is ignored (i.e. the added column is always copied) and the parent data frame&#39;s column is filled with <code>missing</code> in rows that are filtered out by <code>df</code>.</p><p>If <code>df</code> isa <code>DataFrame</code> that has no columns and only values other than <code>AbstractVector</code> are passed then it is used to create a one-element column. If <code>df</code> isa <code>DataFrame</code> that has no columns and at least one <code>AbstractVector</code> is passed then its length is used to determine the number of elements in all created columns. In all other cases the number of rows in all created columns must match <code>nrow(df)</code>. .</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; df = DataFrame(a=1:3)
3×1 DataFrame
 Row │ a
     │ Int64
─────┼───────
   1 │     1
   2 │     2
   3 │     3

julia&gt; insertcols!(df, 1, :b =&gt; &#39;a&#39;:&#39;c&#39;)
3×2 DataFrame
 Row │ b     a
     │ Char  Int64
─────┼─────────────
   1 │ a         1
   2 │ b         2
   3 │ c         3

julia&gt; insertcols!(df, 2, :c =&gt; 2:4, :c =&gt; 3:5, makeunique=true)
3×4 DataFrame
 Row │ b     c      c_1    a
     │ Char  Int64  Int64  Int64
─────┼───────────────────────────
   1 │ a         2      3      1
   2 │ b         3      4      2
   3 │ c         4      5      3

julia&gt; insertcols!(df, :b, :d =&gt; 7:9, after=true)
3×5 DataFrame
 Row │ b     d      c      c_1    a
     │ Char  Int64  Int64  Int64  Int64
─────┼──────────────────────────────────
   1 │ a         7      2      3      1
   2 │ b         8      3      4      2
   3 │ c         9      4      5      3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/10c5b5e9e7f916024b2f102d040fdd9d4e6bd371/src/dataframe/dataframe.jl#L758-L837">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFrames.mapcols" href="#DataFrames.mapcols"><code>DataFrames.mapcols</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">mapcols(f::Union{Function, Type}, df::AbstractDataFrame)</code></pre><p>Return a <code>DataFrame</code> where each column of <code>df</code> is transformed using function <code>f</code>. <code>f</code> must return <code>AbstractVector</code> objects all with the same length or scalars (all values other than <code>AbstractVector</code> are considered to be a scalar).</p><p>Note that <code>mapcols</code> guarantees not to reuse the columns from <code>df</code> in the returned <code>DataFrame</code>. If <code>f</code> returns its argument then it gets copied before being stored.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; df = DataFrame(x=1:4, y=11:14)
4×2 DataFrame
 Row │ x      y
     │ Int64  Int64
─────┼──────────────
   1 │     1     11
   2 │     2     12
   3 │     3     13
   4 │     4     14

julia&gt; mapcols(x -&gt; x.^2, df)
4×2 DataFrame
 Row │ x      y
     │ Int64  Int64
─────┼──────────────
   1 │     1    121
   2 │     4    144
   3 │     9    169
   4 │    16    196</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/10c5b5e9e7f916024b2f102d040fdd9d4e6bd371/src/abstractdataframe/iteration.jl#L338-L370">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFrames.mapcols!" href="#DataFrames.mapcols!"><code>DataFrames.mapcols!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">mapcols!(f::Union{Function, Type}, df::DataFrame)</code></pre><p>Update a <code>DataFrame</code> in-place where each column of <code>df</code> is transformed using function <code>f</code>. <code>f</code> must return <code>AbstractVector</code> objects all with the same length or scalars (all values other than <code>AbstractVector</code> are considered to be a scalar).</p><p>Note that <code>mapcols!</code> reuses the columns from <code>df</code> if they are returned by <code>f</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; df = DataFrame(x=1:4, y=11:14)
4×2 DataFrame
 Row │ x      y
     │ Int64  Int64
─────┼──────────────
   1 │     1     11
   2 │     2     12
   3 │     3     13
   4 │     4     14

julia&gt; mapcols!(x -&gt; x.^2, df);

julia&gt; df
4×2 DataFrame
 Row │ x      y
     │ Int64  Int64
─────┼──────────────
   1 │     1    121
   2 │     4    144
   3 │     9    169
   4 │    16    196</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/10c5b5e9e7f916024b2f102d040fdd9d4e6bd371/src/abstractdataframe/iteration.jl#L395-L428">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.push!" href="#Base.push!"><code>Base.push!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">push!(df::DataFrame, row::Union{Tuple, AbstractArray}; promote::Bool=false)
push!(df::DataFrame, row::Union{DataFrameRow, NamedTuple, AbstractDict};
      cols::Symbol=:setequal, promote::Bool=(cols in [:union, :subset]))</code></pre><p>Add in-place one row at the end of <code>df</code> taking the values from <code>row</code>.</p><p>Column types of <code>df</code> are preserved, and new values are converted if necessary. An error is thrown if conversion fails.</p><p>If <code>row</code> is neither a <code>DataFrameRow</code>, <code>NamedTuple</code> nor <code>AbstractDict</code> then it must be a <code>Tuple</code> or an <code>AbstractArray</code> and columns are matched by order of appearance. In this case <code>row</code> must contain the same number of elements as the number of columns in <code>df</code>.</p><p>If <code>row</code> is a <code>DataFrameRow</code>, <code>NamedTuple</code> or <code>AbstractDict</code> then values in <code>row</code> are matched to columns in <code>df</code> based on names. The exact behavior depends on the <code>cols</code> argument value in the following way:</p><ul><li>If <code>cols == :setequal</code> (this is the default) then <code>row</code> must contain exactly the same columns as <code>df</code> (but possibly in a different order).</li><li>If <code>cols == :orderequal</code> then <code>row</code> must contain the same columns in the same order (for <code>AbstractDict</code> this option requires that <code>keys(row)</code> matches <code>propertynames(df)</code> to allow for support of ordered dicts; however, if <code>row</code> is a <code>Dict</code> an error is thrown as it is an unordered collection).</li><li>If <code>cols == :intersect</code> then <code>row</code> may contain more columns than <code>df</code>, but all column names that are present in <code>df</code> must be present in <code>row</code> and only they are used to populate a new row in <code>df</code>.</li><li>If <code>cols == :subset</code> then <code>push!</code> behaves like for <code>:intersect</code> but if some column is missing in <code>row</code> then a <code>missing</code> value is pushed to <code>df</code>.</li><li>If <code>cols == :union</code> then columns missing in <code>df</code> that are present in <code>row</code> are added to <code>df</code> (using <code>missing</code> for existing rows) and a <code>missing</code> value is pushed to columns missing in <code>row</code> that are present in <code>df</code>.</li></ul><p>If <code>promote=true</code> and element type of a column present in <code>df</code> does not allow the type of a pushed argument then a new column with a promoted element type allowing it is freshly allocated and stored in <code>df</code>. If <code>promote=false</code> an error is thrown.</p><p>As a special case, if <code>df</code> has no columns and <code>row</code> is a <code>NamedTuple</code> or <code>DataFrameRow</code>, columns are created for all values in <code>row</code>, using their names and order.</p><p>Please note that <code>push!</code> must not be used on a <code>DataFrame</code> that contains columns that are aliases (equal when compared with <code>===</code>).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; df = DataFrame(A=1:3, B=1:3);

julia&gt; push!(df, (true, false))
4×2 DataFrame
 Row │ A      B
     │ Int64  Int64
─────┼──────────────
   1 │     1      1
   2 │     2      2
   3 │     3      3
   4 │     1      0

julia&gt; push!(df, df[1, :])
5×2 DataFrame
 Row │ A      B
     │ Int64  Int64
─────┼──────────────
   1 │     1      1
   2 │     2      2
   3 │     3      3
   4 │     1      0
   5 │     1      1

julia&gt; push!(df, (C=&quot;something&quot;, A=true, B=false), cols=:intersect)
6×2 DataFrame
 Row │ A      B
     │ Int64  Int64
─────┼──────────────
   1 │     1      1
   2 │     2      2
   3 │     3      3
   4 │     1      0
   5 │     1      1
   6 │     1      0

julia&gt; push!(df, Dict(:A=&gt;1.0, :C=&gt;1.0), cols=:union)
7×3 DataFrame
 Row │ A        B        C
     │ Float64  Int64?   Float64?
─────┼─────────────────────────────
   1 │     1.0        1  missing
   2 │     2.0        2  missing
   3 │     3.0        3  missing
   4 │     1.0        0  missing
   5 │     1.0        1  missing
   6 │     1.0        0  missing
   7 │     1.0  missing        1.0

julia&gt; push!(df, NamedTuple(), cols=:subset)
8×3 DataFrame
 Row │ A          B        C
     │ Float64?   Int64?   Float64?
─────┼───────────────────────────────
   1 │       1.0        1  missing
   2 │       2.0        2  missing
   3 │       3.0        3  missing
   4 │       1.0        0  missing
   5 │       1.0        1  missing
   6 │       1.0        0  missing
   7 │       1.0  missing        1.0
   8 │ missing    missing  missing</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/10c5b5e9e7f916024b2f102d040fdd9d4e6bd371/src/dataframe/dataframe.jl#L1568-L1678">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.reduce" href="#Base.reduce"><code>Base.reduce</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">reduce(::typeof(vcat),
       dfs::Union{AbstractVector{&lt;:AbstractDataFrame},
                  Tuple{AbstractDataFrame, Vararg{AbstractDataFrame}}};
       cols::Union{Symbol, AbstractVector{Symbol},
                   AbstractVector{&lt;:AbstractString}}=:setequal,
       source::Union{Nothing, Symbol, AbstractString,
                     Pair{&lt;:Union{Symbol, AbstractString}, &lt;:AbstractVector}}=nothing)</code></pre><p>Efficiently reduce the given vector or tuple of <code>AbstractDataFrame</code>s with <code>vcat</code>.</p><p>The column order, names, and types of the resulting <code>DataFrame</code>, and the behavior of <code>cols</code> and <code>source</code> keyword arguments follow the rules specified for <a href="#Base.vcat"><code>vcat</code></a> of <code>AbstractDataFrame</code>s.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; df1 = DataFrame(A=1:3, B=1:3)
3×2 DataFrame
 Row │ A      B
     │ Int64  Int64
─────┼──────────────
   1 │     1      1
   2 │     2      2
   3 │     3      3

julia&gt; df2 = DataFrame(A=4:6, B=4:6)
3×2 DataFrame
 Row │ A      B
     │ Int64  Int64
─────┼──────────────
   1 │     4      4
   2 │     5      5
   3 │     6      6

julia&gt; df3 = DataFrame(A=7:9, C=7:9)
3×2 DataFrame
 Row │ A      C
     │ Int64  Int64
─────┼──────────────
   1 │     7      7
   2 │     8      8
   3 │     9      9

julia&gt; reduce(vcat, (df1, df2))
6×2 DataFrame
 Row │ A      B
     │ Int64  Int64
─────┼──────────────
   1 │     1      1
   2 │     2      2
   3 │     3      3
   4 │     4      4
   5 │     5      5
   6 │     6      6

julia&gt; reduce(vcat, [df1, df2, df3], cols=:union, source=:source)
9×4 DataFrame
 Row │ A      B        C        source
     │ Int64  Int64?   Int64?   Int64
─────┼─────────────────────────────────
   1 │     1        1  missing       1
   2 │     2        2  missing       1
   3 │     3        3  missing       1
   4 │     4        4  missing       2
   5 │     5        5  missing       2
   6 │     6        6  missing       2
   7 │     7  missing        7       3
   8 │     8  missing        8       3
   9 │     9  missing        9       3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/10c5b5e9e7f916024b2f102d040fdd9d4e6bd371/src/abstractdataframe/abstractdataframe.jl#L1682-L1753">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.repeat" href="#Base.repeat"><code>Base.repeat</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">repeat(df::AbstractDataFrame; inner::Integer = 1, outer::Integer = 1)</code></pre><p>Construct a data frame by repeating rows in <code>df</code>. <code>inner</code> specifies how many times each row is repeated, and <code>outer</code> specifies how many times the full set of rows is repeated.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; df = DataFrame(a=1:2, b=3:4)
2×2 DataFrame
 Row │ a      b
     │ Int64  Int64
─────┼──────────────
   1 │     1      3
   2 │     2      4

julia&gt; repeat(df, inner=2, outer=3)
12×2 DataFrame
 Row │ a      b
     │ Int64  Int64
─────┼──────────────
   1 │     1      3
   2 │     1      3
   3 │     2      4
   4 │     2      4
   5 │     1      3
   6 │     1      3
   7 │     2      4
   8 │     2      4
   9 │     1      3
  10 │     1      3
  11 │     2      4
  12 │     2      4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/10c5b5e9e7f916024b2f102d040fdd9d4e6bd371/src/abstractdataframe/abstractdataframe.jl#L1881-L1916">source</a></section><section><div><pre><code class="nohighlight hljs">repeat(df::AbstractDataFrame, count::Integer)</code></pre><p>Construct a data frame by repeating each row in <code>df</code> the number of times specified by <code>count</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; df = DataFrame(a=1:2, b=3:4)
2×2 DataFrame
 Row │ a      b
     │ Int64  Int64
─────┼──────────────
   1 │     1      3
   2 │     2      4

julia&gt; repeat(df, 2)
4×2 DataFrame
 Row │ a      b
     │ Int64  Int64
─────┼──────────────
   1 │     1      3
   2 │     2      4
   3 │     1      3
   4 │     2      4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/10c5b5e9e7f916024b2f102d040fdd9d4e6bd371/src/abstractdataframe/abstractdataframe.jl#L1923-L1949">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFrames.repeat!" href="#DataFrames.repeat!"><code>DataFrames.repeat!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">repeat!(df::DataFrame; inner::Integer=1, outer::Integer=1)</code></pre><p>Update a data frame <code>df</code> in-place by repeating its rows. <code>inner</code> specifies how many times each row is repeated, and <code>outer</code> specifies how many times the full set of rows is repeated. Columns of <code>df</code> are freshly allocated.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; df = DataFrame(a=1:2, b=3:4)
2×2 DataFrame
 Row │ a      b
     │ Int64  Int64
─────┼──────────────
   1 │     1      3
   2 │     2      4

julia&gt; repeat!(df, inner=2, outer=3);

julia&gt; df
12×2 DataFrame
 Row │ a      b
     │ Int64  Int64
─────┼──────────────
   1 │     1      3
   2 │     1      3
   3 │     2      4
   4 │     2      4
   5 │     1      3
   6 │     1      3
   7 │     2      4
   8 │     2      4
   9 │     1      3
  10 │     1      3
  11 │     2      4
  12 │     2      4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/10c5b5e9e7f916024b2f102d040fdd9d4e6bd371/src/dataframe/dataframe.jl#L1725-L1762">source</a></section><section><div><pre><code class="nohighlight hljs">repeat!(df::DataFrame, count::Integer)</code></pre><p>Update a data frame <code>df</code> in-place by repeating its rows the number of times specified by <code>count</code>. Columns of <code>df</code> are freshly allocated.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; df = DataFrame(a=1:2, b=3:4)
2×2 DataFrame
 Row │ a      b
     │ Int64  Int64
─────┼──────────────
   1 │     1      3
   2 │     2      4

julia&gt; repeat(df, 2)
4×2 DataFrame
 Row │ a      b
     │ Int64  Int64
─────┼──────────────
   1 │     1      3
   2 │     2      4
   3 │     1      3
   4 │     2      4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/10c5b5e9e7f916024b2f102d040fdd9d4e6bd371/src/dataframe/dataframe.jl#L1769-L1795">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.reverse" href="#Base.reverse"><code>Base.reverse</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">reverse(df::AbstractDataFrame)</code></pre><p>Return a data frame containing the rows in <code>df</code> in reversed order.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; df = DataFrame(a=1:5, b=6:10, c=11:15)
5×3 DataFrame
 Row │ a      b      c
     │ Int64  Int64  Int64
─────┼─────────────────────
   1 │     1      6     11
   2 │     2      7     12
   3 │     3      8     13
   4 │     4      9     14
   5 │     5     10     15

julia&gt; reverse(df)
5×3 DataFrame
 Row │ a      b      c
     │ Int64  Int64  Int64
─────┼─────────────────────
   1 │     5     10     15
   2 │     4      9     14
   3 │     3      8     13
   4 │     2      7     12
   5 │     1      6     11</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/10c5b5e9e7f916024b2f102d040fdd9d4e6bd371/src/abstractdataframe/abstractdataframe.jl#L2263-L2293">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFrames.select" href="#DataFrames.select"><code>DataFrames.select</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">select(df::AbstractDataFrame, args...; copycols::Bool=true, renamecols::Bool=true)
select(args::Callable, df::DataFrame; renamecols::Bool=true)
select(gd::GroupedDataFrame, args...; copycols::Bool=true, keepkeys::Bool=true,
       ungroup::Bool=true, renamecols::Bool=true)
select(f::Base.Callable, gd::GroupedDataFrame; copycols::Bool=true,
       keepkeys::Bool=true, ungroup::Bool=true, renamecols::Bool=true)</code></pre><p>Create a new data frame that contains columns from <code>df</code> or <code>gd</code> specified by <code>args</code> and return it. The result is guaranteed to have the same number of rows as <code>df</code>, except when no columns are selected (in which case the result has zero rows).</p><p>Below detailed common rules for all transformation functions supported by DataFrames.jl are explained and compared.</p><p>All these operations are supported both for <code>AbstractDataFrame</code> (when split and combine steps are skipped) and <code>GroupedDataFrame</code>. Technically, <code>AbstractDataFrame</code> is just considered as being grouped on no columns (meaning it has a single group, or zero groups if it is empty). The only difference is that in this case the <code>keepkeys</code> and <code>ungroup</code> keyword arguments (described below) are not supported and a data frame is always returned, as there are no split and combine steps in this case.</p><p>In order to perform operations by groups you first need to create a <code>GroupedDataFrame</code> object from your data frame using the <code>groupby</code> function that takes two arguments: (1) a data frame to be grouped, and (2) a set of columns to group by.</p><p>Operations can then be applied on each group using one of the following functions:</p><ul><li><code>combine</code>: does not put restrictions on number of rows returned, the order of rows is specified by the order of groups in <code>GroupedDataFrame</code>; it is typically used to compute summary statistics by group;</li><li><code>select</code>: return a data frame with the number and order of rows exactly the same as the source data frame, including only new calculated columns; <code>select!</code> is an in-place version of <code>select</code>;</li><li><code>transform</code>: return a data frame with the number and order of rows exactly the same as the source data frame, including all columns from the source and new calculated columns; <code>transform!</code> is an in-place version of <code>transform</code>.</li></ul><p>All these functions take a specification of one or more functions to apply to each subset of the <code>DataFrame</code>. This specification can be of the following forms:</p><ol><li>standard column selectors (integers, <code>Symbol</code>s, strings, vectors of integers, vectors of <code>Symbol</code>s, vectors of strings, <code>All</code>, <code>Cols</code>, <code>:</code>, <code>Between</code>, <code>Not</code> and regular expressions)</li><li>a <code>cols =&gt; function</code> pair indicating that <code>function</code> should be called with positional arguments holding columns <code>cols</code>, which can be any valid column selector; in this case target column name is automatically generated and it is assumed that <code>function</code> returns a single value or a vector; the generated name is created by concatenating source column name and <code>function</code> name by default (see examples below).</li><li>a <code>cols =&gt; function =&gt; target_cols</code> form additionally explicitly specifying the target column or columns, which must be a single name (as a <code>Symbol</code> or a string), a vector of names or <code>AsTable</code>. Additionally it can be a <code>Function</code> which takes a string or a vector of strings as an argument containing names of columns selected by <code>cols</code>, and returns the target columns names (all accepted types except <code>AsTable</code> are allowed).</li><li>a <code>col =&gt; target_cols</code> pair, which renames the column <code>col</code> to <code>target_cols</code>, which must be single name (as a <code>Symbol</code> or a string), a vector of names or <code>AsTable</code>.</li><li>a <code>nrow</code> or <code>nrow =&gt; target_cols</code> form which efficiently computes the number of rows in a group; without <code>target_cols</code> the new column is called <code>:nrow</code>, otherwise it must be single name (as a <code>Symbol</code> or a string).</li><li>vectors or matrices containing transformations specified by the <code>Pair</code> syntax described in points 2 to 5</li><li>a function which will be called with a <code>SubDataFrame</code> corresponding to each group if a <code>GroupedDataFrame</code> is processed, or with the data frame itself if an <code>AbstractDataFrame</code> is processed; this form should be avoided due to its poor performance unless the number of groups is small or a very large number of columns are processed (in which case <code>SubDataFrame</code> avoids excessive compilation)</li></ol><p>Note! If the expression of the form <code>x =&gt; y</code> is passed then except for the special convenience form <code>nrow =&gt; target_cols</code> it is always interpreted as <code>cols =&gt; function</code>. In particular the following expression <code>function =&gt; target_cols</code> is not a valid transformation specification.</p><p>Note! If <code>cols</code> or <code>target_cols</code> are one of <code>All</code>, <code>Cols</code>, <code>Between</code>, or <code>Not</code>, broadcasting using <code>.=&gt;</code> is supported and is equivalent to broadcasting the result of <code>names(df, cols)</code> or <code>names(df, target_cols)</code>. This behaves as if broadcasting happened after replacing the selector with selected column names within the data frame scope.</p><p>All functions have two types of signatures. One of them takes a <code>GroupedDataFrame</code> as the first argument and an arbitrary number of transformations described above as following arguments. The second type of signature is when a <code>Function</code> or a <code>Type</code> is passed as the first argument and a <code>GroupedDataFrame</code> as the second argument (similar to <code>map</code>).</p><p>As a special rule, with the <code>cols =&gt; function</code> and <code>cols =&gt; function =&gt; target_cols</code> syntaxes, if <code>cols</code> is wrapped in an <code>AsTable</code> object then a <code>NamedTuple</code> containing columns selected by <code>cols</code> is passed to <code>function</code>.</p><p>What is allowed for <code>function</code> to return is determined by the <code>target_cols</code> value:</p><ol><li>If both <code>cols</code> and <code>target_cols</code> are omitted (so only a <code>function</code> is passed), then returning a data frame, a matrix, a <code>NamedTuple</code>, or a <code>DataFrameRow</code> will produce multiple columns in the result. Returning any other value produces a single column.</li><li>If <code>target_cols</code> is a <code>Symbol</code> or a string then the function is assumed to return a single column. In this case returning a data frame, a matrix, a <code>NamedTuple</code>, or a <code>DataFrameRow</code> raises an error.</li><li>If <code>target_cols</code> is a vector of <code>Symbol</code>s or strings or <code>AsTable</code> it is assumed that <code>function</code> returns multiple columns. If <code>function</code> returns one of <code>AbstractDataFrame</code>, <code>NamedTuple</code>, <code>DataFrameRow</code>, <code>AbstractMatrix</code> then rules described in point 1 above apply. If <code>function</code> returns an <code>AbstractVector</code> then each element of this vector must support the <code>keys</code> function, which must return a collection of <code>Symbol</code>s, strings or integers; the return value of <code>keys</code> must be identical for all elements. Then as many columns are created as there are elements in the return value of the <code>keys</code> function. If <code>target_cols</code> is <code>AsTable</code> then their names are set to be equal to the key names except if <code>keys</code> returns integers, in which case they are prefixed by <code>x</code> (so the column names are e.g. <code>x1</code>, <code>x2</code>, ...). If <code>target_cols</code> is a vector of <code>Symbol</code>s or strings then column names produced using the rules above are ignored and replaced by <code>target_cols</code> (the number of columns must be the same as the length of <code>target_cols</code> in this case). If <code>fun</code> returns a value of any other type then it is assumed that it is a table conforming to the Tables.jl API and the <code>Tables.columntable</code> function is called on it to get the resulting columns and their names. The names are retained when <code>target_cols</code> is <code>AsTable</code> and are replaced if <code>target_cols</code> is a vector of <code>Symbol</code>s or strings.</li></ol><p>In all of these cases, <code>function</code> can return either a single row or multiple rows. As a particular rule, values wrapped in a <code>Ref</code> or a <code>0</code>-dimensional <code>AbstractArray</code> are unwrapped and then treated as a single row.</p><p><code>select</code>/<code>select!</code> and <code>transform</code>/<code>transform!</code> always return a data frame with the same number and order of rows as the source (even if <code>GroupedDataFrame</code> had its groups reordered), except when selection results in zero columns in the resulting data frame (in which case the result has zero rows).</p><p>For <code>combine</code>, rows in the returned object appear in the order of groups in the <code>GroupedDataFrame</code>. The functions can return an arbitrary number of rows for each group, but the kind of returned object and the number and names of columns must be the same for all groups, except when a <code>DataFrame()</code> or <code>NamedTuple()</code> is returned, in which case a given group is skipped.</p><p>It is allowed to mix single values and vectors if multiple transformations are requested. In this case single value will be repeated to match the length of columns specified by returned vectors.</p><p>To apply <code>function</code> to each row instead of whole columns, it can be wrapped in a <code>ByRow</code> struct. <code>cols</code> can be any column indexing syntax, in which case <code>function</code> will be passed one argument for each of the columns specified by <code>cols</code> or a <code>NamedTuple</code> of them if specified columns are wrapped in <code>AsTable</code>. If <code>ByRow</code> is used it is allowed for <code>cols</code> to select an empty set of columns, in which case <code>function</code> is called for each row without any arguments and an empty <code>NamedTuple</code> is passed if empty set of columns is wrapped in <code>AsTable</code>.</p><p>If a collection of column names is passed then requesting duplicate column names in target data frame are accepted (e.g. <code>select!(df, [:a], :, r&quot;a&quot;)</code> is allowed) and only the first occurrence is used. In particular a syntax to move column <code>:col</code> to the first position in the data frame is <code>select!(df, :col, :)</code>. On the contrary, output column names of renaming, transformation and single column selection operations must be unique, so e.g. <code>select!(df, :a, :a =&gt; :a)</code> or <code>select!(df, :a, :a =&gt; ByRow(sin) =&gt; :a)</code> are not allowed.</p><p>In general columns returned by transformations are stored in the target data frame without copying. An exception to this rule is when columns from the source data frame are reused in the target data frame. This can happen via expressions like: <code>:x1</code>, <code>[:x1, :x2]</code>, <code>:x1 =&gt; :x2</code>, <code>:x1 =&gt; identity =&gt; :x2</code>, or <code>:x1 =&gt; (x -&gt; @view x[inds])</code> (note that in the last case the source column is reused indirectly via a view). In such cases the behavior depends on the value of the <code>copycols</code> keyword argument:</p><ul><li>if <code>copycols=true</code> then results of such transformations always perform a copy of the source column or its view;</li><li>if <code>copycols=false</code> then copies are only performed to avoid storing the same column several times in the target data frame; more precisely, no copy is made the first time a column is used, but each subsequent reuse of a source column (when compared using <code>===</code>, which excludes views of source columns) performs a copy;</li></ul><p>Note that performing <code>transform!</code> or <code>select!</code> assumes that <code>copycols=false</code>.</p><p>If <code>df</code> is a <code>SubDataFrame</code> and <code>copycols=true</code> then a <code>DataFrame</code> is returned and the same copying rules apply as for a <code>DataFrame</code> input: this means in particular that selected columns will be copied. If <code>copycols=false</code>, a <code>SubDataFrame</code> is returned without copying columns and in this case transforming or renaming columns is not allowed.</p><p>If a <code>GroupedDataFrame</code> is passed, a separate task is spawned for each specified transformation; each transformation then spawns as many tasks as Julia threads, and splits processing of groups across them (however, currently transformations with optimized implementations like <code>sum</code> and transformations that return multiple rows use a single task for all groups). This allows for parallel operation when Julia was started with more than one thread. Passed transformation functions should therefore not modify global variables (i.e. they should be pure), or use locks to control parallel accesses. In the future, parallelism may be extended to other cases, so this requirement also holds for <code>DataFrame</code> inputs.</p><p>In order to improve the performance of the operations some transformations invoke optimized implementation, see <a href="../internals/#DataFrames.table_transformation"><code>table_transformation</code></a> for details.</p><p><strong>Keyword arguments</strong></p><ul><li><code>copycols::Bool=true</code> : whether columns of the source data frame should be copied if no transformation is applied to them.</li><li><code>renamecols::Bool=true</code> : whether in the <code>cols =&gt; function</code> form automatically generated column names should include the name of transformation functions or not.</li><li><code>keepkeys::Bool=true</code> : whether grouping columns of <code>gd</code> should be kept in the returned data frame.</li><li><code>ungroup::Bool=true</code> : whether the return value of the operation on <code>gd</code> should be a data frame or a <code>GroupedDataFrame</code>.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; df = DataFrame(a=1:3, b=4:6)
3×2 DataFrame
 Row │ a      b
     │ Int64  Int64
─────┼──────────────
   1 │     1      4
   2 │     2      5
   3 │     3      6

julia&gt; select(df, 2)
3×1 DataFrame
 Row │ b
     │ Int64
─────┼───────
   1 │     4
   2 │     5
   3 │     6

julia&gt; select(df, :a =&gt; ByRow(sin) =&gt; :c, :b)
3×2 DataFrame
 Row │ c         b
     │ Float64   Int64
─────┼─────────────────
   1 │ 0.841471      4
   2 │ 0.909297      5
   3 │ 0.14112       6

julia&gt; select(df, :, [:a, :b] =&gt; (a, b) -&gt; a .+ b .- sum(b)/length(b))
3×3 DataFrame
 Row │ a      b      a_b_function
     │ Int64  Int64  Float64
─────┼────────────────────────────
   1 │     1      4           0.0
   2 │     2      5           2.0
   3 │     3      6           4.0

julia&gt; select(df, All() .=&gt; [minimum maximum])
3×4 DataFrame
 Row │ a_minimum  b_minimum  a_maximum  b_maximum
     │ Int64      Int64      Int64      Int64
─────┼────────────────────────────────────────────
   1 │         1          4          3          6
   2 │         1          4          3          6
   3 │         1          4          3          6

julia&gt; using Statistics

julia&gt; select(df, AsTable(:) =&gt; ByRow(mean), renamecols=false)
3×1 DataFrame
 Row │ a_b
     │ Float64
─────┼─────────
   1 │     2.5
   2 │     3.5
   3 │     4.5

julia&gt; select(df, AsTable(:) =&gt; ByRow(mean) =&gt; x -&gt; join(x, &quot;_&quot;))
3×1 DataFrame
 Row │ a_b
     │ Float64
─────┼─────────
   1 │     2.5
   2 │     3.5
   3 │     4.5

julia&gt; select(first, df)
3×2 DataFrame
 Row │ a      b
     │ Int64  Int64
─────┼──────────────
   1 │     1      4
   2 │     1      4
   3 │     1      4

julia&gt; df = DataFrame(a=1:3, b=4:6, c=7:9)
3×3 DataFrame
 Row │ a      b      c
     │ Int64  Int64  Int64
─────┼─────────────────────
   1 │     1      4      7
   2 │     2      5      8
   3 │     3      6      9

julia&gt; select(df, AsTable(:) =&gt; ByRow(x -&gt; (mean=mean(x), std=std(x))) =&gt; :stats,
              AsTable(:) =&gt; ByRow(x -&gt; (mean=mean(x), std=std(x))) =&gt; AsTable)
3×3 DataFrame
 Row │ stats                    mean     std
     │ NamedTup…                Float64  Float64
─────┼───────────────────────────────────────────
   1 │ (mean = 4.0, std = 3.0)      4.0      3.0
   2 │ (mean = 5.0, std = 3.0)      5.0      3.0
   3 │ (mean = 6.0, std = 3.0)      6.0      3.0

julia&gt; df = DataFrame(a=[1, 1, 1, 2, 2, 1, 1, 2],
                      b=repeat([2, 1], outer=[4]),
                      c=1:8)
8×3 DataFrame
 Row │ a      b      c
     │ Int64  Int64  Int64
─────┼─────────────────────
   1 │     1      2      1
   2 │     1      1      2
   3 │     1      2      3
   4 │     2      1      4
   5 │     2      2      5
   6 │     1      1      6
   7 │     1      2      7
   8 │     2      1      8

julia&gt; gd = groupby(df, :a)
GroupedDataFrame with 2 groups based on key: a
First Group (5 rows): a = 1
 Row │ a      b      c
     │ Int64  Int64  Int64
─────┼─────────────────────
   1 │     1      2      1
   2 │     1      1      2
   3 │     1      2      3
   4 │     1      1      6
   5 │     1      2      7
⋮
Last Group (3 rows): a = 2
 Row │ a      b      c
     │ Int64  Int64  Int64
─────┼─────────────────────
   1 │     2      1      4
   2 │     2      2      5
   3 │     2      1      8</code></pre><p><strong>specifying a name for target column</strong></p><pre><code class="language-julia-repl hljs">julia&gt; df = DataFrame(a=[1, 1, 1, 2, 2, 1, 1, 2],
                      b=repeat([2, 1], outer=[4]),
                      c=1:8);

julia&gt; gd = groupby(df, :a);

julia&gt; select(gd, :c =&gt; (x -&gt; sum(log, x)) =&gt; :sum_log_c)
8×2 DataFrame
 Row │ a      sum_log_c
     │ Int64  Float64
─────┼──────────────────
   1 │     1    5.52943
   2 │     1    5.52943
   3 │     1    5.52943
   4 │     2    5.07517
   5 │     2    5.07517
   6 │     1    5.52943
   7 │     1    5.52943
   8 │     2    5.07517

julia&gt; select(gd, [:b, :c] .=&gt; sum) # passing a vector of pairs
8×3 DataFrame
 Row │ a      b_sum  c_sum
     │ Int64  Int64  Int64
─────┼─────────────────────
   1 │     1      8     19
   2 │     1      8     19
   3 │     1      8     19
   4 │     2      4     17
   5 │     2      4     17
   6 │     1      8     19
   7 │     1      8     19
   8 │     2      4     17</code></pre><p><strong>multiple arguments, renaming and keepkeys</strong></p><pre><code class="language-julia-repl hljs">julia&gt; df = DataFrame(a=[1, 1, 1, 2, 2, 1, 1, 2],
                      b=repeat([2, 1], outer=[4]),
                      c=1:8);

julia&gt; gd = groupby(df, :a);

julia&gt; select(gd, :b =&gt; :b1, :c =&gt; :c1, [:b, :c] =&gt; +, keepkeys=false)
8×3 DataFrame
 Row │ b1     c1     b_c_+
     │ Int64  Int64  Int64
─────┼─────────────────────
   1 │     2      1      3
   2 │     1      2      3
   3 │     2      3      5
   4 │     1      4      5
   5 │     2      5      7
   6 │     1      6      7
   7 │     2      7      9
   8 │     1      8      9</code></pre><p><strong>broadcasting and column expansion</strong></p><pre><code class="language-julia-repl hljs">julia&gt; df = DataFrame(a=[1, 1, 1, 2, 2, 1, 1, 2],
                      b=repeat([2, 1], outer=[4]),
                      c=1:8);

julia&gt; gd = groupby(df, :a);

julia&gt; select(gd, :b, AsTable([:b, :c]) =&gt; ByRow(extrema) =&gt; [:min, :max])
8×4 DataFrame
 Row │ a      b      min    max
     │ Int64  Int64  Int64  Int64
─────┼────────────────────────────
   1 │     1      2      1      2
   2 │     1      1      1      2
   3 │     1      2      2      3
   4 │     2      1      1      4
   5 │     2      2      2      5
   6 │     1      1      1      6
   7 │     1      2      2      7
   8 │     2      1      1      8

julia&gt; select(gd, :, AsTable(Not(:a)) =&gt; sum, renamecols=false)
8×4 DataFrame
 Row │ a      b      c      b_c
     │ Int64  Int64  Int64  Int64
─────┼────────────────────────────
   1 │     1      2      1      3
   2 │     1      1      2      3
   3 │     1      2      3      5
   4 │     2      1      4      5
   5 │     2      2      5      7
   6 │     1      1      6      7
   7 │     1      2      7      9
   8 │     2      1      8      9</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/10c5b5e9e7f916024b2f102d040fdd9d4e6bd371/src/abstractdataframe/selection.jl#L917-L1170">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFrames.select!" href="#DataFrames.select!"><code>DataFrames.select!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">select!(df::AbstractDataFrame, args...; renamecols::Bool=true)
select!(args::Base.Callable, df::DataFrame; renamecols::Bool=true)
select!(gd::GroupedDataFrame, args...; ungroup::Bool=true, renamecols::Bool=true)
select!(f::Base.Callable, gd::GroupedDataFrame; ungroup::Bool=true, renamecols::Bool=true)</code></pre><p>Mutate <code>df</code> or <code>gd</code> in place to retain only columns or transformations specified by <code>args...</code> and return it. The result is guaranteed to have the same number of rows as <code>df</code> or parent of <code>gd</code>, except when no columns are selected (in which case the result has zero rows).</p><p>If a <code>SubDataFrame</code> or <code>GroupedDataFrame{SubDataFrame}</code> is passed, the parent data frame is updated using columns generated by <code>args...</code>, following the same rules as indexing:</p><ul><li>for existing columns filtered-out rows are filled with values present in the old columns</li><li>for new columns (which is only allowed if <code>SubDataFrame</code> was created with <code>:</code> as column selector) filtered-out rows are filled with <code>missing</code></li><li>if <code>SubDataFrame</code> was not created with <code>:</code> as column selector then <code>select!</code> is only allowed if the transformations keep exactly the same sequence of column names as is in the passed <code>df</code></li></ul><p>If a <code>GroupedDataFrame</code> is passed then it is updated to reflect the new rows of its updated parent. If there are independent <code>GroupedDataFrame</code> objects constructed using the same parent data frame they might get corrupt.</p><p>Below detailed common rules for all transformation functions supported by DataFrames.jl are explained and compared.</p><p>All these operations are supported both for <code>AbstractDataFrame</code> (when split and combine steps are skipped) and <code>GroupedDataFrame</code>. Technically, <code>AbstractDataFrame</code> is just considered as being grouped on no columns (meaning it has a single group, or zero groups if it is empty). The only difference is that in this case the <code>keepkeys</code> and <code>ungroup</code> keyword arguments (described below) are not supported and a data frame is always returned, as there are no split and combine steps in this case.</p><p>In order to perform operations by groups you first need to create a <code>GroupedDataFrame</code> object from your data frame using the <code>groupby</code> function that takes two arguments: (1) a data frame to be grouped, and (2) a set of columns to group by.</p><p>Operations can then be applied on each group using one of the following functions:</p><ul><li><code>combine</code>: does not put restrictions on number of rows returned, the order of rows is specified by the order of groups in <code>GroupedDataFrame</code>; it is typically used to compute summary statistics by group;</li><li><code>select</code>: return a data frame with the number and order of rows exactly the same as the source data frame, including only new calculated columns; <code>select!</code> is an in-place version of <code>select</code>;</li><li><code>transform</code>: return a data frame with the number and order of rows exactly the same as the source data frame, including all columns from the source and new calculated columns; <code>transform!</code> is an in-place version of <code>transform</code>.</li></ul><p>All these functions take a specification of one or more functions to apply to each subset of the <code>DataFrame</code>. This specification can be of the following forms:</p><ol><li>standard column selectors (integers, <code>Symbol</code>s, strings, vectors of integers, vectors of <code>Symbol</code>s, vectors of strings, <code>All</code>, <code>Cols</code>, <code>:</code>, <code>Between</code>, <code>Not</code> and regular expressions)</li><li>a <code>cols =&gt; function</code> pair indicating that <code>function</code> should be called with positional arguments holding columns <code>cols</code>, which can be any valid column selector; in this case target column name is automatically generated and it is assumed that <code>function</code> returns a single value or a vector; the generated name is created by concatenating source column name and <code>function</code> name by default (see examples below).</li><li>a <code>cols =&gt; function =&gt; target_cols</code> form additionally explicitly specifying the target column or columns, which must be a single name (as a <code>Symbol</code> or a string), a vector of names or <code>AsTable</code>. Additionally it can be a <code>Function</code> which takes a string or a vector of strings as an argument containing names of columns selected by <code>cols</code>, and returns the target columns names (all accepted types except <code>AsTable</code> are allowed).</li><li>a <code>col =&gt; target_cols</code> pair, which renames the column <code>col</code> to <code>target_cols</code>, which must be single name (as a <code>Symbol</code> or a string), a vector of names or <code>AsTable</code>.</li><li>a <code>nrow</code> or <code>nrow =&gt; target_cols</code> form which efficiently computes the number of rows in a group; without <code>target_cols</code> the new column is called <code>:nrow</code>, otherwise it must be single name (as a <code>Symbol</code> or a string).</li><li>vectors or matrices containing transformations specified by the <code>Pair</code> syntax described in points 2 to 5</li><li>a function which will be called with a <code>SubDataFrame</code> corresponding to each group if a <code>GroupedDataFrame</code> is processed, or with the data frame itself if an <code>AbstractDataFrame</code> is processed; this form should be avoided due to its poor performance unless the number of groups is small or a very large number of columns are processed (in which case <code>SubDataFrame</code> avoids excessive compilation)</li></ol><p>Note! If the expression of the form <code>x =&gt; y</code> is passed then except for the special convenience form <code>nrow =&gt; target_cols</code> it is always interpreted as <code>cols =&gt; function</code>. In particular the following expression <code>function =&gt; target_cols</code> is not a valid transformation specification.</p><p>Note! If <code>cols</code> or <code>target_cols</code> are one of <code>All</code>, <code>Cols</code>, <code>Between</code>, or <code>Not</code>, broadcasting using <code>.=&gt;</code> is supported and is equivalent to broadcasting the result of <code>names(df, cols)</code> or <code>names(df, target_cols)</code>. This behaves as if broadcasting happened after replacing the selector with selected column names within the data frame scope.</p><p>All functions have two types of signatures. One of them takes a <code>GroupedDataFrame</code> as the first argument and an arbitrary number of transformations described above as following arguments. The second type of signature is when a <code>Function</code> or a <code>Type</code> is passed as the first argument and a <code>GroupedDataFrame</code> as the second argument (similar to <code>map</code>).</p><p>As a special rule, with the <code>cols =&gt; function</code> and <code>cols =&gt; function =&gt; target_cols</code> syntaxes, if <code>cols</code> is wrapped in an <code>AsTable</code> object then a <code>NamedTuple</code> containing columns selected by <code>cols</code> is passed to <code>function</code>.</p><p>What is allowed for <code>function</code> to return is determined by the <code>target_cols</code> value:</p><ol><li>If both <code>cols</code> and <code>target_cols</code> are omitted (so only a <code>function</code> is passed), then returning a data frame, a matrix, a <code>NamedTuple</code>, or a <code>DataFrameRow</code> will produce multiple columns in the result. Returning any other value produces a single column.</li><li>If <code>target_cols</code> is a <code>Symbol</code> or a string then the function is assumed to return a single column. In this case returning a data frame, a matrix, a <code>NamedTuple</code>, or a <code>DataFrameRow</code> raises an error.</li><li>If <code>target_cols</code> is a vector of <code>Symbol</code>s or strings or <code>AsTable</code> it is assumed that <code>function</code> returns multiple columns. If <code>function</code> returns one of <code>AbstractDataFrame</code>, <code>NamedTuple</code>, <code>DataFrameRow</code>, <code>AbstractMatrix</code> then rules described in point 1 above apply. If <code>function</code> returns an <code>AbstractVector</code> then each element of this vector must support the <code>keys</code> function, which must return a collection of <code>Symbol</code>s, strings or integers; the return value of <code>keys</code> must be identical for all elements. Then as many columns are created as there are elements in the return value of the <code>keys</code> function. If <code>target_cols</code> is <code>AsTable</code> then their names are set to be equal to the key names except if <code>keys</code> returns integers, in which case they are prefixed by <code>x</code> (so the column names are e.g. <code>x1</code>, <code>x2</code>, ...). If <code>target_cols</code> is a vector of <code>Symbol</code>s or strings then column names produced using the rules above are ignored and replaced by <code>target_cols</code> (the number of columns must be the same as the length of <code>target_cols</code> in this case). If <code>fun</code> returns a value of any other type then it is assumed that it is a table conforming to the Tables.jl API and the <code>Tables.columntable</code> function is called on it to get the resulting columns and their names. The names are retained when <code>target_cols</code> is <code>AsTable</code> and are replaced if <code>target_cols</code> is a vector of <code>Symbol</code>s or strings.</li></ol><p>In all of these cases, <code>function</code> can return either a single row or multiple rows. As a particular rule, values wrapped in a <code>Ref</code> or a <code>0</code>-dimensional <code>AbstractArray</code> are unwrapped and then treated as a single row.</p><p><code>select</code>/<code>select!</code> and <code>transform</code>/<code>transform!</code> always return a data frame with the same number and order of rows as the source (even if <code>GroupedDataFrame</code> had its groups reordered), except when selection results in zero columns in the resulting data frame (in which case the result has zero rows).</p><p>For <code>combine</code>, rows in the returned object appear in the order of groups in the <code>GroupedDataFrame</code>. The functions can return an arbitrary number of rows for each group, but the kind of returned object and the number and names of columns must be the same for all groups, except when a <code>DataFrame()</code> or <code>NamedTuple()</code> is returned, in which case a given group is skipped.</p><p>It is allowed to mix single values and vectors if multiple transformations are requested. In this case single value will be repeated to match the length of columns specified by returned vectors.</p><p>To apply <code>function</code> to each row instead of whole columns, it can be wrapped in a <code>ByRow</code> struct. <code>cols</code> can be any column indexing syntax, in which case <code>function</code> will be passed one argument for each of the columns specified by <code>cols</code> or a <code>NamedTuple</code> of them if specified columns are wrapped in <code>AsTable</code>. If <code>ByRow</code> is used it is allowed for <code>cols</code> to select an empty set of columns, in which case <code>function</code> is called for each row without any arguments and an empty <code>NamedTuple</code> is passed if empty set of columns is wrapped in <code>AsTable</code>.</p><p>If a collection of column names is passed then requesting duplicate column names in target data frame are accepted (e.g. <code>select!(df, [:a], :, r&quot;a&quot;)</code> is allowed) and only the first occurrence is used. In particular a syntax to move column <code>:col</code> to the first position in the data frame is <code>select!(df, :col, :)</code>. On the contrary, output column names of renaming, transformation and single column selection operations must be unique, so e.g. <code>select!(df, :a, :a =&gt; :a)</code> or <code>select!(df, :a, :a =&gt; ByRow(sin) =&gt; :a)</code> are not allowed.</p><p>In general columns returned by transformations are stored in the target data frame without copying. An exception to this rule is when columns from the source data frame are reused in the target data frame. This can happen via expressions like: <code>:x1</code>, <code>[:x1, :x2]</code>, <code>:x1 =&gt; :x2</code>, <code>:x1 =&gt; identity =&gt; :x2</code>, or <code>:x1 =&gt; (x -&gt; @view x[inds])</code> (note that in the last case the source column is reused indirectly via a view). In such cases the behavior depends on the value of the <code>copycols</code> keyword argument:</p><ul><li>if <code>copycols=true</code> then results of such transformations always perform a copy of the source column or its view;</li><li>if <code>copycols=false</code> then copies are only performed to avoid storing the same column several times in the target data frame; more precisely, no copy is made the first time a column is used, but each subsequent reuse of a source column (when compared using <code>===</code>, which excludes views of source columns) performs a copy;</li></ul><p>Note that performing <code>transform!</code> or <code>select!</code> assumes that <code>copycols=false</code>.</p><p>If <code>df</code> is a <code>SubDataFrame</code> and <code>copycols=true</code> then a <code>DataFrame</code> is returned and the same copying rules apply as for a <code>DataFrame</code> input: this means in particular that selected columns will be copied. If <code>copycols=false</code>, a <code>SubDataFrame</code> is returned without copying columns and in this case transforming or renaming columns is not allowed.</p><p>If a <code>GroupedDataFrame</code> is passed, a separate task is spawned for each specified transformation; each transformation then spawns as many tasks as Julia threads, and splits processing of groups across them (however, currently transformations with optimized implementations like <code>sum</code> and transformations that return multiple rows use a single task for all groups). This allows for parallel operation when Julia was started with more than one thread. Passed transformation functions should therefore not modify global variables (i.e. they should be pure), or use locks to control parallel accesses. In the future, parallelism may be extended to other cases, so this requirement also holds for <code>DataFrame</code> inputs.</p><p>In order to improve the performance of the operations some transformations invoke optimized implementation, see <a href="../internals/#DataFrames.table_transformation"><code>table_transformation</code></a> for details.</p><p><strong>Keyword arguments</strong></p><ul><li><code>renamecols::Bool=true</code> : whether in the <code>cols =&gt; function</code> form automatically generated column names should include the name of transformation functions or not.</li><li><code>ungroup::Bool=true</code> : whether the return value of the operation on <code>gd</code> should be a data frame or a <code>GroupedDataFrame</code>.</li></ul><p>See <a href="#DataFrames.select"><code>select</code></a> for examples.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/10c5b5e9e7f916024b2f102d040fdd9d4e6bd371/src/abstractdataframe/selection.jl#L838-L872">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFrames.transform" href="#DataFrames.transform"><code>DataFrames.transform</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">transform(df::AbstractDataFrame, args...; copycols::Bool=true, renamecols::Bool=true)
transform(f::Callable, df::DataFrame; renamecols::Bool=true)
transform(gd::GroupedDataFrame, args...; copycols::Bool=true,
          keepkeys::Bool=true, ungroup::Bool=true, renamecols::Bool=true)
transform(f::Base.Callable, gd::GroupedDataFrame; copycols::Bool=true,
          keepkeys::Bool=true, ungroup::Bool=true, renamecols::Bool=true)</code></pre><p>Create a new data frame that contains columns from <code>df</code> or <code>gd</code> plus columns specified by <code>args</code> and return it. The result is guaranteed to have the same number of rows as <code>df</code>. Equivalent to <code>select(df, :, args...)</code> or <code>select(gd, :, args...)</code>.</p><p>Below detailed common rules for all transformation functions supported by DataFrames.jl are explained and compared.</p><p>All these operations are supported both for <code>AbstractDataFrame</code> (when split and combine steps are skipped) and <code>GroupedDataFrame</code>. Technically, <code>AbstractDataFrame</code> is just considered as being grouped on no columns (meaning it has a single group, or zero groups if it is empty). The only difference is that in this case the <code>keepkeys</code> and <code>ungroup</code> keyword arguments (described below) are not supported and a data frame is always returned, as there are no split and combine steps in this case.</p><p>In order to perform operations by groups you first need to create a <code>GroupedDataFrame</code> object from your data frame using the <code>groupby</code> function that takes two arguments: (1) a data frame to be grouped, and (2) a set of columns to group by.</p><p>Operations can then be applied on each group using one of the following functions:</p><ul><li><code>combine</code>: does not put restrictions on number of rows returned, the order of rows is specified by the order of groups in <code>GroupedDataFrame</code>; it is typically used to compute summary statistics by group;</li><li><code>select</code>: return a data frame with the number and order of rows exactly the same as the source data frame, including only new calculated columns; <code>select!</code> is an in-place version of <code>select</code>;</li><li><code>transform</code>: return a data frame with the number and order of rows exactly the same as the source data frame, including all columns from the source and new calculated columns; <code>transform!</code> is an in-place version of <code>transform</code>.</li></ul><p>All these functions take a specification of one or more functions to apply to each subset of the <code>DataFrame</code>. This specification can be of the following forms:</p><ol><li>standard column selectors (integers, <code>Symbol</code>s, strings, vectors of integers, vectors of <code>Symbol</code>s, vectors of strings, <code>All</code>, <code>Cols</code>, <code>:</code>, <code>Between</code>, <code>Not</code> and regular expressions)</li><li>a <code>cols =&gt; function</code> pair indicating that <code>function</code> should be called with positional arguments holding columns <code>cols</code>, which can be any valid column selector; in this case target column name is automatically generated and it is assumed that <code>function</code> returns a single value or a vector; the generated name is created by concatenating source column name and <code>function</code> name by default (see examples below).</li><li>a <code>cols =&gt; function =&gt; target_cols</code> form additionally explicitly specifying the target column or columns, which must be a single name (as a <code>Symbol</code> or a string), a vector of names or <code>AsTable</code>. Additionally it can be a <code>Function</code> which takes a string or a vector of strings as an argument containing names of columns selected by <code>cols</code>, and returns the target columns names (all accepted types except <code>AsTable</code> are allowed).</li><li>a <code>col =&gt; target_cols</code> pair, which renames the column <code>col</code> to <code>target_cols</code>, which must be single name (as a <code>Symbol</code> or a string), a vector of names or <code>AsTable</code>.</li><li>a <code>nrow</code> or <code>nrow =&gt; target_cols</code> form which efficiently computes the number of rows in a group; without <code>target_cols</code> the new column is called <code>:nrow</code>, otherwise it must be single name (as a <code>Symbol</code> or a string).</li><li>vectors or matrices containing transformations specified by the <code>Pair</code> syntax described in points 2 to 5</li><li>a function which will be called with a <code>SubDataFrame</code> corresponding to each group if a <code>GroupedDataFrame</code> is processed, or with the data frame itself if an <code>AbstractDataFrame</code> is processed; this form should be avoided due to its poor performance unless the number of groups is small or a very large number of columns are processed (in which case <code>SubDataFrame</code> avoids excessive compilation)</li></ol><p>Note! If the expression of the form <code>x =&gt; y</code> is passed then except for the special convenience form <code>nrow =&gt; target_cols</code> it is always interpreted as <code>cols =&gt; function</code>. In particular the following expression <code>function =&gt; target_cols</code> is not a valid transformation specification.</p><p>Note! If <code>cols</code> or <code>target_cols</code> are one of <code>All</code>, <code>Cols</code>, <code>Between</code>, or <code>Not</code>, broadcasting using <code>.=&gt;</code> is supported and is equivalent to broadcasting the result of <code>names(df, cols)</code> or <code>names(df, target_cols)</code>. This behaves as if broadcasting happened after replacing the selector with selected column names within the data frame scope.</p><p>All functions have two types of signatures. One of them takes a <code>GroupedDataFrame</code> as the first argument and an arbitrary number of transformations described above as following arguments. The second type of signature is when a <code>Function</code> or a <code>Type</code> is passed as the first argument and a <code>GroupedDataFrame</code> as the second argument (similar to <code>map</code>).</p><p>As a special rule, with the <code>cols =&gt; function</code> and <code>cols =&gt; function =&gt; target_cols</code> syntaxes, if <code>cols</code> is wrapped in an <code>AsTable</code> object then a <code>NamedTuple</code> containing columns selected by <code>cols</code> is passed to <code>function</code>.</p><p>What is allowed for <code>function</code> to return is determined by the <code>target_cols</code> value:</p><ol><li>If both <code>cols</code> and <code>target_cols</code> are omitted (so only a <code>function</code> is passed), then returning a data frame, a matrix, a <code>NamedTuple</code>, or a <code>DataFrameRow</code> will produce multiple columns in the result. Returning any other value produces a single column.</li><li>If <code>target_cols</code> is a <code>Symbol</code> or a string then the function is assumed to return a single column. In this case returning a data frame, a matrix, a <code>NamedTuple</code>, or a <code>DataFrameRow</code> raises an error.</li><li>If <code>target_cols</code> is a vector of <code>Symbol</code>s or strings or <code>AsTable</code> it is assumed that <code>function</code> returns multiple columns. If <code>function</code> returns one of <code>AbstractDataFrame</code>, <code>NamedTuple</code>, <code>DataFrameRow</code>, <code>AbstractMatrix</code> then rules described in point 1 above apply. If <code>function</code> returns an <code>AbstractVector</code> then each element of this vector must support the <code>keys</code> function, which must return a collection of <code>Symbol</code>s, strings or integers; the return value of <code>keys</code> must be identical for all elements. Then as many columns are created as there are elements in the return value of the <code>keys</code> function. If <code>target_cols</code> is <code>AsTable</code> then their names are set to be equal to the key names except if <code>keys</code> returns integers, in which case they are prefixed by <code>x</code> (so the column names are e.g. <code>x1</code>, <code>x2</code>, ...). If <code>target_cols</code> is a vector of <code>Symbol</code>s or strings then column names produced using the rules above are ignored and replaced by <code>target_cols</code> (the number of columns must be the same as the length of <code>target_cols</code> in this case). If <code>fun</code> returns a value of any other type then it is assumed that it is a table conforming to the Tables.jl API and the <code>Tables.columntable</code> function is called on it to get the resulting columns and their names. The names are retained when <code>target_cols</code> is <code>AsTable</code> and are replaced if <code>target_cols</code> is a vector of <code>Symbol</code>s or strings.</li></ol><p>In all of these cases, <code>function</code> can return either a single row or multiple rows. As a particular rule, values wrapped in a <code>Ref</code> or a <code>0</code>-dimensional <code>AbstractArray</code> are unwrapped and then treated as a single row.</p><p><code>select</code>/<code>select!</code> and <code>transform</code>/<code>transform!</code> always return a data frame with the same number and order of rows as the source (even if <code>GroupedDataFrame</code> had its groups reordered), except when selection results in zero columns in the resulting data frame (in which case the result has zero rows).</p><p>For <code>combine</code>, rows in the returned object appear in the order of groups in the <code>GroupedDataFrame</code>. The functions can return an arbitrary number of rows for each group, but the kind of returned object and the number and names of columns must be the same for all groups, except when a <code>DataFrame()</code> or <code>NamedTuple()</code> is returned, in which case a given group is skipped.</p><p>It is allowed to mix single values and vectors if multiple transformations are requested. In this case single value will be repeated to match the length of columns specified by returned vectors.</p><p>To apply <code>function</code> to each row instead of whole columns, it can be wrapped in a <code>ByRow</code> struct. <code>cols</code> can be any column indexing syntax, in which case <code>function</code> will be passed one argument for each of the columns specified by <code>cols</code> or a <code>NamedTuple</code> of them if specified columns are wrapped in <code>AsTable</code>. If <code>ByRow</code> is used it is allowed for <code>cols</code> to select an empty set of columns, in which case <code>function</code> is called for each row without any arguments and an empty <code>NamedTuple</code> is passed if empty set of columns is wrapped in <code>AsTable</code>.</p><p>If a collection of column names is passed then requesting duplicate column names in target data frame are accepted (e.g. <code>select!(df, [:a], :, r&quot;a&quot;)</code> is allowed) and only the first occurrence is used. In particular a syntax to move column <code>:col</code> to the first position in the data frame is <code>select!(df, :col, :)</code>. On the contrary, output column names of renaming, transformation and single column selection operations must be unique, so e.g. <code>select!(df, :a, :a =&gt; :a)</code> or <code>select!(df, :a, :a =&gt; ByRow(sin) =&gt; :a)</code> are not allowed.</p><p>In general columns returned by transformations are stored in the target data frame without copying. An exception to this rule is when columns from the source data frame are reused in the target data frame. This can happen via expressions like: <code>:x1</code>, <code>[:x1, :x2]</code>, <code>:x1 =&gt; :x2</code>, <code>:x1 =&gt; identity =&gt; :x2</code>, or <code>:x1 =&gt; (x -&gt; @view x[inds])</code> (note that in the last case the source column is reused indirectly via a view). In such cases the behavior depends on the value of the <code>copycols</code> keyword argument:</p><ul><li>if <code>copycols=true</code> then results of such transformations always perform a copy of the source column or its view;</li><li>if <code>copycols=false</code> then copies are only performed to avoid storing the same column several times in the target data frame; more precisely, no copy is made the first time a column is used, but each subsequent reuse of a source column (when compared using <code>===</code>, which excludes views of source columns) performs a copy;</li></ul><p>Note that performing <code>transform!</code> or <code>select!</code> assumes that <code>copycols=false</code>.</p><p>If <code>df</code> is a <code>SubDataFrame</code> and <code>copycols=true</code> then a <code>DataFrame</code> is returned and the same copying rules apply as for a <code>DataFrame</code> input: this means in particular that selected columns will be copied. If <code>copycols=false</code>, a <code>SubDataFrame</code> is returned without copying columns and in this case transforming or renaming columns is not allowed.</p><p>If a <code>GroupedDataFrame</code> is passed, a separate task is spawned for each specified transformation; each transformation then spawns as many tasks as Julia threads, and splits processing of groups across them (however, currently transformations with optimized implementations like <code>sum</code> and transformations that return multiple rows use a single task for all groups). This allows for parallel operation when Julia was started with more than one thread. Passed transformation functions should therefore not modify global variables (i.e. they should be pure), or use locks to control parallel accesses. In the future, parallelism may be extended to other cases, so this requirement also holds for <code>DataFrame</code> inputs.</p><p>In order to improve the performance of the operations some transformations invoke optimized implementation, see <a href="../internals/#DataFrames.table_transformation"><code>table_transformation</code></a> for details.</p><p><strong>Keyword arguments</strong></p><ul><li><code>copycols::Bool=true</code> : whether columns of the source data frame should be copied if no transformation is applied to them.</li><li><code>renamecols::Bool=true</code> : whether in the <code>cols =&gt; function</code> form automatically generated column names should include the name of transformation functions or not.</li><li><code>keepkeys::Bool=true</code> : whether grouping columns of <code>gd</code> should be kept in the returned data frame.</li><li><code>ungroup::Bool=true</code> : whether the return value of the operation on <code>gd</code> should be a data frame or a <code>GroupedDataFrame</code>.</li></ul><p>Note that when the first argument is a <code>GroupedDataFrame</code>, <code>keepkeys=false</code> is needed to be able to return a different value for the grouping column:</p><pre><code class="language-julia-repl hljs">julia&gt; gdf = groupby(DataFrame(x=1:2), :x)
GroupedDataFrame with 2 groups based on key: x
First Group (1 row): x = 1
 Row │ x
     │ Int64
─────┼───────
   1 │     1
⋮
Last Group (1 row): x = 2
 Row │ x
     │ Int64
─────┼───────
   1 │     2

julia&gt; transform(gdf, x -&gt; (x=10,), keepkeys=false)
2×1 DataFrame
 Row │ x
     │ Int64
─────┼───────
   1 │    10
   2 │    10

julia&gt; transform(gdf, x -&gt; (x=10,), keepkeys=true)
ERROR: ArgumentError: column :x in returned data frame is not equal to grouping key :x</code></pre><p>See <a href="#DataFrames.select"><code>select</code></a> for more examples.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/10c5b5e9e7f916024b2f102d040fdd9d4e6bd371/src/abstractdataframe/selection.jl#L1182-L1237">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFrames.transform!" href="#DataFrames.transform!"><code>DataFrames.transform!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">transform!(df::AbstractDataFrame, args...; renamecols::Bool=true)
transform!(args::Callable, df::AbstractDataFrame; renamecols::Bool=true)
transform!(gd::GroupedDataFrame, args...; ungroup::Bool=true, renamecols::Bool=true)
transform!(f::Base.Callable, gd::GroupedDataFrame; ungroup::Bool=true, renamecols::Bool=true)</code></pre><p>Mutate <code>df</code> or <code>gd</code> in place to add columns specified by <code>args...</code> and return it. The result is guaranteed to have the same number of rows as <code>df</code>. Equivalent to <code>select!(df, :, args...)</code> or <code>select!(gd, :, args...)</code>, except that column renaming performs a copy.</p><p>Below detailed common rules for all transformation functions supported by DataFrames.jl are explained and compared.</p><p>All these operations are supported both for <code>AbstractDataFrame</code> (when split and combine steps are skipped) and <code>GroupedDataFrame</code>. Technically, <code>AbstractDataFrame</code> is just considered as being grouped on no columns (meaning it has a single group, or zero groups if it is empty). The only difference is that in this case the <code>keepkeys</code> and <code>ungroup</code> keyword arguments (described below) are not supported and a data frame is always returned, as there are no split and combine steps in this case.</p><p>In order to perform operations by groups you first need to create a <code>GroupedDataFrame</code> object from your data frame using the <code>groupby</code> function that takes two arguments: (1) a data frame to be grouped, and (2) a set of columns to group by.</p><p>Operations can then be applied on each group using one of the following functions:</p><ul><li><code>combine</code>: does not put restrictions on number of rows returned, the order of rows is specified by the order of groups in <code>GroupedDataFrame</code>; it is typically used to compute summary statistics by group;</li><li><code>select</code>: return a data frame with the number and order of rows exactly the same as the source data frame, including only new calculated columns; <code>select!</code> is an in-place version of <code>select</code>;</li><li><code>transform</code>: return a data frame with the number and order of rows exactly the same as the source data frame, including all columns from the source and new calculated columns; <code>transform!</code> is an in-place version of <code>transform</code>.</li></ul><p>All these functions take a specification of one or more functions to apply to each subset of the <code>DataFrame</code>. This specification can be of the following forms:</p><ol><li>standard column selectors (integers, <code>Symbol</code>s, strings, vectors of integers, vectors of <code>Symbol</code>s, vectors of strings, <code>All</code>, <code>Cols</code>, <code>:</code>, <code>Between</code>, <code>Not</code> and regular expressions)</li><li>a <code>cols =&gt; function</code> pair indicating that <code>function</code> should be called with positional arguments holding columns <code>cols</code>, which can be any valid column selector; in this case target column name is automatically generated and it is assumed that <code>function</code> returns a single value or a vector; the generated name is created by concatenating source column name and <code>function</code> name by default (see examples below).</li><li>a <code>cols =&gt; function =&gt; target_cols</code> form additionally explicitly specifying the target column or columns, which must be a single name (as a <code>Symbol</code> or a string), a vector of names or <code>AsTable</code>. Additionally it can be a <code>Function</code> which takes a string or a vector of strings as an argument containing names of columns selected by <code>cols</code>, and returns the target columns names (all accepted types except <code>AsTable</code> are allowed).</li><li>a <code>col =&gt; target_cols</code> pair, which renames the column <code>col</code> to <code>target_cols</code>, which must be single name (as a <code>Symbol</code> or a string), a vector of names or <code>AsTable</code>.</li><li>a <code>nrow</code> or <code>nrow =&gt; target_cols</code> form which efficiently computes the number of rows in a group; without <code>target_cols</code> the new column is called <code>:nrow</code>, otherwise it must be single name (as a <code>Symbol</code> or a string).</li><li>vectors or matrices containing transformations specified by the <code>Pair</code> syntax described in points 2 to 5</li><li>a function which will be called with a <code>SubDataFrame</code> corresponding to each group if a <code>GroupedDataFrame</code> is processed, or with the data frame itself if an <code>AbstractDataFrame</code> is processed; this form should be avoided due to its poor performance unless the number of groups is small or a very large number of columns are processed (in which case <code>SubDataFrame</code> avoids excessive compilation)</li></ol><p>Note! If the expression of the form <code>x =&gt; y</code> is passed then except for the special convenience form <code>nrow =&gt; target_cols</code> it is always interpreted as <code>cols =&gt; function</code>. In particular the following expression <code>function =&gt; target_cols</code> is not a valid transformation specification.</p><p>Note! If <code>cols</code> or <code>target_cols</code> are one of <code>All</code>, <code>Cols</code>, <code>Between</code>, or <code>Not</code>, broadcasting using <code>.=&gt;</code> is supported and is equivalent to broadcasting the result of <code>names(df, cols)</code> or <code>names(df, target_cols)</code>. This behaves as if broadcasting happened after replacing the selector with selected column names within the data frame scope.</p><p>All functions have two types of signatures. One of them takes a <code>GroupedDataFrame</code> as the first argument and an arbitrary number of transformations described above as following arguments. The second type of signature is when a <code>Function</code> or a <code>Type</code> is passed as the first argument and a <code>GroupedDataFrame</code> as the second argument (similar to <code>map</code>).</p><p>As a special rule, with the <code>cols =&gt; function</code> and <code>cols =&gt; function =&gt; target_cols</code> syntaxes, if <code>cols</code> is wrapped in an <code>AsTable</code> object then a <code>NamedTuple</code> containing columns selected by <code>cols</code> is passed to <code>function</code>.</p><p>What is allowed for <code>function</code> to return is determined by the <code>target_cols</code> value:</p><ol><li>If both <code>cols</code> and <code>target_cols</code> are omitted (so only a <code>function</code> is passed), then returning a data frame, a matrix, a <code>NamedTuple</code>, or a <code>DataFrameRow</code> will produce multiple columns in the result. Returning any other value produces a single column.</li><li>If <code>target_cols</code> is a <code>Symbol</code> or a string then the function is assumed to return a single column. In this case returning a data frame, a matrix, a <code>NamedTuple</code>, or a <code>DataFrameRow</code> raises an error.</li><li>If <code>target_cols</code> is a vector of <code>Symbol</code>s or strings or <code>AsTable</code> it is assumed that <code>function</code> returns multiple columns. If <code>function</code> returns one of <code>AbstractDataFrame</code>, <code>NamedTuple</code>, <code>DataFrameRow</code>, <code>AbstractMatrix</code> then rules described in point 1 above apply. If <code>function</code> returns an <code>AbstractVector</code> then each element of this vector must support the <code>keys</code> function, which must return a collection of <code>Symbol</code>s, strings or integers; the return value of <code>keys</code> must be identical for all elements. Then as many columns are created as there are elements in the return value of the <code>keys</code> function. If <code>target_cols</code> is <code>AsTable</code> then their names are set to be equal to the key names except if <code>keys</code> returns integers, in which case they are prefixed by <code>x</code> (so the column names are e.g. <code>x1</code>, <code>x2</code>, ...). If <code>target_cols</code> is a vector of <code>Symbol</code>s or strings then column names produced using the rules above are ignored and replaced by <code>target_cols</code> (the number of columns must be the same as the length of <code>target_cols</code> in this case). If <code>fun</code> returns a value of any other type then it is assumed that it is a table conforming to the Tables.jl API and the <code>Tables.columntable</code> function is called on it to get the resulting columns and their names. The names are retained when <code>target_cols</code> is <code>AsTable</code> and are replaced if <code>target_cols</code> is a vector of <code>Symbol</code>s or strings.</li></ol><p>In all of these cases, <code>function</code> can return either a single row or multiple rows. As a particular rule, values wrapped in a <code>Ref</code> or a <code>0</code>-dimensional <code>AbstractArray</code> are unwrapped and then treated as a single row.</p><p><code>select</code>/<code>select!</code> and <code>transform</code>/<code>transform!</code> always return a data frame with the same number and order of rows as the source (even if <code>GroupedDataFrame</code> had its groups reordered), except when selection results in zero columns in the resulting data frame (in which case the result has zero rows).</p><p>For <code>combine</code>, rows in the returned object appear in the order of groups in the <code>GroupedDataFrame</code>. The functions can return an arbitrary number of rows for each group, but the kind of returned object and the number and names of columns must be the same for all groups, except when a <code>DataFrame()</code> or <code>NamedTuple()</code> is returned, in which case a given group is skipped.</p><p>It is allowed to mix single values and vectors if multiple transformations are requested. In this case single value will be repeated to match the length of columns specified by returned vectors.</p><p>To apply <code>function</code> to each row instead of whole columns, it can be wrapped in a <code>ByRow</code> struct. <code>cols</code> can be any column indexing syntax, in which case <code>function</code> will be passed one argument for each of the columns specified by <code>cols</code> or a <code>NamedTuple</code> of them if specified columns are wrapped in <code>AsTable</code>. If <code>ByRow</code> is used it is allowed for <code>cols</code> to select an empty set of columns, in which case <code>function</code> is called for each row without any arguments and an empty <code>NamedTuple</code> is passed if empty set of columns is wrapped in <code>AsTable</code>.</p><p>If a collection of column names is passed then requesting duplicate column names in target data frame are accepted (e.g. <code>select!(df, [:a], :, r&quot;a&quot;)</code> is allowed) and only the first occurrence is used. In particular a syntax to move column <code>:col</code> to the first position in the data frame is <code>select!(df, :col, :)</code>. On the contrary, output column names of renaming, transformation and single column selection operations must be unique, so e.g. <code>select!(df, :a, :a =&gt; :a)</code> or <code>select!(df, :a, :a =&gt; ByRow(sin) =&gt; :a)</code> are not allowed.</p><p>In general columns returned by transformations are stored in the target data frame without copying. An exception to this rule is when columns from the source data frame are reused in the target data frame. This can happen via expressions like: <code>:x1</code>, <code>[:x1, :x2]</code>, <code>:x1 =&gt; :x2</code>, <code>:x1 =&gt; identity =&gt; :x2</code>, or <code>:x1 =&gt; (x -&gt; @view x[inds])</code> (note that in the last case the source column is reused indirectly via a view). In such cases the behavior depends on the value of the <code>copycols</code> keyword argument:</p><ul><li>if <code>copycols=true</code> then results of such transformations always perform a copy of the source column or its view;</li><li>if <code>copycols=false</code> then copies are only performed to avoid storing the same column several times in the target data frame; more precisely, no copy is made the first time a column is used, but each subsequent reuse of a source column (when compared using <code>===</code>, which excludes views of source columns) performs a copy;</li></ul><p>Note that performing <code>transform!</code> or <code>select!</code> assumes that <code>copycols=false</code>.</p><p>If <code>df</code> is a <code>SubDataFrame</code> and <code>copycols=true</code> then a <code>DataFrame</code> is returned and the same copying rules apply as for a <code>DataFrame</code> input: this means in particular that selected columns will be copied. If <code>copycols=false</code>, a <code>SubDataFrame</code> is returned without copying columns and in this case transforming or renaming columns is not allowed.</p><p>If a <code>GroupedDataFrame</code> is passed, a separate task is spawned for each specified transformation; each transformation then spawns as many tasks as Julia threads, and splits processing of groups across them (however, currently transformations with optimized implementations like <code>sum</code> and transformations that return multiple rows use a single task for all groups). This allows for parallel operation when Julia was started with more than one thread. Passed transformation functions should therefore not modify global variables (i.e. they should be pure), or use locks to control parallel accesses. In the future, parallelism may be extended to other cases, so this requirement also holds for <code>DataFrame</code> inputs.</p><p>In order to improve the performance of the operations some transformations invoke optimized implementation, see <a href="../internals/#DataFrames.table_transformation"><code>table_transformation</code></a> for details.</p><p><strong>Keyword arguments</strong></p><ul><li><code>renamecols::Bool=true</code> : whether in the <code>cols =&gt; function</code> form automatically generated column names should include the name of transformation functions or not.</li><li><code>ungroup::Bool=true</code> : whether the return value of the operation on <code>gd</code> should be a data frame or a <code>GroupedDataFrame</code>.</li></ul><p>See <a href="#DataFrames.select"><code>select</code></a> for examples.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/10c5b5e9e7f916024b2f102d040fdd9d4e6bd371/src/abstractdataframe/selection.jl#L886-L906">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.vcat" href="#Base.vcat"><code>Base.vcat</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">vcat(dfs::AbstractDataFrame...;
     cols::Union{Symbol, AbstractVector{Symbol},
                 AbstractVector{&lt;:AbstractString}}=:setequal,
     source::Union{Nothing, Symbol, AbstractString,
                   Pair{&lt;:Union{Symbol, AbstractString}, &lt;:AbstractVector}}=nothing)</code></pre><p>Vertically concatenate <code>AbstractDataFrame</code>s.</p><p>The <code>cols</code> keyword argument determines the columns of the returned data frame:</p><ul><li><code>:setequal</code>: require all data frames to have the same column names disregarding order. If they appear in different orders, the order of the first provided data frame is used.</li><li><code>:orderequal</code>: require all data frames to have the same column names and in the same order.</li><li><code>:intersect</code>: only the columns present in <em>all</em> provided data frames are kept. If the intersection is empty, an empty data frame is returned.</li><li><code>:union</code>: columns present in <em>at least one</em> of the provided data frames are kept. Columns not present in some data frames are filled with <code>missing</code> where necessary.</li><li>A vector of <code>Symbol</code>s or strings: only listed columns are kept. Columns not present in some data frames are filled with <code>missing</code> where necessary.</li></ul><p>The <code>source</code> keyword argument, if not <code>nothing</code> (the default), specifies the additional column to be added in the last position in the resulting data frame that will identify the source data frame. It can be a <code>Symbol</code> or an <code>AbstractString</code>, in which case the identifier will be the number of the passed source data frame, or a <code>Pair</code> consisting of a <code>Symbol</code> or an <code>AbstractString</code> and of a vector specifying the data frame identifiers (which do not have to be unique). The name of the source column is not allowed to be present in any source data frame.</p><p>The order of columns is determined by the order they appear in the included data frames, searching through the header of the first data frame, then the second, etc.</p><p>The element types of columns are determined using <code>promote_type</code>, as with <code>vcat</code> for <code>AbstractVector</code>s.</p><p><code>vcat</code> ignores empty data frames, making it possible to initialize an empty data frame at the beginning of a loop and <code>vcat</code> onto it.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; df1 = DataFrame(A=1:3, B=1:3)
3×2 DataFrame
 Row │ A      B
     │ Int64  Int64
─────┼──────────────
   1 │     1      1
   2 │     2      2
   3 │     3      3

julia&gt; df2 = DataFrame(A=4:6, B=4:6)
3×2 DataFrame
 Row │ A      B
     │ Int64  Int64
─────┼──────────────
   1 │     4      4
   2 │     5      5
   3 │     6      6

julia&gt; df3 = DataFrame(A=7:9, C=7:9)
3×2 DataFrame
 Row │ A      C
     │ Int64  Int64
─────┼──────────────
   1 │     7      7
   2 │     8      8
   3 │     9      9

julia&gt; df4 = DataFrame()
0×0 DataFrame

julia&gt; vcat(df1, df2)
6×2 DataFrame
 Row │ A      B
     │ Int64  Int64
─────┼──────────────
   1 │     1      1
   2 │     2      2
   3 │     3      3
   4 │     4      4
   5 │     5      5
   6 │     6      6

julia&gt; vcat(df1, df3, cols=:union)
6×3 DataFrame
 Row │ A      B        C
     │ Int64  Int64?   Int64?
─────┼─────────────────────────
   1 │     1        1  missing
   2 │     2        2  missing
   3 │     3        3  missing
   4 │     7  missing        7
   5 │     8  missing        8
   6 │     9  missing        9

julia&gt; vcat(df1, df3, cols=:intersect)
6×1 DataFrame
 Row │ A
     │ Int64
─────┼───────
   1 │     1
   2 │     2
   3 │     3
   4 │     7
   5 │     8
   6 │     9

julia&gt; vcat(df4, df1)
3×2 DataFrame
 Row │ A      B
     │ Int64  Int64
─────┼──────────────
   1 │     1      1
   2 │     2      2
   3 │     3      3

julia&gt; vcat(df1, df2, df3, df4, cols=:union, source=&quot;source&quot;)
9×4 DataFrame
 Row │ A      B        C        source
     │ Int64  Int64?   Int64?   Int64
─────┼─────────────────────────────────
   1 │     1        1  missing       1
   2 │     2        2  missing       1
   3 │     3        3  missing       1
   4 │     4        4  missing       2
   5 │     5        5  missing       2
   6 │     6        6  missing       2
   7 │     7  missing        7       3
   8 │     8  missing        8       3
   9 │     9  missing        9       3

julia&gt; vcat(df1, df2, df4, df3, cols=:union, source=:source =&gt; &#39;a&#39;:&#39;d&#39;)
9×4 DataFrame
 Row │ A      B        C        source
     │ Int64  Int64?   Int64?   Char
─────┼─────────────────────────────────
   1 │     1        1  missing  a
   2 │     2        2  missing  a
   3 │     3        3  missing  a
   4 │     4        4  missing  b
   5 │     5        5  missing  b
   6 │     6        6  missing  b
   7 │     7  missing        7  d
   8 │     8  missing        8  d
   9 │     9  missing        9  d</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/10c5b5e9e7f916024b2f102d040fdd9d4e6bd371/src/abstractdataframe/abstractdataframe.jl#L1525-L1674">source</a></section></article><h2 id="Reshaping-data-frames-between-tall-and-wide-formats"><a class="docs-heading-anchor" href="#Reshaping-data-frames-between-tall-and-wide-formats">Reshaping data frames between tall and wide formats</a><a id="Reshaping-data-frames-between-tall-and-wide-formats-1"></a><a class="docs-heading-anchor-permalink" href="#Reshaping-data-frames-between-tall-and-wide-formats" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="DataFrames.stack" href="#DataFrames.stack"><code>DataFrames.stack</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">stack(df::AbstractDataFrame[, measure_vars[, id_vars] ];
      variable_name=:variable, value_name=:value,
      view::Bool=false, variable_eltype::Type=String)</code></pre><p>Stack a data frame <code>df</code>, i.e. convert it from wide to long format.</p><p>Return the long-format <code>DataFrame</code> with: columns for each of the <code>id_vars</code>, column <code>value_name</code> (<code>:value</code> by default) holding the values of the stacked columns (<code>measure_vars</code>), and column <code>variable_name</code> (<code>:variable</code> by default) a vector holding the name of the corresponding <code>measure_vars</code> variable.</p><p>If <code>view=true</code> then return a stacked view of a data frame (long format). The result is a view because the columns are special <code>AbstractVectors</code> that return views into the original data frame.</p><p><strong>Arguments</strong></p><ul><li><code>df</code> : the AbstractDataFrame to be stacked</li><li><code>measure_vars</code> : the columns to be stacked (the measurement variables), as a column selector (<code>Symbol</code>, string or integer; <code>:</code>, <code>Cols</code>, <code>All</code>, <code>Between</code>, <code>Not</code>, a regular expression, or a vector of <code>Symbol</code>s, strings or integers). If neither <code>measure_vars</code> or <code>id_vars</code> are given, <code>measure_vars</code> defaults to all floating point columns.</li><li><code>id_vars</code> : the identifier columns that are repeated during stacking, as a column selector (<code>Symbol</code>, string or integer; <code>:</code>, <code>Cols</code>, <code>All</code>, <code>Between</code>, <code>Not</code>, a regular expression, or a vector of <code>Symbol</code>s, strings or integers). Defaults to all variables that are not <code>measure_vars</code></li><li><code>variable_name</code> : the name (<code>Symbol</code> or string) of the new stacked column that shall hold the names of each of <code>measure_vars</code></li><li><code>value_name</code> : the name (<code>Symbol</code> or string) of the new stacked column containing the values from each of <code>measure_vars</code></li><li><code>view</code> : whether the stacked data frame should be a view rather than contain freshly allocated vectors.</li><li><code>variable_eltype</code> : determines the element type of column <code>variable_name</code>. By default a <code>PooledArray{String}</code> is created. If <code>variable_eltype=Symbol</code> a <code>PooledVector{Symbol}</code> is created, and if <code>variable_eltype=CategoricalValue{String}</code> a <code>CategoricalArray{String}</code> is produced (call <code>using CategoricalArrays</code> first if needed) Passing any other type <code>T</code> will produce a <code>PooledVector{T}</code> column as long as it supports conversion from <code>String</code>. When <code>view=true</code>, a <code>RepeatedVector{T}</code> is produced.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; df = DataFrame(a=repeat(1:3, inner=2),
                      b=repeat(1:2, inner=3),
                      c=repeat(1:1, inner=6),
                      d=repeat(1:6, inner=1),
                      e=string.(&#39;a&#39;:&#39;f&#39;))
6×5 DataFrame
 Row │ a      b      c      d      e
     │ Int64  Int64  Int64  Int64  String
─────┼────────────────────────────────────
   1 │     1      1      1      1  a
   2 │     1      1      1      2  b
   3 │     2      1      1      3  c
   4 │     2      2      1      4  d
   5 │     3      2      1      5  e
   6 │     3      2      1      6  f

julia&gt; stack(df, [:c, :d])
12×5 DataFrame
 Row │ a      b      e       variable  value
     │ Int64  Int64  String  String    Int64
─────┼───────────────────────────────────────
   1 │     1      1  a       c             1
   2 │     1      1  b       c             1
   3 │     2      1  c       c             1
   4 │     2      2  d       c             1
   5 │     3      2  e       c             1
   6 │     3      2  f       c             1
   7 │     1      1  a       d             1
   8 │     1      1  b       d             2
   9 │     2      1  c       d             3
  10 │     2      2  d       d             4
  11 │     3      2  e       d             5
  12 │     3      2  f       d             6

julia&gt; stack(df, [:c, :d], [:a])
12×3 DataFrame
 Row │ a      variable  value
     │ Int64  String    Int64
─────┼────────────────────────
   1 │     1  c             1
   2 │     1  c             1
   3 │     2  c             1
   4 │     2  c             1
   5 │     3  c             1
   6 │     3  c             1
   7 │     1  d             1
   8 │     1  d             2
   9 │     2  d             3
  10 │     2  d             4
  11 │     3  d             5
  12 │     3  d             6

julia&gt; stack(df, Not([:a, :b, :e]))
12×5 DataFrame
 Row │ a      b      e       variable  value
     │ Int64  Int64  String  String    Int64
─────┼───────────────────────────────────────
   1 │     1      1  a       c             1
   2 │     1      1  b       c             1
   3 │     2      1  c       c             1
   4 │     2      2  d       c             1
   5 │     3      2  e       c             1
   6 │     3      2  f       c             1
   7 │     1      1  a       d             1
   8 │     1      1  b       d             2
   9 │     2      1  c       d             3
  10 │     2      2  d       d             4
  11 │     3      2  e       d             5
  12 │     3      2  f       d             6

julia&gt; stack(df, Not([:a, :b, :e]), variable_name=:somemeasure)
12×5 DataFrame
 Row │ a      b      e       somemeasure  value
     │ Int64  Int64  String  String       Int64
─────┼──────────────────────────────────────────
   1 │     1      1  a       c                1
   2 │     1      1  b       c                1
   3 │     2      1  c       c                1
   4 │     2      2  d       c                1
   5 │     3      2  e       c                1
   6 │     3      2  f       c                1
   7 │     1      1  a       d                1
   8 │     1      1  b       d                2
   9 │     2      1  c       d                3
  10 │     2      2  d       d                4
  11 │     3      2  e       d                5
  12 │     3      2  f       d                6</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/10c5b5e9e7f916024b2f102d040fdd9d4e6bd371/src/abstractdataframe/reshape.jl#L1-L133">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFrames.unstack" href="#DataFrames.unstack"><code>DataFrames.unstack</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">unstack(df::AbstractDataFrame, rowkeys, colkey, value; renamecols::Function=identity,
        allowmissing::Bool=false, allowduplicates::Bool=false, fill=missing)
unstack(df::AbstractDataFrame, colkey, value; renamecols::Function=identity,
        allowmissing::Bool=false, allowduplicates::Bool=false, fill=missing)
unstack(df::AbstractDataFrame; renamecols::Function=identity,
        allowmissing::Bool=false, allowduplicates::Bool=false, fill=missing)</code></pre><p>Unstack data frame <code>df</code>, i.e. convert it from long to wide format.</p><p>Row and column keys will be ordered in the order of their first appearance.</p><p><strong>Positional arguments</strong></p><ul><li><code>df</code> : the AbstractDataFrame to be unstacked</li><li><code>rowkeys</code> : the columns with a unique key for each row, if not given, find a key by grouping on anything not a <code>colkey</code> or <code>value</code>. Can be any column selector (<code>Symbol</code>, string or integer; <code>:</code>, <code>Cols</code>, <code>All</code>, <code>Between</code>, <code>Not</code>, a regular expression, or a vector of <code>Symbol</code>s, strings or integers).</li><li><code>colkey</code> : the column (<code>Symbol</code>, string or integer) holding the column names in wide format, defaults to <code>:variable</code></li><li><code>value</code> : the value column (<code>Symbol</code>, string or integer), defaults to <code>:value</code></li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>renamecols</code>: a function called on each unique value in <code>colkey</code>; it must return the name of the column to be created (typically as a string or a <code>Symbol</code>). Duplicates in resulting names when converted to <code>Symbol</code> are not allowed. By default no transformation is performed.</li><li><code>allowmissing</code>: if <code>false</code> (the default) then an error will be thrown if <code>colkey</code> contains <code>missing</code> values; if <code>true</code> then a column referring to <code>missing</code> value will be created.</li><li><code>allowduplicates</code>: if <code>false</code> (the default) then an error an error will be thrown if combination of <code>rowkeys</code> and <code>colkey</code> contains duplicate entries; if <code>true</code> then  then the last encountered <code>value</code> will be retained.</li><li><code>fill</code>: missing row/column combinations are filled with this value. The default is <code>missing</code>. If the <code>value</code> column is a <code>CategoricalVector</code> and <code>fill</code> is not <code>missing</code> then in order to keep unstacked value columns also <code>CategoricalVector</code> the <code>fill</code> must be passed as <code>CategoricalValue</code></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; wide = DataFrame(id=1:6,
                        a=repeat(1:3, inner=2),
                        b=repeat(1.0:2.0, inner=3),
                        c=repeat(1.0:1.0, inner=6),
                        d=repeat(1.0:3.0, inner=2))
6×5 DataFrame
 Row │ id     a      b        c        d
     │ Int64  Int64  Float64  Float64  Float64
─────┼─────────────────────────────────────────
   1 │     1      1      1.0      1.0      1.0
   2 │     2      1      1.0      1.0      1.0
   3 │     3      2      1.0      1.0      2.0
   4 │     4      2      2.0      1.0      2.0
   5 │     5      3      2.0      1.0      3.0
   6 │     6      3      2.0      1.0      3.0

julia&gt; long = stack(wide)
18×4 DataFrame
 Row │ id     a      variable  value
     │ Int64  Int64  String    Float64
─────┼─────────────────────────────────
   1 │     1      1  b             1.0
   2 │     2      1  b             1.0
   3 │     3      2  b             1.0
   4 │     4      2  b             2.0
   5 │     5      3  b             2.0
   6 │     6      3  b             2.0
   7 │     1      1  c             1.0
   8 │     2      1  c             1.0
  ⋮  │   ⋮      ⋮       ⋮         ⋮
  12 │     6      3  c             1.0
  13 │     1      1  d             1.0
  14 │     2      1  d             1.0
  15 │     3      2  d             2.0
  16 │     4      2  d             2.0
  17 │     5      3  d             3.0
  18 │     6      3  d             3.0
                         3 rows omitted

julia&gt; unstack(long)
6×5 DataFrame
 Row │ id     a      b         c         d
     │ Int64  Int64  Float64?  Float64?  Float64?
─────┼────────────────────────────────────────────
   1 │     1      1       1.0       1.0       1.0
   2 │     2      1       1.0       1.0       1.0
   3 │     3      2       1.0       1.0       2.0
   4 │     4      2       2.0       1.0       2.0
   5 │     5      3       2.0       1.0       3.0
   6 │     6      3       2.0       1.0       3.0

julia&gt; unstack(long, :variable, :value)
6×5 DataFrame
 Row │ id     a      b         c         d
     │ Int64  Int64  Float64?  Float64?  Float64?
─────┼────────────────────────────────────────────
   1 │     1      1       1.0       1.0       1.0
   2 │     2      1       1.0       1.0       1.0
   3 │     3      2       1.0       1.0       2.0
   4 │     4      2       2.0       1.0       2.0
   5 │     5      3       2.0       1.0       3.0
   6 │     6      3       2.0       1.0       3.0

julia&gt; unstack(long, :id, :variable, :value)
6×4 DataFrame
 Row │ id     b         c         d
     │ Int64  Float64?  Float64?  Float64?
─────┼─────────────────────────────────────
   1 │     1       1.0       1.0       1.0
   2 │     2       1.0       1.0       1.0
   3 │     3       1.0       1.0       2.0
   4 │     4       2.0       1.0       2.0
   5 │     5       2.0       1.0       3.0
   6 │     6       2.0       1.0       3.0

julia&gt; unstack(long, [:id, :a], :variable, :value)
6×5 DataFrame
 Row │ id     a      b         c         d
     │ Int64  Int64  Float64?  Float64?  Float64?
─────┼────────────────────────────────────────────
   1 │     1      1       1.0       1.0       1.0
   2 │     2      1       1.0       1.0       1.0
   3 │     3      2       1.0       1.0       2.0
   4 │     4      2       2.0       1.0       2.0
   5 │     5      3       2.0       1.0       3.0
   6 │     6      3       2.0       1.0       3.0

julia&gt; unstack(long, :id, :variable, :value, renamecols=x-&gt;Symbol(:_, x))
6×4 DataFrame
 Row │ id     _b        _c        _d
     │ Int64  Float64?  Float64?  Float64?
─────┼─────────────────────────────────────
   1 │     1       1.0       1.0       1.0
   2 │     2       1.0       1.0       1.0
   3 │     3       1.0       1.0       2.0
   4 │     4       2.0       1.0       2.0
   5 │     5       2.0       1.0       3.0
   6 │     6       2.0       1.0       3.0

julia&gt; df = DataFrame(id=[&quot;1&quot;, &quot;1&quot;, &quot;2&quot;],
                      variable=[&quot;Var1&quot;, &quot;Var2&quot;, &quot;Var1&quot;],
                      value=[1, 2, 3])
3×3 DataFrame
 Row │ id      variable  value
     │ String  String    Int64
─────┼─────────────────────────
   1 │ 1       Var1          1
   2 │ 1       Var2          2
   3 │ 2       Var1          3

julia&gt; unstack(df, :variable, :value, fill=0)
2×3 DataFrame
 Row │ id      Var1   Var2
     │ String  Int64  Int64
─────┼──────────────────────
   1 │ 1           1      2
   2 │ 2           3      0</code></pre><p>Note that there are some differences between the widened results above.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/10c5b5e9e7f916024b2f102d040fdd9d4e6bd371/src/abstractdataframe/reshape.jl#L199-L359">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.permutedims" href="#Base.permutedims"><code>Base.permutedims</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">permutedims(df::AbstractDataFrame, src_namescol::Union{Int, Symbol, AbstractString},
            [dest_namescol::Union{Symbol, AbstractString}];
            makeunique::Bool=false)</code></pre><p>Turn <code>df</code> on its side such that rows become columns and values in the column indexed by <code>src_namescol</code> become the names of new columns. In the resulting <code>DataFrame</code>, column names of <code>df</code> will become the first column with name specified by <code>dest_namescol</code>.</p><p><strong>Arguments</strong></p><ul><li><code>df</code> : the <code>AbstractDataFrame</code></li><li><code>src_namescol</code> : the column that will become the new header. This column&#39;s element type must be <code>AbstractString</code> or <code>Symbol</code>.</li><li><code>dest_namescol</code> : the name of the first column in the returned <code>DataFrame</code>. Defaults to the same name as <code>src_namescol</code>.</li><li><code>makeunique</code> : if <code>false</code> (the default), an error will be raised if duplicate names are found; if <code>true</code>, duplicate names will be suffixed with <code>_i</code> (<code>i</code> starting at 1 for the first duplicate).</li></ul><p>Note: The element types of columns in resulting <code>DataFrame</code> (other than the first column, which always has element type <code>String</code>) will depend on the element types of <em>all</em> input columns based on the result of <code>promote_type</code>. That is, if the source data frame contains <code>Int</code> and <code>Float64</code> columns, resulting columns will have element type <code>Float64</code>. If the source has <code>Int</code> and <code>String</code> columns, resulting columns will have element type <code>Any</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; df1 = DataFrame(a=[&quot;x&quot;, &quot;y&quot;], b=[1.0, 2.0], c=[3, 4], d=[true, false])
2×4 DataFrame
 Row │ a       b        c      d
     │ String  Float64  Int64  Bool
─────┼───────────────────────────────
   1 │ x           1.0      3   true
   2 │ y           2.0      4  false

julia&gt; permutedims(df1, 1) # note the column types
3×3 DataFrame
 Row │ a       x        y
     │ String  Float64  Float64
─────┼──────────────────────────
   1 │ b           1.0      2.0
   2 │ c           3.0      4.0
   3 │ d           1.0      0.0

julia&gt; df2 = DataFrame(a=[&quot;x&quot;, &quot;y&quot;], b=[1, &quot;two&quot;], c=[3, 4], d=[true, false])
2×4 DataFrame
 Row │ a       b    c      d
     │ String  Any  Int64  Bool
─────┼───────────────────────────
   1 │ x       1        3   true
   2 │ y       two      4  false

julia&gt; permutedims(df2, 1, &quot;different_name&quot;)
3×3 DataFrame
 Row │ different_name  x     y
     │ String          Any   Any
─────┼─────────────────────────────
   1 │ b               1     two
   2 │ c               3     4
   3 │ d               true  false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/10c5b5e9e7f916024b2f102d040fdd9d4e6bd371/src/abstractdataframe/reshape.jl#L572-L637">source</a></section></article><h2 id="Sorting"><a class="docs-heading-anchor" href="#Sorting">Sorting</a><a id="Sorting-1"></a><a class="docs-heading-anchor-permalink" href="#Sorting" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Base.issorted" href="#Base.issorted"><code>Base.issorted</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">issorted(df::AbstractDataFrame, cols=All();
         lt::Union{Function, AbstractVector{&lt;:Function}}=isless,
         by::Union{Function, AbstractVector{&lt;:Function}}=identity,
         rev::Union{Bool, AbstractVector{Bool}}=false,
         order::Union{Ordering, AbstractVector{&lt;:Ordering}}=Forward)</code></pre><p>Test whether data frame <code>df</code> sorted by column(s) <code>cols</code>. Checking against multiple columns is done lexicographically.</p><p><code>cols</code> can be any column selector (<code>Symbol</code>, string or integer; <code>:</code>, <code>Cols</code>, <code>All</code>, <code>Between</code>, <code>Not</code>, a regular expression, or a vector of <code>Symbol</code>s, strings or integers). If <code>cols</code> selects no columns, check whether <code>df</code> is sorted on all columns (this behaviour is deprecated and will change in future versions).</p><p>If <code>rev</code> is <code>true</code>, reverse sorting is performed. To enable reverse sorting only for some columns, pass <code>order(c, rev=true)</code> in <code>cols</code>, with <code>c</code> the corresponding column index (see example below).</p><p>The <code>by</code> keyword allows providing a function that will be applied to each cell before comparison; the <code>lt</code> keyword allows providing a custom &quot;less than&quot; function. If both <code>by</code> and <code>lt</code> are specified, the <code>lt</code> function is applied to the result of the <code>by</code> function.</p><p>All the keyword arguments can be either a single value, which is applied to all columns, or a vector of length equal to the number of columns that the operation is performed on. In such a case each entry is used for the column in the corresponding position in <code>cols</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; df = DataFrame(a=[1, 2, 3, 4], b=[4, 3, 2, 1])
4×2 DataFrame
 Row │ a      b
     │ Int64  Int64
─────┼──────────────
   1 │     1      4
   2 │     2      3
   3 │     3      2
   4 │     4      1

julia&gt; issorted(df)
true

julia&gt; issorted(df, :a)
true

julia&gt; issorted(df, :b)
false

julia&gt; issorted(df, :b, rev=true)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/10c5b5e9e7f916024b2f102d040fdd9d4e6bd371/src/abstractdataframe/sort.jl#L353-L393">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFrames.order" href="#DataFrames.order"><code>DataFrames.order</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">order(col::ColumnIndex; kwargs...)</code></pre><p>Specify sorting order for a column <code>col</code> in a data frame. <code>kwargs</code> can be <code>lt</code>, <code>by</code>, <code>rev</code>, and <code>order</code> with values following the rules defined in <a href="#Base.sort!"><code>sort!</code></a>.</p><p>See also: <a href="#Base.sort!"><code>sort!</code></a>, <a href="#Base.sort"><code>sort</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; df = DataFrame(x=[-3, -1, 0, 2, 4], y=1:5)
5×2 DataFrame
 Row │ x      y
     │ Int64  Int64
─────┼──────────────
   1 │    -3      1
   2 │    -1      2
   3 │     0      3
   4 │     2      4
   5 │     4      5

julia&gt; sort(df, order(:x, rev=true))
5×2 DataFrame
 Row │ x      y
     │ Int64  Int64
─────┼──────────────
   1 │     4      5
   2 │     2      4
   3 │     0      3
   4 │    -1      2
   5 │    -3      1

julia&gt; sort(df, order(:x, by=abs))
5×2 DataFrame
 Row │ x      y
     │ Int64  Int64
─────┼──────────────
   1 │     0      3
   2 │    -1      2
   3 │     2      4
   4 │    -3      1
   5 │     4      5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/10c5b5e9e7f916024b2f102d040fdd9d4e6bd371/src/abstractdataframe/sort.jl#L22-L66">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.sort" href="#Base.sort"><code>Base.sort</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">sort(df::AbstractDataFrame, cols=All();
     alg::Union{Algorithm, Nothing}=nothing,
     lt::Union{Function, AbstractVector{&lt;:Function}}=isless,
     by::Union{Function, AbstractVector{&lt;:Function}}=identity,
     rev::Union{Bool, AbstractVector{Bool}}=false,
     order::Union{Ordering, AbstractVector{&lt;:Ordering}}=Forward,
     view::Bool=false)</code></pre><p>Return a data frame containing the rows in <code>df</code> sorted by column(s) <code>cols</code>. Sorting on multiple columns is done lexicographically.</p><p><code>cols</code> can be any column selector (<code>Symbol</code>, string or integer; <code>:</code>, <code>Cols</code>, <code>All</code>, <code>Between</code>, <code>Not</code>, a regular expression, or a vector of <code>Symbol</code>s, strings or integers). If <code>cols</code> selects no columns, sort <code>df</code> on all columns (this behaviour is deprecated and will change in future versions).</p><p>If <code>rev</code> is <code>true</code>, reverse sorting is performed. To enable reverse sorting only for some columns, pass <code>order(c, rev=true)</code> in <code>cols</code>, with <code>c</code> the corresponding column index (see example below).</p><p>The <code>by</code> keyword allows providing a function that will be applied to each cell before comparison; the <code>lt</code> keyword allows providing a custom &quot;less than&quot; function. If both <code>by</code> and <code>lt</code> are specified, the <code>lt</code> function is applied to the result of the <code>by</code> function.</p><p>All the keyword arguments can be either a single value, which is applied to all columns, or a vector of length equal to the number of columns that the operation is performed on. In such a case each entry is used for the column in the corresponding position in <code>cols</code>.</p><p>If <code>alg</code> is <code>nothing</code> (the default), the most appropriate algorithm is chosen automatically among <code>TimSort</code>, <code>MergeSort</code> and <code>RadixSort</code> depending on the type of the sorting columns and on the number of rows in <code>df</code>.</p><p>If <code>view=false</code> a freshly allocated <code>DataFrame</code> is returned. If <code>view=true</code> then a <code>SubDataFrame</code> view into <code>df</code> is returned.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; df = DataFrame(x=[3, 1, 2, 1], y=[&quot;b&quot;, &quot;c&quot;, &quot;a&quot;, &quot;b&quot;])
4×2 DataFrame
 Row │ x      y
     │ Int64  String
─────┼───────────────
   1 │     3  b
   2 │     1  c
   3 │     2  a
   4 │     1  b

julia&gt; sort(df, :x)
4×2 DataFrame
 Row │ x      y
     │ Int64  String
─────┼───────────────
   1 │     1  c
   2 │     1  b
   3 │     2  a
   4 │     3  b

julia&gt; sort(df, [:x, :y])
4×2 DataFrame
 Row │ x      y
     │ Int64  String
─────┼───────────────
   1 │     1  b
   2 │     1  c
   3 │     2  a
   4 │     3  b

julia&gt; sort(df, [:x, :y], rev=true)
4×2 DataFrame
 Row │ x      y
     │ Int64  String
─────┼───────────────
   1 │     3  b
   2 │     2  a
   3 │     1  c
   4 │     1  b

julia&gt; sort(df, [:x, order(:y, rev=true)])
4×2 DataFrame
 Row │ x      y
     │ Int64  String
─────┼───────────────
   1 │     1  c
   2 │     1  b
   3 │     2  a
   4 │     3  b</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/10c5b5e9e7f916024b2f102d040fdd9d4e6bd371/src/abstractdataframe/sort.jl#L417-L494">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.sort!" href="#Base.sort!"><code>Base.sort!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">sort!(df::AbstractDataFrame, cols=All();
      alg::Union{Algorithm, Nothing}=nothing,
      lt::Union{Function, AbstractVector{&lt;:Function}}=isless,
      by::Union{Function, AbstractVector{&lt;:Function}}=identity,
      rev::Union{Bool, AbstractVector{Bool}}=false,
      order::Union{Ordering, AbstractVector{&lt;:Ordering}}=Forward)</code></pre><p>Sort data frame <code>df</code> by column(s) <code>cols</code>. Sorting on multiple columns is done lexicographicallly.</p><p><code>cols</code> can be any column selector (<code>Symbol</code>, string or integer; <code>:</code>, <code>Cols</code>, <code>All</code>, <code>Between</code>, <code>Not</code>, a regular expression, or a vector of <code>Symbol</code>s, strings or integers). If <code>cols</code> selects no columns, sort <code>df</code> on all columns (this behaviour is deprecated and will change in future versions).</p><p>If <code>rev</code> is <code>true</code>, reverse sorting is performed. To enable reverse sorting only for some columns, pass <code>order(c, rev=true)</code> in <code>cols</code>, with <code>c</code> the corresponding column index (see example below).</p><p>The <code>by</code> keyword allows providing a function that will be applied to each cell before comparison; the <code>lt</code> keyword allows providing a custom &quot;less than&quot; function. If both <code>by</code> and <code>lt</code> are specified, the <code>lt</code> function is applied to the result of the <code>by</code> function.</p><p>All the keyword arguments can be either a single value, which is applied to all columns, or a vector of length equal to the number of columns that the operation is performed on. In such a case each entry is used for the column in the corresponding position in <code>cols</code>.</p><p>If <code>alg</code> is <code>nothing</code> (the default), the most appropriate algorithm is chosen automatically among <code>TimSort</code>, <code>MergeSort</code> and <code>RadixSort</code> depending on the type of the sorting columns and on the number of rows in <code>df</code>.</p><p><code>sort!</code> will produce a correct result even if some columns of passed data frame are identical (checked with <code>===</code>). Otherwise, if two columns share some part of memory but are not identical (e.g. are different views of the same parent vector) then <code>sort!</code> result might be incorrect.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; df = DataFrame(x=[3, 1, 2, 1], y=[&quot;b&quot;, &quot;c&quot;, &quot;a&quot;, &quot;b&quot;])
4×2 DataFrame
 Row │ x      y
     │ Int64  String
─────┼───────────────
   1 │     3  b
   2 │     1  c
   3 │     2  a
   4 │     1  b

julia&gt; sort!(df, :x)
4×2 DataFrame
 Row │ x      y
     │ Int64  String
─────┼───────────────
   1 │     1  c
   2 │     1  b
   3 │     2  a
   4 │     3  b

julia&gt; sort!(df, [:x, :y])
4×2 DataFrame
 Row │ x      y
     │ Int64  String
─────┼───────────────
   1 │     1  b
   2 │     1  c
   3 │     2  a
   4 │     3  b

julia&gt; sort!(df, [:x, :y], rev=true)
4×2 DataFrame
 Row │ x      y
     │ Int64  String
─────┼───────────────
   1 │     3  b
   2 │     2  a
   3 │     1  c
   4 │     1  b

julia&gt; sort!(df, [:x, order(:y, rev=true)])
4×2 DataFrame
 Row │ x      y
     │ Int64  String
─────┼───────────────
   1 │     1  c
   2 │     1  b
   3 │     2  a
   4 │     3  b</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/10c5b5e9e7f916024b2f102d040fdd9d4e6bd371/src/abstractdataframe/sort.jl#L590-L668">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.sortperm" href="#Base.sortperm"><code>Base.sortperm</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">sortperm(df::AbstractDataFrame, cols=All();
         alg::Union{Algorithm, Nothing}=nothing,
         lt::Union{Function, AbstractVector{&lt;:Function}}=isless,
         by::Union{Function, AbstractVector{&lt;:Function}}=identity,
         rev::Union{Bool, AbstractVector{Bool}}=false,
         order::Union{Ordering, AbstractVector{&lt;:Ordering}}=Forward)</code></pre><p>Return a permutation vector of row indices of data frame <code>df</code> that puts them in sorted order according to column(s) <code>cols</code>. Order on multiple columns is computed lexicographically.</p><p><code>cols</code> can be any column selector (<code>Symbol</code>, string or integer; <code>:</code>, <code>Cols</code>, <code>All</code>, <code>Between</code>, <code>Not</code>, a regular expression, or a vector of <code>Symbol</code>s, strings or integers). If <code>cols</code> selects no columns, return permutation vector based on sorting all columns (this behaviour is deprecated and will change in future versions).</p><p>If <code>rev</code> is <code>true</code>, reverse sorting is performed. To enable reverse sorting only for some columns, pass <code>order(c, rev=true)</code> in <code>cols</code>, with <code>c</code> the corresponding column index (see example below).</p><p>The <code>by</code> keyword allows providing a function that will be applied to each cell before comparison; the <code>lt</code> keyword allows providing a custom &quot;less than&quot; function. If both <code>by</code> and <code>lt</code> are specified, the <code>lt</code> function is applied to the result of the <code>by</code> function.</p><p>All the keyword arguments can be either a single value, which is applied to all columns, or a vector of length equal to the number of columns that the operation is performed on. In such a case each entry is used for the column in the corresponding position in <code>cols</code>.</p><p>If <code>alg</code> is <code>nothing</code> (the default), the most appropriate algorithm is chosen automatically among <code>TimSort</code>, <code>MergeSort</code> and <code>RadixSort</code> depending on the type of the sorting columns and on the number of rows in <code>df</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; df = DataFrame(x=[3, 1, 2, 1], y=[&quot;b&quot;, &quot;c&quot;, &quot;a&quot;, &quot;b&quot;])
4×2 DataFrame
 Row │ x      y
     │ Int64  String
─────┼───────────────
   1 │     3  b
   2 │     1  c
   3 │     2  a
   4 │     1  b

julia&gt; sortperm(df, :x)
4-element Vector{Int64}:
 2
 4
 3
 1

julia&gt; sortperm(df, [:x, :y])
4-element Vector{Int64}:
 4
 2
 3
 1

julia&gt; sortperm(df, [:x, :y], rev=true)
4-element Vector{Int64}:
 1
 3
 2
 4

julia&gt; sortperm(df, [:x, order(:y, rev=true)])
4-element Vector{Int64}:
 2
 4
 3
 1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/10c5b5e9e7f916024b2f102d040fdd9d4e6bd371/src/abstractdataframe/sort.jl#L506-L568">source</a></section></article><h2 id="Joining"><a class="docs-heading-anchor" href="#Joining">Joining</a><a id="Joining-1"></a><a class="docs-heading-anchor-permalink" href="#Joining" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="DataAPI.antijoin" href="#DataAPI.antijoin"><code>DataAPI.antijoin</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">antijoin(df1, df2; on, makeunique=false, validate=(false, false), matchmissing=:error)</code></pre><p>Perform an anti join of two data frame objects and return a <code>DataFrame</code> containing the result. An anti join returns the subset of rows of <code>df1</code> that do not match with the keys in <code>df2</code>.</p><p>The order of rows in the result is undefined and may change in the future releases.</p><p><strong>Arguments</strong></p><ul><li><code>df1</code>, <code>df2</code>: the <code>AbstractDataFrames</code> to be joined</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>on</code> : A column name to join <code>df1</code> and <code>df2</code> on. If the columns on which <code>df1</code> and <code>df2</code> will be joined have different names, then a <code>left=&gt;right</code> pair can be passed. It is also allowed to perform a join on multiple columns, in which case a vector of column names or column name pairs can be passed (mixing names and pairs is allowed).</li><li><code>makeunique</code> : if <code>false</code> (the default), an error will be raised if duplicate names are found in columns not joined on; if <code>true</code>, duplicate names will be suffixed with <code>_i</code> (<code>i</code> starting at 1 for the first duplicate).</li><li><code>validate</code> : whether to check that columns passed as the <code>on</code> argument  define unique keys in each input data frame (according to <code>isequal</code>).  Can be a tuple or a pair, with the first element indicating whether to  run check for <code>df1</code> and the second element for <code>df2</code>.  By default no check is performed.</li><li><code>matchmissing</code> : if equal to <code>:error</code> throw an error if <code>missing</code> is present in <code>on</code> columns; if equal to <code>:equal</code> then <code>missing</code> is allowed and missings are matched; if equal to <code>:notequal</code> then missings are dropped in <code>df2</code> <code>on</code> columns; <code>isequal</code> is used for comparisons of rows for equality</li></ul><p>It is not allowed to join on columns that contain <code>NaN</code> or <code>-0.0</code> in real or imaginary part of the number. If you need to perform a join on such values use CategoricalArrays.jl and transform a column containing such values into a <code>CategoricalVector</code>.</p><p>When merging <code>on</code> categorical columns that differ in the ordering of their levels, the ordering of the left data frame takes precedence over the ordering of the right data frame.</p><p>See also: <a href="#DataAPI.innerjoin"><code>innerjoin</code></a>, <a href="#DataAPI.leftjoin"><code>leftjoin</code></a>, <a href="#DataAPI.rightjoin"><code>rightjoin</code></a>,           <a href="#DataAPI.outerjoin"><code>outerjoin</code></a>, <a href="#DataAPI.semijoin"><code>semijoin</code></a>, <a href="#DataAPI.crossjoin"><code>crossjoin</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; name = DataFrame(ID=[1, 2, 3], Name=[&quot;John Doe&quot;, &quot;Jane Doe&quot;, &quot;Joe Blogs&quot;])
3×2 DataFrame
 Row │ ID     Name
     │ Int64  String
─────┼──────────────────
   1 │     1  John Doe
   2 │     2  Jane Doe
   3 │     3  Joe Blogs

julia&gt; job = DataFrame(ID=[1, 2, 4], Job=[&quot;Lawyer&quot;, &quot;Doctor&quot;, &quot;Farmer&quot;])
3×2 DataFrame
 Row │ ID     Job
     │ Int64  String
─────┼───────────────
   1 │     1  Lawyer
   2 │     2  Doctor
   3 │     4  Farmer

julia&gt; antijoin(name, job, on = :ID)
1×2 DataFrame
 Row │ ID     Name
     │ Int64  String
─────┼──────────────────
   1 │     3  Joe Blogs

julia&gt; job2 = DataFrame(identifier=[1, 2, 4], Job=[&quot;Lawyer&quot;, &quot;Doctor&quot;, &quot;Farmer&quot;])
3×2 DataFrame
 Row │ identifier  Job
     │ Int64       String
─────┼────────────────────
   1 │          1  Lawyer
   2 │          2  Doctor
   3 │          4  Farmer

julia&gt; antijoin(name, job2, on = :ID =&gt; :identifier)
1×2 DataFrame
 Row │ ID     Name
     │ Int64  String
─────┼──────────────────
   1 │     3  Joe Blogs

julia&gt; antijoin(name, job2, on = [:ID =&gt; :identifier])
1×2 DataFrame
 Row │ ID     Name
     │ Int64  String
─────┼──────────────────
   1 │     3  Joe Blogs</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/10c5b5e9e7f916024b2f102d040fdd9d4e6bd371/src/join/composer.jl#L1161-L1255">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataAPI.crossjoin" href="#DataAPI.crossjoin"><code>DataAPI.crossjoin</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">crossjoin(df1, df2, dfs...; makeunique = false)</code></pre><p>Perform a cross join of two or more data frame objects and return a <code>DataFrame</code> containing the result. A cross join returns the cartesian product of rows from all passed data frames, where the first passed data frame is assigned to the dimension that changes the slowest and the last data frame is assigned to the dimension that changes the fastest.</p><p><strong>Arguments</strong></p><ul><li><code>df1</code>, <code>df2</code>, <code>dfs...</code> : the <code>AbstractDataFrames</code> to be joined</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>makeunique</code> : if <code>false</code> (the default), an error will be raised if duplicate names are found in columns not joined on; if <code>true</code>, duplicate names will be suffixed with <code>_i</code> (<code>i</code> starting at 1 for the first duplicate).</li></ul><p>If more than two data frames are passed, the join is performed recursively with left associativity.</p><p>See also: <a href="#DataAPI.innerjoin"><code>innerjoin</code></a>, <a href="#DataAPI.leftjoin"><code>leftjoin</code></a>, <a href="#DataAPI.rightjoin"><code>rightjoin</code></a>,           <a href="#DataAPI.outerjoin"><code>outerjoin</code></a>, <a href="#DataAPI.semijoin"><code>semijoin</code></a>, <a href="#DataAPI.antijoin"><code>antijoin</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; df1 = DataFrame(X=1:3)
3×1 DataFrame
 Row │ X
     │ Int64
─────┼───────
   1 │     1
   2 │     2
   3 │     3

julia&gt; df2 = DataFrame(Y=[&quot;a&quot;, &quot;b&quot;])
2×1 DataFrame
 Row │ Y
     │ String
─────┼────────
   1 │ a
   2 │ b

julia&gt; crossjoin(df1, df2)
6×2 DataFrame
 Row │ X      Y
     │ Int64  String
─────┼───────────────
   1 │     1  a
   2 │     1  b
   3 │     2  a
   4 │     2  b
   5 │     3  a
   6 │     3  b</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/10c5b5e9e7f916024b2f102d040fdd9d4e6bd371/src/join/composer.jl#L1265-L1320">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataAPI.innerjoin" href="#DataAPI.innerjoin"><code>DataAPI.innerjoin</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">innerjoin(df1, df2; on, makeunique=false, validate=(false, false),
          renamecols=(identity =&gt; identity), matchmissing=:error)
innerjoin(df1, df2, dfs...; on, makeunique=false,
          validate=(false, false), matchmissing=:error)</code></pre><p>Perform an inner join of two or more data frame objects and return a <code>DataFrame</code> containing the result. An inner join includes rows with keys that match in all passed data frames.</p><p>The order of rows in the result is undefined and may change in the future releases.</p><p>In the returned data frame the type of the columns on which the data frames are joined is determined by the type of these columns in <code>df1</code>. This behavior may change in future releases.</p><p><strong>Arguments</strong></p><ul><li><code>df1</code>, <code>df2</code>, <code>dfs...</code>: the <code>AbstractDataFrames</code> to be joined</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>on</code> : A column name to join <code>df1</code> and <code>df2</code> on. If the columns on which <code>df1</code> and <code>df2</code> will be joined have different names, then a <code>left=&gt;right</code> pair can be passed. It is also allowed to perform a join on multiple columns, in which case a vector of column names or column name pairs can be passed (mixing names and pairs is allowed). If more than two data frames are joined then only a column name or a vector of column names are allowed. <code>on</code> is a required argument.</li><li><code>makeunique</code> : if <code>false</code> (the default), an error will be raised if duplicate names are found in columns not joined on; if <code>true</code>, duplicate names will be suffixed with <code>_i</code> (<code>i</code> starting at 1 for the first duplicate).</li><li><code>validate</code> : whether to check that columns passed as the <code>on</code> argument define unique keys in each input data frame (according to <code>isequal</code>). Can be a tuple or a pair, with the first element indicating whether to run check for <code>df1</code> and the second element for <code>df2</code>. By default no check is performed.</li><li><code>renamecols</code> : a <code>Pair</code> specifying how columns of left and right data frames should be renamed in the resulting data frame. Each element of the pair can be a string or a <code>Symbol</code> can be passed in which case it is appended to the original column name; alternatively a function can be passed in which case it is applied to each column name, which is passed to it as a <code>String</code>. Note that <code>renamecols</code> does not affect <code>on</code> columns, whose names are always taken from the left data frame and left unchanged.</li><li><code>matchmissing</code> : if equal to <code>:error</code> throw an error if <code>missing</code> is present in <code>on</code> columns; if equal to <code>:equal</code> then <code>missing</code> is allowed and missings are matched; if equal to <code>:notequal</code> then missings are dropped in <code>df1</code> and <code>df2</code> <code>on</code> columns; <code>isequal</code> is used for comparisons of rows for equality</li></ul><p>It is not allowed to join on columns that contain <code>NaN</code> or <code>-0.0</code> in real or imaginary part of the number. If you need to perform a join on such values use CategoricalArrays.jl and transform a column containing such values into a <code>CategoricalVector</code>.</p><p>When merging <code>on</code> categorical columns that differ in the ordering of their levels, the ordering of the left data frame takes precedence over the ordering of the right data frame.</p><p>If more than two data frames are passed, the join is performed recursively with left associativity. In this case the <code>validate</code> keyword argument is applied recursively with left associativity.</p><p>See also: <a href="#DataAPI.leftjoin"><code>leftjoin</code></a>, <a href="#DataAPI.rightjoin"><code>rightjoin</code></a>, <a href="#DataAPI.outerjoin"><code>outerjoin</code></a>,           <a href="#DataAPI.semijoin"><code>semijoin</code></a>, <a href="#DataAPI.antijoin"><code>antijoin</code></a>, <a href="#DataAPI.crossjoin"><code>crossjoin</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; name = DataFrame(ID=[1, 2, 3], Name=[&quot;John Doe&quot;, &quot;Jane Doe&quot;, &quot;Joe Blogs&quot;])
3×2 DataFrame
 Row │ ID     Name
     │ Int64  String
─────┼──────────────────
   1 │     1  John Doe
   2 │     2  Jane Doe
   3 │     3  Joe Blogs

julia&gt; job = DataFrame(ID=[1, 2, 4], Job=[&quot;Lawyer&quot;, &quot;Doctor&quot;, &quot;Farmer&quot;])
3×2 DataFrame
 Row │ ID     Job
     │ Int64  String
─────┼───────────────
   1 │     1  Lawyer
   2 │     2  Doctor
   3 │     4  Farmer

julia&gt; innerjoin(name, job, on = :ID)
2×3 DataFrame
 Row │ ID     Name      Job
     │ Int64  String    String
─────┼─────────────────────────
   1 │     1  John Doe  Lawyer
   2 │     2  Jane Doe  Doctor

julia&gt; job2 = DataFrame(identifier=[1, 2, 4], Job=[&quot;Lawyer&quot;, &quot;Doctor&quot;, &quot;Farmer&quot;])
3×2 DataFrame
 Row │ identifier  Job
     │ Int64       String
─────┼────────────────────
   1 │          1  Lawyer
   2 │          2  Doctor
   3 │          4  Farmer

julia&gt; innerjoin(name, job2, on = :ID =&gt; :identifier, renamecols = &quot;_left&quot; =&gt; &quot;_right&quot;)
2×3 DataFrame
 Row │ ID     Name_left  Job_right
     │ Int64  String     String
─────┼─────────────────────────────
   1 │     1  John Doe   Lawyer
   2 │     2  Jane Doe   Doctor

julia&gt; innerjoin(name, job2, on = [:ID =&gt; :identifier], renamecols = uppercase =&gt; lowercase)
2×3 DataFrame
 Row │ ID     NAME      job
     │ Int64  String    String
─────┼─────────────────────────
   1 │     1  John Doe  Lawyer
   2 │     2  Jane Doe  Doctor</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/10c5b5e9e7f916024b2f102d040fdd9d4e6bd371/src/join/composer.jl#L448-L565">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataAPI.leftjoin" href="#DataAPI.leftjoin"><code>DataAPI.leftjoin</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">leftjoin(df1, df2; on, makeunique=false, source=nothing, validate=(false, false),
         renamecols=(identity =&gt; identity), matchmissing=:error)</code></pre><p>Perform a left join of two data frame objects and return a <code>DataFrame</code> containing the result. A left join includes all rows from <code>df1</code>.</p><p>The order of rows in the result is undefined and may change in the future releases.</p><p>In the returned data frame the type of the columns on which the data frames are joined is determined by the type of these columns in <code>df1</code>. This behavior may change in future releases.</p><p><strong>Arguments</strong></p><ul><li><code>df1</code>, <code>df2</code>: the <code>AbstractDataFrames</code> to be joined</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>on</code> : A column name to join <code>df1</code> and <code>df2</code> on. If the columns on which <code>df1</code> and <code>df2</code> will be joined have different names, then a <code>left=&gt;right</code> pair can be passed. It is also allowed to perform a join on multiple columns, in which case a vector of column names or column name pairs can be passed (mixing names and pairs is allowed).</li><li><code>makeunique</code> : if <code>false</code> (the default), an error will be raised if duplicate names are found in columns not joined on; if <code>true</code>, duplicate names will be suffixed with <code>_i</code> (<code>i</code> starting at 1 for the first duplicate).</li><li><code>source</code> : Default: <code>nothing</code>. If a <code>Symbol</code> or string, adds indicator column with the given name, for whether a row appeared in only <code>df1</code> (<code>&quot;left_only&quot;</code>) or in both (<code>&quot;both&quot;</code>). If the name is already in use, the column name will be modified if <code>makeunique=true</code>.</li><li><code>validate</code> : whether to check that columns passed as the <code>on</code> argument define unique keys in each input data frame (according to <code>isequal</code>). Can be a tuple or a pair, with the first element indicating whether to run check for <code>df1</code> and the second element for <code>df2</code>. By default no check is performed.</li><li><code>renamecols</code> : a <code>Pair</code> specifying how columns of left and right data frames should be renamed in the resulting data frame. Each element of the pair can be a string or a <code>Symbol</code> can be passed in which case it is appended to the original column name; alternatively a function can be passed in which case it is applied to each column name, which is passed to it as a <code>String</code>. Note that <code>renamecols</code> does not affect <code>on</code> columns, whose names are always taken from the left data frame and left unchanged.</li><li><code>matchmissing</code> : if equal to <code>:error</code> throw an error if <code>missing</code> is present in <code>on</code> columns; if equal to <code>:equal</code> then <code>missing</code> is allowed and missings are matched; if equal to <code>:notequal</code> then missings are dropped in <code>df2</code> <code>on</code> columns; <code>isequal</code> is used for comparisons of rows for equality</li></ul><p>All columns of the returned data frame will support missing values.</p><p>It is not allowed to join on columns that contain <code>NaN</code> or <code>-0.0</code> in real or imaginary part of the number. If you need to perform a join on such values use CategoricalArrays.jl and transform a column containing such values into a <code>CategoricalVector</code>.</p><p>When merging <code>on</code> categorical columns that differ in the ordering of their levels, the ordering of the left data frame takes precedence over the ordering of the right data frame.</p><p>See also: <a href="#DataAPI.innerjoin"><code>innerjoin</code></a>, <a href="#DataAPI.rightjoin"><code>rightjoin</code></a>, <a href="#DataAPI.outerjoin"><code>outerjoin</code></a>,           <a href="#DataAPI.semijoin"><code>semijoin</code></a>, <a href="#DataAPI.antijoin"><code>antijoin</code></a>, <a href="#DataAPI.crossjoin"><code>crossjoin</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; name = DataFrame(ID=[1, 2, 3], Name=[&quot;John Doe&quot;, &quot;Jane Doe&quot;, &quot;Joe Blogs&quot;])
3×2 DataFrame
 Row │ ID     Name
     │ Int64  String
─────┼──────────────────
   1 │     1  John Doe
   2 │     2  Jane Doe
   3 │     3  Joe Blogs

julia&gt; job = DataFrame(ID=[1, 2, 4], Job=[&quot;Lawyer&quot;, &quot;Doctor&quot;, &quot;Farmer&quot;])
3×2 DataFrame
 Row │ ID     Job
     │ Int64  String
─────┼───────────────
   1 │     1  Lawyer
   2 │     2  Doctor
   3 │     4  Farmer

julia&gt; leftjoin(name, job, on = :ID)
3×3 DataFrame
 Row │ ID     Name       Job
     │ Int64  String     String?
─────┼───────────────────────────
   1 │     1  John Doe   Lawyer
   2 │     2  Jane Doe   Doctor
   3 │     3  Joe Blogs  missing

julia&gt; job2 = DataFrame(identifier=[1, 2, 4], Job=[&quot;Lawyer&quot;, &quot;Doctor&quot;, &quot;Farmer&quot;])
3×2 DataFrame
 Row │ identifier  Job
     │ Int64       String
─────┼────────────────────
   1 │          1  Lawyer
   2 │          2  Doctor
   3 │          4  Farmer

julia&gt; leftjoin(name, job2, on = :ID =&gt; :identifier, renamecols = &quot;_left&quot; =&gt; &quot;_right&quot;)
3×3 DataFrame
 Row │ ID     Name_left  Job_right
     │ Int64  String     String?
─────┼─────────────────────────────
   1 │     1  John Doe   Lawyer
   2 │     2  Jane Doe   Doctor
   3 │     3  Joe Blogs  missing

julia&gt; leftjoin(name, job2, on = [:ID =&gt; :identifier], renamecols = uppercase =&gt; lowercase)
3×3 DataFrame
 Row │ ID     NAME       job
     │ Int64  String     String?
─────┼───────────────────────────
   1 │     1  John Doe   Lawyer
   2 │     2  Jane Doe   Doctor
   3 │     3  Joe Blogs  missing</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/10c5b5e9e7f916024b2f102d040fdd9d4e6bd371/src/join/composer.jl#L592-L709">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFrames.leftjoin!" href="#DataFrames.leftjoin!"><code>DataFrames.leftjoin!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">leftjoin!(df1, df2; on, makeunique=false, source=nothing,
          matchmissing=:error)</code></pre><p>Perform a left join of two data frame objects by updating the <code>df1</code> with the joined columns from <code>df2</code>.</p><p>A left join includes all rows from <code>df1</code> and leaves all rows and columns from <code>df1</code> untouched. Note that each row in <code>df1</code> must have at most one match in <code>df2</code>. Otherwise, this function would not be able to execute the join in-place since new rows would need to be added to <code>df1</code>.</p><p><strong>Arguments</strong></p><ul><li><code>df1</code>, <code>df2</code>: the <code>AbstractDataFrames</code> to be joined</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>on</code> : A column name to join <code>df1</code> and <code>df2</code> on. If the columns on which <code>df1</code> and <code>df2</code> will be joined have different names, then a <code>left=&gt;right</code> pair can be passed. It is also allowed to perform a join on multiple columns, in which case a vector of column names or column name pairs can be passed (mixing names and pairs is allowed).</li><li><code>makeunique</code> : if <code>false</code> (the default), an error will be raised if duplicate names are found in columns not joined on; if <code>true</code>, duplicate names will be suffixed with <code>_i</code> (<code>i</code> starting at 1 for the first duplicate).</li><li><code>source</code> : Default: <code>nothing</code>. If a <code>Symbol</code> or string, adds indicator column with the given name, for whether a row appeared in only <code>df1</code> (<code>&quot;left_only&quot;</code>) or in both (<code>&quot;both&quot;</code>). If the name is already in use, the column name will be modified if <code>makeunique=true</code>.</li><li><code>matchmissing</code> : if equal to <code>:error</code> throw an error if <code>missing</code> is present in <code>on</code> columns; if equal to <code>:equal</code> then <code>missing</code> is allowed and missings are matched; if equal to <code>:notequal</code> then missings are dropped in <code>df2</code> <code>on</code> columns; <code>isequal</code> is used for comparisons of rows for equality</li></ul><p>The columns added to <code>df1</code> from <code>df2</code> will support missing values.</p><p>It is not allowed to join on columns that contain <code>NaN</code> or <code>-0.0</code> in real or imaginary part of the number. If you need to perform a join on such values use CategoricalArrays.jl and transform a column containing such values into a <code>CategoricalVector</code>.</p><p>See also: <a href="#DataAPI.leftjoin"><code>leftjoin</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; name = DataFrame(ID=[1, 2, 3], Name=[&quot;John Doe&quot;, &quot;Jane Doe&quot;, &quot;Joe Blogs&quot;])
3×2 DataFrame
 Row │ ID     Name
     │ Int64  String
─────┼──────────────────
   1 │     1  John Doe
   2 │     2  Jane Doe
   3 │     3  Joe Blogs

julia&gt; job = DataFrame(ID=[1, 2, 4], Job=[&quot;Lawyer&quot;, &quot;Doctor&quot;, &quot;Farmer&quot;])
3×2 DataFrame
 Row │ ID     Job
     │ Int64  String
─────┼───────────────
   1 │     1  Lawyer
   2 │     2  Doctor
   3 │     4  Farmer

julia&gt; leftjoin!(name, job, on = :ID)
3×3 DataFrame
 Row │ ID     Name       Job
     │ Int64  String     String?
─────┼───────────────────────────
   1 │     1  John Doe   Lawyer
   2 │     2  Jane Doe   Doctor
   3 │     3  Joe Blogs  missing

julia&gt; job2 = DataFrame(identifier=[1, 2, 4], Job=[&quot;Lawyer&quot;, &quot;Doctor&quot;, &quot;Farmer&quot;])
3×2 DataFrame
 Row │ identifier  Job
     │ Int64       String
─────┼────────────────────
   1 │          1  Lawyer
   2 │          2  Doctor
   3 │          4  Farmer

julia&gt; leftjoin!(name, job2, on = :ID =&gt; :identifier, makeunique=true, source=:source)
3×5 DataFrame
 Row │ ID     Name       Job      Job_1    source
     │ Int64  String     String?  String?  String
─────┼───────────────────────────────────────────────
   1 │     1  John Doe   Lawyer   Lawyer   both
   2 │     2  Jane Doe   Doctor   Doctor   both
   3 │     3  Joe Blogs  missing  missing  left_only</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/10c5b5e9e7f916024b2f102d040fdd9d4e6bd371/src/join/inplace.jl#L1-L92">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataAPI.outerjoin" href="#DataAPI.outerjoin"><code>DataAPI.outerjoin</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">outerjoin(df1, df2; on, makeunique=false, source=nothing, validate=(false, false),
          renamecols=(identity =&gt; identity), matchmissing=:error)
outerjoin(df1, df2, dfs...; on, makeunique = false,
          validate = (false, false), matchmissing=:error)</code></pre><p>Perform an outer join of two or more data frame objects and return a <code>DataFrame</code> containing the result. An outer join includes rows with keys that appear in any of the passed data frames.</p><p>The order of rows in the result is undefined and may change in the future releases.</p><p>In the returned data frame the type of the columns on which the data frames are joined is determined by the element type of these columns both <code>df1</code> and <code>df2</code>. This behavior may change in future releases.</p><p><strong>Arguments</strong></p><ul><li><code>df1</code>, <code>df2</code>, <code>dfs...</code> : the <code>AbstractDataFrames</code> to be joined</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>on</code> : A column name to join <code>df1</code> and <code>df2</code> on. If the columns on which <code>df1</code> and <code>df2</code> will be joined have different names, then a <code>left=&gt;right</code> pair can be passed. It is also allowed to perform a join on multiple columns, in which case a vector of column names or column name pairs can be passed (mixing names and pairs is allowed). If more than two data frames are joined then only a column name or a vector of column names are allowed. <code>on</code> is a required argument.</li><li><code>makeunique</code> : if <code>false</code> (the default), an error will be raised if duplicate names are found in columns not joined on; if <code>true</code>, duplicate names will be suffixed with <code>_i</code> (<code>i</code> starting at 1 for the first duplicate).</li><li><code>source</code> : Default: <code>nothing</code>. If a <code>Symbol</code> or string, adds indicator column with the given name for whether a row appeared in only <code>df1</code> (<code>&quot;left_only&quot;</code>), only <code>df2</code> (<code>&quot;right_only&quot;</code>) or in both (<code>&quot;both&quot;</code>). If the name is already in use, the column name will be modified if <code>makeunique=true</code>. This argument is only supported when joining exactly two data frames.</li><li><code>validate</code> : whether to check that columns passed as the <code>on</code> argument define unique keys in each input data frame (according to <code>isequal</code>). Can be a tuple or a pair, with the first element indicating whether to run check for <code>df1</code> and the second element for <code>df2</code>. By default no check is performed.</li><li><code>renamecols</code> : a <code>Pair</code> specifying how columns of left and right data frames should be renamed in the resulting data frame. Each element of the pair can be a string or a <code>Symbol</code> can be passed in which case it is appended to the original column name; alternatively a function can be passed in which case it is applied to each column name, which is passed to it as a <code>String</code>. Note that <code>renamecols</code> does not affect <code>on</code> columns, whose names are always taken from the left data frame and left unchanged.</li><li><code>matchmissing</code> : if equal to <code>:error</code> throw an error if <code>missing</code> is present in <code>on</code> columns; if equal to <code>:equal</code> then <code>missing</code> is allowed and missings are matched; <code>isequal</code> is used for comparisons of rows for equality</li></ul><p>All columns of the returned data frame will support missing values.</p><p>It is not allowed to join on columns that contain <code>NaN</code> or <code>-0.0</code> in real or imaginary part of the number. If you need to perform a join on such values use CategoricalArrays.jl and transform a column containing such values into a <code>CategoricalVector</code>.</p><p>When merging <code>on</code> categorical columns that differ in the ordering of their levels, the ordering of the left data frame takes precedence over the ordering of the right data frame.</p><p>If more than two data frames are passed, the join is performed recursively with left associativity. In this case the <code>indicator</code> keyword argument is not supported and <code>validate</code> keyword argument is applied recursively with left associativity.</p><p>See also: <a href="#DataAPI.innerjoin"><code>innerjoin</code></a>, <a href="#DataAPI.leftjoin"><code>leftjoin</code></a>, <a href="#DataAPI.rightjoin"><code>rightjoin</code></a>,           <a href="#DataAPI.semijoin"><code>semijoin</code></a>, <a href="#DataAPI.antijoin"><code>antijoin</code></a>, <a href="#DataAPI.crossjoin"><code>crossjoin</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; name = DataFrame(ID=[1, 2, 3], Name=[&quot;John Doe&quot;, &quot;Jane Doe&quot;, &quot;Joe Blogs&quot;])
3×2 DataFrame
 Row │ ID     Name
     │ Int64  String
─────┼──────────────────
   1 │     1  John Doe
   2 │     2  Jane Doe
   3 │     3  Joe Blogs

julia&gt; job = DataFrame(ID=[1, 2, 4], Job=[&quot;Lawyer&quot;, &quot;Doctor&quot;, &quot;Farmer&quot;])
3×2 DataFrame
 Row │ ID     Job
     │ Int64  String
─────┼───────────────
   1 │     1  Lawyer
   2 │     2  Doctor
   3 │     4  Farmer

julia&gt; outerjoin(name, job, on = :ID)
4×3 DataFrame
 Row │ ID     Name       Job
     │ Int64  String?    String?
─────┼───────────────────────────
   1 │     1  John Doe   Lawyer
   2 │     2  Jane Doe   Doctor
   3 │     3  Joe Blogs  missing
   4 │     4  missing    Farmer

julia&gt; job2 = DataFrame(identifier=[1, 2, 4], Job=[&quot;Lawyer&quot;, &quot;Doctor&quot;, &quot;Farmer&quot;])
3×2 DataFrame
 Row │ identifier  Job
     │ Int64       String
─────┼────────────────────
   1 │          1  Lawyer
   2 │          2  Doctor
   3 │          4  Farmer

julia&gt; rightjoin(name, job2, on = :ID =&gt; :identifier, renamecols = &quot;_left&quot; =&gt; &quot;_right&quot;)
3×3 DataFrame
 Row │ ID     Name_left  Job_right
     │ Int64  String?    String
─────┼─────────────────────────────
   1 │     1  John Doe   Lawyer
   2 │     2  Jane Doe   Doctor
   3 │     4  missing    Farmer

julia&gt; rightjoin(name, job2, on = [:ID =&gt; :identifier], renamecols = uppercase =&gt; lowercase)
3×3 DataFrame
 Row │ ID     NAME      job
     │ Int64  String?   String
─────┼─────────────────────────
   1 │     1  John Doe  Lawyer
   2 │     2  Jane Doe  Doctor
   3 │     4  missing   Farmer</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/10c5b5e9e7f916024b2f102d040fdd9d4e6bd371/src/join/composer.jl#L885-L1013">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataAPI.rightjoin" href="#DataAPI.rightjoin"><code>DataAPI.rightjoin</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">rightjoin(df1, df2; on, makeunique=false, source=nothing,
          validate=(false, false), renamecols=(identity =&gt; identity),
          matchmissing=:error)</code></pre><p>Perform a right join on two data frame objects and return a <code>DataFrame</code> containing the result. A right join includes all rows from <code>df2</code>.</p><p>The order of rows in the result is undefined and may change in the future releases.</p><p>In the returned data frame the type of the columns on which the data frames are joined is determined by the type of these columns in <code>df2</code>. This behavior may change in future releases.</p><p><strong>Arguments</strong></p><ul><li><code>df1</code>, <code>df2</code>: the <code>AbstractDataFrames</code> to be joined</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>on</code> : A column name to join <code>df1</code> and <code>df2</code> on. If the columns on which <code>df1</code> and <code>df2</code> will be joined have different names, then a <code>left=&gt;right</code> pair can be passed. It is also allowed to perform a join on multiple columns, in which case a vector of column names or column name pairs can be passed (mixing names and pairs is allowed).</li><li><code>makeunique</code> : if <code>false</code> (the default), an error will be raised if duplicate names are found in columns not joined on; if <code>true</code>, duplicate names will be suffixed with <code>_i</code> (<code>i</code> starting at 1 for the first duplicate).</li><li><code>source</code> : Default: <code>nothing</code>. If a <code>Symbol</code> or string, adds indicator column with the given name for whether a row appeared in only <code>df2</code> (<code>&quot;right_only&quot;</code>) or in both (<code>&quot;both&quot;</code>). If the name is already in use, the column name will be modified if <code>makeunique=true</code>.</li><li><code>validate</code> : whether to check that columns passed as the <code>on</code> argument define unique keys in each input data frame (according to <code>isequal</code>). Can be a tuple or a pair, with the first element indicating whether to run check for <code>df1</code> and the second element for <code>df2</code>. By default no check is performed.</li><li><code>renamecols</code> : a <code>Pair</code> specifying how columns of left and right data frames should be renamed in the resulting data frame. Each element of the pair can be a string or a <code>Symbol</code> can be passed in which case it is appended to the original column name; alternatively a function can be passed in which case it is applied to each column name, which is passed to it as a <code>String</code>. Note that <code>renamecols</code> does not affect <code>on</code> columns, whose names are always taken from the left data frame and left unchanged.</li><li><code>matchmissing</code> : if equal to <code>:error</code> throw an error if <code>missing</code> is present in <code>on</code> columns; if equal to <code>:equal</code> then <code>missing</code> is allowed and missings are matched; if equal to <code>:notequal</code> then missings are dropped in <code>df1</code> <code>on</code> columns; <code>isequal</code> is used for comparisons of rows for equality</li></ul><p>All columns of the returned data frame will support missing values.</p><p>It is not allowed to join on columns that contain <code>NaN</code> or <code>-0.0</code> in real or imaginary part of the number. If you need to perform a join on such values use CategoricalArrays.jl and transform a column containing such values into a <code>CategoricalVector</code>.</p><p>When merging <code>on</code> categorical columns that differ in the ordering of their levels, the ordering of the left data frame takes precedence over the ordering of the right data frame.</p><p>See also: <a href="#DataAPI.innerjoin"><code>innerjoin</code></a>, <a href="#DataAPI.leftjoin"><code>leftjoin</code></a>, <a href="#DataAPI.outerjoin"><code>outerjoin</code></a>,           <a href="#DataAPI.semijoin"><code>semijoin</code></a>, <a href="#DataAPI.antijoin"><code>antijoin</code></a>, <a href="#DataAPI.crossjoin"><code>crossjoin</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; name = DataFrame(ID=[1, 2, 3], Name=[&quot;John Doe&quot;, &quot;Jane Doe&quot;, &quot;Joe Blogs&quot;])
3×2 DataFrame
 Row │ ID     Name
     │ Int64  String
─────┼──────────────────
   1 │     1  John Doe
   2 │     2  Jane Doe
   3 │     3  Joe Blogs

julia&gt; job = DataFrame(ID=[1, 2, 4], Job=[&quot;Lawyer&quot;, &quot;Doctor&quot;, &quot;Farmer&quot;])
3×2 DataFrame
 Row │ ID     Job
     │ Int64  String
─────┼───────────────
   1 │     1  Lawyer
   2 │     2  Doctor
   3 │     4  Farmer

julia&gt; rightjoin(name, job, on = :ID)
3×3 DataFrame
 Row │ ID     Name      Job
     │ Int64  String?   String
─────┼─────────────────────────
   1 │     1  John Doe  Lawyer
   2 │     2  Jane Doe  Doctor
   3 │     4  missing   Farmer

julia&gt; job2 = DataFrame(identifier=[1, 2, 4], Job=[&quot;Lawyer&quot;, &quot;Doctor&quot;, &quot;Farmer&quot;])
3×2 DataFrame
 Row │ identifier  Job
     │ Int64       String
─────┼────────────────────
   1 │          1  Lawyer
   2 │          2  Doctor
   3 │          4  Farmer

julia&gt; rightjoin(name, job2, on = :ID =&gt; :identifier, renamecols = &quot;_left&quot; =&gt; &quot;_right&quot;)
3×3 DataFrame
 Row │ ID     Name_left  Job_right
     │ Int64  String?    String
─────┼─────────────────────────────
   1 │     1  John Doe   Lawyer
   2 │     2  Jane Doe   Doctor
   3 │     4  missing    Farmer

julia&gt; rightjoin(name, job2, on = [:ID =&gt; :identifier], renamecols = uppercase =&gt; lowercase)
3×3 DataFrame
 Row │ ID     NAME      job
     │ Int64  String?   String
─────┼─────────────────────────
   1 │     1  John Doe  Lawyer
   2 │     2  Jane Doe  Doctor
   3 │     4  missing   Farmer</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/10c5b5e9e7f916024b2f102d040fdd9d4e6bd371/src/join/composer.jl#L738-L856">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataAPI.semijoin" href="#DataAPI.semijoin"><code>DataAPI.semijoin</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">semijoin(df1, df2; on, makeunique=false, validate=(false, false), matchmissing=:error)</code></pre><p>Perform a semi join of two data frame objects and return a <code>DataFrame</code> containing the result. A semi join returns the subset of rows of <code>df1</code> that match with the keys in <code>df2</code>.</p><p>The order of rows in the result is undefined and may change in the future releases.</p><p><strong>Arguments</strong></p><ul><li><code>df1</code>, <code>df2</code>: the <code>AbstractDataFrames</code> to be joined</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>on</code> : A column name to join <code>df1</code> and <code>df2</code> on. If the columns on which <code>df1</code> and <code>df2</code> will be joined have different names, then a <code>left=&gt;right</code> pair can be passed. It is also allowed to perform a join on multiple columns, in which case a vector of column names or column name pairs can be passed (mixing names and pairs is allowed).</li><li><code>makeunique</code> : if <code>false</code> (the default), an error will be raised if duplicate names are found in columns not joined on; if <code>true</code>, duplicate names will be suffixed with <code>_i</code> (<code>i</code> starting at 1 for the first duplicate).</li><li><code>indicator</code> : Default: <code>nothing</code>. If a <code>Symbol</code> or string, adds categorical indicator  column with the given name for whether a row appeared in only <code>df1</code> (<code>&quot;left_only&quot;</code>),  only <code>df2</code> (<code>&quot;right_only&quot;</code>) or in both (<code>&quot;both&quot;</code>). If the name is already in use,  the column name will be modified if <code>makeunique=true</code>.</li><li><code>validate</code> : whether to check that columns passed as the <code>on</code> argument  define unique keys in each input data frame (according to <code>isequal</code>).  Can be a tuple or a pair, with the first element indicating whether to  run check for <code>df1</code> and the second element for <code>df2</code>.  By default no check is performed.</li><li><code>matchmissing</code> : if equal to <code>:error</code> throw an error if <code>missing</code> is present in <code>on</code> columns; if equal to <code>:equal</code> then <code>missing</code> is allowed and missings are matched; if equal to <code>:notequal</code> then missings are dropped in <code>df2</code> <code>on</code> columns; <code>isequal</code> is used for comparisons of rows for equality</li></ul><p>It is not allowed to join on columns that contain <code>NaN</code> or <code>-0.0</code> in real or imaginary part of the number. If you need to perform a join on such values use CategoricalArrays.jl and transform a column containing such values into a <code>CategoricalVector</code>.</p><p>When merging <code>on</code> categorical columns that differ in the ordering of their levels, the ordering of the left data frame takes precedence over the ordering of the right data frame.</p><p>See also: <a href="#DataAPI.innerjoin"><code>innerjoin</code></a>, <a href="#DataAPI.leftjoin"><code>leftjoin</code></a>, <a href="#DataAPI.rightjoin"><code>rightjoin</code></a>,           <a href="#DataAPI.outerjoin"><code>outerjoin</code></a>, <a href="#DataAPI.antijoin"><code>antijoin</code></a>, <a href="#DataAPI.crossjoin"><code>crossjoin</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; name = DataFrame(ID=[1, 2, 3], Name=[&quot;John Doe&quot;, &quot;Jane Doe&quot;, &quot;Joe Blogs&quot;])
3×2 DataFrame
 Row │ ID     Name
     │ Int64  String
─────┼──────────────────
   1 │     1  John Doe
   2 │     2  Jane Doe
   3 │     3  Joe Blogs

julia&gt; job = DataFrame(ID=[1, 2, 4], Job=[&quot;Lawyer&quot;, &quot;Doctor&quot;, &quot;Farmer&quot;])
3×2 DataFrame
 Row │ ID     Job
     │ Int64  String
─────┼───────────────
   1 │     1  Lawyer
   2 │     2  Doctor
   3 │     4  Farmer

julia&gt; semijoin(name, job, on = :ID)
2×2 DataFrame
 Row │ ID     Name
     │ Int64  String
─────┼─────────────────
   1 │     1  John Doe
   2 │     2  Jane Doe

julia&gt; job2 = DataFrame(identifier=[1, 2, 4], Job=[&quot;Lawyer&quot;, &quot;Doctor&quot;, &quot;Farmer&quot;])
3×2 DataFrame
 Row │ identifier  Job
     │ Int64       String
─────┼────────────────────
   1 │          1  Lawyer
   2 │          2  Doctor
   3 │          4  Farmer

julia&gt; semijoin(name, job2, on = :ID =&gt; :identifier)
2×2 DataFrame
 Row │ ID     Name
     │ Int64  String
─────┼─────────────────
   1 │     1  John Doe
   2 │     2  Jane Doe

julia&gt; semijoin(name, job2, on = [:ID =&gt; :identifier])
2×2 DataFrame
 Row │ ID     Name
     │ Int64  String
─────┼─────────────────
   1 │     1  John Doe
   2 │     2  Jane Doe</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/10c5b5e9e7f916024b2f102d040fdd9d4e6bd371/src/join/composer.jl#L1051-L1152">source</a></section></article><h2 id="Grouping"><a class="docs-heading-anchor" href="#Grouping">Grouping</a><a id="Grouping-1"></a><a class="docs-heading-anchor-permalink" href="#Grouping" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Base.get" href="#Base.get"><code>Base.get</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get(gd::GroupedDataFrame, key, default)</code></pre><p>Get a group based on the values of the grouping columns.</p><p><code>key</code> may be a <code>GroupKey</code>, <code>NamedTuple</code> or <code>Tuple</code> of grouping column values (in the same order as the <code>cols</code> argument to <code>groupby</code>). It may also be an <code>AbstractDict</code>, in which case the order of the arguments does not matter.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; df = DataFrame(a=repeat([:foo, :bar, :baz], outer=[2]),
                      b=repeat([2, 1], outer=[3]),
                      c=1:6);

julia&gt; gd = groupby(df, :a)
GroupedDataFrame with 3 groups based on key: a
First Group (2 rows): a = :foo
 Row │ a       b      c
     │ Symbol  Int64  Int64
─────┼──────────────────────
   1 │ foo         2      1
   2 │ foo         1      4
⋮
Last Group (2 rows): a = :baz
 Row │ a       b      c
     │ Symbol  Int64  Int64
─────┼──────────────────────
   1 │ baz         2      3
   2 │ baz         1      6

julia&gt; get(gd, (a=:bar,), nothing)
2×3 SubDataFrame
 Row │ a       b      c
     │ Symbol  Int64  Int64
─────┼──────────────────────
   1 │ bar         1      2
   2 │ bar         2      5

julia&gt; get(gd, (:baz,), nothing)
2×3 SubDataFrame
 Row │ a       b      c
     │ Symbol  Int64  Int64
─────┼──────────────────────
   1 │ baz         2      3
   2 │ baz         1      6

julia&gt; get(gd, (:qux,), nothing)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/10c5b5e9e7f916024b2f102d040fdd9d4e6bd371/src/groupeddataframe/groupeddataframe.jl#L903-L953">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFrames.groupby" href="#DataFrames.groupby"><code>DataFrames.groupby</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">groupby(d::AbstractDataFrame, cols;
        sort::Union{Bool, Nothing}=nothing,
        skipmissing::Bool=false)</code></pre><p>Return a <code>GroupedDataFrame</code> representing a view of an <code>AbstractDataFrame</code> split into row groups.</p><p><strong>Arguments</strong></p><ul><li><code>df</code> : an <code>AbstractDataFrame</code> to split</li><li><code>cols</code> : data frame columns to group by. Can be any column selector (<code>Symbol</code>, string or integer; <code>:</code>, <code>Cols</code>, <code>All</code>, <code>Between</code>, <code>Not</code>, a regular expression, or a vector of <code>Symbol</code>s, strings or integers).</li><li><code>sort</code> : if <code>sort=true</code> sort groups according to the values of the grouping columns <code>cols</code>; if <code>sort=false</code> groups are created in order of their appereance in <code>df</code> if <code>sort=nothing</code> (the default) then the fastest available grouping algorithm is picked and in consequence the order of groups in the result is undefined and may change in future releases; below a description of the current implementation is provided.</li><li><code>skipmissing</code> : whether to skip groups with <code>missing</code> values in one of the grouping columns <code>cols</code></li></ul><p><strong>Details</strong></p><p>An iterator over a <code>GroupedDataFrame</code> returns a <code>SubDataFrame</code> view for each grouping into <code>df</code>. Within each group, the order of rows in <code>df</code> is preserved.</p><p><code>cols</code> can be any valid data frame indexing expression. In particular if it is an empty vector then a single-group <code>GroupedDataFrame</code> is created.</p><p>A <code>GroupedDataFrame</code> also supports indexing by groups, <code>select</code>, <code>transform</code>, and <code>combine</code> (which applies a function to each group and combines the result into a data frame).</p><p><code>GroupedDataFrame</code> also supports the dictionary interface. The keys are <a href="../types/#DataFrames.GroupKey"><code>GroupKey</code></a> objects returned by <a href="#Base.keys"><code>keys(::GroupedDataFrame)</code></a>, which can also be used to get the values of the grouping columns for each group. <code>Tuples</code> and <code>NamedTuple</code>s containing the values of the grouping columns (in the same order as the <code>cols</code> argument) are also accepted as indices. Finally, an <code>AbstractDict</code> can be used to index into a grouped data frame where the keys are column names of the data frame. The order of the keys does not matter in this case.</p><p>In the current implementation if <code>sort=nothing</code> groups are ordered following the order of appearance of values in the grouping columns, except when all grouping columns provide non-<code>nothing</code> <code>DataAPI.refpool</code>, in which case the order of groups follows the order of values returned by <code>DataAPI.refpool</code>. As a particular application of this rule if all <code>cols</code> are <code>CategoricalVector</code>s then groups are always sorted. Integer columns with a narrow range also use this this optimization, so to the order of groups when grouping on integer columns is undefined. A column is considered to be an integer column when deciding on the grouping algorithm choice if its <code>eltype</code> is a subtype of <code>Union{Missing, Real}</code>, all its elements are either <code>missing</code> or pass <code>isinteger</code> test, and none of them is equal to <code>-0.0</code>.</p><p><strong>See also</strong></p><p><a href="#DataFrames.combine"><code>combine</code></a>, <a href="#DataFrames.select"><code>select</code></a>, <a href="#DataFrames.select!"><code>select!</code></a>, <a href="#DataFrames.transform"><code>transform</code></a>, <a href="#DataFrames.transform!"><code>transform!</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; df = DataFrame(a=repeat([1, 2, 3, 4], outer=[2]),
                      b=repeat([2, 1], outer=[4]),
                      c=1:8);

julia&gt; gd = groupby(df, :a)
GroupedDataFrame with 4 groups based on key: a
First Group (2 rows): a = 1
 Row │ a      b      c
     │ Int64  Int64  Int64
─────┼─────────────────────
   1 │     1      2      1
   2 │     1      2      5
⋮
Last Group (2 rows): a = 4
 Row │ a      b      c
     │ Int64  Int64  Int64
─────┼─────────────────────
   1 │     4      1      4
   2 │     4      1      8

julia&gt; gd[1]
2×3 SubDataFrame
 Row │ a      b      c
     │ Int64  Int64  Int64
─────┼─────────────────────
   1 │     1      2      1
   2 │     1      2      5

julia&gt; last(gd)
2×3 SubDataFrame
 Row │ a      b      c
     │ Int64  Int64  Int64
─────┼─────────────────────
   1 │     4      1      4
   2 │     4      1      8

julia&gt; gd[(a=3,)]
2×3 SubDataFrame
 Row │ a      b      c
     │ Int64  Int64  Int64
─────┼─────────────────────
   1 │     3      2      3
   2 │     3      2      7

julia&gt; gd[Dict(&quot;a&quot; =&gt; 3)]
2×3 SubDataFrame
 Row │ a      b      c
     │ Int64  Int64  Int64
─────┼─────────────────────
   1 │     3      2      3
   2 │     3      2      7

julia&gt; gd[(3,)]
2×3 SubDataFrame
 Row │ a      b      c
     │ Int64  Int64  Int64
─────┼─────────────────────
   1 │     3      2      3
   2 │     3      2      7

julia&gt; k = first(keys(gd))
GroupKey: (a = 1,)

julia&gt; gd[k]
2×3 SubDataFrame
 Row │ a      b      c
     │ Int64  Int64  Int64
─────┼─────────────────────
   1 │     1      2      1
   2 │     1      2      5

julia&gt; for g in gd
           println(g)
       end
2×3 SubDataFrame
 Row │ a      b      c
     │ Int64  Int64  Int64
─────┼─────────────────────
   1 │     1      2      1
   2 │     1      2      5
2×3 SubDataFrame
 Row │ a      b      c
     │ Int64  Int64  Int64
─────┼─────────────────────
   1 │     2      1      2
   2 │     2      1      6
2×3 SubDataFrame
 Row │ a      b      c
     │ Int64  Int64  Int64
─────┼─────────────────────
   1 │     3      2      3
   2 │     3      2      7
2×3 SubDataFrame
 Row │ a      b      c
     │ Int64  Int64  Int64
─────┼─────────────────────
   1 │     4      1      4
   2 │     4      1      8</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/10c5b5e9e7f916024b2f102d040fdd9d4e6bd371/src/groupeddataframe/groupeddataframe.jl#L50-L210">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFrames.groupcols" href="#DataFrames.groupcols"><code>DataFrames.groupcols</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">groupcols(gd::GroupedDataFrame)</code></pre><p>Return a vector of <code>Symbol</code> column names in <code>parent(gd)</code> used for grouping.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/10c5b5e9e7f916024b2f102d040fdd9d4e6bd371/src/groupeddataframe/groupeddataframe.jl#L361-L365">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFrames.groupindices" href="#DataFrames.groupindices"><code>DataFrames.groupindices</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">groupindices(gd::GroupedDataFrame)</code></pre><p>Return a vector of group indices for each row of <code>parent(gd)</code>.</p><p>Rows appearing in group <code>gd[i]</code> are attributed index <code>i</code>. Rows not present in any group are attributed <code>missing</code> (this can happen if <code>skipmissing=true</code> was passed when creating <code>gd</code>, or if <code>gd</code> is a subset from a larger <a href="../types/#DataFrames.GroupedDataFrame"><code>GroupedDataFrame</code></a>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/10c5b5e9e7f916024b2f102d040fdd9d4e6bd371/src/groupeddataframe/groupeddataframe.jl#L349-L358">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.keys" href="#Base.keys"><code>Base.keys</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">keys(gd::GroupedDataFrame)</code></pre><p>Get the set of keys for each group of the <code>GroupedDataFrame</code> <code>gd</code> as a <a href="../types/#DataFrames.GroupKeys"><code>GroupKeys</code></a> object. Each key is a <a href="../types/#DataFrames.GroupKey"><code>GroupKey</code></a>, which behaves like a <code>NamedTuple</code> holding the values of the grouping columns for a given group. Unlike the equivalent <code>Tuple</code>, <code>NamedTuple</code>, and <code>AbstractDict</code>, these keys can be used to index into <code>gd</code> efficiently. The ordering of the keys is identical to the ordering of the groups of <code>gd</code> under iteration and integer indexing.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; df = DataFrame(a=repeat([:foo, :bar, :baz], outer=[4]),
                      b=repeat([2, 1], outer=[6]),
                      c=1:12);

julia&gt; gd = groupby(df, [:a, :b])
GroupedDataFrame with 6 groups based on keys: a, b
First Group (2 rows): a = :foo, b = 2
 Row │ a       b      c
     │ Symbol  Int64  Int64
─────┼──────────────────────
   1 │ foo         2      1
   2 │ foo         2      7
⋮
Last Group (2 rows): a = :baz, b = 1
 Row │ a       b      c
     │ Symbol  Int64  Int64
─────┼──────────────────────
   1 │ baz         1      6
   2 │ baz         1     12

julia&gt; keys(gd)
6-element DataFrames.GroupKeys{GroupedDataFrame{DataFrame}}:
 GroupKey: (a = :foo, b = 2)
 GroupKey: (a = :bar, b = 1)
 GroupKey: (a = :baz, b = 2)
 GroupKey: (a = :foo, b = 1)
 GroupKey: (a = :bar, b = 2)
 GroupKey: (a = :baz, b = 1)

julia&gt; k = keys(gd)[1]
GroupKey: (a = :foo, b = 2)

julia&gt; keys(k)
2-element Vector{Symbol}:
 :a
 :b

julia&gt; values(k)  # Same as Tuple(k)
(:foo, 2)

julia&gt; NamedTuple(k)
(a = :foo, b = 2)

julia&gt; k.a
:foo

julia&gt; k[:a]
:foo

julia&gt; k[1]
:foo</code></pre><p>Keys can be used as indices to retrieve the corresponding group from their <code>GroupedDataFrame</code>:</p><pre><code class="language-julia-repl hljs">julia&gt; gd[k]
2×3 SubDataFrame
 Row │ a       b      c
     │ Symbol  Int64  Int64
─────┼──────────────────────
   1 │ foo         2      1
   2 │ foo         2      7

julia&gt; gd[keys(gd)[1]] == gd[1]
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/10c5b5e9e7f916024b2f102d040fdd9d4e6bd371/src/groupeddataframe/groupeddataframe.jl#L777-L858">source</a></section><section><div><pre><code class="nohighlight hljs">keys(dfc::DataFrameColumns)</code></pre><p>Get a vector of column names of <code>dfc</code> as <code>Symbol</code>s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/10c5b5e9e7f916024b2f102d040fdd9d4e6bd371/src/abstractdataframe/iteration.jl#L223-L227">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.parent" href="#Base.parent"><code>Base.parent</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">parent(gd::GroupedDataFrame)</code></pre><p>Return the parent data frame of <code>gd</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/10c5b5e9e7f916024b2f102d040fdd9d4e6bd371/src/groupeddataframe/groupeddataframe.jl#L299-L303">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFrames.valuecols" href="#DataFrames.valuecols"><code>DataFrames.valuecols</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">valuecols(gd::GroupedDataFrame)</code></pre><p>Return a vector of <code>Symbol</code> column names in <code>parent(gd)</code> not used for grouping.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/10c5b5e9e7f916024b2f102d040fdd9d4e6bd371/src/groupeddataframe/groupeddataframe.jl#L372-L376">source</a></section></article><h2 id="Filtering-rows"><a class="docs-heading-anchor" href="#Filtering-rows">Filtering rows</a><a id="Filtering-rows-1"></a><a class="docs-heading-anchor-permalink" href="#Filtering-rows" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Base.deleteat!" href="#Base.deleteat!"><code>Base.deleteat!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">deleteat!(df::DataFrame, inds)</code></pre><p>Delete rows specified by <code>inds</code> from a <code>DataFrame</code> <code>df</code> in place and return it.</p><p>Internally <code>deleteat!</code> is called for all columns so <code>inds</code> must be: a vector of sorted and unique integers, a boolean vector, an integer, or <code>Not</code> wrapping any valid selector.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; df = DataFrame(a=1:3, b=4:6)
3×2 DataFrame
 Row │ a      b
     │ Int64  Int64
─────┼──────────────
   1 │     1      4
   2 │     2      5
   3 │     3      6

julia&gt; deleteat!(df, 2)
2×2 DataFrame
 Row │ a      b
     │ Int64  Int64
─────┼──────────────
   1 │     1      4
   2 │     3      6</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/10c5b5e9e7f916024b2f102d040fdd9d4e6bd371/src/dataframe/dataframe.jl#L1001-L1029">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.empty" href="#Base.empty"><code>Base.empty</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">empty(df::AbstractDataFrame)</code></pre><p>Create a new <code>DataFrame</code> with the same column names and column element types as <code>df</code> but with zero rows.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/10c5b5e9e7f916024b2f102d040fdd9d4e6bd371/src/abstractdataframe/abstractdataframe.jl#L408-L413">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.empty!" href="#Base.empty!"><code>Base.empty!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">empty!(df::DataFrame)</code></pre><p>Remove all rows from <code>df</code>, making each of its columns empty.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/10c5b5e9e7f916024b2f102d040fdd9d4e6bd371/src/dataframe/dataframe.jl#L1083-L1087">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.filter" href="#Base.filter"><code>Base.filter</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">filter(fun, df::AbstractDataFrame; view::Bool=false)
filter(cols =&gt; fun, df::AbstractDataFrame; view::Bool=false)</code></pre><p>Return a data frame containing only rows from <code>df</code> for which <code>fun</code> returns <code>true</code>.</p><p>If <code>cols</code> is not specified then the predicate <code>fun</code> is passed <code>DataFrameRow</code>s. Elements of a <code>DataFrameRow</code> may be accessed with dot syntax or column indexing inside <code>fun</code>.</p><p>If <code>cols</code> is specified then the predicate <code>fun</code> is passed elements of the corresponding columns as separate positional arguments, unless <code>cols</code> is an <code>AsTable</code> selector, in which case a <code>NamedTuple</code> of these arguments is passed. <code>cols</code> can be any column selector (<code>Symbol</code>, string or integer; <code>:</code>, <code>Cols</code>, <code>All</code>, <code>Between</code>, <code>Not</code>, a regular expression, or a vector of <code>Symbol</code>s, strings or integers), and column duplicates are allowed if a vector of <code>Symbol</code>s, strings, or integers is passed.</p><p>If <code>view=false</code> a freshly allocated <code>DataFrame</code> is returned. If <code>view=true</code> then a <code>SubDataFrame</code> view into <code>df</code> is returned.</p><p>Passing <code>cols</code> leads to a more efficient execution of the operation for large data frames.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>This method is defined so that DataFrames.jl implements the Julia API for collections, but it is generally recommended to use the <a href="#DataFrames.subset"><code>subset</code></a> function instead as it is consistent with other DataFrames.jl functions (as opposed to <code>filter</code>).</p></div></div><p>See also: <a href="#Base.filter!"><code>filter!</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; df = DataFrame(x=[3, 1, 2, 1], y=[&quot;b&quot;, &quot;c&quot;, &quot;a&quot;, &quot;b&quot;])
4×2 DataFrame
 Row │ x      y
     │ Int64  String
─────┼───────────────
   1 │     3  b
   2 │     1  c
   3 │     2  a
   4 │     1  b

julia&gt; filter(row -&gt; row.x &gt; 1, df)
2×2 DataFrame
 Row │ x      y
     │ Int64  String
─────┼───────────────
   1 │     3  b
   2 │     2  a

julia&gt; filter(row -&gt; row[&quot;x&quot;] &gt; 1, df)
2×2 DataFrame
 Row │ x      y
     │ Int64  String
─────┼───────────────
   1 │     3  b
   2 │     2  a

julia&gt; filter(:x =&gt; x -&gt; x &gt; 1, df)
2×2 DataFrame
 Row │ x      y
     │ Int64  String
─────┼───────────────
   1 │     3  b
   2 │     2  a

julia&gt; filter([:x, :y] =&gt; (x, y) -&gt; x == 1 || y == &quot;b&quot;, df)
3×2 DataFrame
 Row │ x      y
     │ Int64  String
─────┼───────────────
   1 │     3  b
   2 │     1  c
   3 │     1  b

julia&gt; filter(AsTable(:) =&gt; nt -&gt; nt.x == 1 || nt.y == &quot;b&quot;, df)
3×2 DataFrame
 Row │ x      y
     │ Int64  String
─────┼───────────────
   1 │     3  b
   2 │     1  c
   3 │     1  b</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/10c5b5e9e7f916024b2f102d040fdd9d4e6bd371/src/abstractdataframe/abstractdataframe.jl#L995-L1081">source</a></section><section><div><pre><code class="nohighlight hljs">filter(fun, gdf::GroupedDataFrame)
filter(cols =&gt; fun, gdf::GroupedDataFrame)</code></pre><p>Return a new <code>GroupedDataFrame</code> containing only groups for which <code>fun</code> returns <code>true</code>.</p><p>If <code>cols</code> is not specified then the predicate <code>fun</code> is called with a <code>SubDataFrame</code> for each group.</p><p>If <code>cols</code> is specified then the predicate <code>fun</code> is called for each group with views of the corresponding columns as separate positional arguments, unless <code>cols</code> is an <code>AsTable</code> selector, in which case a <code>NamedTuple</code> of these arguments is passed. <code>cols</code> can be any column selector (<code>Symbol</code>, string or integer; <code>:</code>, <code>Cols</code>, <code>All</code>, <code>Between</code>, <code>Not</code>, a regular expression, or a vector of <code>Symbol</code>s, strings or integers), and column duplicates are allowed if a vector of <code>Symbol</code>s, strings, or integers is passed.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>This method is defined so that DataFrames.jl implements the Julia API for collections, but it is generally recommended to use the <a href="#DataFrames.subset"><code>subset</code></a> function instead as it is consistent with other DataFrames.jl functions (as opposed to <code>filter</code>).</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; df = DataFrame(g=[1, 2], x=[&#39;a&#39;, &#39;b&#39;]);

julia&gt; gd = groupby(df, :g)
GroupedDataFrame with 2 groups based on key: g
First Group (1 row): g = 1
 Row │ g      x
     │ Int64  Char
─────┼─────────────
   1 │     1  a
⋮
Last Group (1 row): g = 2
 Row │ g      x
     │ Int64  Char
─────┼─────────────
   1 │     2  b

julia&gt; filter(x -&gt; x.x[1] == &#39;a&#39;, gd)
GroupedDataFrame with 1 group based on key: g
First Group (1 row): g = 1
 Row │ g      x
     │ Int64  Char
─────┼─────────────
   1 │     1  a

julia&gt; filter(:x =&gt; x -&gt; x[1] == &#39;a&#39;, gd)
GroupedDataFrame with 1 group based on key: g
First Group (1 row): g = 1
 Row │ g      x
     │ Int64  Char
─────┼─────────────
   1 │     1  a</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/10c5b5e9e7f916024b2f102d040fdd9d4e6bd371/src/groupeddataframe/groupeddataframe.jl#L962-L1020">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.filter!" href="#Base.filter!"><code>Base.filter!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">filter!(fun, df::AbstractDataFrame)
filter!(cols =&gt; fun, df::AbstractDataFrame)</code></pre><p>Remove rows from data frame <code>df</code> for which <code>fun</code> returns <code>false</code>.</p><p>If <code>cols</code> is not specified then the predicate <code>fun</code> is passed <code>DataFrameRow</code>s. Elements of a <code>DataFrameRow</code> may be accessed with dot syntax or column indexing inside <code>fun</code>.</p><p>If <code>cols</code> is specified then the predicate <code>fun</code> is passed elements of the corresponding columns as separate positional arguments, unless <code>cols</code> is an <code>AsTable</code> selector, in which case a <code>NamedTuple</code> of these arguments is passed. <code>cols</code> can be any column selector (<code>Symbol</code>, string or integer; <code>:</code>, <code>Cols</code>, <code>All</code>, <code>Between</code>, <code>Not</code>, a regular expression, or a vector of <code>Symbol</code>s, strings or integers), and column duplicates are allowed if a vector of <code>Symbol</code>s, strings, or integers is passed.</p><p>Passing <code>cols</code> leads to a more efficient execution of the operation for large data frames.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>This method is defined so that DataFrames.jl implements the Julia API for collections, but it is generally recommended to use the <a href="#DataFrames.subset!"><code>subset!</code></a> function instead as it is consistent with other DataFrames.jl functions (as opposed to <code>filter!</code>).</p></div></div><p>See also: <a href="#Base.filter"><code>filter</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; df = DataFrame(x=[3, 1, 2, 1], y=[&quot;b&quot;, &quot;c&quot;, &quot;a&quot;, &quot;b&quot;])
4×2 DataFrame
 Row │ x      y
     │ Int64  String
─────┼───────────────
   1 │     3  b
   2 │     1  c
   3 │     2  a
   4 │     1  b

julia&gt; filter!(row -&gt; row.x &gt; 1, df)
2×2 DataFrame
 Row │ x      y
     │ Int64  String
─────┼───────────────
   1 │     3  b
   2 │     2  a

julia&gt; filter!(row -&gt; row[&quot;x&quot;] &gt; 1, df)
2×2 DataFrame
 Row │ x      y
     │ Int64  String
─────┼───────────────
   1 │     3  b
   2 │     2  a

julia&gt; filter!(:x =&gt; x -&gt; x == 3, df)
1×2 DataFrame
 Row │ x      y
     │ Int64  String
─────┼───────────────
   1 │     3  b

julia&gt; df = DataFrame(x=[3, 1, 2, 1], y=[&quot;b&quot;, &quot;c&quot;, &quot;a&quot;, &quot;b&quot;]);

julia&gt; filter!([:x, :y] =&gt; (x, y) -&gt; x == 1 || y == &quot;b&quot;, df)
3×2 DataFrame
 Row │ x      y
     │ Int64  String
─────┼───────────────
   1 │     3  b
   2 │     1  c
   3 │     1  b

julia&gt; df = DataFrame(x=[3, 1, 2, 1], y=[&quot;b&quot;, &quot;c&quot;, &quot;a&quot;, &quot;b&quot;]);

julia&gt; filter!(AsTable(:) =&gt; nt -&gt; nt.x == 1 || nt.y == &quot;b&quot;, df)
3×2 DataFrame
 Row │ x      y
     │ Int64  String
─────┼───────────────
   1 │     3  b
   2 │     1  c
   3 │     1  b</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/10c5b5e9e7f916024b2f102d040fdd9d4e6bd371/src/abstractdataframe/abstractdataframe.jl#L1125-L1210">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.first" href="#Base.first"><code>Base.first</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">first(df::AbstractDataFrame)</code></pre><p>Get the first row of <code>df</code> as a <code>DataFrameRow</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/10c5b5e9e7f916024b2f102d040fdd9d4e6bd371/src/abstractdataframe/abstractdataframe.jl#L481-L485">source</a></section><section><div><pre><code class="nohighlight hljs">first(df::AbstractDataFrame, n::Integer; view::Bool=false)</code></pre><p>Get a data frame with the <code>n</code> first rows of <code>df</code>.</p><p>If <code>view=false</code> a freshly allocated <code>DataFrame</code> is returned. If <code>view=true</code> then a <code>SubDataFrame</code> view into <code>df</code> is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/10c5b5e9e7f916024b2f102d040fdd9d4e6bd371/src/abstractdataframe/abstractdataframe.jl#L488-L495">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.last" href="#Base.last"><code>Base.last</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">last(df::AbstractDataFrame)</code></pre><p>Get the last row of <code>df</code> as a <code>DataFrameRow</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/10c5b5e9e7f916024b2f102d040fdd9d4e6bd371/src/abstractdataframe/abstractdataframe.jl#L499-L503">source</a></section><section><div><pre><code class="nohighlight hljs">last(df::AbstractDataFrame, n::Integer; view::Bool=false)</code></pre><p>Get a data frame with the <code>n</code> last rows of <code>df</code>.</p><p>If <code>view=false</code> a freshly allocated <code>DataFrame</code> is returned. If <code>view=true</code> then a <code>SubDataFrame</code> view into <code>df</code> is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/10c5b5e9e7f916024b2f102d040fdd9d4e6bd371/src/abstractdataframe/abstractdataframe.jl#L506-L513">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.Iterators.only" href="#Base.Iterators.only"><code>Base.Iterators.only</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">only(df::AbstractDataFrame)</code></pre><p>If <code>df</code> has a single row return it as a <code>DataFrameRow</code>; otherwise throw <code>ArgumentError</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/10c5b5e9e7f916024b2f102d040fdd9d4e6bd371/src/abstractdataframe/abstractdataframe.jl#L471-L475">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFrames.nonunique" href="#DataFrames.nonunique"><code>DataFrames.nonunique</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">nonunique(df::AbstractDataFrame)
nonunique(df::AbstractDataFrame, cols)</code></pre><p>Return a <code>Vector{Bool}</code> in which <code>true</code> entries indicate duplicate rows. A row is a duplicate if there exists a prior row with all columns containing equal values (according to <code>isequal</code>).</p><p>See also <a href="#Base.unique"><code>unique</code></a> and <a href="#Base.unique!"><code>unique!</code></a>.</p><p><strong>Arguments</strong></p><ul><li><code>df</code> : <code>AbstractDataFrame</code></li><li><code>cols</code> : a selector specifying the column(s) or their transformations to compare. Can be any column selector or transformation accepted by <a href="#DataFrames.select"><code>select</code></a>.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; df = DataFrame(i=1:4, x=[1, 2, 1, 2])
4×2 DataFrame
 Row │ i      x
     │ Int64  Int64
─────┼──────────────
   1 │     1      1
   2 │     2      2
   3 │     3      1
   4 │     4      2

julia&gt; df = vcat(df, df)
8×2 DataFrame
 Row │ i      x
     │ Int64  Int64
─────┼──────────────
   1 │     1      1
   2 │     2      2
   3 │     3      1
   4 │     4      2
   5 │     1      1
   6 │     2      2
   7 │     3      1
   8 │     4      2

julia&gt; nonunique(df)
8-element Vector{Bool}:
 0
 0
 0
 0
 1
 1
 1
 1

julia&gt; nonunique(df, 2)
8-element Vector{Bool}:
 0
 0
 1
 1
 1
 1
 1
 1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/10c5b5e9e7f916024b2f102d040fdd9d4e6bd371/src/abstractdataframe/abstractdataframe.jl#L1273-L1336">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFrames.subset" href="#DataFrames.subset"><code>DataFrames.subset</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">subset(df::AbstractDataFrame, args...; skipmissing::Bool=false, view::Bool=false)
subset(gdf::GroupedDataFrame, args...; skipmissing::Bool=false, view::Bool=false,
       ungroup::Bool=true)</code></pre><p>Return a copy of data frame <code>df</code> or parent of <code>gdf</code> containing only rows for which all values produced by transformation(s) <code>args</code> for a given row are <code>true</code>. All transformations must produce vectors containing <code>true</code> or <code>false</code> (and optionally <code>missing</code> if <code>skipmissing=true</code>).</p><p>Each argument passed in <code>args</code> can be any specifier following the rules described for <a href="#DataFrames.select"><code>select</code></a> with the restriction that:</p><ul><li>specifying target column name is not allowed as <code>subset</code> does not create new columns;</li><li>every passed transformation must return a scalar or a vector (returning <code>AbstractDataFrame</code>, <code>NamedTuple</code>, <code>DataFrameRow</code> or <code>AbstractMatrix</code> is not supported).</li></ul><p>If <code>skipmissing=false</code> (the default) <code>args</code> are required to produce vectors containing only <code>Bool</code> values. If <code>skipmissing=true</code>, additionally <code>missing</code> is allowed and it is treated as <code>false</code> (i.e. rows for which one of the conditions returns <code>missing</code> are skipped).</p><p>If <code>view=true</code> a <code>SubDataFrame</code> view  is returned instead of a <code>DataFrame</code>.</p><p>If <code>ungroup=false</code> the resulting data frame is re-grouped based on the same grouping columns as <code>gdf</code> and a <code>GroupedDataFrame</code> is returned.</p><p>If a <code>GroupedDataFrame</code> is passed then it must include all groups present in the <code>parent</code> data frame, like in <a href="#DataFrames.select!"><code>select!</code></a>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Note that as the <code>subset</code> function works in exactly the same way as other transformation functions defined in DataFrames.jl this is the preferred way to subset rows of a data frame or grouped data frame. In particular it uses a different set of rules for specifying transformations than <a href="#Base.filter"><code>filter</code></a> which is implemented in DataFrames.jl to ensure support for the standard Julia API for collections.</p></div></div><p>See also: <a href="#DataFrames.subset!"><code>subset!</code></a>, <a href="#Base.filter"><code>filter</code></a>, <a href="#DataFrames.select"><code>select</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; df = DataFrame(id=1:4, x=[true, false, true, false],
                      y=[true, true, false, false],
                      z=[true, true, missing, missing], v=[1, 2, 11, 12])
4×5 DataFrame
 Row │ id     x      y      z        v
     │ Int64  Bool   Bool   Bool?    Int64
─────┼─────────────────────────────────────
   1 │     1   true   true     true      1
   2 │     2  false   true     true      2
   3 │     3   true  false  missing     11
   4 │     4  false  false  missing     12

julia&gt; subset(df, :x)
2×5 DataFrame
 Row │ id     x     y      z        v
     │ Int64  Bool  Bool   Bool?    Int64
─────┼────────────────────────────────────
   1 │     1  true   true     true      1
   2 │     3  true  false  missing     11

julia&gt; subset(df, :v =&gt; x -&gt; x .&gt; 3)
2×5 DataFrame
 Row │ id     x      y      z        v
     │ Int64  Bool   Bool   Bool?    Int64
─────┼─────────────────────────────────────
   1 │     3   true  false  missing     11
   2 │     4  false  false  missing     12

julia&gt; subset(df, :x, :y =&gt; ByRow(!))
1×5 DataFrame
 Row │ id     x     y      z        v
     │ Int64  Bool  Bool   Bool?    Int64
─────┼────────────────────────────────────
   1 │     3  true  false  missing     11

julia&gt; subset(df, :x, :z, skipmissing=true)
1×5 DataFrame
 Row │ id     x     y     z      v
     │ Int64  Bool  Bool  Bool?  Int64
─────┼─────────────────────────────────
   1 │     1  true  true   true      1

julia&gt; subset(df, :x, :z)
ERROR: ArgumentError: missing was returned in condition number 2 but only true or false are allowed; pass skipmissing=true to skip missing values

julia&gt; subset(groupby(df, :y), :v =&gt; x -&gt; x .&gt; minimum(x))
2×5 DataFrame
 Row │ id     x      y      z        v
     │ Int64  Bool   Bool   Bool?    Int64
─────┼─────────────────────────────────────
   1 │     2  false   true     true      2
   2 │     4  false  false  missing     12</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/10c5b5e9e7f916024b2f102d040fdd9d4e6bd371/src/abstractdataframe/subset.jl#L132-L230">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFrames.subset!" href="#DataFrames.subset!"><code>DataFrames.subset!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">subset!(df::AbstractDataFrame, args...; skipmissing::Bool=false)
subset!(gdf::GroupedDataFrame{DataFrame}, args..., skipmissing::Bool=false,
        ungroup::Bool=true)</code></pre><p>Update data frame <code>df</code> or the parent of <code>gdf</code> in place to contain only rows for which all values produced by transformation(s) <code>args</code> for a given row is <code>true</code>. All transformations must produce vectors containing <code>true</code> or <code>false</code> (and optionally <code>missing</code> if <code>skipmissing=true</code>).</p><p>Each argument passed in <code>args</code> can be any specifier following the rules described for <a href="#DataFrames.select"><code>select</code></a> with the restriction that:</p><ul><li>specifying target column name is not allowed as <code>subset!</code> does not create new columns;</li><li>every passed transformation must return a scalar or a vector (returning <code>AbstractDataFrame</code>, <code>NamedTuple</code>, <code>DataFrameRow</code> or <code>AbstractMatrix</code> is not supported).</li></ul><p>If <code>skipmissing=false</code> (the default) <code>args</code> are required to produce vectors containing only <code>Bool</code> values. If <code>skipmissing=true</code>, additionally <code>missing</code> is allowed and it is treated as <code>false</code> (i.e. rows for which one of the conditions returns <code>missing</code> are skipped).</p><p>If <code>ungroup=false</code> the resulting data frame is re-grouped based on the same grouping columns as <code>gdf</code> and a <code>GroupedDataFrame</code> is returned.</p><p>If <code>GroupedDataFrame</code> is subsetted then it must include all groups present in the <code>parent</code> data frame, like in <a href="#DataFrames.select!"><code>select!</code></a>. In this case the passed <code>GroupedDataFrame</code> is updated to have correct groups after its parent is updated.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Note that as the <code>subset!</code> function works in exactly the same way as other transformation functions defined in DataFrames.jl this is the preferred way to subset rows of a data frame or grouped data frame. In particular it uses a different set of rules for specifying transformations than <a href="#Base.filter!"><code>filter!</code></a> which is implemented in DataFrames.jl to ensure support for the standard Julia API for collections.</p></div></div><p>See also: <a href="#DataFrames.subset"><code>subset</code></a>, <a href="#Base.filter!"><code>filter!</code></a>, <a href="#DataFrames.select!"><code>select!</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; df = DataFrame(id=1:4, x=[true, false, true, false], y=[true, true, false, false])
4×3 DataFrame
 Row │ id     x      y
     │ Int64  Bool   Bool
─────┼─────────────────────
   1 │     1   true   true
   2 │     2  false   true
   3 │     3   true  false
   4 │     4  false  false

julia&gt; subset!(df, :x, :y =&gt; ByRow(!));

julia&gt; df
1×3 DataFrame
 Row │ id     x     y
     │ Int64  Bool  Bool
─────┼────────────────────
   1 │     3  true  false

julia&gt; df = DataFrame(id=1:4, y=[true, true, false, false], v=[1, 2, 11, 12]);

julia&gt; subset!(groupby(df, :y), :v =&gt; x -&gt; x .&gt; minimum(x));

julia&gt; df
2×3 DataFrame
 Row │ id     y      v
     │ Int64  Bool   Int64
─────┼─────────────────────
   1 │     2   true      2
   2 │     4  false     12

julia&gt; df = DataFrame(id=1:4, x=[true, false, true, false],
                      z=[true, true, missing, missing], v=1:4)
4×4 DataFrame
 Row │ id     x      z        v
     │ Int64  Bool   Bool?    Int64
─────┼──────────────────────────────
   1 │     1   true     true      1
   2 │     2  false     true      2
   3 │     3   true  missing      3
   4 │     4  false  missing      4

julia&gt; subset!(df, :x, :z)
ERROR: ArgumentError: missing was returned in condition number 2 but only true or false are allowed; pass skipmissing=true to skip missing values

julia&gt; subset!(df, :x, :z, skipmissing=true);

julia&gt; df
1×4 DataFrame
 Row │ id     x     z      v
     │ Int64  Bool  Bool?  Int64
─────┼───────────────────────────
   1 │     1  true   true      1

julia&gt; df = DataFrame(id=1:4, x=[true, false, true, false], y=[true, true, false, false],
                      z=[true, true, missing, missing], v=[1, 2, 11, 12]);

julia&gt; subset!(groupby(df, :y), :v =&gt; x -&gt; x .&gt; minimum(x));

julia&gt; df
2×5 DataFrame
 Row │ id     x      y      z        v
     │ Int64  Bool   Bool   Bool?    Int64
─────┼─────────────────────────────────────
   1 │     2  false   true     true      2
   2 │     4  false  false  missing     12</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/10c5b5e9e7f916024b2f102d040fdd9d4e6bd371/src/abstractdataframe/subset.jl#L247-L359">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.unique" href="#Base.unique"><code>Base.unique</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">unique(df::AbstractDataFrame; view::Bool=false)
unique(df::AbstractDataFrame, cols; view::Bool=false)
unique!(df::AbstractDataFrame)
unique!(df::AbstractDataFrame, cols)</code></pre><p>Return a data frame containing only the first occurrence of unique rows in <code>df</code>. When <code>cols</code> is specified, the returned <code>DataFrame</code> contains complete rows, retaining in each case the first occurrence of a given combination of values in selected columns or their transformations. <code>cols</code> can be any column selector or transformation accepted by <a href="#DataFrames.select"><code>select</code></a>.</p><p>For <code>unique</code>, if <code>view=false</code> a freshly allocated <code>DataFrame</code> is returned, and if <code>view=true</code> then a <code>SubDataFrame</code> view into <code>df</code> is returned.</p><p><code>unique!</code> updates <code>df</code> in-place and does not support the <code>view</code> keyword argument.</p><p>See also <a href="#DataFrames.nonunique"><code>nonunique</code></a>.</p><p><strong>Arguments</strong></p><ul><li><code>df</code> : the AbstractDataFrame</li><li><code>cols</code> :  column indicator (Symbol, Int, Vector{Symbol}, Regex, etc.)</li></ul><p>specifying the column(s) to compare.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; df = DataFrame(i=1:4, x=[1, 2, 1, 2])
4×2 DataFrame
 Row │ i      x
     │ Int64  Int64
─────┼──────────────
   1 │     1      1
   2 │     2      2
   3 │     3      1
   4 │     4      2

julia&gt; df = vcat(df, df)
8×2 DataFrame
 Row │ i      x
     │ Int64  Int64
─────┼──────────────
   1 │     1      1
   2 │     2      2
   3 │     3      1
   4 │     4      2
   5 │     1      1
   6 │     2      2
   7 │     3      1
   8 │     4      2

julia&gt; unique(df)   # doesn&#39;t modify df
4×2 DataFrame
 Row │ i      x
     │ Int64  Int64
─────┼──────────────
   1 │     1      1
   2 │     2      2
   3 │     3      1
   4 │     4      2

julia&gt; unique(df, 2)
2×2 DataFrame
 Row │ i      x
     │ Int64  Int64
─────┼──────────────
   1 │     1      1
   2 │     2      2

julia&gt; unique!(df)  # modifies df
4×2 DataFrame
 Row │ i      x
     │ Int64  Int64
─────┼──────────────
   1 │     1      1
   2 │     2      2
   3 │     3      1
   4 │     4      2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/10c5b5e9e7f916024b2f102d040fdd9d4e6bd371/src/abstractdataframe/abstractdataframe.jl#L1371-L1450">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.unique!" href="#Base.unique!"><code>Base.unique!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">unique(df::AbstractDataFrame; view::Bool=false)
unique(df::AbstractDataFrame, cols; view::Bool=false)
unique!(df::AbstractDataFrame)
unique!(df::AbstractDataFrame, cols)</code></pre><p>Return a data frame containing only the first occurrence of unique rows in <code>df</code>. When <code>cols</code> is specified, the returned <code>DataFrame</code> contains complete rows, retaining in each case the first occurrence of a given combination of values in selected columns or their transformations. <code>cols</code> can be any column selector or transformation accepted by <a href="#DataFrames.select"><code>select</code></a>.</p><p>For <code>unique</code>, if <code>view=false</code> a freshly allocated <code>DataFrame</code> is returned, and if <code>view=true</code> then a <code>SubDataFrame</code> view into <code>df</code> is returned.</p><p><code>unique!</code> updates <code>df</code> in-place and does not support the <code>view</code> keyword argument.</p><p>See also <a href="#DataFrames.nonunique"><code>nonunique</code></a>.</p><p><strong>Arguments</strong></p><ul><li><code>df</code> : the AbstractDataFrame</li><li><code>cols</code> :  column indicator (Symbol, Int, Vector{Symbol}, Regex, etc.)</li></ul><p>specifying the column(s) to compare.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; df = DataFrame(i=1:4, x=[1, 2, 1, 2])
4×2 DataFrame
 Row │ i      x
     │ Int64  Int64
─────┼──────────────
   1 │     1      1
   2 │     2      2
   3 │     3      1
   4 │     4      2

julia&gt; df = vcat(df, df)
8×2 DataFrame
 Row │ i      x
     │ Int64  Int64
─────┼──────────────
   1 │     1      1
   2 │     2      2
   3 │     3      1
   4 │     4      2
   5 │     1      1
   6 │     2      2
   7 │     3      1
   8 │     4      2

julia&gt; unique(df)   # doesn&#39;t modify df
4×2 DataFrame
 Row │ i      x
     │ Int64  Int64
─────┼──────────────
   1 │     1      1
   2 │     2      2
   3 │     3      1
   4 │     4      2

julia&gt; unique(df, 2)
2×2 DataFrame
 Row │ i      x
     │ Int64  Int64
─────┼──────────────
   1 │     1      1
   2 │     2      2

julia&gt; unique!(df)  # modifies df
4×2 DataFrame
 Row │ i      x
     │ Int64  Int64
─────┼──────────────
   1 │     1      1
   2 │     2      2
   3 │     3      1
   4 │     4      2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/10c5b5e9e7f916024b2f102d040fdd9d4e6bd371/src/abstractdataframe/abstractdataframe.jl#L1371-L1450">source</a></section></article><h2 id="Working-with-missing-values"><a class="docs-heading-anchor" href="#Working-with-missing-values">Working with missing values</a><a id="Working-with-missing-values-1"></a><a class="docs-heading-anchor-permalink" href="#Working-with-missing-values" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Missings.allowmissing" href="#Missings.allowmissing"><code>Missings.allowmissing</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">allowmissing(df::AbstractDataFrame, cols=:)</code></pre><p>Return a copy of data frame <code>df</code> with columns <code>cols</code> converted to element type <code>Union{T, Missing}</code> from <code>T</code> to allow support for missing values.</p><p><code>cols</code> can be any column selector (<code>Symbol</code>, string or integer; <code>:</code>, <code>Cols</code>, <code>All</code>, <code>Between</code>, <code>Not</code>, a regular expression, or a vector of <code>Symbol</code>s, strings or integers).</p><p>If <code>cols</code> is omitted all columns in the data frame are converted.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; df = DataFrame(a=[1, 2])
2×1 DataFrame
 Row │ a
     │ Int64
─────┼───────
   1 │     1
   2 │     2

julia&gt; allowmissing(df)
2×1 DataFrame
 Row │ a
     │ Int64?
─────┼────────
   1 │      1
   2 │      2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/10c5b5e9e7f916024b2f102d040fdd9d4e6bd371/src/abstractdataframe/abstractdataframe.jl#L2088-L2117">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFrames.allowmissing!" href="#DataFrames.allowmissing!"><code>DataFrames.allowmissing!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">allowmissing!(df::DataFrame, cols=:)</code></pre><p>Convert columns <code>cols</code> of data frame <code>df</code> from element type <code>T</code> to <code>Union{T, Missing}</code> to support missing values.</p><p><code>cols</code> can be any column selector (<code>Symbol</code>, string or integer; <code>:</code>, <code>Cols</code>, <code>All</code>, <code>Between</code>, <code>Not</code>, a regular expression, or a vector of <code>Symbol</code>s, strings or integers).</p><p>If <code>cols</code> is omitted all columns in the data frame are converted.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/10c5b5e9e7f916024b2f102d040fdd9d4e6bd371/src/dataframe/dataframe.jl#L1138-L1147">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFrames.completecases" href="#DataFrames.completecases"><code>DataFrames.completecases</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">completecases(df::AbstractDataFrame, cols=:)</code></pre><p>Return a Boolean vector with <code>true</code> entries indicating rows without missing values (complete cases) in data frame <code>df</code>.</p><p>If <code>cols</code> is provided, only missing values in the corresponding columns areconsidered. <code>cols</code> can be any column selector (<code>Symbol</code>, string or integer; <code>:</code>, <code>Cols</code>, <code>All</code>, <code>Between</code>, <code>Not</code>, a regular expression, or a vector of <code>Symbol</code>s, strings or integers).</p><p>See also: <a href="#DataFrames.dropmissing"><code>dropmissing</code></a> and <a href="#DataFrames.dropmissing!"><code>dropmissing!</code></a>. Use <code>findall(completecases(df))</code> to get the indices of the rows.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; df = DataFrame(i=1:5,
                      x=[missing, 4, missing, 2, 1],
                      y=[missing, missing, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;])
5×3 DataFrame
 Row │ i      x        y
     │ Int64  Int64?   String?
─────┼─────────────────────────
   1 │     1  missing  missing
   2 │     2        4  missing
   3 │     3  missing  c
   4 │     4        2  d
   5 │     5        1  e

julia&gt; completecases(df)
5-element BitVector:
 0
 0
 0
 1
 1

julia&gt; completecases(df, :x)
5-element BitVector:
 0
 1
 0
 1
 1

julia&gt; completecases(df, [:x, :y])
5-element BitVector:
 0
 0
 0
 1
 1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/10c5b5e9e7f916024b2f102d040fdd9d4e6bd371/src/abstractdataframe/abstractdataframe.jl#L755-L807">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Missings.disallowmissing" href="#Missings.disallowmissing"><code>Missings.disallowmissing</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">disallowmissing(df::AbstractDataFrame, cols=:; error::Bool=true)</code></pre><p>Return a copy of data frame <code>df</code> with columns <code>cols</code> converted from element type <code>Union{T, Missing}</code> to <code>T</code> to drop support for missing values.</p><p><code>cols</code> can be any column selector (<code>Symbol</code>, string or integer; <code>:</code>, <code>Cols</code>, <code>All</code>, <code>Between</code>, <code>Not</code>, a regular expression, or a vector of <code>Symbol</code>s, strings or integers).</p><p>If <code>cols</code> is omitted all columns in the data frame are converted.</p><p>If <code>error=false</code> then columns containing a <code>missing</code> value will be skipped instead of throwing an error.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; df = DataFrame(a=Union{Int, Missing}[1, 2])
2×1 DataFrame
 Row │ a
     │ Int64?
─────┼────────
   1 │      1
   2 │      2

julia&gt; disallowmissing(df)
2×1 DataFrame
 Row │ a
     │ Int64
─────┼───────
   1 │     1
   2 │     2

julia&gt; df = DataFrame(a=[1, missing])
2×1 DataFrame
 Row │ a
     │ Int64?
─────┼─────────
   1 │       1
   2 │ missing

julia&gt; disallowmissing(df, error=false)
2×1 DataFrame
 Row │ a
     │ Int64?
─────┼─────────
   1 │       1
   2 │ missing</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/10c5b5e9e7f916024b2f102d040fdd9d4e6bd371/src/abstractdataframe/abstractdataframe.jl#L2006-L2054">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFrames.disallowmissing!" href="#DataFrames.disallowmissing!"><code>DataFrames.disallowmissing!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">disallowmissing!(df::DataFrame, cols=:; error::Bool=true)</code></pre><p>Convert columns <code>cols</code> of data frame <code>df</code> from element type <code>Union{T, Missing}</code> to <code>T</code> to drop support for missing values.</p><p><code>cols</code> can be any column selector (<code>Symbol</code>, string or integer; <code>:</code>, <code>Cols</code>, <code>All</code>, <code>Between</code>, <code>Not</code>, a regular expression, or a vector of <code>Symbol</code>s, strings or integers).</p><p>If <code>cols</code> is omitted all columns in the data frame are converted.</p><p>If <code>error=false</code> then columns containing a <code>missing</code> value will be skipped instead of throwing an error.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/10c5b5e9e7f916024b2f102d040fdd9d4e6bd371/src/dataframe/dataframe.jl#L1176-L1188">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFrames.dropmissing" href="#DataFrames.dropmissing"><code>DataFrames.dropmissing</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">dropmissing(df::AbstractDataFrame, cols=:; view::Bool=false, disallowmissing::Bool=!view)</code></pre><p>Return a data frame excluding rows with missing values in <code>df</code>.</p><p>If <code>cols</code> is provided, only missing values in the corresponding columns are considered. <code>cols</code> can be any column selector (<code>Symbol</code>, string or integer; <code>:</code>, <code>Cols</code>, <code>All</code>, <code>Between</code>, <code>Not</code>, a regular expression, or a vector of <code>Symbol</code>s, strings or integers).</p><p>If <code>view=false</code> a freshly allocated <code>DataFrame</code> is returned. If <code>view=true</code> then a <code>SubDataFrame</code> view into <code>df</code> is returned. In this case <code>disallowmissing</code> must be <code>false</code>.</p><p>If <code>disallowmissing</code> is <code>true</code> (the default when <code>view</code> is <code>false</code>) then columns specified in <code>cols</code> will be converted so as not to allow for missing values using <a href="#DataFrames.disallowmissing!"><code>disallowmissing!</code></a>.</p><p>See also: <a href="#DataFrames.completecases"><code>completecases</code></a> and <a href="#DataFrames.dropmissing!"><code>dropmissing!</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; df = DataFrame(i=1:5,
                      x=[missing, 4, missing, 2, 1],
                      y=[missing, missing, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;])
5×3 DataFrame
 Row │ i      x        y
     │ Int64  Int64?   String?
─────┼─────────────────────────
   1 │     1  missing  missing
   2 │     2        4  missing
   3 │     3  missing  c
   4 │     4        2  d
   5 │     5        1  e

julia&gt; dropmissing(df)
2×3 DataFrame
 Row │ i      x      y
     │ Int64  Int64  String
─────┼──────────────────────
   1 │     4      2  d
   2 │     5      1  e

julia&gt; dropmissing(df, disallowmissing=false)
2×3 DataFrame
 Row │ i      x       y
     │ Int64  Int64?  String?
─────┼────────────────────────
   1 │     4       2  d
   2 │     5       1  e

julia&gt; dropmissing(df, :x)
3×3 DataFrame
 Row │ i      x      y
     │ Int64  Int64  String?
─────┼───────────────────────
   1 │     2      4  missing
   2 │     4      2  d
   3 │     5      1  e

julia&gt; dropmissing(df, [:x, :y])
2×3 DataFrame
 Row │ i      x      y
     │ Int64  Int64  String
─────┼──────────────────────
   1 │     4      2  d
   2 │     5      1  e</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/10c5b5e9e7f916024b2f102d040fdd9d4e6bd371/src/abstractdataframe/abstractdataframe.jl#L840-L907">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFrames.dropmissing!" href="#DataFrames.dropmissing!"><code>DataFrames.dropmissing!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">dropmissing!(df::AbstractDataFrame, cols=:; disallowmissing::Bool=true)</code></pre><p>Remove rows with missing values from data frame <code>df</code> and return it.</p><p>If <code>cols</code> is provided, only missing values in the corresponding columns are considered. <code>cols</code> can be any column selector (<code>Symbol</code>, string or integer; <code>:</code>, <code>Cols</code>, <code>All</code>, <code>Between</code>, <code>Not</code>, a regular expression, or a vector of <code>Symbol</code>s, strings or integers).</p><p>If <code>disallowmissing</code> is <code>true</code> (the default) then the <code>cols</code> columns will get converted using <a href="#DataFrames.disallowmissing!"><code>disallowmissing!</code></a>.</p><p>See also: <a href="#DataFrames.dropmissing"><code>dropmissing</code></a> and <a href="#DataFrames.completecases"><code>completecases</code></a>.</p><pre><code class="language-julia-repl hljs">julia&gt; df = DataFrame(i=1:5,
                      x=[missing, 4, missing, 2, 1],
                      y=[missing, missing, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;])
5×3 DataFrame
 Row │ i      x        y
     │ Int64  Int64?   String?
─────┼─────────────────────────
   1 │     1  missing  missing
   2 │     2        4  missing
   3 │     3  missing  c
   4 │     4        2  d
   5 │     5        1  e

julia&gt; dropmissing!(copy(df))
2×3 DataFrame
 Row │ i      x      y
     │ Int64  Int64  String
─────┼──────────────────────
   1 │     4      2  d
   2 │     5      1  e

julia&gt; dropmissing!(copy(df), disallowmissing=false)
2×3 DataFrame
 Row │ i      x       y
     │ Int64  Int64?  String?
─────┼────────────────────────
   1 │     4       2  d
   2 │     5       1  e

julia&gt; dropmissing!(copy(df), :x)
3×3 DataFrame
 Row │ i      x      y
     │ Int64  Int64  String?
─────┼───────────────────────
   1 │     2      4  missing
   2 │     4      2  d
   3 │     5      1  e

julia&gt; dropmissing!(df, [:x, :y])
2×3 DataFrame
 Row │ i      x      y
     │ Int64  Int64  String
─────┼──────────────────────
   1 │     4      2  d
   2 │     5      1  e</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/10c5b5e9e7f916024b2f102d040fdd9d4e6bd371/src/abstractdataframe/abstractdataframe.jl#L924-L984">source</a></section></article><h2 id="Iteration"><a class="docs-heading-anchor" href="#Iteration">Iteration</a><a id="Iteration-1"></a><a class="docs-heading-anchor-permalink" href="#Iteration" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Base.eachcol" href="#Base.eachcol"><code>Base.eachcol</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">eachcol(df::AbstractDataFrame)</code></pre><p>Return a <code>DataFrameColumns</code> object that is a vector-like that allows iterating an <code>AbstractDataFrame</code> column by column.</p><p>Indexing into <code>DataFrameColumns</code> objects using integer, <code>Symbol</code> or string returns the corresponding column (without copying). Indexing into <code>DataFrameColumns</code> objects using a multiple column selector returns a subsetted <code>DataFrameColumns</code> object with a new parent containing only the selected columns (without copying).</p><p><code>DataFrameColumns</code> supports most of the <code>AbstractVector</code> API. The key differences are that it is read-only and that the <code>keys</code> function returns a vector of <code>Symbol</code>s (and not integers as for normal vectors).</p><p>In particular <code>findnext</code>, <code>findprev</code>, <code>findfirst</code>, <code>findlast</code>, and <code>findall</code> functions are supported, and in <code>findnext</code> and <code>findprev</code> functions it is allowed to pass an integer, string, or <code>Symbol</code> as a reference index.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; df = DataFrame(x=1:4, y=11:14)
4×2 DataFrame
 Row │ x      y
     │ Int64  Int64
─────┼──────────────
   1 │     1     11
   2 │     2     12
   3 │     3     13
   4 │     4     14

julia&gt; eachcol(df)
4×2 DataFrameColumns
 Row │ x      y
     │ Int64  Int64
─────┼──────────────
   1 │     1     11
   2 │     2     12
   3 │     3     13
   4 │     4     14

julia&gt; collect(eachcol(df))
2-element Vector{AbstractVector}:
 [1, 2, 3, 4]
 [11, 12, 13, 14]

julia&gt; map(eachcol(df)) do col
           maximum(col) - minimum(col)
       end
2-element Vector{Int64}:
 3
 3

julia&gt; sum.(eachcol(df))
2-element Vector{Int64}:
 10
 50</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/10c5b5e9e7f916024b2f102d040fdd9d4e6bd371/src/abstractdataframe/iteration.jl#L125-L172">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.eachrow" href="#Base.eachrow"><code>Base.eachrow</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">eachrow(df::AbstractDataFrame)</code></pre><p>Return a <code>DataFrameRows</code> that iterates a data frame row by row, with each row represented as a <code>DataFrameRow</code>.</p><p>Because <code>DataFrameRow</code>s have an <code>eltype</code> of <code>Any</code>, use <code>copy(dfr::DataFrameRow)</code> to obtain a named tuple, which supports iteration and property access like a <code>DataFrameRow</code>, but also passes information on the <code>eltypes</code> of the columns of <code>df</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; df = DataFrame(x=1:4, y=11:14)
4×2 DataFrame
 Row │ x      y
     │ Int64  Int64
─────┼──────────────
   1 │     1     11
   2 │     2     12
   3 │     3     13
   4 │     4     14

julia&gt; eachrow(df)
4×2 DataFrameRows
 Row │ x      y
     │ Int64  Int64
─────┼──────────────
   1 │     1     11
   2 │     2     12
   3 │     3     13
   4 │     4     14

julia&gt; copy.(eachrow(df))
4-element Vector{NamedTuple{(:x, :y), Tuple{Int64, Int64}}}:
 (x = 1, y = 11)
 (x = 2, y = 12)
 (x = 3, y = 13)
 (x = 4, y = 14)

julia&gt; eachrow(view(df, [4, 3], [2, 1]))
2×2 DataFrameRows
 Row │ y      x
     │ Int64  Int64
─────┼──────────────
   1 │    14      4
   2 │    13      3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/10c5b5e9e7f916024b2f102d040fdd9d4e6bd371/src/abstractdataframe/iteration.jl#L27-L74">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.values" href="#Base.values"><code>Base.values</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">values(dfc::DataFrameColumns)</code></pre><p>Get a vector of columns from <code>dfc</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/10c5b5e9e7f916024b2f102d040fdd9d4e6bd371/src/abstractdataframe/iteration.jl#L230-L234">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.pairs" href="#Base.pairs"><code>Base.pairs</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pairs(dfc::DataFrameColumns)</code></pre><p>Return an iterator of pairs associating the name of each column of <code>dfc</code> with the corresponding column vector, i.e. <code>name =&gt; col</code> where <code>name</code> is the column name of the column <code>col</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/10c5b5e9e7f916024b2f102d040fdd9d4e6bd371/src/abstractdataframe/iteration.jl#L237-L243">source</a></section></article><h2 id="Equality"><a class="docs-heading-anchor" href="#Equality">Equality</a><a id="Equality-1"></a><a class="docs-heading-anchor-permalink" href="#Equality" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Base.isapprox" href="#Base.isapprox"><code>Base.isapprox</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">isapprox(df1::AbstractDataFrame, df2::AbstractDataFrame;
         rtol::Real=atol&gt;0 ? 0 : √eps, atol::Real=0,
         nans::Bool=false, norm::Function=norm)</code></pre><p>Inexact equality comparison. <code>df1</code> and <code>df2</code> must have the same size and column names. Return  <code>true</code> if <code>isapprox</code> with given keyword arguments applied to all pairs of columns stored in <code>df1</code> and <code>df2</code> returns <code>true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/10c5b5e9e7f916024b2f102d040fdd9d4e6bd371/src/abstractdataframe/abstractdataframe.jl#L444-L452">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../types/">« Types</a><a class="docs-footer-nextpage" href="../indexing/">Indexing »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Monday 19 September 2022 15:54">Monday 19 September 2022</span>. Using Julia version 1.8.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
