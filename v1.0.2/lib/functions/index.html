<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Functions · DataFrames.jl</title><link rel="canonical" href="https://juliadata.github.io/DataFrames.jl/stable/lib/functions/"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="DataFrames.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">DataFrames.jl</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><span class="tocitem">User Guide</span><ul><li><a class="tocitem" href="../../man/getting_started/">Getting Started</a></li><li><a class="tocitem" href="../../man/working_with_dataframes/">Working with DataFrames</a></li><li><a class="tocitem" href="../../man/importing_and_exporting/">Importing and Exporting Data (I/O)</a></li><li><a class="tocitem" href="../../man/joins/">Joins</a></li><li><a class="tocitem" href="../../man/split_apply_combine/">Split-apply-combine</a></li><li><a class="tocitem" href="../../man/reshaping_and_pivoting/">Reshaping</a></li><li><a class="tocitem" href="../../man/sorting/">Sorting</a></li><li><a class="tocitem" href="../../man/categorical/">Categorical Data</a></li><li><a class="tocitem" href="../../man/missing/">Missing Data</a></li><li><a class="tocitem" href="../../man/querying_frameworks/">Data manipulation frameworks</a></li><li><a class="tocitem" href="../../man/comparisons/">Comparison with Python/R/Stata</a></li></ul></li><li><span class="tocitem">API</span><ul><li><a class="tocitem" href="../types/">Types</a></li><li class="is-active"><a class="tocitem" href>Functions</a><ul class="internal"><li><a class="tocitem" href="#Constructing-data-frames"><span>Constructing data frames</span></a></li><li><a class="tocitem" href="#Summary-information"><span>Summary information</span></a></li><li><a class="tocitem" href="#Working-with-column-names"><span>Working with column names</span></a></li><li><a class="tocitem" href="#Mutating-and-transforming-data-frames-and-grouped-data-frames"><span>Mutating and transforming data frames and grouped data frames</span></a></li><li><a class="tocitem" href="#Reshaping-data-frames-between-tall-and-wide-formats"><span>Reshaping data frames between tall and wide formats</span></a></li><li><a class="tocitem" href="#Sorting"><span>Sorting</span></a></li><li><a class="tocitem" href="#Joining"><span>Joining</span></a></li><li><a class="tocitem" href="#Grouping"><span>Grouping</span></a></li><li><a class="tocitem" href="#Filtering-rows"><span>Filtering rows</span></a></li><li><a class="tocitem" href="#Working-with-missing-values"><span>Working with missing values</span></a></li><li><a class="tocitem" href="#Iteration"><span>Iteration</span></a></li><li><a class="tocitem" href="#Equality"><span>Equality</span></a></li></ul></li><li><a class="tocitem" href="../indexing/">Indexing</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">API</a></li><li class="is-active"><a href>Functions</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Functions</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaData/DataFrames.jl/blob/master/docs/src/lib/functions.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Functions"><a class="docs-heading-anchor" href="#Functions">Functions</a><a id="Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Functions" title="Permalink"></a></h1><ul><li><a href="#Base.Iterators.only"><code>Base.Iterators.only</code></a></li><li><a href="#Base.append!"><code>Base.append!</code></a></li><li><a href="#Base.copy"><code>Base.copy</code></a></li><li><a href="#Base.delete!"><code>Base.delete!</code></a></li><li><a href="#Base.eachcol"><code>Base.eachcol</code></a></li><li><a href="#Base.eachrow"><code>Base.eachrow</code></a></li><li><a href="#Base.empty"><code>Base.empty</code></a></li><li><a href="#Base.empty!"><code>Base.empty!</code></a></li><li><a href="#Base.filter"><code>Base.filter</code></a></li><li><a href="#Base.filter!"><code>Base.filter!</code></a></li><li><a href="#Base.first"><code>Base.first</code></a></li><li><a href="#Base.get"><code>Base.get</code></a></li><li><a href="#Base.hcat"><code>Base.hcat</code></a></li><li><a href="#Base.isapprox"><code>Base.isapprox</code></a></li><li><a href="#Base.issorted"><code>Base.issorted</code></a></li><li><a href="#Base.keys"><code>Base.keys</code></a></li><li><a href="#Base.last"><code>Base.last</code></a></li><li><a href="#Base.length"><code>Base.length</code></a></li><li><a href="#Base.names"><code>Base.names</code></a></li><li><a href="#Base.ndims"><code>Base.ndims</code></a></li><li><a href="#Base.pairs"><code>Base.pairs</code></a></li><li><a href="#Base.parent"><code>Base.parent</code></a></li><li><a href="#Base.permutedims"><code>Base.permutedims</code></a></li><li><a href="#Base.propertynames"><code>Base.propertynames</code></a></li><li><a href="#Base.push!"><code>Base.push!</code></a></li><li><a href="#Base.reduce"><code>Base.reduce</code></a></li><li><a href="#Base.repeat"><code>Base.repeat</code></a></li><li><a href="#Base.show"><code>Base.show</code></a></li><li><a href="#Base.similar"><code>Base.similar</code></a></li><li><a href="#Base.size"><code>Base.size</code></a></li><li><a href="#Base.sort"><code>Base.sort</code></a></li><li><a href="#Base.sort!"><code>Base.sort!</code></a></li><li><a href="#Base.sortperm"><code>Base.sortperm</code></a></li><li><a href="#Base.unique"><code>Base.unique</code></a></li><li><a href="#Base.unique!"><code>Base.unique!</code></a></li><li><a href="#Base.values"><code>Base.values</code></a></li><li><a href="#Base.vcat"><code>Base.vcat</code></a></li><li><a href="#DataAPI.describe"><code>DataAPI.describe</code></a></li><li><a href="#DataFrames.allowmissing!"><code>DataFrames.allowmissing!</code></a></li><li><a href="#DataFrames.antijoin"><code>DataFrames.antijoin</code></a></li><li><a href="#DataFrames.combine"><code>DataFrames.combine</code></a></li><li><a href="#DataFrames.completecases"><code>DataFrames.completecases</code></a></li><li><a href="#DataFrames.crossjoin"><code>DataFrames.crossjoin</code></a></li><li><a href="#DataFrames.disallowmissing!"><code>DataFrames.disallowmissing!</code></a></li><li><a href="#DataFrames.dropmissing"><code>DataFrames.dropmissing</code></a></li><li><a href="#DataFrames.dropmissing!"><code>DataFrames.dropmissing!</code></a></li><li><a href="#DataFrames.flatten"><code>DataFrames.flatten</code></a></li><li><a href="#DataFrames.groupby"><code>DataFrames.groupby</code></a></li><li><a href="#DataFrames.groupcols"><code>DataFrames.groupcols</code></a></li><li><a href="#DataFrames.groupindices"><code>DataFrames.groupindices</code></a></li><li><a href="#DataFrames.innerjoin"><code>DataFrames.innerjoin</code></a></li><li><a href="#DataFrames.insertcols!"><code>DataFrames.insertcols!</code></a></li><li><a href="#DataFrames.leftjoin"><code>DataFrames.leftjoin</code></a></li><li><a href="#DataFrames.mapcols"><code>DataFrames.mapcols</code></a></li><li><a href="#DataFrames.mapcols!"><code>DataFrames.mapcols!</code></a></li><li><a href="#DataFrames.ncol"><code>DataFrames.ncol</code></a></li><li><a href="#DataFrames.nonunique"><code>DataFrames.nonunique</code></a></li><li><a href="#DataFrames.nrow"><code>DataFrames.nrow</code></a></li><li><a href="#DataFrames.order"><code>DataFrames.order</code></a></li><li><a href="#DataFrames.outerjoin"><code>DataFrames.outerjoin</code></a></li><li><a href="#DataFrames.rename"><code>DataFrames.rename</code></a></li><li><a href="#DataFrames.rename!"><code>DataFrames.rename!</code></a></li><li><a href="#DataFrames.repeat!"><code>DataFrames.repeat!</code></a></li><li><a href="#DataFrames.rightjoin"><code>DataFrames.rightjoin</code></a></li><li><a href="#DataFrames.rownumber"><code>DataFrames.rownumber</code></a></li><li><a href="#DataFrames.select"><code>DataFrames.select</code></a></li><li><a href="#DataFrames.select!"><code>DataFrames.select!</code></a></li><li><a href="#DataFrames.semijoin"><code>DataFrames.semijoin</code></a></li><li><a href="#DataFrames.stack"><code>DataFrames.stack</code></a></li><li><a href="#DataFrames.subset"><code>DataFrames.subset</code></a></li><li><a href="#DataFrames.subset!"><code>DataFrames.subset!</code></a></li><li><a href="#DataFrames.transform"><code>DataFrames.transform</code></a></li><li><a href="#DataFrames.transform!"><code>DataFrames.transform!</code></a></li><li><a href="#DataFrames.unstack"><code>DataFrames.unstack</code></a></li><li><a href="#DataFrames.valuecols"><code>DataFrames.valuecols</code></a></li><li><a href="#Missings.allowmissing"><code>Missings.allowmissing</code></a></li><li><a href="#Missings.disallowmissing"><code>Missings.disallowmissing</code></a></li></ul><h2 id="Constructing-data-frames"><a class="docs-heading-anchor" href="#Constructing-data-frames">Constructing data frames</a><a id="Constructing-data-frames-1"></a><a class="docs-heading-anchor-permalink" href="#Constructing-data-frames" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Base.copy" href="#Base.copy"><code>Base.copy</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">copy(df::DataFrame; copycols::Bool=true)</code></pre><p>Copy data frame <code>df</code>. If <code>copycols=true</code> (the default), return a new  <code>DataFrame</code> holding copies of column vectors in <code>df</code>. If <code>copycols=false</code>, return a new <code>DataFrame</code> sharing column vectors with <code>df</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/6e35e296fbdef047cfdb043d54f80375331b47b5/src/dataframe/dataframe.jl#L924-L931">source</a></section><section><div><pre><code class="language-none">copy(dfr::DataFrameRow)</code></pre><p>Construct a <code>NamedTuple</code> with the same contents as the <a href="../types/#DataFrames.DataFrameRow"><code>DataFrameRow</code></a>. This method returns a <code>NamedTuple</code> so that the returned object is not affected by changes to the parent data frame of which <code>dfr</code> is a view.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/6e35e296fbdef047cfdb043d54f80375331b47b5/src/dataframerow/dataframerow.jl#L434-L441">source</a></section><section><div><pre><code class="language-none">copy(key::GroupKey)</code></pre><p>Construct a <code>NamedTuple</code> with the same contents as the <a href="../types/#DataFrames.GroupKey"><code>GroupKey</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/6e35e296fbdef047cfdb043d54f80375331b47b5/src/groupeddataframe/groupeddataframe.jl#L573-L577">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.similar" href="#Base.similar"><code>Base.similar</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">similar(df::AbstractDataFrame, rows::Integer=nrow(df))</code></pre><p>Create a new <code>DataFrame</code> with the same column names and column element types as <code>df</code>. An optional second argument can be provided to request a number of rows that is different than the number of rows present in <code>df</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/6e35e296fbdef047cfdb043d54f80375331b47b5/src/abstractdataframe/abstractdataframe.jl#L373-L379">source</a></section></article><h2 id="Summary-information"><a class="docs-heading-anchor" href="#Summary-information">Summary information</a><a id="Summary-information-1"></a><a class="docs-heading-anchor-permalink" href="#Summary-information" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="DataAPI.describe" href="#DataAPI.describe"><code>DataAPI.describe</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">describe(df::AbstractDataFrame; cols=:)
describe(df::AbstractDataFrame, stats::Union{Symbol, Pair}...; cols=:)</code></pre><p>Return descriptive statistics for a data frame as a new <code>DataFrame</code> where each row represents a variable and each column a summary statistic.</p><p><strong>Arguments</strong></p><ul><li><code>df</code> : the <code>AbstractDataFrame</code></li><li><code>stats::Union{Symbol, Pair}...</code> : the summary statistics to report. Arguments can be:<ul><li>A symbol from the list <code>:mean</code>, <code>:std</code>, <code>:min</code>, <code>:q25</code>, <code>:median</code>, <code>:q75</code>, <code>:max</code>, <code>:eltype</code>, <code>:nunique</code>, <code>:first</code>, <code>:last</code>, and <code>:nmissing</code>. The default statistics used are <code>:mean</code>, <code>:min</code>, <code>:median</code>, <code>:max</code>, <code>:nmissing</code>, and <code>:eltype</code>.</li><li><code>:all</code> as the only <code>Symbol</code> argument to return all statistics.</li><li>A <code>function =&gt; name</code> pair where <code>name</code> is a <code>Symbol</code> or string. This will create a column of summary statistics with the provided name.</li></ul></li><li><code>cols</code> : a keyword argument allowing to select only a subset or transformation of columns from <code>df</code> to describe. Can be any column selector or transformation accepted by <a href="#DataFrames.select"><code>select</code></a>.</li></ul><p><strong>Details</strong></p><p>For <code>Real</code> columns, compute the mean, standard deviation, minimum, first quantile, median, third quantile, and maximum. If a column does not derive from <code>Real</code>, <code>describe</code> will attempt to calculate all statistics, using <code>nothing</code> as a fall-back in the case of an error.</p><p>When <code>stats</code> contains <code>:nunique</code>, <code>describe</code> will report the number of unique values in a column. If a column&#39;s base type derives from <code>Real</code>, <code>:nunique</code> will return <code>nothing</code>s.</p><p>Missing values are filtered in the calculation of all statistics, however the column <code>:nmissing</code> will report the number of missing values of that variable.</p><p>If custom functions are provided, they are called repeatedly with the vector corresponding to each column as the only argument. For columns allowing for missing values, the vector is wrapped in a call to <code>skipmissing</code>: custom functions must therefore support such objects (and not only vectors), and cannot access missing values.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; df = DataFrame(i=1:10, x=0.1:0.1:1.0, y=&#39;a&#39;:&#39;j&#39;);

julia&gt; describe(df)
3×7 DataFrame
 Row │ variable  mean    min  median  max  nmissing  eltype
     │ Symbol    Union…  Any  Union…  Any  Int64     DataType
─────┼────────────────────────────────────────────────────────
   1 │ i         5.5     1    5.5     10          0  Int64
   2 │ x         0.55    0.1  0.55    1.0         0  Float64
   3 │ y                 a            j           0  Char

julia&gt; describe(df, :min, :max)
3×3 DataFrame
 Row │ variable  min  max
     │ Symbol    Any  Any
─────┼────────────────────
   1 │ i         1    10
   2 │ x         0.1  1.0
   3 │ y         a    j

julia&gt; describe(df, :min, sum =&gt; :sum)
3×3 DataFrame
 Row │ variable  min  sum
     │ Symbol    Any  Union…
─────┼───────────────────────
   1 │ i         1    55
   2 │ x         0.1  5.5
   3 │ y         a

julia&gt; describe(df, :min, sum =&gt; :sum, cols=:x)
1×3 DataFrame
 Row │ variable  min      sum
     │ Symbol    Float64  Float64
─────┼────────────────────────────
   1 │ x             0.1      5.5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/6e35e296fbdef047cfdb043d54f80375331b47b5/src/abstractdataframe/abstractdataframe.jl#L488-L567">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.length" href="#Base.length"><code>Base.length</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">length(dfr::DataFrameRow)</code></pre><p>Return the number of elements of <code>dfr</code>.</p><p>See also: <a href="#Base.size"><code>size</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; dfr = DataFrame(a=1:3, b=&#39;a&#39;:&#39;c&#39;)[1, :]
DataFrameRow
 Row │ a      b
     │ Int64  Char
─────┼─────────────
   1 │     1  a

julia&gt; length(dfr)
2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/6e35e296fbdef047cfdb043d54f80375331b47b5/src/dataframerow/dataframerow.jl#L352-L371">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFrames.ncol" href="#DataFrames.ncol"><code>DataFrames.ncol</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">nrow(df::AbstractDataFrame)
ncol(df::AbstractDataFrame)</code></pre><p>Return the number of rows or columns in an <code>AbstractDataFrame</code> <code>df</code>.</p><p>See also <a href="#Base.size"><code>size</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; df = DataFrame(i = 1:10, x = rand(10), y = rand([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;], 10));

julia&gt; size(df)
(10, 3)

julia&gt; nrow(df)
10

julia&gt; ncol(df)
3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/6e35e296fbdef047cfdb043d54f80375331b47b5/src/abstractdataframe/abstractdataframe.jl#L1892-L1915">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.ndims" href="#Base.ndims"><code>Base.ndims</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">ndims(::AbstractDataFrame)
ndims(::Type{&lt;:AbstractDataFrame})</code></pre><p>Return the number of dimensions of a data frame, which is always <code>2</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/6e35e296fbdef047cfdb043d54f80375331b47b5/src/abstractdataframe/abstractdataframe.jl#L346-L351">source</a></section><section><div><pre><code class="language-none">ndims(::DataFrameRow)
ndims(::Type{&lt;:DataFrameRow})</code></pre><p>Return the number of dimensions of a data frame row, which is always <code>1</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/6e35e296fbdef047cfdb043d54f80375331b47b5/src/dataframerow/dataframerow.jl#L374-L379">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFrames.nrow" href="#DataFrames.nrow"><code>DataFrames.nrow</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">nrow(df::AbstractDataFrame)
ncol(df::AbstractDataFrame)</code></pre><p>Return the number of rows or columns in an <code>AbstractDataFrame</code> <code>df</code>.</p><p>See also <a href="#Base.size"><code>size</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; df = DataFrame(i = 1:10, x = rand(10), y = rand([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;], 10));

julia&gt; size(df)
(10, 3)

julia&gt; nrow(df)
10

julia&gt; ncol(df)
3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/6e35e296fbdef047cfdb043d54f80375331b47b5/src/abstractdataframe/abstractdataframe.jl#L1892-L1915">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFrames.rownumber" href="#DataFrames.rownumber"><code>DataFrames.rownumber</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">rownumber(dfr::DataFrameRow)</code></pre><p>Return a row number in the <code>AbstractDataFrame</code> that <code>dfr</code> was created from.</p><p>Note that this differs from the first element in the tuple returned by <code>parentindices</code>. The latter gives the row number in the <code>parent(dfr)</code>, which is the source <code>DataFrame</code> where data that <code>dfr</code> gives access to is stored.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; df = DataFrame(reshape(1:12, 3, 4), :auto)
3×4 DataFrame
 Row │ x1     x2     x3     x4
     │ Int64  Int64  Int64  Int64
─────┼────────────────────────────
   1 │     1      4      7     10
   2 │     2      5      8     11
   3 │     3      6      9     12

julia&gt; dfr = df[2, :]
DataFrameRow
 Row │ x1     x2     x3     x4
     │ Int64  Int64  Int64  Int64
─────┼────────────────────────────
   2 │     2      5      8     11

julia&gt; rownumber(dfr)
2

julia&gt; parentindices(dfr)
(2, Base.OneTo(4))

julia&gt; parent(dfr)
3×4 DataFrame
 Row │ x1     x2     x3     x4
     │ Int64  Int64  Int64  Int64
─────┼────────────────────────────
   1 │     1      4      7     10
   2 │     2      5      8     11
   3 │     3      6      9     12

julia&gt; dfv = @view df[2:3, 1:3]
2×3 SubDataFrame
 Row │ x1     x2     x3
     │ Int64  Int64  Int64
─────┼─────────────────────
   1 │     2      5      8
   2 │     3      6      9

julia&gt; dfrv = dfv[2, :]
DataFrameRow
 Row │ x1     x2     x3
     │ Int64  Int64  Int64
─────┼─────────────────────
   3 │     3      6      9

julia&gt; rownumber(dfrv)
2

julia&gt; parentindices(dfrv)
(3, 1:3)

julia&gt; parent(dfrv)
3×4 DataFrame
 Row │ x1     x2     x3     x4
     │ Int64  Int64  Int64  Int64
─────┼────────────────────────────
   1 │     1      4      7     10
   2 │     2      5      8     11
   3 │     3      6      9     12</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/6e35e296fbdef047cfdb043d54f80375331b47b5/src/dataframerow/dataframerow.jl#L121-L193">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.show" href="#Base.show"><code>Base.show</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">show([io::IO, ]df::AbstractDataFrame;
     allrows::Bool = !get(io, :limit, false),
     allcols::Bool = !get(io, :limit, false),
     allgroups::Bool = !get(io, :limit, false),
     rowlabel::Symbol = :Row,
     summary::Bool = true,
     eltypes::Bool = true,
     truncate::Int = 32,
     kwargs...)</code></pre><p>Render a data frame to an I/O stream. The specific visual representation chosen depends on the width of the display.</p><p>If <code>io</code> is omitted, the result is printed to <code>stdout</code>, and <code>allrows</code>, <code>allcols</code> and <code>allgroups</code> default to <code>false</code>.</p><p><strong>Arguments</strong></p><ul><li><code>io::IO</code>: The I/O stream to which <code>df</code> will be printed.</li><li><code>df::AbstractDataFrame</code>: The data frame to print.</li><li><code>allrows::Bool</code>: Whether to print all rows, rather than a subset that fits the device height. By default this is the case only if <code>io</code> does not have the <code>IOContext</code> property <code>limit</code> set.</li><li><code>allcols::Bool</code>: Whether to print all columns, rather than a subset that fits the device width. By default this is the case only if <code>io</code> does not have the <code>IOContext</code> property <code>limit</code> set.</li><li><code>allgroups::Bool</code>: Whether to print all groups rather than the first and last, when <code>df</code> is a <code>GroupedDataFrame</code>. By default this is the case only if <code>io</code> does not have the <code>IOContext</code> property <code>limit</code> set.</li><li><code>rowlabel::Symbol = :Row</code>: The label to use for the column containing row numbers.</li><li><code>summary::Bool = true</code>: Whether to print a brief string summary of the data frame.</li><li><code>eltypes::Bool = true</code>: Whether to print the column types under column names.</li><li><code>truncate::Int = 32</code>: the maximal display width the output can use before being truncated (in the <code>textwidth</code> sense, excluding <code>…</code>). If <code>truncate</code> is 0 or less, no truncation is applied.</li><li><code>kwargs...</code>: Any keyword argument supported by the function <code>pretty_table</code> of PrettyTables.jl can be passed here to customize the output.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using DataFrames

julia&gt; df = DataFrame(A = 1:3, B = [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;]);

julia&gt; show(df, show_row_number=false)
3×2 DataFrame
 A      B
 Int64  String
───────────────
     1  x
     2  y
     3  z</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/6e35e296fbdef047cfdb043d54f80375331b47b5/src/abstractdataframe/show.jl#L335-L389">source</a></section><section><div><pre><code class="language-none">show(io::IO, mime::MIME, df::AbstractDataFrame)</code></pre><p>Render a data frame to an I/O stream in MIME type <code>mime</code>.</p><p><strong>Arguments</strong></p><ul><li><code>io::IO</code>: The I/O stream to which <code>df</code> will be printed.</li><li><code>mime::MIME</code>: supported MIME types are: <code>&quot;text/plain&quot;</code>, <code>&quot;text/html&quot;</code>, <code>&quot;text/latex&quot;</code>, <code>&quot;text/csv&quot;</code>, <code>&quot;text/tab-separated-values&quot;</code> (the last two MIME types do not support  showing <code>#undef</code> values)</li><li><code>df::AbstractDataFrame</code>: The data frame to print.</li></ul><p>Additionally selected MIME types support passing the following keyword arguments:</p><ul><li>MIME type <code>&quot;text/plain&quot;</code> accepts all listed keyword arguments and therir behavior is identical as for <code>show(::IO, ::AbstractDataFrame)</code></li><li>MIME type <code>&quot;text/html&quot;</code> accepts <code>summary</code> keyword argument which allows to choose whether to print a brief string summary of the data frame.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; show(stdout, MIME(&quot;text/latex&quot;), DataFrame(A = 1:3, B = [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;]))
\begin{tabular}{r|cc}
	&amp; A &amp; B\\
	\hline
	&amp; Int64 &amp; String\\
	\hline
	1 &amp; 1 &amp; x \\
	2 &amp; 2 &amp; y \\
	3 &amp; 3 &amp; z \\
\end{tabular}
14

julia&gt; show(stdout, MIME(&quot;text/csv&quot;), DataFrame(A = 1:3, B = [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;]))
&quot;A&quot;,&quot;B&quot;
1,&quot;x&quot;
2,&quot;y&quot;
3,&quot;z&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/6e35e296fbdef047cfdb043d54f80375331b47b5/src/abstractdataframe/io.jl#L1-L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.size" href="#Base.size"><code>Base.size</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">size(df::AbstractDataFrame[, dim])</code></pre><p>Return a tuple containing the number of rows and columns of <code>df</code>. Optionally a dimension <code>dim</code> can be specified, where <code>1</code> corresponds to rows and <code>2</code> corresponds to columns.</p><p>See also: <a href="#DataFrames.nrow"><code>nrow</code></a>, <a href="#DataFrames.ncol"><code>ncol</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; df = DataFrame(a=1:3, b=&#39;a&#39;:&#39;c&#39;);

julia&gt; size(df)
(3, 2)

julia&gt; size(df, 1)
3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/6e35e296fbdef047cfdb043d54f80375331b47b5/src/abstractdataframe/abstractdataframe.jl#L307-L326">source</a></section><section><div><pre><code class="language-none">size(dfr::DataFrameRow[, dim])</code></pre><p>Return a 1-tuple containing the number of elements of <code>dfr</code>. If an optional dimension <code>dim</code> is specified, it must be <code>1</code>, and the number of elements is returned directly as a number.</p><p>See also: <a href="#Base.length"><code>length</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; dfr = DataFrame(a=1:3, b=&#39;a&#39;:&#39;c&#39;)[1, :]
DataFrameRow
 Row │ a      b
     │ Int64  Char
─────┼─────────────
   1 │     1  a

julia&gt; size(dfr)
(2,)

julia&gt; size(dfr, 1)
2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/6e35e296fbdef047cfdb043d54f80375331b47b5/src/dataframerow/dataframerow.jl#L324-L348">source</a></section></article><h2 id="Working-with-column-names"><a class="docs-heading-anchor" href="#Working-with-column-names">Working with column names</a><a id="Working-with-column-names-1"></a><a class="docs-heading-anchor-permalink" href="#Working-with-column-names" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Base.names" href="#Base.names"><code>Base.names</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">names(df::AbstractDataFrame)
names(df::AbstractDataFrame, cols)</code></pre><p>Return a freshly allocated <code>Vector{String}</code> of names of columns contained in <code>df</code>.</p><p>If <code>cols</code> is passed then restrict returned column names to those matching the selector (this is useful in particular with regular expressions, <code>Cols</code>, <code>Not</code>, and <code>Between</code>). <code>cols</code> can be:</p><ul><li>any column selector (<code>Symbol</code>, string or integer; <code>:</code>, <code>Cols</code>, <code>All</code>, <code>Between</code>, <code>Not</code>, a regular expression, or a vector of <code>Symbol</code>s, strings or integers)</li><li>a <code>Type</code>, in which case names of columns whose <code>eltype</code> is a subtype of <code>T</code> are returned</li><li>a <code>Function</code> predicate taking the column name as a string and returning <code>true</code> for columns that should be kept</li></ul><p>See also <a href="#Base.propertynames"><code>propertynames</code></a> which returns a <code>Vector{Symbol}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/6e35e296fbdef047cfdb043d54f80375331b47b5/src/abstractdataframe/abstractdataframe.jl#L63-L79">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.propertynames" href="#Base.propertynames"><code>Base.propertynames</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">propertynames(df::AbstractDataFrame)</code></pre><p>Return a freshly allocated <code>Vector{Symbol}</code> of names of columns contained in <code>df</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/6e35e296fbdef047cfdb043d54f80375331b47b5/src/abstractdataframe/abstractdataframe.jl#L360-L364">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFrames.rename" href="#DataFrames.rename"><code>DataFrames.rename</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">rename(df::AbstractDataFrame, vals::AbstractVector{Symbol};
       makeunique::Bool=false)
rename(df::AbstractDataFrame, vals::AbstractVector{&lt;:AbstractString};
       makeunique::Bool=false)
rename(df::AbstractDataFrame, (from =&gt; to)::Pair...)
rename(df::AbstractDataFrame, d::AbstractDict)
rename(df::AbstractDataFrame, d::AbstractVector{&lt;:Pair})
rename(f::Function, df::AbstractDataFrame)</code></pre><p>Create a new data frame that is a copy of <code>df</code> with changed column names. Each name is changed at most once. Permutation of names is allowed.</p><p><strong>Arguments</strong></p><ul><li><code>df</code> : the <code>AbstractDataFrame</code>; if it is a <code>SubDataFrame</code> then renaming is only allowed if it was created using <code>:</code> as a column selector.</li><li><code>d</code> : an <code>AbstractDict</code> or an <code>AbstractVector</code> of <code>Pair</code>s that maps the original names or column numbers to new names</li><li><code>f</code> : a function which for each column takes the old name as a <code>String</code> and returns the new name that gets converted to a <code>Symbol</code></li><li><code>vals</code> : new column names as a vector of <code>Symbol</code>s or <code>AbstractString</code>s of the same length as the number of columns in <code>df</code></li><li><code>makeunique</code> : if <code>false</code> (the default), an error will be raised if duplicate names are found; if <code>true</code>, duplicate names will be suffixed with <code>_i</code> (<code>i</code> starting at 1 for the first duplicate).</li></ul><p>If pairs are passed to <code>rename</code> (as positional arguments or in a dictionary or a vector) then:</p><ul><li><code>from</code> value can be a <code>Symbol</code>, an <code>AbstractString</code> or an <code>Integer</code>;</li><li><code>to</code> value can be a <code>Symbol</code> or an <code>AbstractString</code>.</li></ul><p>Mixing symbols and strings in <code>to</code> and <code>from</code> is not allowed.</p><p>See also: <a href="#DataFrames.rename!"><code>rename!</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; df = DataFrame(i = 1, x = 2, y = 3)
1×3 DataFrame
 Row │ i      x      y
     │ Int64  Int64  Int64
─────┼─────────────────────
   1 │     1      2      3

julia&gt; rename(df, :i =&gt; :A, :x =&gt; :X)
1×3 DataFrame
 Row │ A      X      y
     │ Int64  Int64  Int64
─────┼─────────────────────
   1 │     1      2      3

julia&gt; rename(df, :x =&gt; :y, :y =&gt; :x)
1×3 DataFrame
 Row │ i      y      x
     │ Int64  Int64  Int64
─────┼─────────────────────
   1 │     1      2      3

julia&gt; rename(df, [1 =&gt; :A, 2 =&gt; :X])
1×3 DataFrame
 Row │ A      X      y
     │ Int64  Int64  Int64
─────┼─────────────────────
   1 │     1      2      3

julia&gt; rename(df, Dict(&quot;i&quot; =&gt; &quot;A&quot;, &quot;x&quot; =&gt; &quot;X&quot;))
1×3 DataFrame
 Row │ A      X      y
     │ Int64  Int64  Int64
─────┼─────────────────────
   1 │     1      2      3

julia&gt; rename(uppercase, df)
1×3 DataFrame
 Row │ I      X      Y
     │ Int64  Int64  Int64
─────┼─────────────────────
   1 │     1      2      3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/6e35e296fbdef047cfdb043d54f80375331b47b5/src/abstractdataframe/abstractdataframe.jl#L220-L299">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFrames.rename!" href="#DataFrames.rename!"><code>DataFrames.rename!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">rename!(df::AbstractDataFrame, vals::AbstractVector{Symbol};
        makeunique::Bool=false)
rename!(df::AbstractDataFrame, vals::AbstractVector{&lt;:AbstractString};
        makeunique::Bool=false)
rename!(df::AbstractDataFrame, (from =&gt; to)::Pair...)
rename!(df::AbstractDataFrame, d::AbstractDict)
rename!(df::AbstractDataFrame, d::AbstractVector{&lt;:Pair})
rename!(f::Function, df::AbstractDataFrame)</code></pre><p>Rename columns of <code>df</code> in-place. Each name is changed at most once. Permutation of names is allowed.</p><p><strong>Arguments</strong></p><ul><li><code>df</code> : the <code>AbstractDataFrame</code></li><li><code>d</code> : an <code>AbstractDict</code> or an <code>AbstractVector</code> of <code>Pair</code>s that maps the original names or column numbers to new names</li><li><code>f</code> : a function which for each column takes the old name as a <code>String</code> and returns the new name that gets converted to a <code>Symbol</code></li><li><code>vals</code> : new column names as a vector of <code>Symbol</code>s or <code>AbstractString</code>s of the same length as the number of columns in <code>df</code></li><li><code>makeunique</code> : if <code>false</code> (the default), an error will be raised if duplicate names are found; if <code>true</code>, duplicate names will be suffixed with <code>_i</code> (<code>i</code> starting at 1 for the first duplicate).</li></ul><p>If pairs are passed to <code>rename!</code> (as positional arguments or in a dictionary or a vector) then:</p><ul><li><code>from</code> value can be a <code>Symbol</code>, an <code>AbstractString</code> or an <code>Integer</code>;</li><li><code>to</code> value can be a <code>Symbol</code> or an <code>AbstractString</code>.</li></ul><p>Mixing symbols and strings in <code>to</code> and <code>from</code> is not allowed.</p><p>See also: <a href="#DataFrames.rename"><code>rename</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; df = DataFrame(i = 1, x = 2, y = 3)
1×3 DataFrame
 Row │ i      x      y
     │ Int64  Int64  Int64
─────┼─────────────────────
   1 │     1      2      3

julia&gt; rename!(df, Dict(:i =&gt; &quot;A&quot;, :x =&gt; &quot;X&quot;))
1×3 DataFrame
 Row │ A      X      y
     │ Int64  Int64  Int64
─────┼─────────────────────
   1 │     1      2      3

julia&gt; rename!(df, [:a, :b, :c])
1×3 DataFrame
 Row │ a      b      c
     │ Int64  Int64  Int64
─────┼─────────────────────
   1 │     1      2      3

julia&gt; rename!(df, [:a, :b, :a])
ERROR: ArgumentError: Duplicate variable names: :a. Pass makeunique=true to make them unique using a suffix automatically.

julia&gt; rename!(df, [:a, :b, :a], makeunique=true)
1×3 DataFrame
 Row │ a      b      a_1
     │ Int64  Int64  Int64
─────┼─────────────────────
   1 │     1      2      3

julia&gt; rename!(uppercase, df)
1×3 DataFrame
 Row │ A      B      A_1
     │ Int64  Int64  Int64
─────┼─────────────────────
   1 │     1      2      3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/6e35e296fbdef047cfdb043d54f80375331b47b5/src/abstractdataframe/abstractdataframe.jl#L100-L174">source</a></section></article><h2 id="Mutating-and-transforming-data-frames-and-grouped-data-frames"><a class="docs-heading-anchor" href="#Mutating-and-transforming-data-frames-and-grouped-data-frames">Mutating and transforming data frames and grouped data frames</a><a id="Mutating-and-transforming-data-frames-and-grouped-data-frames-1"></a><a class="docs-heading-anchor-permalink" href="#Mutating-and-transforming-data-frames-and-grouped-data-frames" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Base.append!" href="#Base.append!"><code>Base.append!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">append!(df::DataFrame, df2::AbstractDataFrame; cols::Symbol=:setequal,
        promote::Bool=(cols in [:union, :subset]))
append!(df::DataFrame, table; cols::Symbol=:setequal,
        promote::Bool=(cols in [:union, :subset]))</code></pre><p>Add the rows of <code>df2</code> to the end of <code>df</code>. If the second argument <code>table</code> is not an <code>AbstractDataFrame</code> then it is converted using <code>DataFrame(table, copycols=false)</code> before being appended.</p><p>The exact behavior of <code>append!</code> depends on the <code>cols</code> argument:</p><ul><li>If <code>cols == :setequal</code> (this is the default) then <code>df2</code> must contain exactly the same columns as <code>df</code> (but possibly in a different order).</li><li>If <code>cols == :orderequal</code> then <code>df2</code> must contain the same columns in the same order (for <code>AbstractDict</code> this option requires that <code>keys(row)</code> matches <code>propertynames(df)</code> to allow for support of ordered dicts; however, if <code>df2</code> is a <code>Dict</code> an error is thrown as it is an unordered collection).</li><li>If <code>cols == :intersect</code> then <code>df2</code> may contain more columns than <code>df</code>, but all column names that are present in <code>df</code> must be present in <code>df2</code> and only these are used.</li><li>If <code>cols == :subset</code> then <code>append!</code> behaves like for <code>:intersect</code> but if some column is missing in <code>df2</code> then a <code>missing</code> value is pushed to <code>df</code>.</li><li>If <code>cols == :union</code> then <code>append!</code> adds columns missing in <code>df</code> that are present in <code>df2</code>, for columns present in <code>df</code> but missing in <code>df2</code> a <code>missing</code> value is pushed.</li></ul><p>If <code>promote=true</code> and element type of a column present in <code>df</code> does not allow the type of a pushed argument then a new column with a promoted element type allowing it is freshly allocated and stored in <code>df</code>. If <code>promote=false</code> an error is thrown.</p><p>The above rule has the following exceptions:</p><ul><li>If <code>df</code> has no columns then copies of columns from <code>df2</code> are added to it.</li><li>If <code>df2</code> has no columns then calling <code>append!</code> leaves <code>df</code> unchanged.</li></ul><p>Please note that <code>append!</code> must not be used on a <code>DataFrame</code> that contains columns that are aliases (equal when compared with <code>===</code>).</p><p><strong>See also</strong></p><p>Use <a href="#Base.push!"><code>push!</code></a> to add individual rows to a data frame and <a href="#Base.vcat"><code>vcat</code></a> to vertically concatenate data frames.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; df1 = DataFrame(A=1:3, B=1:3)
3×2 DataFrame
 Row │ A      B
     │ Int64  Int64
─────┼──────────────
   1 │     1      1
   2 │     2      2
   3 │     3      3

julia&gt; df2 = DataFrame(A=4.0:6.0, B=4:6)
3×2 DataFrame
 Row │ A        B
     │ Float64  Int64
─────┼────────────────
   1 │     4.0      4
   2 │     5.0      5
   3 │     6.0      6

julia&gt; append!(df1, df2);

julia&gt; df1
6×2 DataFrame
 Row │ A      B
     │ Int64  Int64
─────┼──────────────
   1 │     1      1
   2 │     2      2
   3 │     3      3
   4 │     4      4
   5 │     5      5
   6 │     6      6</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/6e35e296fbdef047cfdb043d54f80375331b47b5/src/dataframe/dataframe.jl#L1159-L1237">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFrames.combine" href="#DataFrames.combine"><code>DataFrames.combine</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">combine(df::AbstractDataFrame, args...; renamecols::Bool=true)
combine(f::Callable, df::AbstractDataFrame; renamecols::Bool=true)
combine(gd::GroupedDataFrame, args...;
        keepkeys::Bool=true, ungroup::Bool=true, renamecols::Bool=true)
combine(f::Base.Callable, gd::GroupedDataFrame;
        keepkeys::Bool=true, ungroup::Bool=true, renamecols::Bool=true)</code></pre><p>Create a new data frame that contains columns from <code>df</code> or <code>gd</code> specified by <code>args</code> and return it. The result can have any number of rows that is determined by the values returned by passed transformations.</p><p>Below detailed common rules for all transformation functions supported by DataFrames.jl are explained and compared.</p><p>All these operations are supported both for <code>AbstractDataFrame</code> (when split and combine steps are skipped) and <code>GroupedDataFrame</code>. Technically, <code>AbstractDataFrame</code> is just considered as being grouped on no columns (meaning it has a single group, or zero groups if it is empty). The only difference is that in this case the <code>keepkeys</code> and <code>ungroup</code> keyword arguments (described below) are not supported and a data frame is always returned, as there are no split and combine steps in this case.</p><p>In order to perform operations by groups you first need to create a <code>GroupedDataFrame</code> object from your data frame using the <code>groupby</code> function that takes two arguments: (1) a data frame to be grouped, and (2) a set of columns to group by.</p><p>Operations can then be applied on each group using one of the following functions:</p><ul><li><code>combine</code>: does not put restrictions on number of rows returned, the order of rows is specified by the order of groups in <code>GroupedDataFrame</code>; it is typically used to compute summary statistics by group;</li><li><code>select</code>: return a data frame with the number and order of rows exactly the same as the source data frame, including only new calculated columns; <code>select!</code> is an in-place version of <code>select</code>;</li><li><code>transform</code>: return a data frame with the number and order of rows exactly the same as the source data frame, including all columns from the source and new calculated columns; <code>transform!</code> is an in-place version of <code>transform</code>.</li></ul><p>All these functions take a specification of one or more functions to apply to each subset of the <code>DataFrame</code>. This specification can be of the following forms:</p><ol><li>standard column selectors (integers, <code>Symbol</code>s, strings, vectors of integers, vectors of <code>Symbol</code>s, vectors of strings, <code>All</code>, <code>Cols</code>, <code>:</code>, <code>Between</code>, <code>Not</code> and regular expressions)</li><li>a <code>cols =&gt; function</code> pair indicating that <code>function</code> should be called with positional arguments holding columns <code>cols</code>, which can be any valid column selector; in this case target column name is automatically generated and it is assumed that <code>function</code> returns a single value or a vector; the generated name is created by concatenating source column name and <code>function</code> name by default (see examples below).</li><li>a <code>cols =&gt; function =&gt; target_cols</code> form additionally explicitly specifying the target column or columns.</li><li>a <code>col =&gt; target_cols</code> pair, which renames the column <code>col</code> to <code>target_cols</code>, which must be single name (as a <code>Symbol</code> or a string).</li><li>a <code>nrow</code> or <code>nrow =&gt; target_cols</code> form which efficiently computes the number of rows in a group; without <code>target_cols</code> the new column is called <code>:nrow</code>, otherwise it must be single name (as a <code>Symbol</code> or a string).</li><li>vectors or matrices containing transformations specified by the <code>Pair</code> syntax described in points 2 to 5</li><li>a function which will be called with a <code>SubDataFrame</code> corresponding to each group; this form should be avoided due to its poor performance unless the number of groups is small or a very large number of columns are processed (in which case <code>SubDataFrame</code> avoids excessive compilation)</li></ol><p>All functions have two types of signatures. One of them takes a <code>GroupedDataFrame</code> as the first argument and an arbitrary number of transformations described above as following arguments. The second type of signature is when a <code>Function</code> or a <code>Type</code> is passed as the first argument and a <code>GroupedDataFrame</code> as the second argument (similar to <code>map</code>).</p><p>As a special rule, with the <code>cols =&gt; function</code> and <code>cols =&gt; function =&gt; target_cols</code> syntaxes, if <code>cols</code> is wrapped in an <code>AsTable</code> object then a <code>NamedTuple</code> containing columns selected by <code>cols</code> is passed to <code>function</code>.</p><p>What is allowed for <code>function</code> to return is determined by the <code>target_cols</code> value:</p><ol><li>If both <code>cols</code> and <code>target_cols</code> are omitted (so only a <code>function</code> is passed), then returning a data frame, a matrix, a <code>NamedTuple</code>, or a <code>DataFrameRow</code> will produce multiple columns in the result. Returning any other value produces a single column.</li><li>If <code>target_cols</code> is a <code>Symbol</code> or a string then the function is assumed to return a single column. In this case returning a data frame, a matrix, a <code>NamedTuple</code>, or a <code>DataFrameRow</code> raises an error.</li><li>If <code>target_cols</code> is a vector of <code>Symbol</code>s or strings or <code>AsTable</code> it is assumed that <code>function</code> returns multiple columns. If <code>function</code> returns one of <code>AbstractDataFrame</code>, <code>NamedTuple</code>, <code>DataFrameRow</code>, <code>AbstractMatrix</code> then rules described in point 1 above apply. If <code>function</code> returns an <code>AbstractVector</code> then each element of this vector must support the <code>keys</code> function, which must return a collection of <code>Symbol</code>s, strings or integers; the return value of <code>keys</code> must be identical for all elements. Then as many columns are created as there are elements in the return value of the <code>keys</code> function. If <code>target_cols</code> is <code>AsTable</code> then their names are set to be equal to the key names except if <code>keys</code> returns integers, in which case they are prefixed by <code>x</code> (so the column names are e.g. <code>x1</code>, <code>x2</code>, ...). If <code>target_cols</code> is a vector of <code>Symbol</code>s or strings then column names produced using the rules above are ignored and replaced by <code>target_cols</code> (the number of columns must be the same as the length of <code>target_cols</code> in this case). If <code>fun</code> returns a value of any other type then it is assumed that it is a table conforming to the Tables.jl API and the <code>Tables.columntable</code> function is called on it to get the resulting columns and their names. The names are retained when <code>target_cols</code> is <code>AsTable</code> and are replaced if <code>target_cols</code> is a vector of <code>Symbol</code>s or strings.</li></ol><p>In all of these cases, <code>function</code> can return either a single row or multiple rows. As a particular rule, values wrapped in a <code>Ref</code> or a <code>0</code>-dimensional <code>AbstractArray</code> are unwrapped and then treated as a single row.</p><p><code>select</code>/<code>select!</code> and <code>transform</code>/<code>transform!</code> always return a <code>DataFrame</code> with the same number and order of rows as the source (even if <code>GroupedDataFrame</code> had its groups reordered).</p><p>For <code>combine</code>, rows in the returned object appear in the order of groups in the <code>GroupedDataFrame</code>. The functions can return an arbitrary number of rows for each group, but the kind of returned object and the number and names of columns must be the same for all groups, except when a <code>DataFrame()</code> or <code>NamedTuple()</code> is returned, in which case a given group is skipped.</p><p>It is allowed to mix single values and vectors if multiple transformations are requested. In this case single value will be repeated to match the length of columns specified by returned vectors.</p><p>To apply <code>function</code> to each row instead of whole columns, it can be wrapped in a <code>ByRow</code> struct. <code>cols</code> can be any column indexing syntax, in which case <code>function</code> will be passed one argument for each of the columns specified by <code>cols</code> or a <code>NamedTuple</code> of them if specified columns are wrapped in <code>AsTable</code>. If <code>ByRow</code> is used it is allowed for <code>cols</code> to select an empty set of columns, in which case <code>function</code> is called for each row without any arguments and an empty <code>NamedTuple</code> is passed if empty set of columns is wrapped in <code>AsTable</code>.</p><p>If a collection of column names is passed then requesting duplicate column names in target data frame are accepted (e.g. <code>select!(df, [:a], :, r&quot;a&quot;)</code> is allowed) and only the first occurrence is used. In particular a syntax to move column <code>:col</code> to the first position in the data frame is <code>select!(df, :col, :)</code>. On the contrary, output column names of renaming, transformation and single column selection operations must be unique, so e.g. <code>select!(df, :a, :a =&gt; :a)</code> or <code>select!(df, :a, :a =&gt; ByRow(sin) =&gt; :a)</code> are not allowed.</p><p>As a general rule if <code>copycols=true</code> columns are copied and when <code>copycols=false</code> columns are reused if possible. Note, however, that including the same column several times in the data frame via renaming or transformations that return the same object without copying may create column aliases even if <code>copycols=true</code>. An example of such a situation is <code>select!(df, :a, :a =&gt; :b, :a =&gt; identity =&gt; :c)</code>. As a special case in <code>transform</code> and <code>transform!</code> column renaming always copies columns to avoid storing aliased columns in the target data frame.</p><p>If <code>df</code> is a <code>SubDataFrame</code> and <code>copycols=true</code> then a <code>DataFrame</code> is returned and the same copying rules apply as for a <code>DataFrame</code> input: this means in particular that selected columns will be copied. If <code>copycols=false</code>, a <code>SubDataFrame</code> is returned without copying columns.</p><p>If a <code>GroupedDataFrame</code> is passed, a separate task is spawned for each specified transformation; each transformation then spawns as many tasks as Julia threads, and splits processing of groups across them (however, currently transformations with optimized implementations like <code>sum</code> and transformations that return multiple rows use a single task for all groups). This allows for parallel operation when Julia was started with more than one thread. Passed transformation functions should therefore not modify global variables (i.e. they should be pure), or use locks to control parallel accesses. In the future, parallelism may be extended to other cases, so this requirement also holds for <code>DataFrame</code> inputs.</p><p><strong>Keyword arguments</strong></p><ul><li><code>renamecols::Bool=true</code> : whether in the <code>cols =&gt; function</code> form automatically generated column names should include the name of transformation functions or not.</li><li><code>keepkeys::Bool=true</code> : whether grouping columns of <code>gd</code> should be kept in the returned data frame.</li><li><code>ungroup::Bool=true</code> : whether the return value of the operation on <code>gd</code> should be a data frame or a <code>GroupedDataFrame</code>.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; df = DataFrame(a=1:3, b=4:6)
3×2 DataFrame
 Row │ a      b
     │ Int64  Int64
─────┼──────────────
   1 │     1      4
   2 │     2      5
   3 │     3      6

julia&gt; combine(df, :a =&gt; sum, nrow, renamecols=false)
1×2 DataFrame
 Row │ a      nrow
     │ Int64  Int64
─────┼──────────────
   1 │     6      3

julia&gt; combine(df, :a =&gt; ByRow(sin) =&gt; :c, :b)
3×2 DataFrame
 Row │ c         b
     │ Float64   Int64
─────┼─────────────────
   1 │ 0.841471      4
   2 │ 0.909297      5
   3 │ 0.14112       6

julia&gt; combine(df, :, [:a, :b] =&gt; (a, b) -&gt; a .+ b .- sum(b)/length(b))
3×3 DataFrame
 Row │ a      b      a_b_function
     │ Int64  Int64  Float64
─────┼────────────────────────────
   1 │     1      4           0.0
   2 │     2      5           2.0
   3 │     3      6           4.0

julia&gt; combine(df, names(df) .=&gt; [minimum maximum])
1×4 DataFrame
 Row │ a_minimum  b_minimum  a_maximum  b_maximum
     │ Int64      Int64      Int64      Int64
─────┼────────────────────────────────────────────
   1 │         1          4          3          6

julia&gt; using Statistics

julia&gt; combine(df, AsTable(:) =&gt; ByRow(mean), renamecols=false)
3×1 DataFrame
 Row │ a_b
     │ Float64
─────┼─────────
   1 │     2.5
   2 │     3.5
   3 │     4.5

julia&gt; combine(first, df)
1×2 DataFrame
 Row │ a      b
     │ Int64  Int64
─────┼──────────────
   1 │     1      4

julia&gt; df = DataFrame(a=1:3, b=4:6, c=7:9)
3×3 DataFrame
 Row │ a      b      c
     │ Int64  Int64  Int64
─────┼─────────────────────
   1 │     1      4      7
   2 │     2      5      8
   3 │     3      6      9

julia&gt; combine(df, AsTable(:) =&gt; ByRow(x -&gt; (mean=mean(x), std=std(x))) =&gt; :stats,
               AsTable(:) =&gt; ByRow(x -&gt; (mean=mean(x), std=std(x))) =&gt; AsTable)
3×3 DataFrame
 Row │ stats                    mean     std
     │ NamedTup…                Float64  Float64
─────┼───────────────────────────────────────────
   1 │ (mean = 4.0, std = 3.0)      4.0      3.0
   2 │ (mean = 5.0, std = 3.0)      5.0      3.0
   3 │ (mean = 6.0, std = 3.0)      6.0      3.0

julia&gt; df = DataFrame(a = repeat([1, 2, 3, 4], outer=[2]),
                      b = repeat([2, 1], outer=[4]),
                      c = 1:8);

julia&gt; gd = groupby(df, :a);

julia&gt; combine(gd, :c =&gt; sum, nrow)
4×3 DataFrame
 Row │ a      c_sum  nrow
     │ Int64  Int64  Int64
─────┼─────────────────────
   1 │     1      6      2
   2 │     2      8      2
   3 │     3     10      2
   4 │     4     12      2

julia&gt; combine(gd, :c =&gt; sum, nrow, ungroup=false)
GroupedDataFrame with 4 groups based on key: a
First Group (1 row): a = 1
 Row │ a      c_sum  nrow
     │ Int64  Int64  Int64
─────┼─────────────────────
   1 │     1      6      2
⋮
Last Group (1 row): a = 4
 Row │ a      c_sum  nrow
     │ Int64  Int64  Int64
─────┼─────────────────────
   1 │     4     12      2

julia&gt; combine(gd) do d # do syntax for the slower variant
           sum(d.c)
       end
4×2 DataFrame
 Row │ a      x1
     │ Int64  Int64
─────┼──────────────
   1 │     1      6
   2 │     2      8
   3 │     3     10
   4 │     4     12

julia&gt; combine(gd, :c =&gt; (x -&gt; sum(log, x)) =&gt; :sum_log_c) # specifying a name for target column
4×2 DataFrame
 Row │ a      sum_log_c
     │ Int64  Float64
─────┼──────────────────
   1 │     1    1.60944
   2 │     2    2.48491
   3 │     3    3.04452
   4 │     4    3.46574

julia&gt; combine(gd, [:b, :c] .=&gt; sum) # passing a vector of pairs
4×3 DataFrame
 Row │ a      b_sum  c_sum
     │ Int64  Int64  Int64
─────┼─────────────────────
   1 │     1      4      6
   2 │     2      2      8
   3 │     3      4     10
   4 │     4      2     12

julia&gt; combine(gd) do sdf # dropping group when DataFrame() is returned
          sdf.c[1] != 1 ? sdf : DataFrame()
       end
6×3 DataFrame
 Row │ a      b      c
     │ Int64  Int64  Int64
─────┼─────────────────────
   1 │     2      1      2
   2 │     2      1      6
   3 │     3      2      3
   4 │     3      2      7
   5 │     4      1      4
   6 │     4      1      8</code></pre><p><strong>auto-splatting, renaming and keepkeys</strong></p><pre><code class="language-julia-repl">julia&gt; df = DataFrame(a = repeat([1, 2, 3, 4], outer=[2]),
                      b = repeat([2, 1], outer=[4]),
                      c = 1:8);

julia&gt; gd = groupby(df, :a);

julia&gt; combine(gd, :b =&gt; :b1, :c =&gt; :c1, [:b, :c] =&gt; +, keepkeys=false)
8×3 DataFrame
 Row │ b1     c1     b_c_+
     │ Int64  Int64  Int64
─────┼─────────────────────
   1 │     2      1      3
   2 │     2      5      7
   3 │     1      2      3
   4 │     1      6      7
   5 │     2      3      5
   6 │     2      7      9
   7 │     1      4      5
   8 │     1      8      9</code></pre><p><strong>broadcasting and column expansion</strong></p><pre><code class="language-julia-repl">julia&gt; df = DataFrame(a = repeat([1, 2, 3, 4], outer=[2]),
                      b = repeat([2, 1], outer=[4]),
                      c = 1:8);

julia&gt; gd = groupby(df, :a);

julia&gt; combine(gd, :b, AsTable([:b, :c]) =&gt; ByRow(extrema) =&gt; [:min, :max])
8×4 DataFrame
 Row │ a      b      min    max
     │ Int64  Int64  Int64  Int64
─────┼────────────────────────────
   1 │     1      2      1      2
   2 │     1      2      2      5
   3 │     2      1      1      2
   4 │     2      1      1      6
   5 │     3      2      2      3
   6 │     3      2      2      7
   7 │     4      1      1      4
   8 │     4      1      1      8

julia&gt; combine(gd, [:b, :c] .=&gt; Ref) # preventing vector from being spread across multiple rows
4×3 DataFrame
 Row │ a      b_Ref      c_Ref
     │ Int64  SubArray…  SubArray…
─────┼─────────────────────────────
   1 │     1  [2, 2]     [1, 5]
   2 │     2  [1, 1]     [2, 6]
   3 │     3  [2, 2]     [3, 7]
   4 │     4  [1, 1]     [4, 8]

julia&gt; combine(gd, AsTable(Not(:a)) =&gt; Ref) # protecting result
4×2 DataFrame
 Row │ a      b_c_Ref
     │ Int64  NamedTup…
─────┼─────────────────────────────────
   1 │     1  (b = [2, 2], c = [1, 5])
   2 │     2  (b = [1, 1], c = [2, 6])
   3 │     3  (b = [2, 2], c = [3, 7])
   4 │     4  (b = [1, 1], c = [4, 8])

julia&gt; combine(gd, :, AsTable(Not(:a)) =&gt; sum, renamecols=false)
8×4 DataFrame
 Row │ a      b      c      b_c
     │ Int64  Int64  Int64  Int64
─────┼────────────────────────────
   1 │     1      2      1      3
   2 │     1      2      5      7
   3 │     2      1      2      3
   4 │     2      1      6      7
   5 │     3      2      3      5
   6 │     3      2      7      9
   7 │     4      1      4      5
   8 │     4      1      8      9</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/6e35e296fbdef047cfdb043d54f80375331b47b5/src/abstractdataframe/selection.jl#L1014-L1272">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFrames.flatten" href="#DataFrames.flatten"><code>DataFrames.flatten</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">flatten(df::AbstractDataFrame, cols)</code></pre><p>When columns <code>cols</code> of data frame <code>df</code> have iterable elements that define <code>length</code> (for example a <code>Vector</code> of <code>Vector</code>s), return a <code>DataFrame</code> where each element of each <code>col</code> in <code>cols</code> is flattened, meaning the column corresponding to <code>col</code> becomes a longer vector where the original entries are concatenated. Elements of row <code>i</code> of <code>df</code> in columns other than <code>cols</code> will be repeated according to the length of <code>df[i, col]</code>. These lengths must therefore be the same for each <code>col</code> in <code>cols</code>, or else an error is raised. Note that these elements are not copied, and thus if they are mutable changing them in the returned <code>DataFrame</code> will affect <code>df</code>.</p><p><code>cols</code> can be any column selector (<code>Symbol</code>, string or integer; <code>:</code>, <code>Cols</code>, <code>All</code>, <code>Between</code>, <code>Not</code>, a regular expression, or a vector of <code>Symbol</code>s, strings or integers).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; df1 = DataFrame(a = [1, 2], b = [[1, 2], [3, 4]], c = [[5, 6], [7, 8]])
2×3 DataFrame
 Row │ a      b       c
     │ Int64  Array…  Array…
─────┼───────────────────────
   1 │     1  [1, 2]  [5, 6]
   2 │     2  [3, 4]  [7, 8]

julia&gt; flatten(df1, :b)
4×3 DataFrame
 Row │ a      b      c
     │ Int64  Int64  Array…
─────┼──────────────────────
   1 │     1      1  [5, 6]
   2 │     1      2  [5, 6]
   3 │     2      3  [7, 8]
   4 │     2      4  [7, 8]

julia&gt; flatten(df1, [:b, :c])
4×3 DataFrame
 Row │ a      b      c
     │ Int64  Int64  Int64
─────┼─────────────────────
   1 │     1      1      5
   2 │     1      2      6
   3 │     2      3      7
   4 │     2      4      8

julia&gt; df2 = DataFrame(a = [1, 2], b = [(&quot;p&quot;, &quot;q&quot;), (&quot;r&quot;, &quot;s&quot;)])
2×2 DataFrame
 Row │ a      b
     │ Int64  Tuple…
─────┼───────────────────
   1 │     1  (&quot;p&quot;, &quot;q&quot;)
   2 │     2  (&quot;r&quot;, &quot;s&quot;)

julia&gt; flatten(df2, :b)
4×2 DataFrame
 Row │ a      b
     │ Int64  String
─────┼───────────────
   1 │     1  p
   2 │     1  q
   3 │     2  r
   4 │     2  s

julia&gt; df3 = DataFrame(a = [1, 2], b = [[1, 2], [3, 4]], c = [[5, 6], [7]])
2×3 DataFrame
 Row │ a      b       c
     │ Int64  Array…  Array…
─────┼───────────────────────
   1 │     1  [1, 2]  [5, 6]
   2 │     2  [3, 4]  [7]

julia&gt; flatten(df3, [:b, :c])
ERROR: ArgumentError: Lengths of iterables stored in columns :b and :c are not the same in row 2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/6e35e296fbdef047cfdb043d54f80375331b47b5/src/abstractdataframe/abstractdataframe.jl#L2034-L2109">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.hcat" href="#Base.hcat"><code>Base.hcat</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">hcat(df::AbstractDataFrame...;
     makeunique::Bool=false, copycols::Bool=true)
hcat(df::AbstractDataFrame..., vs::AbstractVector;
     makeunique::Bool=false, copycols::Bool=true)
hcat(vs::AbstractVector, df::AbstractDataFrame;
     makeunique::Bool=false, copycols::Bool=true)</code></pre><p>Horizontally concatenate <code>AbstractDataFrames</code> and optionally <code>AbstractVector</code>s.</p><p>If <code>AbstractVector</code> is passed then a column name for it is automatically generated as <code>:x1</code> by default.</p><p>If <code>makeunique=false</code> (the default) column names of passed objects must be unique. If <code>makeunique=true</code> then duplicate column names will be suffixed with <code>_i</code> (<code>i</code> starting at 1 for the first duplicate).</p><p>If <code>copycols=true</code> (the default) then the <code>DataFrame</code> returned by <code>hcat</code> will contain copied columns from the source data frames. If <code>copycols=false</code> then it will contain columns as they are stored in the source (without copying). This option should be used with caution as mutating either the columns in sources or in the returned <code>DataFrame</code> might lead to the corruption of the other object.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; df1 = DataFrame(A=1:3, B=1:3)
3×2 DataFrame
 Row │ A      B
     │ Int64  Int64
─────┼──────────────
   1 │     1      1
   2 │     2      2
   3 │     3      3

julia&gt; df2 = DataFrame(A=4:6, B=4:6)
3×2 DataFrame
 Row │ A      B
     │ Int64  Int64
─────┼──────────────
   1 │     4      4
   2 │     5      5
   3 │     6      6

julia&gt; df3 = hcat(df1, df2, makeunique=true)
3×4 DataFrame
 Row │ A      B      A_1    B_1
     │ Int64  Int64  Int64  Int64
─────┼────────────────────────────
   1 │     1      1      4      4
   2 │     2      2      5      5
   3 │     3      3      6      6

julia&gt; df3.A === df1.A
false

julia&gt; df3 = hcat(df1, df2, makeunique=true, copycols=false);

julia&gt; df3.A === df1.A
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/6e35e296fbdef047cfdb043d54f80375331b47b5/src/abstractdataframe/abstractdataframe.jl#L1355-L1416">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFrames.insertcols!" href="#DataFrames.insertcols!"><code>DataFrames.insertcols!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">insertcols!(df::DataFrame[, col], (name=&gt;val)::Pair...;
            makeunique::Bool=false, copycols::Bool=true)</code></pre><p>Insert a column into a data frame in place. Return the updated <code>DataFrame</code>. If <code>col</code> is omitted it is set to <code>ncol(df)+1</code> (the column is inserted as the last column).</p><p><strong>Arguments</strong></p><ul><li><code>df</code> : the DataFrame to which we want to add columns</li><li><code>col</code> : a position at which we want to insert a column, passed as an integer or a column name (a string or a <code>Symbol</code>); the column selected with <code>col</code> and columns following it are shifted to the right in <code>df</code> after the operation</li><li><code>name</code> : the name of the new column</li><li><code>val</code> : an <code>AbstractVector</code> giving the contents of the new column or a value of any type other than <code>AbstractArray</code> which will be repeated to fill a new vector; As a particular rule a values stored in a <code>Ref</code> or a <code>0</code>-dimensional <code>AbstractArray</code> are unwrapped and treated in the same way.</li><li><code>makeunique</code> : Defines what to do if <code>name</code> already exists in <code>df</code>; if it is <code>false</code> an error will be thrown; if it is <code>true</code> a new unique name will be generated by adding a suffix</li><li><code>copycols</code> : whether vectors passed as columns should be copied</li></ul><p>If <code>val</code> is an <code>AbstractRange</code> then the result of <code>collect(val)</code> is inserted.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; df = DataFrame(a=1:3)
3×1 DataFrame
 Row │ a
     │ Int64
─────┼───────
   1 │     1
   2 │     2
   3 │     3

julia&gt; insertcols!(df, 1, :b =&gt; &#39;a&#39;:&#39;c&#39;)
3×2 DataFrame
 Row │ b     a
     │ Char  Int64
─────┼─────────────
   1 │ a         1
   2 │ b         2
   3 │ c         3

julia&gt; insertcols!(df, 2, :c =&gt; 2:4, :c =&gt; 3:5, makeunique=true)
3×4 DataFrame
 Row │ b     c      c_1    a
     │ Char  Int64  Int64  Int64
─────┼───────────────────────────
   1 │ a         2      3      1
   2 │ b         3      4      2
   3 │ c         4      5      3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/6e35e296fbdef047cfdb043d54f80375331b47b5/src/dataframe/dataframe.jl#L750-L804">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFrames.mapcols" href="#DataFrames.mapcols"><code>DataFrames.mapcols</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">mapcols(f::Union{Function, Type}, df::AbstractDataFrame)</code></pre><p>Return a <code>DataFrame</code> where each column of <code>df</code> is transformed using function <code>f</code>. <code>f</code> must return <code>AbstractVector</code> objects all with the same length or scalars (all values other than <code>AbstractVector</code> are considered to be a scalar).</p><p>Note that <code>mapcols</code> guarantees not to reuse the columns from <code>df</code> in the returned <code>DataFrame</code>. If <code>f</code> returns its argument then it gets copied before being stored.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; df = DataFrame(x=1:4, y=11:14)
4×2 DataFrame
 Row │ x      y
     │ Int64  Int64
─────┼──────────────
   1 │     1     11
   2 │     2     12
   3 │     3     13
   4 │     4     14

julia&gt; mapcols(x -&gt; x.^2, df)
4×2 DataFrame
 Row │ x      y
     │ Int64  Int64
─────┼──────────────
   1 │     1    121
   2 │     4    144
   3 │     9    169
   4 │    16    196</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/6e35e296fbdef047cfdb043d54f80375331b47b5/src/abstractdataframe/iteration.jl#L338-L370">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFrames.mapcols!" href="#DataFrames.mapcols!"><code>DataFrames.mapcols!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">mapcols!(f::Union{Function, Type}, df::DataFrame)</code></pre><p>Update a <code>DataFrame</code> in-place where each column of <code>df</code> is transformed using function <code>f</code>. <code>f</code> must return <code>AbstractVector</code> objects all with the same length or scalars (all values other than <code>AbstractVector</code> are considered to be a scalar).</p><p>Note that <code>mapcols!</code> reuses the columns from <code>df</code> if they are returned by <code>f</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; df = DataFrame(x=1:4, y=11:14)
4×2 DataFrame
 Row │ x      y
     │ Int64  Int64
─────┼──────────────
   1 │     1     11
   2 │     2     12
   3 │     3     13
   4 │     4     14

julia&gt; mapcols!(x -&gt; x.^2, df);

julia&gt; df
4×2 DataFrame
 Row │ x      y
     │ Int64  Int64
─────┼──────────────
   1 │     1    121
   2 │     4    144
   3 │     9    169
   4 │    16    196</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/6e35e296fbdef047cfdb043d54f80375331b47b5/src/abstractdataframe/iteration.jl#L395-L428">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.push!" href="#Base.push!"><code>Base.push!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">push!(df::DataFrame, row::Union{Tuple, AbstractArray}; promote::Bool=false)
push!(df::DataFrame, row::Union{DataFrameRow, NamedTuple, AbstractDict};
      cols::Symbol=:setequal, promote::Bool=(cols in [:union, :subset]))</code></pre><p>Add in-place one row at the end of <code>df</code> taking the values from <code>row</code>.</p><p>Column types of <code>df</code> are preserved, and new values are converted if necessary. An error is thrown if conversion fails.</p><p>If <code>row</code> is neither a <code>DataFrameRow</code>, <code>NamedTuple</code> nor <code>AbstractDict</code> then it must be a <code>Tuple</code> or an <code>AbstractArray</code> and columns are matched by order of appearance. In this case <code>row</code> must contain the same number of elements as the number of columns in <code>df</code>.</p><p>If <code>row</code> is a <code>DataFrameRow</code>, <code>NamedTuple</code> or <code>AbstractDict</code> then values in <code>row</code> are matched to columns in <code>df</code> based on names. The exact behavior depends on the <code>cols</code> argument value in the following way:</p><ul><li>If <code>cols == :setequal</code> (this is the default) then <code>row</code> must contain exactly the same columns as <code>df</code> (but possibly in a different order).</li><li>If <code>cols == :orderequal</code> then <code>row</code> must contain the same columns in the same order (for <code>AbstractDict</code> this option requires that <code>keys(row)</code> matches <code>propertynames(df)</code> to allow for support of ordered dicts; however, if <code>row</code> is a <code>Dict</code> an error is thrown as it is an unordered collection).</li><li>If <code>cols == :intersect</code> then <code>row</code> may contain more columns than <code>df</code>, but all column names that are present in <code>df</code> must be present in <code>row</code> and only they are used to populate a new row in <code>df</code>.</li><li>If <code>cols == :subset</code> then <code>push!</code> behaves like for <code>:intersect</code> but if some column is missing in <code>row</code> then a <code>missing</code> value is pushed to <code>df</code>.</li><li>If <code>cols == :union</code> then columns missing in <code>df</code> that are present in <code>row</code> are added to <code>df</code> (using <code>missing</code> for existing rows) and a <code>missing</code> value is pushed to columns missing in <code>row</code> that are present in <code>df</code>.</li></ul><p>If <code>promote=true</code> and element type of a column present in <code>df</code> does not allow the type of a pushed argument then a new column with a promoted element type allowing it is freshly allocated and stored in <code>df</code>. If <code>promote=false</code> an error is thrown.</p><p>As a special case, if <code>df</code> has no columns and <code>row</code> is a <code>NamedTuple</code> or <code>DataFrameRow</code>, columns are created for all values in <code>row</code>, using their names and order.</p><p>Please note that <code>push!</code> must not be used on a <code>DataFrame</code> that contains columns that are aliases (equal when compared with <code>===</code>).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; df = DataFrame(A=1:3, B=1:3);

julia&gt; push!(df, (true, false))
4×2 DataFrame
 Row │ A      B
     │ Int64  Int64
─────┼──────────────
   1 │     1      1
   2 │     2      2
   3 │     3      3
   4 │     1      0

julia&gt; push!(df, df[1, :])
5×2 DataFrame
 Row │ A      B
     │ Int64  Int64
─────┼──────────────
   1 │     1      1
   2 │     2      2
   3 │     3      3
   4 │     1      0
   5 │     1      1

julia&gt; push!(df, (C=&quot;something&quot;, A=true, B=false), cols=:intersect)
6×2 DataFrame
 Row │ A      B
     │ Int64  Int64
─────┼──────────────
   1 │     1      1
   2 │     2      2
   3 │     3      3
   4 │     1      0
   5 │     1      1
   6 │     1      0

julia&gt; push!(df, Dict(:A=&gt;1.0, :C=&gt;1.0), cols=:union)
7×3 DataFrame
 Row │ A        B        C
     │ Float64  Int64?   Float64?
─────┼─────────────────────────────
   1 │     1.0        1  missing
   2 │     2.0        2  missing
   3 │     3.0        3  missing
   4 │     1.0        0  missing
   5 │     1.0        1  missing
   6 │     1.0        0  missing
   7 │     1.0  missing        1.0

julia&gt; push!(df, NamedTuple(), cols=:subset)
8×3 DataFrame
 Row │ A          B        C
     │ Float64?   Int64?   Float64?
─────┼───────────────────────────────
   1 │       1.0        1  missing
   2 │       2.0        2  missing
   3 │       3.0        3  missing
   4 │       1.0        0  missing
   5 │       1.0        1  missing
   6 │       1.0        0  missing
   7 │       1.0  missing        1.0
   8 │ missing    missing  missing</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/6e35e296fbdef047cfdb043d54f80375331b47b5/src/dataframe/dataframe.jl#L1493-L1603">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.reduce" href="#Base.reduce"><code>Base.reduce</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">reduce(::typeof(vcat),
       dfs::Union{AbstractVector{&lt;:AbstractDataFrame},
                  Tuple{AbstractDataFrame, Vararg{AbstractDataFrame}}};
       cols::Union{Symbol, AbstractVector{Symbol},
                   AbstractVector{&lt;:AbstractString}}=:setequal,
       source::Union{Nothing, Symbol, AbstractString,
                     Pair{&lt;:Union{Symbol, AbstractString}, &lt;:AbstractVector}}=nothing)</code></pre><p>Efficiently reduce the given vector or tuple of <code>AbstractDataFrame</code>s with <code>vcat</code>.</p><p>The column order, names, and types of the resulting <code>DataFrame</code>, and the behavior of <code>cols</code> and <code>source</code> keyword arguments follow the rules specified for <a href="#Base.vcat"><code>vcat</code></a> of <code>AbstractDataFrame</code>s.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; df1 = DataFrame(A=1:3, B=1:3)
3×2 DataFrame
 Row │ A      B
     │ Int64  Int64
─────┼──────────────
   1 │     1      1
   2 │     2      2
   3 │     3      3

julia&gt; df2 = DataFrame(A=4:6, B=4:6)
3×2 DataFrame
 Row │ A      B
     │ Int64  Int64
─────┼──────────────
   1 │     4      4
   2 │     5      5
   3 │     6      6

julia&gt; df3 = DataFrame(A=7:9, C=7:9)
3×2 DataFrame
 Row │ A      C
     │ Int64  Int64
─────┼──────────────
   1 │     7      7
   2 │     8      8
   3 │     9      9

julia&gt; reduce(vcat, (df1, df2))
6×2 DataFrame
 Row │ A      B
     │ Int64  Int64
─────┼──────────────
   1 │     1      1
   2 │     2      2
   3 │     3      3
   4 │     4      4
   5 │     5      5
   6 │     6      6

julia&gt; reduce(vcat, [df1, df2, df3], cols=:union, source=:source)
9×4 DataFrame
 Row │ A      B        C        source
     │ Int64  Int64?   Int64?   Int64
─────┼─────────────────────────────────
   1 │     1        1  missing       1
   2 │     2        2  missing       1
   3 │     3        3  missing       1
   4 │     4        4  missing       2
   5 │     5        5  missing       2
   6 │     6        6  missing       2
   7 │     7  missing        7       3
   8 │     8  missing        8       3
   9 │     9  missing        9       3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/6e35e296fbdef047cfdb043d54f80375331b47b5/src/abstractdataframe/abstractdataframe.jl#L1594-L1665">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.repeat" href="#Base.repeat"><code>Base.repeat</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">repeat(df::AbstractDataFrame; inner::Integer = 1, outer::Integer = 1)</code></pre><p>Construct a data frame by repeating rows in <code>df</code>. <code>inner</code> specifies how many times each row is repeated, and <code>outer</code> specifies how many times the full set of rows is repeated.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; df = DataFrame(a = 1:2, b = 3:4)
2×2 DataFrame
 Row │ a      b
     │ Int64  Int64
─────┼──────────────
   1 │     1      3
   2 │     2      4

julia&gt; repeat(df, inner = 2, outer = 3)
12×2 DataFrame
 Row │ a      b
     │ Int64  Int64
─────┼──────────────
   1 │     1      3
   2 │     1      3
   3 │     2      4
   4 │     2      4
   5 │     1      3
   6 │     1      3
   7 │     2      4
   8 │     2      4
   9 │     1      3
  10 │     1      3
  11 │     2      4
  12 │     2      4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/6e35e296fbdef047cfdb043d54f80375331b47b5/src/abstractdataframe/abstractdataframe.jl#L1793-L1828">source</a></section><section><div><pre><code class="language-none">repeat(df::AbstractDataFrame, count::Integer)</code></pre><p>Construct a data frame by repeating each row in <code>df</code> the number of times specified by <code>count</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; df = DataFrame(a = 1:2, b = 3:4)
2×2 DataFrame
 Row │ a      b
     │ Int64  Int64
─────┼──────────────
   1 │     1      3
   2 │     2      4

julia&gt; repeat(df, 2)
4×2 DataFrame
 Row │ a      b
     │ Int64  Int64
─────┼──────────────
   1 │     1      3
   2 │     2      4
   3 │     1      3
   4 │     2      4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/6e35e296fbdef047cfdb043d54f80375331b47b5/src/abstractdataframe/abstractdataframe.jl#L1835-L1861">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFrames.repeat!" href="#DataFrames.repeat!"><code>DataFrames.repeat!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">repeat!(df::DataFrame; inner::Integer = 1, outer::Integer = 1)</code></pre><p>Update a data frame <code>df</code> in-place by repeating its rows. <code>inner</code> specifies how many times each row is repeated, and <code>outer</code> specifies how many times the full set of rows is repeated. Columns of <code>df</code> are freshly allocated.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; df = DataFrame(a = 1:2, b = 3:4)
2×2 DataFrame
 Row │ a      b
     │ Int64  Int64
─────┼──────────────
   1 │     1      3
   2 │     2      4

julia&gt; repeat!(df, inner = 2, outer = 3);

julia&gt; df
12×2 DataFrame
 Row │ a      b
     │ Int64  Int64
─────┼──────────────
   1 │     1      3
   2 │     1      3
   3 │     2      4
   4 │     2      4
   5 │     1      3
   6 │     1      3
   7 │     2      4
   8 │     2      4
   9 │     1      3
  10 │     1      3
  11 │     2      4
  12 │     2      4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/6e35e296fbdef047cfdb043d54f80375331b47b5/src/dataframe/dataframe.jl#L1650-L1687">source</a></section><section><div><pre><code class="language-none">repeat!(df::DataFrame, count::Integer)</code></pre><p>Update a data frame <code>df</code> in-place by repeating its rows the number of times specified by <code>count</code>. Columns of <code>df</code> are freshly allocated.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; df = DataFrame(a = 1:2, b = 3:4)
2×2 DataFrame
 Row │ a      b
     │ Int64  Int64
─────┼──────────────
   1 │     1      3
   2 │     2      4

julia&gt; repeat(df, 2)
4×2 DataFrame
 Row │ a      b
     │ Int64  Int64
─────┼──────────────
   1 │     1      3
   2 │     2      4
   3 │     1      3
   4 │     2      4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/6e35e296fbdef047cfdb043d54f80375331b47b5/src/dataframe/dataframe.jl#L1694-L1720">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFrames.select" href="#DataFrames.select"><code>DataFrames.select</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">select(df::AbstractDataFrame, args...; copycols::Bool=true, renamecols::Bool=true)
select(args::Callable, df::DataFrame; renamecols::Bool=true)
select(gd::GroupedDataFrame, args...; copycols::Bool=true, keepkeys::Bool=true,
       ungroup::Bool=true, renamecols::Bool=true)
select(f::Base.Callable, gd::GroupedDataFrame; copycols::Bool=true,
       keepkeys::Bool=true, ungroup::Bool=true, renamecols::Bool=true)</code></pre><p>Create a new data frame that contains columns from <code>df</code> or <code>gd</code> specified by <code>args</code> and return it. The result is guaranteed to have the same number of rows as <code>df</code>, except when no columns are selected (in which case the result has zero rows).</p><p>Below detailed common rules for all transformation functions supported by DataFrames.jl are explained and compared.</p><p>All these operations are supported both for <code>AbstractDataFrame</code> (when split and combine steps are skipped) and <code>GroupedDataFrame</code>. Technically, <code>AbstractDataFrame</code> is just considered as being grouped on no columns (meaning it has a single group, or zero groups if it is empty). The only difference is that in this case the <code>keepkeys</code> and <code>ungroup</code> keyword arguments (described below) are not supported and a data frame is always returned, as there are no split and combine steps in this case.</p><p>In order to perform operations by groups you first need to create a <code>GroupedDataFrame</code> object from your data frame using the <code>groupby</code> function that takes two arguments: (1) a data frame to be grouped, and (2) a set of columns to group by.</p><p>Operations can then be applied on each group using one of the following functions:</p><ul><li><code>combine</code>: does not put restrictions on number of rows returned, the order of rows is specified by the order of groups in <code>GroupedDataFrame</code>; it is typically used to compute summary statistics by group;</li><li><code>select</code>: return a data frame with the number and order of rows exactly the same as the source data frame, including only new calculated columns; <code>select!</code> is an in-place version of <code>select</code>;</li><li><code>transform</code>: return a data frame with the number and order of rows exactly the same as the source data frame, including all columns from the source and new calculated columns; <code>transform!</code> is an in-place version of <code>transform</code>.</li></ul><p>All these functions take a specification of one or more functions to apply to each subset of the <code>DataFrame</code>. This specification can be of the following forms:</p><ol><li>standard column selectors (integers, <code>Symbol</code>s, strings, vectors of integers, vectors of <code>Symbol</code>s, vectors of strings, <code>All</code>, <code>Cols</code>, <code>:</code>, <code>Between</code>, <code>Not</code> and regular expressions)</li><li>a <code>cols =&gt; function</code> pair indicating that <code>function</code> should be called with positional arguments holding columns <code>cols</code>, which can be any valid column selector; in this case target column name is automatically generated and it is assumed that <code>function</code> returns a single value or a vector; the generated name is created by concatenating source column name and <code>function</code> name by default (see examples below).</li><li>a <code>cols =&gt; function =&gt; target_cols</code> form additionally explicitly specifying the target column or columns.</li><li>a <code>col =&gt; target_cols</code> pair, which renames the column <code>col</code> to <code>target_cols</code>, which must be single name (as a <code>Symbol</code> or a string).</li><li>a <code>nrow</code> or <code>nrow =&gt; target_cols</code> form which efficiently computes the number of rows in a group; without <code>target_cols</code> the new column is called <code>:nrow</code>, otherwise it must be single name (as a <code>Symbol</code> or a string).</li><li>vectors or matrices containing transformations specified by the <code>Pair</code> syntax described in points 2 to 5</li><li>a function which will be called with a <code>SubDataFrame</code> corresponding to each group; this form should be avoided due to its poor performance unless the number of groups is small or a very large number of columns are processed (in which case <code>SubDataFrame</code> avoids excessive compilation)</li></ol><p>All functions have two types of signatures. One of them takes a <code>GroupedDataFrame</code> as the first argument and an arbitrary number of transformations described above as following arguments. The second type of signature is when a <code>Function</code> or a <code>Type</code> is passed as the first argument and a <code>GroupedDataFrame</code> as the second argument (similar to <code>map</code>).</p><p>As a special rule, with the <code>cols =&gt; function</code> and <code>cols =&gt; function =&gt; target_cols</code> syntaxes, if <code>cols</code> is wrapped in an <code>AsTable</code> object then a <code>NamedTuple</code> containing columns selected by <code>cols</code> is passed to <code>function</code>.</p><p>What is allowed for <code>function</code> to return is determined by the <code>target_cols</code> value:</p><ol><li>If both <code>cols</code> and <code>target_cols</code> are omitted (so only a <code>function</code> is passed), then returning a data frame, a matrix, a <code>NamedTuple</code>, or a <code>DataFrameRow</code> will produce multiple columns in the result. Returning any other value produces a single column.</li><li>If <code>target_cols</code> is a <code>Symbol</code> or a string then the function is assumed to return a single column. In this case returning a data frame, a matrix, a <code>NamedTuple</code>, or a <code>DataFrameRow</code> raises an error.</li><li>If <code>target_cols</code> is a vector of <code>Symbol</code>s or strings or <code>AsTable</code> it is assumed that <code>function</code> returns multiple columns. If <code>function</code> returns one of <code>AbstractDataFrame</code>, <code>NamedTuple</code>, <code>DataFrameRow</code>, <code>AbstractMatrix</code> then rules described in point 1 above apply. If <code>function</code> returns an <code>AbstractVector</code> then each element of this vector must support the <code>keys</code> function, which must return a collection of <code>Symbol</code>s, strings or integers; the return value of <code>keys</code> must be identical for all elements. Then as many columns are created as there are elements in the return value of the <code>keys</code> function. If <code>target_cols</code> is <code>AsTable</code> then their names are set to be equal to the key names except if <code>keys</code> returns integers, in which case they are prefixed by <code>x</code> (so the column names are e.g. <code>x1</code>, <code>x2</code>, ...). If <code>target_cols</code> is a vector of <code>Symbol</code>s or strings then column names produced using the rules above are ignored and replaced by <code>target_cols</code> (the number of columns must be the same as the length of <code>target_cols</code> in this case). If <code>fun</code> returns a value of any other type then it is assumed that it is a table conforming to the Tables.jl API and the <code>Tables.columntable</code> function is called on it to get the resulting columns and their names. The names are retained when <code>target_cols</code> is <code>AsTable</code> and are replaced if <code>target_cols</code> is a vector of <code>Symbol</code>s or strings.</li></ol><p>In all of these cases, <code>function</code> can return either a single row or multiple rows. As a particular rule, values wrapped in a <code>Ref</code> or a <code>0</code>-dimensional <code>AbstractArray</code> are unwrapped and then treated as a single row.</p><p><code>select</code>/<code>select!</code> and <code>transform</code>/<code>transform!</code> always return a <code>DataFrame</code> with the same number and order of rows as the source (even if <code>GroupedDataFrame</code> had its groups reordered).</p><p>For <code>combine</code>, rows in the returned object appear in the order of groups in the <code>GroupedDataFrame</code>. The functions can return an arbitrary number of rows for each group, but the kind of returned object and the number and names of columns must be the same for all groups, except when a <code>DataFrame()</code> or <code>NamedTuple()</code> is returned, in which case a given group is skipped.</p><p>It is allowed to mix single values and vectors if multiple transformations are requested. In this case single value will be repeated to match the length of columns specified by returned vectors.</p><p>To apply <code>function</code> to each row instead of whole columns, it can be wrapped in a <code>ByRow</code> struct. <code>cols</code> can be any column indexing syntax, in which case <code>function</code> will be passed one argument for each of the columns specified by <code>cols</code> or a <code>NamedTuple</code> of them if specified columns are wrapped in <code>AsTable</code>. If <code>ByRow</code> is used it is allowed for <code>cols</code> to select an empty set of columns, in which case <code>function</code> is called for each row without any arguments and an empty <code>NamedTuple</code> is passed if empty set of columns is wrapped in <code>AsTable</code>.</p><p>If a collection of column names is passed then requesting duplicate column names in target data frame are accepted (e.g. <code>select!(df, [:a], :, r&quot;a&quot;)</code> is allowed) and only the first occurrence is used. In particular a syntax to move column <code>:col</code> to the first position in the data frame is <code>select!(df, :col, :)</code>. On the contrary, output column names of renaming, transformation and single column selection operations must be unique, so e.g. <code>select!(df, :a, :a =&gt; :a)</code> or <code>select!(df, :a, :a =&gt; ByRow(sin) =&gt; :a)</code> are not allowed.</p><p>As a general rule if <code>copycols=true</code> columns are copied and when <code>copycols=false</code> columns are reused if possible. Note, however, that including the same column several times in the data frame via renaming or transformations that return the same object without copying may create column aliases even if <code>copycols=true</code>. An example of such a situation is <code>select!(df, :a, :a =&gt; :b, :a =&gt; identity =&gt; :c)</code>. As a special case in <code>transform</code> and <code>transform!</code> column renaming always copies columns to avoid storing aliased columns in the target data frame.</p><p>If <code>df</code> is a <code>SubDataFrame</code> and <code>copycols=true</code> then a <code>DataFrame</code> is returned and the same copying rules apply as for a <code>DataFrame</code> input: this means in particular that selected columns will be copied. If <code>copycols=false</code>, a <code>SubDataFrame</code> is returned without copying columns.</p><p>If a <code>GroupedDataFrame</code> is passed, a separate task is spawned for each specified transformation; each transformation then spawns as many tasks as Julia threads, and splits processing of groups across them (however, currently transformations with optimized implementations like <code>sum</code> and transformations that return multiple rows use a single task for all groups). This allows for parallel operation when Julia was started with more than one thread. Passed transformation functions should therefore not modify global variables (i.e. they should be pure), or use locks to control parallel accesses. In the future, parallelism may be extended to other cases, so this requirement also holds for <code>DataFrame</code> inputs.</p><p><strong>Keyword arguments</strong></p><ul><li><code>copycols::Bool=true</code> : whether columns of the source data frame should be copied if no transformation is applied to them.</li><li><code>renamecols::Bool=true</code> : whether in the <code>cols =&gt; function</code> form automatically generated column names should include the name of transformation functions or not.</li><li><code>keepkeys::Bool=true</code> : whether grouping columns of <code>gd</code> should be kept in the returned data frame.</li><li><code>ungroup::Bool=true</code> : whether the return value of the operation on <code>gd</code> should be a data frame or a <code>GroupedDataFrame</code>.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; df = DataFrame(a=1:3, b=4:6)
3×2 DataFrame
 Row │ a      b
     │ Int64  Int64
─────┼──────────────
   1 │     1      4
   2 │     2      5
   3 │     3      6

julia&gt; select(df, 2)
3×1 DataFrame
 Row │ b
     │ Int64
─────┼───────
   1 │     4
   2 │     5
   3 │     6

julia&gt; select(df, :a =&gt; ByRow(sin) =&gt; :c, :b)
3×2 DataFrame
 Row │ c         b
     │ Float64   Int64
─────┼─────────────────
   1 │ 0.841471      4
   2 │ 0.909297      5
   3 │ 0.14112       6

julia&gt; select(df, :, [:a, :b] =&gt; (a, b) -&gt; a .+ b .- sum(b)/length(b))
3×3 DataFrame
 Row │ a      b      a_b_function
     │ Int64  Int64  Float64
─────┼────────────────────────────
   1 │     1      4           0.0
   2 │     2      5           2.0
   3 │     3      6           4.0

julia&gt; select(df, names(df) .=&gt; [minimum maximum])
3×4 DataFrame
 Row │ a_minimum  b_minimum  a_maximum  b_maximum
     │ Int64      Int64      Int64      Int64
─────┼────────────────────────────────────────────
   1 │         1          4          3          6
   2 │         1          4          3          6
   3 │         1          4          3          6

julia&gt; using Statistics

julia&gt; select(df, AsTable(:) =&gt; ByRow(mean), renamecols=false)
3×1 DataFrame
 Row │ a_b
     │ Float64
─────┼─────────
   1 │     2.5
   2 │     3.5
   3 │     4.5

julia&gt; select(first, df)
3×2 DataFrame
 Row │ a      b
     │ Int64  Int64
─────┼──────────────
   1 │     1      4
   2 │     1      4
   3 │     1      4

julia&gt; df = DataFrame(a=1:3, b=4:6, c=7:9)
3×3 DataFrame
 Row │ a      b      c
     │ Int64  Int64  Int64
─────┼─────────────────────
   1 │     1      4      7
   2 │     2      5      8
   3 │     3      6      9

julia&gt; select(df, AsTable(:) =&gt; ByRow(x -&gt; (mean=mean(x), std=std(x))) =&gt; :stats,
              AsTable(:) =&gt; ByRow(x -&gt; (mean=mean(x), std=std(x))) =&gt; AsTable)
3×3 DataFrame
 Row │ stats                    mean     std
     │ NamedTup…                Float64  Float64
─────┼───────────────────────────────────────────
   1 │ (mean = 4.0, std = 3.0)      4.0      3.0
   2 │ (mean = 5.0, std = 3.0)      5.0      3.0
   3 │ (mean = 6.0, std = 3.0)      6.0      3.0

julia&gt; df = DataFrame(a = [1, 1, 1, 2, 2, 1, 1, 2],
                      b = repeat([2, 1], outer=[4]),
                      c = 1:8)
8×3 DataFrame
 Row │ a      b      c
     │ Int64  Int64  Int64
─────┼─────────────────────
   1 │     1      2      1
   2 │     1      1      2
   3 │     1      2      3
   4 │     2      1      4
   5 │     2      2      5
   6 │     1      1      6
   7 │     1      2      7
   8 │     2      1      8

julia&gt; gd = groupby(df, :a)
GroupedDataFrame with 2 groups based on key: a
First Group (5 rows): a = 1
 Row │ a      b      c
     │ Int64  Int64  Int64
─────┼─────────────────────
   1 │     1      2      1
   2 │     1      1      2
   3 │     1      2      3
   4 │     1      1      6
   5 │     1      2      7
⋮
Last Group (3 rows): a = 2
 Row │ a      b      c
     │ Int64  Int64  Int64
─────┼─────────────────────
   1 │     2      1      4
   2 │     2      2      5
   3 │     2      1      8</code></pre><p><strong>specifying a name for target column</strong></p><pre><code class="language-julia-repl">julia&gt; df = DataFrame(a = [1, 1, 1, 2, 2, 1, 1, 2],
                      b = repeat([2, 1], outer=[4]),
                      c = 1:8);

julia&gt; gd = groupby(df, :a);

julia&gt; select(gd, :c =&gt; (x -&gt; sum(log, x)) =&gt; :sum_log_c)
8×2 DataFrame
 Row │ a      sum_log_c
     │ Int64  Float64
─────┼──────────────────
   1 │     1    5.52943
   2 │     1    5.52943
   3 │     1    5.52943
   4 │     2    5.07517
   5 │     2    5.07517
   6 │     1    5.52943
   7 │     1    5.52943
   8 │     2    5.07517

julia&gt; select(gd, [:b, :c] .=&gt; sum) # passing a vector of pairs
8×3 DataFrame
 Row │ a      b_sum  c_sum
     │ Int64  Int64  Int64
─────┼─────────────────────
   1 │     1      8     19
   2 │     1      8     19
   3 │     1      8     19
   4 │     2      4     17
   5 │     2      4     17
   6 │     1      8     19
   7 │     1      8     19
   8 │     2      4     17</code></pre><p><strong>multiple arguments, renaming and keepkeys</strong></p><pre><code class="language-julia-repl">julia&gt; df = DataFrame(a = [1, 1, 1, 2, 2, 1, 1, 2],
                      b = repeat([2, 1], outer=[4]),
                      c = 1:8);

julia&gt; gd = groupby(df, :a);

julia&gt; select(gd, :b =&gt; :b1, :c =&gt; :c1, [:b, :c] =&gt; +, keepkeys=false)
8×3 DataFrame
 Row │ b1     c1     b_c_+
     │ Int64  Int64  Int64
─────┼─────────────────────
   1 │     2      1      3
   2 │     1      2      3
   3 │     2      3      5
   4 │     1      4      5
   5 │     2      5      7
   6 │     1      6      7
   7 │     2      7      9
   8 │     1      8      9</code></pre><p><strong>broadcasting and column expansion</strong></p><pre><code class="language-julia-repl">julia&gt; df = DataFrame(a = [1, 1, 1, 2, 2, 1, 1, 2],
                      b = repeat([2, 1], outer=[4]),
                      c = 1:8);

julia&gt; gd = groupby(df, :a);

julia&gt; select(gd, :b, AsTable([:b, :c]) =&gt; ByRow(extrema) =&gt; [:min, :max])
8×4 DataFrame
 Row │ a      b      min    max
     │ Int64  Int64  Int64  Int64
─────┼────────────────────────────
   1 │     1      2      1      2
   2 │     1      1      1      2
   3 │     1      2      2      3
   4 │     2      1      1      4
   5 │     2      2      2      5
   6 │     1      1      1      6
   7 │     1      2      2      7
   8 │     2      1      1      8

julia&gt; select(gd, :, AsTable(Not(:a)) =&gt; sum, renamecols=false)
8×4 DataFrame
 Row │ a      b      c      b_c
     │ Int64  Int64  Int64  Int64
─────┼────────────────────────────
   1 │     1      2      1      3
   2 │     1      1      2      3
   3 │     1      2      3      5
   4 │     2      1      4      5
   5 │     2      2      5      7
   6 │     1      1      6      7
   7 │     1      2      7      9
   8 │     2      1      8      9</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/6e35e296fbdef047cfdb043d54f80375331b47b5/src/abstractdataframe/selection.jl#L680-L925">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFrames.select!" href="#DataFrames.select!"><code>DataFrames.select!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">select!(df::DataFrame, args...; renamecols::Bool=true)
select!(args::Base.Callable, df::DataFrame; renamecols::Bool=true)
select!(gd::GroupedDataFrame{DataFrame}, args...; ungroup::Bool=true, renamecols::Bool=true)
select!(f::Base.Callable, gd::GroupedDataFrame; ungroup::Bool=true, renamecols::Bool=true)</code></pre><p>Mutate <code>df</code> or <code>gd</code> in place to retain only columns or transformations specified by <code>args...</code> and return it. The result is guaranteed to have the same number of rows as <code>df</code> or parent of <code>gd</code>, except when no columns are selected (in which case the result has zero rows).</p><p>If <code>gd</code> is passed then it is updated to reflect the new rows of its updated parent. If there are independent <code>GroupedDataFrame</code> objects constructed using the same parent data frame they might get corrupt.</p><p>Below detailed common rules for all transformation functions supported by DataFrames.jl are explained and compared.</p><p>All these operations are supported both for <code>AbstractDataFrame</code> (when split and combine steps are skipped) and <code>GroupedDataFrame</code>. Technically, <code>AbstractDataFrame</code> is just considered as being grouped on no columns (meaning it has a single group, or zero groups if it is empty). The only difference is that in this case the <code>keepkeys</code> and <code>ungroup</code> keyword arguments (described below) are not supported and a data frame is always returned, as there are no split and combine steps in this case.</p><p>In order to perform operations by groups you first need to create a <code>GroupedDataFrame</code> object from your data frame using the <code>groupby</code> function that takes two arguments: (1) a data frame to be grouped, and (2) a set of columns to group by.</p><p>Operations can then be applied on each group using one of the following functions:</p><ul><li><code>combine</code>: does not put restrictions on number of rows returned, the order of rows is specified by the order of groups in <code>GroupedDataFrame</code>; it is typically used to compute summary statistics by group;</li><li><code>select</code>: return a data frame with the number and order of rows exactly the same as the source data frame, including only new calculated columns; <code>select!</code> is an in-place version of <code>select</code>;</li><li><code>transform</code>: return a data frame with the number and order of rows exactly the same as the source data frame, including all columns from the source and new calculated columns; <code>transform!</code> is an in-place version of <code>transform</code>.</li></ul><p>All these functions take a specification of one or more functions to apply to each subset of the <code>DataFrame</code>. This specification can be of the following forms:</p><ol><li>standard column selectors (integers, <code>Symbol</code>s, strings, vectors of integers, vectors of <code>Symbol</code>s, vectors of strings, <code>All</code>, <code>Cols</code>, <code>:</code>, <code>Between</code>, <code>Not</code> and regular expressions)</li><li>a <code>cols =&gt; function</code> pair indicating that <code>function</code> should be called with positional arguments holding columns <code>cols</code>, which can be any valid column selector; in this case target column name is automatically generated and it is assumed that <code>function</code> returns a single value or a vector; the generated name is created by concatenating source column name and <code>function</code> name by default (see examples below).</li><li>a <code>cols =&gt; function =&gt; target_cols</code> form additionally explicitly specifying the target column or columns.</li><li>a <code>col =&gt; target_cols</code> pair, which renames the column <code>col</code> to <code>target_cols</code>, which must be single name (as a <code>Symbol</code> or a string).</li><li>a <code>nrow</code> or <code>nrow =&gt; target_cols</code> form which efficiently computes the number of rows in a group; without <code>target_cols</code> the new column is called <code>:nrow</code>, otherwise it must be single name (as a <code>Symbol</code> or a string).</li><li>vectors or matrices containing transformations specified by the <code>Pair</code> syntax described in points 2 to 5</li><li>a function which will be called with a <code>SubDataFrame</code> corresponding to each group; this form should be avoided due to its poor performance unless the number of groups is small or a very large number of columns are processed (in which case <code>SubDataFrame</code> avoids excessive compilation)</li></ol><p>All functions have two types of signatures. One of them takes a <code>GroupedDataFrame</code> as the first argument and an arbitrary number of transformations described above as following arguments. The second type of signature is when a <code>Function</code> or a <code>Type</code> is passed as the first argument and a <code>GroupedDataFrame</code> as the second argument (similar to <code>map</code>).</p><p>As a special rule, with the <code>cols =&gt; function</code> and <code>cols =&gt; function =&gt; target_cols</code> syntaxes, if <code>cols</code> is wrapped in an <code>AsTable</code> object then a <code>NamedTuple</code> containing columns selected by <code>cols</code> is passed to <code>function</code>.</p><p>What is allowed for <code>function</code> to return is determined by the <code>target_cols</code> value:</p><ol><li>If both <code>cols</code> and <code>target_cols</code> are omitted (so only a <code>function</code> is passed), then returning a data frame, a matrix, a <code>NamedTuple</code>, or a <code>DataFrameRow</code> will produce multiple columns in the result. Returning any other value produces a single column.</li><li>If <code>target_cols</code> is a <code>Symbol</code> or a string then the function is assumed to return a single column. In this case returning a data frame, a matrix, a <code>NamedTuple</code>, or a <code>DataFrameRow</code> raises an error.</li><li>If <code>target_cols</code> is a vector of <code>Symbol</code>s or strings or <code>AsTable</code> it is assumed that <code>function</code> returns multiple columns. If <code>function</code> returns one of <code>AbstractDataFrame</code>, <code>NamedTuple</code>, <code>DataFrameRow</code>, <code>AbstractMatrix</code> then rules described in point 1 above apply. If <code>function</code> returns an <code>AbstractVector</code> then each element of this vector must support the <code>keys</code> function, which must return a collection of <code>Symbol</code>s, strings or integers; the return value of <code>keys</code> must be identical for all elements. Then as many columns are created as there are elements in the return value of the <code>keys</code> function. If <code>target_cols</code> is <code>AsTable</code> then their names are set to be equal to the key names except if <code>keys</code> returns integers, in which case they are prefixed by <code>x</code> (so the column names are e.g. <code>x1</code>, <code>x2</code>, ...). If <code>target_cols</code> is a vector of <code>Symbol</code>s or strings then column names produced using the rules above are ignored and replaced by <code>target_cols</code> (the number of columns must be the same as the length of <code>target_cols</code> in this case). If <code>fun</code> returns a value of any other type then it is assumed that it is a table conforming to the Tables.jl API and the <code>Tables.columntable</code> function is called on it to get the resulting columns and their names. The names are retained when <code>target_cols</code> is <code>AsTable</code> and are replaced if <code>target_cols</code> is a vector of <code>Symbol</code>s or strings.</li></ol><p>In all of these cases, <code>function</code> can return either a single row or multiple rows. As a particular rule, values wrapped in a <code>Ref</code> or a <code>0</code>-dimensional <code>AbstractArray</code> are unwrapped and then treated as a single row.</p><p><code>select</code>/<code>select!</code> and <code>transform</code>/<code>transform!</code> always return a <code>DataFrame</code> with the same number and order of rows as the source (even if <code>GroupedDataFrame</code> had its groups reordered).</p><p>For <code>combine</code>, rows in the returned object appear in the order of groups in the <code>GroupedDataFrame</code>. The functions can return an arbitrary number of rows for each group, but the kind of returned object and the number and names of columns must be the same for all groups, except when a <code>DataFrame()</code> or <code>NamedTuple()</code> is returned, in which case a given group is skipped.</p><p>It is allowed to mix single values and vectors if multiple transformations are requested. In this case single value will be repeated to match the length of columns specified by returned vectors.</p><p>To apply <code>function</code> to each row instead of whole columns, it can be wrapped in a <code>ByRow</code> struct. <code>cols</code> can be any column indexing syntax, in which case <code>function</code> will be passed one argument for each of the columns specified by <code>cols</code> or a <code>NamedTuple</code> of them if specified columns are wrapped in <code>AsTable</code>. If <code>ByRow</code> is used it is allowed for <code>cols</code> to select an empty set of columns, in which case <code>function</code> is called for each row without any arguments and an empty <code>NamedTuple</code> is passed if empty set of columns is wrapped in <code>AsTable</code>.</p><p>If a collection of column names is passed then requesting duplicate column names in target data frame are accepted (e.g. <code>select!(df, [:a], :, r&quot;a&quot;)</code> is allowed) and only the first occurrence is used. In particular a syntax to move column <code>:col</code> to the first position in the data frame is <code>select!(df, :col, :)</code>. On the contrary, output column names of renaming, transformation and single column selection operations must be unique, so e.g. <code>select!(df, :a, :a =&gt; :a)</code> or <code>select!(df, :a, :a =&gt; ByRow(sin) =&gt; :a)</code> are not allowed.</p><p>As a general rule if <code>copycols=true</code> columns are copied and when <code>copycols=false</code> columns are reused if possible. Note, however, that including the same column several times in the data frame via renaming or transformations that return the same object without copying may create column aliases even if <code>copycols=true</code>. An example of such a situation is <code>select!(df, :a, :a =&gt; :b, :a =&gt; identity =&gt; :c)</code>. As a special case in <code>transform</code> and <code>transform!</code> column renaming always copies columns to avoid storing aliased columns in the target data frame.</p><p>If <code>df</code> is a <code>SubDataFrame</code> and <code>copycols=true</code> then a <code>DataFrame</code> is returned and the same copying rules apply as for a <code>DataFrame</code> input: this means in particular that selected columns will be copied. If <code>copycols=false</code>, a <code>SubDataFrame</code> is returned without copying columns.</p><p>If a <code>GroupedDataFrame</code> is passed, a separate task is spawned for each specified transformation; each transformation then spawns as many tasks as Julia threads, and splits processing of groups across them (however, currently transformations with optimized implementations like <code>sum</code> and transformations that return multiple rows use a single task for all groups). This allows for parallel operation when Julia was started with more than one thread. Passed transformation functions should therefore not modify global variables (i.e. they should be pure), or use locks to control parallel accesses. In the future, parallelism may be extended to other cases, so this requirement also holds for <code>DataFrame</code> inputs.</p><p><strong>Keyword arguments</strong></p><ul><li><code>renamecols::Bool=true</code> : whether in the <code>cols =&gt; function</code> form automatically generated column names should include the name of transformation functions or not.</li><li><code>ungroup::Bool=true</code> : whether the return value of the operation on <code>gd</code> should be a data frame or a <code>GroupedDataFrame</code>.</li></ul><p>See <a href="#DataFrames.select"><code>select</code></a> for examples.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/6e35e296fbdef047cfdb043d54f80375331b47b5/src/abstractdataframe/selection.jl#L606-L630">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFrames.transform" href="#DataFrames.transform"><code>DataFrames.transform</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">transform(df::AbstractDataFrame, args...; copycols::Bool=true, renamecols::Bool=true)
transform(f::Callable, df::DataFrame; renamecols::Bool=true)
transform(gd::GroupedDataFrame, args...; copycols::Bool=true,
          keepkeys::Bool=true, ungroup::Bool=true, renamecols::Bool=true)
transform(f::Base.Callable, gd::GroupedDataFrame; copycols::Bool=true,
          keepkeys::Bool=true, ungroup::Bool=true, renamecols::Bool=true)</code></pre><p>Create a new data frame that contains columns from <code>df</code> or <code>gd</code> plus columns specified by <code>args</code> and return it. The result is guaranteed to have the same number of rows as <code>df</code>. Equivalent to <code>select(df, :, args...)</code> or <code>select(gd, :, args...)</code>.</p><p>Below detailed common rules for all transformation functions supported by DataFrames.jl are explained and compared.</p><p>All these operations are supported both for <code>AbstractDataFrame</code> (when split and combine steps are skipped) and <code>GroupedDataFrame</code>. Technically, <code>AbstractDataFrame</code> is just considered as being grouped on no columns (meaning it has a single group, or zero groups if it is empty). The only difference is that in this case the <code>keepkeys</code> and <code>ungroup</code> keyword arguments (described below) are not supported and a data frame is always returned, as there are no split and combine steps in this case.</p><p>In order to perform operations by groups you first need to create a <code>GroupedDataFrame</code> object from your data frame using the <code>groupby</code> function that takes two arguments: (1) a data frame to be grouped, and (2) a set of columns to group by.</p><p>Operations can then be applied on each group using one of the following functions:</p><ul><li><code>combine</code>: does not put restrictions on number of rows returned, the order of rows is specified by the order of groups in <code>GroupedDataFrame</code>; it is typically used to compute summary statistics by group;</li><li><code>select</code>: return a data frame with the number and order of rows exactly the same as the source data frame, including only new calculated columns; <code>select!</code> is an in-place version of <code>select</code>;</li><li><code>transform</code>: return a data frame with the number and order of rows exactly the same as the source data frame, including all columns from the source and new calculated columns; <code>transform!</code> is an in-place version of <code>transform</code>.</li></ul><p>All these functions take a specification of one or more functions to apply to each subset of the <code>DataFrame</code>. This specification can be of the following forms:</p><ol><li>standard column selectors (integers, <code>Symbol</code>s, strings, vectors of integers, vectors of <code>Symbol</code>s, vectors of strings, <code>All</code>, <code>Cols</code>, <code>:</code>, <code>Between</code>, <code>Not</code> and regular expressions)</li><li>a <code>cols =&gt; function</code> pair indicating that <code>function</code> should be called with positional arguments holding columns <code>cols</code>, which can be any valid column selector; in this case target column name is automatically generated and it is assumed that <code>function</code> returns a single value or a vector; the generated name is created by concatenating source column name and <code>function</code> name by default (see examples below).</li><li>a <code>cols =&gt; function =&gt; target_cols</code> form additionally explicitly specifying the target column or columns.</li><li>a <code>col =&gt; target_cols</code> pair, which renames the column <code>col</code> to <code>target_cols</code>, which must be single name (as a <code>Symbol</code> or a string).</li><li>a <code>nrow</code> or <code>nrow =&gt; target_cols</code> form which efficiently computes the number of rows in a group; without <code>target_cols</code> the new column is called <code>:nrow</code>, otherwise it must be single name (as a <code>Symbol</code> or a string).</li><li>vectors or matrices containing transformations specified by the <code>Pair</code> syntax described in points 2 to 5</li><li>a function which will be called with a <code>SubDataFrame</code> corresponding to each group; this form should be avoided due to its poor performance unless the number of groups is small or a very large number of columns are processed (in which case <code>SubDataFrame</code> avoids excessive compilation)</li></ol><p>All functions have two types of signatures. One of them takes a <code>GroupedDataFrame</code> as the first argument and an arbitrary number of transformations described above as following arguments. The second type of signature is when a <code>Function</code> or a <code>Type</code> is passed as the first argument and a <code>GroupedDataFrame</code> as the second argument (similar to <code>map</code>).</p><p>As a special rule, with the <code>cols =&gt; function</code> and <code>cols =&gt; function =&gt; target_cols</code> syntaxes, if <code>cols</code> is wrapped in an <code>AsTable</code> object then a <code>NamedTuple</code> containing columns selected by <code>cols</code> is passed to <code>function</code>.</p><p>What is allowed for <code>function</code> to return is determined by the <code>target_cols</code> value:</p><ol><li>If both <code>cols</code> and <code>target_cols</code> are omitted (so only a <code>function</code> is passed), then returning a data frame, a matrix, a <code>NamedTuple</code>, or a <code>DataFrameRow</code> will produce multiple columns in the result. Returning any other value produces a single column.</li><li>If <code>target_cols</code> is a <code>Symbol</code> or a string then the function is assumed to return a single column. In this case returning a data frame, a matrix, a <code>NamedTuple</code>, or a <code>DataFrameRow</code> raises an error.</li><li>If <code>target_cols</code> is a vector of <code>Symbol</code>s or strings or <code>AsTable</code> it is assumed that <code>function</code> returns multiple columns. If <code>function</code> returns one of <code>AbstractDataFrame</code>, <code>NamedTuple</code>, <code>DataFrameRow</code>, <code>AbstractMatrix</code> then rules described in point 1 above apply. If <code>function</code> returns an <code>AbstractVector</code> then each element of this vector must support the <code>keys</code> function, which must return a collection of <code>Symbol</code>s, strings or integers; the return value of <code>keys</code> must be identical for all elements. Then as many columns are created as there are elements in the return value of the <code>keys</code> function. If <code>target_cols</code> is <code>AsTable</code> then their names are set to be equal to the key names except if <code>keys</code> returns integers, in which case they are prefixed by <code>x</code> (so the column names are e.g. <code>x1</code>, <code>x2</code>, ...). If <code>target_cols</code> is a vector of <code>Symbol</code>s or strings then column names produced using the rules above are ignored and replaced by <code>target_cols</code> (the number of columns must be the same as the length of <code>target_cols</code> in this case). If <code>fun</code> returns a value of any other type then it is assumed that it is a table conforming to the Tables.jl API and the <code>Tables.columntable</code> function is called on it to get the resulting columns and their names. The names are retained when <code>target_cols</code> is <code>AsTable</code> and are replaced if <code>target_cols</code> is a vector of <code>Symbol</code>s or strings.</li></ol><p>In all of these cases, <code>function</code> can return either a single row or multiple rows. As a particular rule, values wrapped in a <code>Ref</code> or a <code>0</code>-dimensional <code>AbstractArray</code> are unwrapped and then treated as a single row.</p><p><code>select</code>/<code>select!</code> and <code>transform</code>/<code>transform!</code> always return a <code>DataFrame</code> with the same number and order of rows as the source (even if <code>GroupedDataFrame</code> had its groups reordered).</p><p>For <code>combine</code>, rows in the returned object appear in the order of groups in the <code>GroupedDataFrame</code>. The functions can return an arbitrary number of rows for each group, but the kind of returned object and the number and names of columns must be the same for all groups, except when a <code>DataFrame()</code> or <code>NamedTuple()</code> is returned, in which case a given group is skipped.</p><p>It is allowed to mix single values and vectors if multiple transformations are requested. In this case single value will be repeated to match the length of columns specified by returned vectors.</p><p>To apply <code>function</code> to each row instead of whole columns, it can be wrapped in a <code>ByRow</code> struct. <code>cols</code> can be any column indexing syntax, in which case <code>function</code> will be passed one argument for each of the columns specified by <code>cols</code> or a <code>NamedTuple</code> of them if specified columns are wrapped in <code>AsTable</code>. If <code>ByRow</code> is used it is allowed for <code>cols</code> to select an empty set of columns, in which case <code>function</code> is called for each row without any arguments and an empty <code>NamedTuple</code> is passed if empty set of columns is wrapped in <code>AsTable</code>.</p><p>If a collection of column names is passed then requesting duplicate column names in target data frame are accepted (e.g. <code>select!(df, [:a], :, r&quot;a&quot;)</code> is allowed) and only the first occurrence is used. In particular a syntax to move column <code>:col</code> to the first position in the data frame is <code>select!(df, :col, :)</code>. On the contrary, output column names of renaming, transformation and single column selection operations must be unique, so e.g. <code>select!(df, :a, :a =&gt; :a)</code> or <code>select!(df, :a, :a =&gt; ByRow(sin) =&gt; :a)</code> are not allowed.</p><p>As a general rule if <code>copycols=true</code> columns are copied and when <code>copycols=false</code> columns are reused if possible. Note, however, that including the same column several times in the data frame via renaming or transformations that return the same object without copying may create column aliases even if <code>copycols=true</code>. An example of such a situation is <code>select!(df, :a, :a =&gt; :b, :a =&gt; identity =&gt; :c)</code>. As a special case in <code>transform</code> and <code>transform!</code> column renaming always copies columns to avoid storing aliased columns in the target data frame.</p><p>If <code>df</code> is a <code>SubDataFrame</code> and <code>copycols=true</code> then a <code>DataFrame</code> is returned and the same copying rules apply as for a <code>DataFrame</code> input: this means in particular that selected columns will be copied. If <code>copycols=false</code>, a <code>SubDataFrame</code> is returned without copying columns.</p><p>If a <code>GroupedDataFrame</code> is passed, a separate task is spawned for each specified transformation; each transformation then spawns as many tasks as Julia threads, and splits processing of groups across them (however, currently transformations with optimized implementations like <code>sum</code> and transformations that return multiple rows use a single task for all groups). This allows for parallel operation when Julia was started with more than one thread. Passed transformation functions should therefore not modify global variables (i.e. they should be pure), or use locks to control parallel accesses. In the future, parallelism may be extended to other cases, so this requirement also holds for <code>DataFrame</code> inputs.</p><p><strong>Keyword arguments</strong></p><ul><li><code>copycols::Bool=true</code> : whether columns of the source data frame should be copied if no transformation is applied to them.</li><li><code>renamecols::Bool=true</code> : whether in the <code>cols =&gt; function</code> form automatically generated column names should include the name of transformation functions or not.</li><li><code>keepkeys::Bool=true</code> : whether grouping columns of <code>gd</code> should be kept in the returned data frame.</li><li><code>ungroup::Bool=true</code> : whether the return value of the operation on <code>gd</code> should be a data frame or a <code>GroupedDataFrame</code>.</li></ul><p>Note that when the first argument is a <code>GroupedDataFrame</code>, <code>keepkeys=false</code> is needed to be able to return a different value for the grouping column:</p><pre><code class="language-julia-repl">julia&gt; gdf = groupby(DataFrame(x=1:2), :x)
GroupedDataFrame with 2 groups based on key: x
First Group (1 row): x = 1
 Row │ x
     │ Int64
─────┼───────
   1 │     1
⋮
Last Group (1 row): x = 2
 Row │ x
     │ Int64
─────┼───────
   1 │     2

julia&gt; transform(gdf, x -&gt; (x=10,), keepkeys=false)
2×1 DataFrame
 Row │ x
     │ Int64
─────┼───────
   1 │    10
   2 │    10

julia&gt; transform(gdf, x -&gt; (x=10,), keepkeys=true)
ERROR: ArgumentError: column :x in returned data frame is not equal to grouping key :x</code></pre><p>See <a href="#DataFrames.select"><code>select</code></a> for more examples.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/6e35e296fbdef047cfdb043d54f80375331b47b5/src/abstractdataframe/selection.jl#L936-L991">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFrames.transform!" href="#DataFrames.transform!"><code>DataFrames.transform!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">transform!(df::DataFrame, args...; renamecols::Bool=true)
transform!(args::Callable, df::DataFrame; renamecols::Bool=true)
transform!(gd::GroupedDataFrame{DataFrame}, args...; ungroup::Bool=true, renamecols::Bool=true)
transform!(f::Base.Callable, gd::GroupedDataFrame; ungroup::Bool=true, renamecols::Bool=true)</code></pre><p>Mutate <code>df</code> or <code>gd</code> in place to add columns specified by <code>args...</code> and return it. The result is guaranteed to have the same number of rows as <code>df</code>. Equivalent to <code>select!(df, :, args...)</code> or <code>select!(gd, :, args...)</code>.</p><p>Below detailed common rules for all transformation functions supported by DataFrames.jl are explained and compared.</p><p>All these operations are supported both for <code>AbstractDataFrame</code> (when split and combine steps are skipped) and <code>GroupedDataFrame</code>. Technically, <code>AbstractDataFrame</code> is just considered as being grouped on no columns (meaning it has a single group, or zero groups if it is empty). The only difference is that in this case the <code>keepkeys</code> and <code>ungroup</code> keyword arguments (described below) are not supported and a data frame is always returned, as there are no split and combine steps in this case.</p><p>In order to perform operations by groups you first need to create a <code>GroupedDataFrame</code> object from your data frame using the <code>groupby</code> function that takes two arguments: (1) a data frame to be grouped, and (2) a set of columns to group by.</p><p>Operations can then be applied on each group using one of the following functions:</p><ul><li><code>combine</code>: does not put restrictions on number of rows returned, the order of rows is specified by the order of groups in <code>GroupedDataFrame</code>; it is typically used to compute summary statistics by group;</li><li><code>select</code>: return a data frame with the number and order of rows exactly the same as the source data frame, including only new calculated columns; <code>select!</code> is an in-place version of <code>select</code>;</li><li><code>transform</code>: return a data frame with the number and order of rows exactly the same as the source data frame, including all columns from the source and new calculated columns; <code>transform!</code> is an in-place version of <code>transform</code>.</li></ul><p>All these functions take a specification of one or more functions to apply to each subset of the <code>DataFrame</code>. This specification can be of the following forms:</p><ol><li>standard column selectors (integers, <code>Symbol</code>s, strings, vectors of integers, vectors of <code>Symbol</code>s, vectors of strings, <code>All</code>, <code>Cols</code>, <code>:</code>, <code>Between</code>, <code>Not</code> and regular expressions)</li><li>a <code>cols =&gt; function</code> pair indicating that <code>function</code> should be called with positional arguments holding columns <code>cols</code>, which can be any valid column selector; in this case target column name is automatically generated and it is assumed that <code>function</code> returns a single value or a vector; the generated name is created by concatenating source column name and <code>function</code> name by default (see examples below).</li><li>a <code>cols =&gt; function =&gt; target_cols</code> form additionally explicitly specifying the target column or columns.</li><li>a <code>col =&gt; target_cols</code> pair, which renames the column <code>col</code> to <code>target_cols</code>, which must be single name (as a <code>Symbol</code> or a string).</li><li>a <code>nrow</code> or <code>nrow =&gt; target_cols</code> form which efficiently computes the number of rows in a group; without <code>target_cols</code> the new column is called <code>:nrow</code>, otherwise it must be single name (as a <code>Symbol</code> or a string).</li><li>vectors or matrices containing transformations specified by the <code>Pair</code> syntax described in points 2 to 5</li><li>a function which will be called with a <code>SubDataFrame</code> corresponding to each group; this form should be avoided due to its poor performance unless the number of groups is small or a very large number of columns are processed (in which case <code>SubDataFrame</code> avoids excessive compilation)</li></ol><p>All functions have two types of signatures. One of them takes a <code>GroupedDataFrame</code> as the first argument and an arbitrary number of transformations described above as following arguments. The second type of signature is when a <code>Function</code> or a <code>Type</code> is passed as the first argument and a <code>GroupedDataFrame</code> as the second argument (similar to <code>map</code>).</p><p>As a special rule, with the <code>cols =&gt; function</code> and <code>cols =&gt; function =&gt; target_cols</code> syntaxes, if <code>cols</code> is wrapped in an <code>AsTable</code> object then a <code>NamedTuple</code> containing columns selected by <code>cols</code> is passed to <code>function</code>.</p><p>What is allowed for <code>function</code> to return is determined by the <code>target_cols</code> value:</p><ol><li>If both <code>cols</code> and <code>target_cols</code> are omitted (so only a <code>function</code> is passed), then returning a data frame, a matrix, a <code>NamedTuple</code>, or a <code>DataFrameRow</code> will produce multiple columns in the result. Returning any other value produces a single column.</li><li>If <code>target_cols</code> is a <code>Symbol</code> or a string then the function is assumed to return a single column. In this case returning a data frame, a matrix, a <code>NamedTuple</code>, or a <code>DataFrameRow</code> raises an error.</li><li>If <code>target_cols</code> is a vector of <code>Symbol</code>s or strings or <code>AsTable</code> it is assumed that <code>function</code> returns multiple columns. If <code>function</code> returns one of <code>AbstractDataFrame</code>, <code>NamedTuple</code>, <code>DataFrameRow</code>, <code>AbstractMatrix</code> then rules described in point 1 above apply. If <code>function</code> returns an <code>AbstractVector</code> then each element of this vector must support the <code>keys</code> function, which must return a collection of <code>Symbol</code>s, strings or integers; the return value of <code>keys</code> must be identical for all elements. Then as many columns are created as there are elements in the return value of the <code>keys</code> function. If <code>target_cols</code> is <code>AsTable</code> then their names are set to be equal to the key names except if <code>keys</code> returns integers, in which case they are prefixed by <code>x</code> (so the column names are e.g. <code>x1</code>, <code>x2</code>, ...). If <code>target_cols</code> is a vector of <code>Symbol</code>s or strings then column names produced using the rules above are ignored and replaced by <code>target_cols</code> (the number of columns must be the same as the length of <code>target_cols</code> in this case). If <code>fun</code> returns a value of any other type then it is assumed that it is a table conforming to the Tables.jl API and the <code>Tables.columntable</code> function is called on it to get the resulting columns and their names. The names are retained when <code>target_cols</code> is <code>AsTable</code> and are replaced if <code>target_cols</code> is a vector of <code>Symbol</code>s or strings.</li></ol><p>In all of these cases, <code>function</code> can return either a single row or multiple rows. As a particular rule, values wrapped in a <code>Ref</code> or a <code>0</code>-dimensional <code>AbstractArray</code> are unwrapped and then treated as a single row.</p><p><code>select</code>/<code>select!</code> and <code>transform</code>/<code>transform!</code> always return a <code>DataFrame</code> with the same number and order of rows as the source (even if <code>GroupedDataFrame</code> had its groups reordered).</p><p>For <code>combine</code>, rows in the returned object appear in the order of groups in the <code>GroupedDataFrame</code>. The functions can return an arbitrary number of rows for each group, but the kind of returned object and the number and names of columns must be the same for all groups, except when a <code>DataFrame()</code> or <code>NamedTuple()</code> is returned, in which case a given group is skipped.</p><p>It is allowed to mix single values and vectors if multiple transformations are requested. In this case single value will be repeated to match the length of columns specified by returned vectors.</p><p>To apply <code>function</code> to each row instead of whole columns, it can be wrapped in a <code>ByRow</code> struct. <code>cols</code> can be any column indexing syntax, in which case <code>function</code> will be passed one argument for each of the columns specified by <code>cols</code> or a <code>NamedTuple</code> of them if specified columns are wrapped in <code>AsTable</code>. If <code>ByRow</code> is used it is allowed for <code>cols</code> to select an empty set of columns, in which case <code>function</code> is called for each row without any arguments and an empty <code>NamedTuple</code> is passed if empty set of columns is wrapped in <code>AsTable</code>.</p><p>If a collection of column names is passed then requesting duplicate column names in target data frame are accepted (e.g. <code>select!(df, [:a], :, r&quot;a&quot;)</code> is allowed) and only the first occurrence is used. In particular a syntax to move column <code>:col</code> to the first position in the data frame is <code>select!(df, :col, :)</code>. On the contrary, output column names of renaming, transformation and single column selection operations must be unique, so e.g. <code>select!(df, :a, :a =&gt; :a)</code> or <code>select!(df, :a, :a =&gt; ByRow(sin) =&gt; :a)</code> are not allowed.</p><p>As a general rule if <code>copycols=true</code> columns are copied and when <code>copycols=false</code> columns are reused if possible. Note, however, that including the same column several times in the data frame via renaming or transformations that return the same object without copying may create column aliases even if <code>copycols=true</code>. An example of such a situation is <code>select!(df, :a, :a =&gt; :b, :a =&gt; identity =&gt; :c)</code>. As a special case in <code>transform</code> and <code>transform!</code> column renaming always copies columns to avoid storing aliased columns in the target data frame.</p><p>If <code>df</code> is a <code>SubDataFrame</code> and <code>copycols=true</code> then a <code>DataFrame</code> is returned and the same copying rules apply as for a <code>DataFrame</code> input: this means in particular that selected columns will be copied. If <code>copycols=false</code>, a <code>SubDataFrame</code> is returned without copying columns.</p><p>If a <code>GroupedDataFrame</code> is passed, a separate task is spawned for each specified transformation; each transformation then spawns as many tasks as Julia threads, and splits processing of groups across them (however, currently transformations with optimized implementations like <code>sum</code> and transformations that return multiple rows use a single task for all groups). This allows for parallel operation when Julia was started with more than one thread. Passed transformation functions should therefore not modify global variables (i.e. they should be pure), or use locks to control parallel accesses. In the future, parallelism may be extended to other cases, so this requirement also holds for <code>DataFrame</code> inputs.</p><p><strong>Keyword arguments</strong></p><ul><li><code>renamecols::Bool=true</code> : whether in the <code>cols =&gt; function</code> form automatically generated column names should include the name of transformation functions or not.</li><li><code>ungroup::Bool=true</code> : whether the return value of the operation on <code>gd</code> should be a data frame or a <code>GroupedDataFrame</code>.</li></ul><p>See <a href="#DataFrames.select"><code>select</code></a> for examples.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/6e35e296fbdef047cfdb043d54f80375331b47b5/src/abstractdataframe/selection.jl#L641-L660">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.vcat" href="#Base.vcat"><code>Base.vcat</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">vcat(dfs::AbstractDataFrame...;
     cols::Union{Symbol, AbstractVector{Symbol},
                 AbstractVector{&lt;:AbstractString}}=:setequal,
     source::Union{Nothing, Symbol, AbstractString,
                   Pair{&lt;:Union{Symbol, AbstractString}, &lt;:AbstractVector}}=nothing)</code></pre><p>Vertically concatenate <code>AbstractDataFrame</code>s.</p><p>The <code>cols</code> keyword argument determines the columns of the returned data frame:</p><ul><li><code>:setequal</code>: require all data frames to have the same column names disregarding order. If they appear in different orders, the order of the first provided data frame is used.</li><li><code>:orderequal</code>: require all data frames to have the same column names and in the same order.</li><li><code>:intersect</code>: only the columns present in <em>all</em> provided data frames are kept. If the intersection is empty, an empty data frame is returned.</li><li><code>:union</code>: columns present in <em>at least one</em> of the provided data frames are kept. Columns not present in some data frames are filled with <code>missing</code> where necessary.</li><li>A vector of <code>Symbol</code>s or strings: only listed columns are kept. Columns not present in some data frames are filled with <code>missing</code> where necessary.</li></ul><p>The <code>source</code> keyword argument, if not <code>nothing</code> (the default), specifies the additional column to be added in the last position in the resulting data frame that will identify the source data frame. It can be a <code>Symbol</code> or an <code>AbstractString</code>, in which case the identifier will be the number of the passed source data frame, or a <code>Pair</code> consisting of a <code>Symbol</code> or an <code>AbstractString</code> and of a vector specifying the data frame identifiers (which do not have to be unique). The name of the source column is not allowed to be present in any source data frame.</p><p>The order of columns is determined by the order they appear in the included data frames, searching through the header of the first data frame, then the second, etc.</p><p>The element types of columns are determined using <code>promote_type</code>, as with <code>vcat</code> for <code>AbstractVector</code>s.</p><p><code>vcat</code> ignores empty data frames, making it possible to initialize an empty data frame at the beginning of a loop and <code>vcat</code> onto it.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; df1 = DataFrame(A=1:3, B=1:3)
3×2 DataFrame
 Row │ A      B
     │ Int64  Int64
─────┼──────────────
   1 │     1      1
   2 │     2      2
   3 │     3      3

julia&gt; df2 = DataFrame(A=4:6, B=4:6)
3×2 DataFrame
 Row │ A      B
     │ Int64  Int64
─────┼──────────────
   1 │     4      4
   2 │     5      5
   3 │     6      6

julia&gt; df3 = DataFrame(A=7:9, C=7:9)
3×2 DataFrame
 Row │ A      C
     │ Int64  Int64
─────┼──────────────
   1 │     7      7
   2 │     8      8
   3 │     9      9

julia&gt; df4 = DataFrame()
0×0 DataFrame

julia&gt; vcat(df1, df2)
6×2 DataFrame
 Row │ A      B
     │ Int64  Int64
─────┼──────────────
   1 │     1      1
   2 │     2      2
   3 │     3      3
   4 │     4      4
   5 │     5      5
   6 │     6      6

julia&gt; vcat(df1, df3, cols=:union)
6×3 DataFrame
 Row │ A      B        C
     │ Int64  Int64?   Int64?
─────┼─────────────────────────
   1 │     1        1  missing
   2 │     2        2  missing
   3 │     3        3  missing
   4 │     7  missing        7
   5 │     8  missing        8
   6 │     9  missing        9

julia&gt; vcat(df1, df3, cols=:intersect)
6×1 DataFrame
 Row │ A
     │ Int64
─────┼───────
   1 │     1
   2 │     2
   3 │     3
   4 │     7
   5 │     8
   6 │     9

julia&gt; vcat(df4, df1)
3×2 DataFrame
 Row │ A      B
     │ Int64  Int64
─────┼──────────────
   1 │     1      1
   2 │     2      2
   3 │     3      3

julia&gt; vcat(df1, df2, df3, df4, cols=:union, source=&quot;source&quot;)
9×4 DataFrame
 Row │ A      B        C        source
     │ Int64  Int64?   Int64?   Int64
─────┼─────────────────────────────────
   1 │     1        1  missing       1
   2 │     2        2  missing       1
   3 │     3        3  missing       1
   4 │     4        4  missing       2
   5 │     5        5  missing       2
   6 │     6        6  missing       2
   7 │     7  missing        7       3
   8 │     8  missing        8       3
   9 │     9  missing        9       3

julia&gt; vcat(df1, df2, df4, df3, cols=:union, source=:source =&gt; &#39;a&#39;:&#39;d&#39;)
9×4 DataFrame
 Row │ A      B        C        source
     │ Int64  Int64?   Int64?   Char
─────┼─────────────────────────────────
   1 │     1        1  missing  a
   2 │     2        2  missing  a
   3 │     3        3  missing  a
   4 │     4        4  missing  b
   5 │     5        5  missing  b
   6 │     6        6  missing  b
   7 │     7  missing        7  d
   8 │     8  missing        8  d
   9 │     9  missing        9  d</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/6e35e296fbdef047cfdb043d54f80375331b47b5/src/abstractdataframe/abstractdataframe.jl#L1437-L1586">source</a></section></article><h2 id="Reshaping-data-frames-between-tall-and-wide-formats"><a class="docs-heading-anchor" href="#Reshaping-data-frames-between-tall-and-wide-formats">Reshaping data frames between tall and wide formats</a><a id="Reshaping-data-frames-between-tall-and-wide-formats-1"></a><a class="docs-heading-anchor-permalink" href="#Reshaping-data-frames-between-tall-and-wide-formats" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="DataFrames.stack" href="#DataFrames.stack"><code>DataFrames.stack</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">stack(df::AbstractDataFrame[, measure_vars[, id_vars] ];
      variable_name=:variable, value_name=:value,
      view::Bool=false, variable_eltype::Type=String)</code></pre><p>Stack a data frame <code>df</code>, i.e. convert it from wide to long format.</p><p>Return the long-format <code>DataFrame</code> with: columns for each of the <code>id_vars</code>, column <code>value_name</code> (<code>:value</code> by default) holding the values of the stacked columns (<code>measure_vars</code>), and column <code>variable_name</code> (<code>:variable</code> by default) a vector holding the name of the corresponding <code>measure_vars</code> variable.</p><p>If <code>view=true</code> then return a stacked view of a data frame (long format). The result is a view because the columns are special <code>AbstractVectors</code> that return views into the original data frame.</p><p><strong>Arguments</strong></p><ul><li><code>df</code> : the AbstractDataFrame to be stacked</li><li><code>measure_vars</code> : the columns to be stacked (the measurement variables), as a column selector (<code>Symbol</code>, string or integer; <code>:</code>, <code>Cols</code>, <code>All</code>, <code>Between</code>, <code>Not</code>, a regular expression, or a vector of <code>Symbol</code>s, strings or integers). If neither <code>measure_vars</code> or <code>id_vars</code> are given, <code>measure_vars</code> defaults to all floating point columns.</li><li><code>id_vars</code> : the identifier columns that are repeated during stacking, as a column selector (<code>Symbol</code>, string or integer; <code>:</code>, <code>Cols</code>, <code>All</code>, <code>Between</code>, <code>Not</code>, a regular expression, or a vector of <code>Symbol</code>s, strings or integers). Defaults to all variables that are not <code>measure_vars</code></li><li><code>variable_name</code> : the name (<code>Symbol</code> or string) of the new stacked column that shall hold the names of each of <code>measure_vars</code></li><li><code>value_name</code> : the name (<code>Symbol</code> or string) of the new stacked column containing the values from each of <code>measure_vars</code></li><li><code>view</code> : whether the stacked data frame should be a view rather than contain freshly allocated vectors.</li><li><code>variable_eltype</code> : determines the element type of column <code>variable_name</code>. By default a <code>PooledArray{String}</code> is created. If <code>variable_eltype=Symbol</code> a <code>PooledVector{Symbol}</code> is created, and if <code>variable_eltype=CategoricalValue{String}</code> a <code>CategoricalArray{String}</code> is produced (call <code>using CategoricalArrays</code> first if needed) Passing any other type <code>T</code> will produce a <code>PooledVector{T}</code> column as long as it supports conversion from <code>String</code>. When <code>view=true</code>, a <code>RepeatedVector{T}</code> is produced.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; df = DataFrame(a = repeat(1:3, inner = 2),
                             b = repeat(1:2, inner = 3),
                             c = repeat(1:1, inner = 6),
                             d = repeat(1:6, inner = 1),
                             e = string.(&#39;a&#39;:&#39;f&#39;))
6×5 DataFrame
 Row │ a      b      c      d      e
     │ Int64  Int64  Int64  Int64  String
─────┼────────────────────────────────────
   1 │     1      1      1      1  a
   2 │     1      1      1      2  b
   3 │     2      1      1      3  c
   4 │     2      2      1      4  d
   5 │     3      2      1      5  e
   6 │     3      2      1      6  f

julia&gt; stack(df, [:c, :d])
12×5 DataFrame
 Row │ a      b      e       variable  value
     │ Int64  Int64  String  String    Int64
─────┼───────────────────────────────────────
   1 │     1      1  a       c             1
   2 │     1      1  b       c             1
   3 │     2      1  c       c             1
   4 │     2      2  d       c             1
   5 │     3      2  e       c             1
   6 │     3      2  f       c             1
   7 │     1      1  a       d             1
   8 │     1      1  b       d             2
   9 │     2      1  c       d             3
  10 │     2      2  d       d             4
  11 │     3      2  e       d             5
  12 │     3      2  f       d             6

julia&gt; stack(df, [:c, :d], [:a])
12×3 DataFrame
 Row │ a      variable  value
     │ Int64  String    Int64
─────┼────────────────────────
   1 │     1  c             1
   2 │     1  c             1
   3 │     2  c             1
   4 │     2  c             1
   5 │     3  c             1
   6 │     3  c             1
   7 │     1  d             1
   8 │     1  d             2
   9 │     2  d             3
  10 │     2  d             4
  11 │     3  d             5
  12 │     3  d             6

julia&gt; stack(df, Not([:a, :b, :e]))
12×5 DataFrame
 Row │ a      b      e       variable  value
     │ Int64  Int64  String  String    Int64
─────┼───────────────────────────────────────
   1 │     1      1  a       c             1
   2 │     1      1  b       c             1
   3 │     2      1  c       c             1
   4 │     2      2  d       c             1
   5 │     3      2  e       c             1
   6 │     3      2  f       c             1
   7 │     1      1  a       d             1
   8 │     1      1  b       d             2
   9 │     2      1  c       d             3
  10 │     2      2  d       d             4
  11 │     3      2  e       d             5
  12 │     3      2  f       d             6

julia&gt; stack(df, Not([:a, :b, :e]), variable_name=:somemeasure)
12×5 DataFrame
 Row │ a      b      e       somemeasure  value
     │ Int64  Int64  String  String       Int64
─────┼──────────────────────────────────────────
   1 │     1      1  a       c                1
   2 │     1      1  b       c                1
   3 │     2      1  c       c                1
   4 │     2      2  d       c                1
   5 │     3      2  e       c                1
   6 │     3      2  f       c                1
   7 │     1      1  a       d                1
   8 │     1      1  b       d                2
   9 │     2      1  c       d                3
  10 │     2      2  d       d                4
  11 │     3      2  e       d                5
  12 │     3      2  f       d                6</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/6e35e296fbdef047cfdb043d54f80375331b47b5/src/abstractdataframe/reshape.jl#L1-L133">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFrames.unstack" href="#DataFrames.unstack"><code>DataFrames.unstack</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">unstack(df::AbstractDataFrame, rowkeys, colkey, value; renamecols::Function=identity,
        allowmissing::Bool=false, allowduplicates::Bool=false)
unstack(df::AbstractDataFrame, colkey, value; renamecols::Function=identity,
        allowmissing::Bool=false, allowduplicates::Bool=false)
unstack(df::AbstractDataFrame; renamecols::Function=identity,
        allowmissing::Bool=false, allowduplicates::Bool=false)</code></pre><p>Unstack data frame <code>df</code>, i.e. convert it from long to wide format.</p><p>Row and column keys will be ordered in the order of their first appearance.</p><p><strong>Positional arguments</strong></p><ul><li><code>df</code> : the AbstractDataFrame to be unstacked</li><li><code>rowkeys</code> : the columns with a unique key for each row, if not given, find a key by grouping on anything not a <code>colkey</code> or <code>value</code>. Can be any column selector (<code>Symbol</code>, string or integer; <code>:</code>, <code>Cols</code>, <code>All</code>, <code>Between</code>, <code>Not</code>, a regular expression, or a vector of <code>Symbol</code>s, strings or integers).</li><li><code>colkey</code> : the column (<code>Symbol</code>, string or integer) holding the column names in wide format, defaults to <code>:variable</code></li><li><code>value</code> : the value column (<code>Symbol</code>, string or integer), defaults to <code>:value</code></li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>renamecols</code>: a function called on each unique value in <code>colkey</code>; it must return the name of the column to be created (typically as a string or a <code>Symbol</code>). Duplicates in resulting names when converted to <code>Symbol</code> are not allowed. By default no transformation is performed.</li><li><code>allowmissing</code>: if <code>false</code> (the default) then an error will be thrown if <code>colkey</code> contains <code>missing</code> values; if <code>true</code> then a column referring to <code>missing</code> value will be created.</li><li><code>allowduplicates</code>: if <code>false</code> (the default) then an error an error will be thrown if combination of <code>rowkeys</code> and <code>colkey</code> contains duplicate entries; if <code>true</code> then  then the last encountered <code>value</code> will be retained.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; wide = DataFrame(id = 1:6,
                                a  = repeat(1:3, inner = 2),
                                b  = repeat(1.0:2.0, inner = 3),
                                c  = repeat(1.0:1.0, inner = 6),
                                d  = repeat(1.0:3.0, inner = 2))
6×5 DataFrame
 Row │ id     a      b        c        d
     │ Int64  Int64  Float64  Float64  Float64
─────┼─────────────────────────────────────────
   1 │     1      1      1.0      1.0      1.0
   2 │     2      1      1.0      1.0      1.0
   3 │     3      2      1.0      1.0      2.0
   4 │     4      2      2.0      1.0      2.0
   5 │     5      3      2.0      1.0      3.0
   6 │     6      3      2.0      1.0      3.0

julia&gt; long = stack(wide)
18×4 DataFrame
 Row │ id     a      variable  value
     │ Int64  Int64  String    Float64
─────┼─────────────────────────────────
   1 │     1      1  b             1.0
   2 │     2      1  b             1.0
   3 │     3      2  b             1.0
   4 │     4      2  b             2.0
   5 │     5      3  b             2.0
   6 │     6      3  b             2.0
   7 │     1      1  c             1.0
   8 │     2      1  c             1.0
  ⋮  │   ⋮      ⋮       ⋮         ⋮
  12 │     6      3  c             1.0
  13 │     1      1  d             1.0
  14 │     2      1  d             1.0
  15 │     3      2  d             2.0
  16 │     4      2  d             2.0
  17 │     5      3  d             3.0
  18 │     6      3  d             3.0
                         3 rows omitted

julia&gt; unstack(long)
6×5 DataFrame
 Row │ id     a      b         c         d
     │ Int64  Int64  Float64?  Float64?  Float64?
─────┼────────────────────────────────────────────
   1 │     1      1       1.0       1.0       1.0
   2 │     2      1       1.0       1.0       1.0
   3 │     3      2       1.0       1.0       2.0
   4 │     4      2       2.0       1.0       2.0
   5 │     5      3       2.0       1.0       3.0
   6 │     6      3       2.0       1.0       3.0

julia&gt; unstack(long, :variable, :value)
6×5 DataFrame
 Row │ id     a      b         c         d
     │ Int64  Int64  Float64?  Float64?  Float64?
─────┼────────────────────────────────────────────
   1 │     1      1       1.0       1.0       1.0
   2 │     2      1       1.0       1.0       1.0
   3 │     3      2       1.0       1.0       2.0
   4 │     4      2       2.0       1.0       2.0
   5 │     5      3       2.0       1.0       3.0
   6 │     6      3       2.0       1.0       3.0

julia&gt; unstack(long, :id, :variable, :value)
6×4 DataFrame
 Row │ id     b         c         d
     │ Int64  Float64?  Float64?  Float64?
─────┼─────────────────────────────────────
   1 │     1       1.0       1.0       1.0
   2 │     2       1.0       1.0       1.0
   3 │     3       1.0       1.0       2.0
   4 │     4       2.0       1.0       2.0
   5 │     5       2.0       1.0       3.0
   6 │     6       2.0       1.0       3.0

julia&gt; unstack(long, [:id, :a], :variable, :value)
6×5 DataFrame
 Row │ id     a      b         c         d
     │ Int64  Int64  Float64?  Float64?  Float64?
─────┼────────────────────────────────────────────
   1 │     1      1       1.0       1.0       1.0
   2 │     2      1       1.0       1.0       1.0
   3 │     3      2       1.0       1.0       2.0
   4 │     4      2       2.0       1.0       2.0
   5 │     5      3       2.0       1.0       3.0
   6 │     6      3       2.0       1.0       3.0

julia&gt; unstack(long, :id, :variable, :value, renamecols=x-&gt;Symbol(:_, x))
6×4 DataFrame
 Row │ id     _b        _c        _d
     │ Int64  Float64?  Float64?  Float64?
─────┼─────────────────────────────────────
   1 │     1       1.0       1.0       1.0
   2 │     2       1.0       1.0       1.0
   3 │     3       1.0       1.0       2.0
   4 │     4       2.0       1.0       2.0
   5 │     5       2.0       1.0       3.0
   6 │     6       2.0       1.0       3.0</code></pre><p>Note that there are some differences between the widened results above.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/6e35e296fbdef047cfdb043d54f80375331b47b5/src/abstractdataframe/reshape.jl#L199-L336">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.permutedims" href="#Base.permutedims"><code>Base.permutedims</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">permutedims(df::AbstractDataFrame, src_namescol::Union{Int, Symbol, AbstractString},
            [dest_namescol::Union{Symbol, AbstractString}];
            makeunique::Bool=false)</code></pre><p>Turn <code>df</code> on its side such that rows become columns and values in the column indexed by <code>src_namescol</code> become the names of new columns. In the resulting <code>DataFrame</code>, column names of <code>df</code> will become the first column with name specified by <code>dest_namescol</code>.</p><p><strong>Arguments</strong></p><ul><li><code>df</code> : the <code>AbstractDataFrame</code></li><li><code>src_namescol</code> : the column that will become the new header. This column&#39;s element type must be <code>AbstractString</code> or <code>Symbol</code>.</li><li><code>dest_namescol</code> : the name of the first column in the returned <code>DataFrame</code>. Defaults to the same name as <code>src_namescol</code>.</li><li><code>makeunique</code> : if <code>false</code> (the default), an error will be raised if duplicate names are found; if <code>true</code>, duplicate names will be suffixed with <code>_i</code> (<code>i</code> starting at 1 for the first duplicate).</li></ul><p>Note: The element types of columns in resulting <code>DataFrame</code> (other than the first column, which always has element type <code>String</code>) will depend on the element types of <em>all</em> input columns based on the result of <code>promote_type</code>. That is, if the source data frame contains <code>Int</code> and <code>Float64</code> columns, resulting columns will have element type <code>Float64</code>. If the source has <code>Int</code> and <code>String</code> columns, resulting columns will have element type <code>Any</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; df1 = DataFrame(a=[&quot;x&quot;, &quot;y&quot;], b=[1.0, 2.0], c=[3, 4], d=[true, false])
2×4 DataFrame
 Row │ a       b        c      d
     │ String  Float64  Int64  Bool
─────┼───────────────────────────────
   1 │ x           1.0      3   true
   2 │ y           2.0      4  false

julia&gt; permutedims(df1, 1) # note the column types
3×3 DataFrame
 Row │ a       x        y
     │ String  Float64  Float64
─────┼──────────────────────────
   1 │ b           1.0      2.0
   2 │ c           3.0      4.0
   3 │ d           1.0      0.0

julia&gt; df2 = DataFrame(a=[&quot;x&quot;, &quot;y&quot;], b=[1, &quot;two&quot;], c=[3, 4], d=[true, false])
2×4 DataFrame
 Row │ a       b    c      d
     │ String  Any  Int64  Bool
─────┼───────────────────────────
   1 │ x       1        3   true
   2 │ y       two      4  false

julia&gt; permutedims(df2, 1, &quot;different_name&quot;)
3×3 DataFrame
 Row │ different_name  x     y
     │ String          Any   Any
─────┼─────────────────────────────
   1 │ b               1     two
   2 │ c               3     4
   3 │ d               true  false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/6e35e296fbdef047cfdb043d54f80375331b47b5/src/abstractdataframe/reshape.jl#L546-L611">source</a></section></article><h2 id="Sorting"><a class="docs-heading-anchor" href="#Sorting">Sorting</a><a id="Sorting-1"></a><a class="docs-heading-anchor-permalink" href="#Sorting" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Base.issorted" href="#Base.issorted"><code>Base.issorted</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">issorted(df::AbstractDataFrame, cols;
         lt=isless, by=identity, rev::Bool=false, order::Ordering=Forward)</code></pre><p>Test whether data frame <code>df</code> sorted by column(s) <code>cols</code>.</p><p><code>cols</code> can be any column selector (<code>Symbol</code>, string or integer; <code>:</code>, <code>Cols</code>, <code>All</code>, <code>Between</code>, <code>Not</code>, a regular expression, or a vector of <code>Symbol</code>s, strings or integers).</p><p>If <code>rev</code> is <code>true</code>, reverse sorting is performed. To enable reverse sorting only for some columns, pass <code>order(c, rev=true)</code> in <code>cols</code>, with <code>c</code> the corresponding column index (see example below). See other methods for a description of other keyword arguments.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/6e35e296fbdef047cfdb043d54f80375331b47b5/src/abstractdataframe/sort.jl#L307-L319">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFrames.order" href="#DataFrames.order"><code>DataFrames.order</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">order(col::ColumnIndex; kwargs...)</code></pre><p>Specify sorting order for a column <code>col</code> in a data frame. <code>kwargs</code> can be <code>lt</code>, <code>by</code>, <code>rev</code>, and <code>order</code> with values following the rules defined in <a href="#Base.sort!"><code>sort!</code></a>.</p><p>See also: <a href="#Base.sort!"><code>sort!</code></a>, <a href="#Base.sort"><code>sort</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; df = DataFrame(x = [-3, -1, 0, 2, 4], y = 1:5)
5×2 DataFrame
 Row │ x      y
     │ Int64  Int64
─────┼──────────────
   1 │    -3      1
   2 │    -1      2
   3 │     0      3
   4 │     2      4
   5 │     4      5

julia&gt; sort(df, order(:x, rev=true))
5×2 DataFrame
 Row │ x      y
     │ Int64  Int64
─────┼──────────────
   1 │     4      5
   2 │     2      4
   3 │     0      3
   4 │    -1      2
   5 │    -3      1

julia&gt; sort(df, order(:x, by=abs))
5×2 DataFrame
 Row │ x      y
     │ Int64  Int64
─────┼──────────────
   1 │     0      3
   2 │    -1      2
   3 │     2      4
   4 │    -3      1
   5 │     4      5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/6e35e296fbdef047cfdb043d54f80375331b47b5/src/abstractdataframe/sort.jl#L22-L66">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.sort" href="#Base.sort"><code>Base.sort</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">sort(df::AbstractDataFrame, cols;
     alg::Union{Algorithm, Nothing}=nothing, lt=isless, by=identity,
     rev::Bool=false, order::Ordering=Forward, view::Bool=false)</code></pre><p>Return a data frame containing the rows in <code>df</code> sorted by column(s) <code>cols</code>.</p><p><code>cols</code> can be any column selector (<code>Symbol</code>, string or integer; <code>:</code>, <code>Cols</code>, <code>All</code>, <code>Between</code>, <code>Not</code>, a regular expression, or a vector of <code>Symbol</code>s, strings or integers).</p><p>If <code>alg</code> is <code>nothing</code> (the default), the most appropriate algorithm is chosen automatically among <code>TimSort</code>, <code>MergeSort</code> and <code>RadixSort</code> depending on the type of the sorting columns and on the number of rows in <code>df</code>. If <code>rev</code> is <code>true</code>, reverse sorting is performed. To enable reverse sorting only for some columns, pass <code>order(c, rev=true)</code> in <code>cols</code>, with <code>c</code> the corresponding column index (see example below).</p><p>If <code>view=false</code> a freshly allocated <code>DataFrame</code> is returned. If <code>view=true</code> then a <code>SubDataFrame</code> view into <code>df</code> is returned.</p><p>See <a href="#Base.sort!"><code>sort!</code></a> for a description of other keyword arguments.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; df = DataFrame(x = [3, 1, 2, 1], y = [&quot;b&quot;, &quot;c&quot;, &quot;a&quot;, &quot;b&quot;])
4×2 DataFrame
 Row │ x      y
     │ Int64  String
─────┼───────────────
   1 │     3  b
   2 │     1  c
   3 │     2  a
   4 │     1  b

julia&gt; sort(df, :x)
4×2 DataFrame
 Row │ x      y
     │ Int64  String
─────┼───────────────
   1 │     1  c
   2 │     1  b
   3 │     2  a
   4 │     3  b

julia&gt; sort(df, [:x, :y])
4×2 DataFrame
 Row │ x      y
     │ Int64  String
─────┼───────────────
   1 │     1  b
   2 │     1  c
   3 │     2  a
   4 │     3  b

julia&gt; sort(df, [:x, :y], rev=true)
4×2 DataFrame
 Row │ x      y
     │ Int64  String
─────┼───────────────
   1 │     3  b
   2 │     2  a
   3 │     1  c
   4 │     1  b

julia&gt; sort(df, [:x, order(:y, rev=true)])
4×2 DataFrame
 Row │ x      y
     │ Int64  String
─────┼───────────────
   1 │     1  c
   2 │     1  b
   3 │     2  a
   4 │     3  b</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/6e35e296fbdef047cfdb043d54f80375331b47b5/src/abstractdataframe/sort.jl#L335-L408">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.sort!" href="#Base.sort!"><code>Base.sort!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">sort!(df::AbstractDataFrame, cols;
      alg::Union{Algorithm, Nothing}=nothing, lt=isless, by=identity,
      rev::Bool=false, order::Ordering=Forward)</code></pre><p>Sort data frame <code>df</code> by column(s) <code>cols</code>.</p><p><code>cols</code> can be any column selector (<code>Symbol</code>, string or integer; <code>:</code>, <code>Cols</code>, <code>All</code>, <code>Between</code>, <code>Not</code>, a regular expression, or a vector of <code>Symbol</code>s, strings or integers).</p><p>If <code>alg</code> is <code>nothing</code> (the default), the most appropriate algorithm is chosen automatically among <code>TimSort</code>, <code>MergeSort</code> and <code>RadixSort</code> depending on the type of the sorting columns and on the number of rows in <code>df</code>. If <code>rev</code> is <code>true</code>, reverse sorting is performed. To enable reverse sorting only for some columns, pass <code>order(c, rev=true)</code> in <code>cols</code>, with <code>c</code> the corresponding column index (see example below). See other methods for a description of other keyword arguments.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; df = DataFrame(x = [3, 1, 2, 1], y = [&quot;b&quot;, &quot;c&quot;, &quot;a&quot;, &quot;b&quot;])
4×2 DataFrame
 Row │ x      y
     │ Int64  String
─────┼───────────────
   1 │     3  b
   2 │     1  c
   3 │     2  a
   4 │     1  b

julia&gt; sort!(df, :x)
4×2 DataFrame
 Row │ x      y
     │ Int64  String
─────┼───────────────
   1 │     1  c
   2 │     1  b
   3 │     2  a
   4 │     3  b

julia&gt; sort!(df, [:x, :y])
4×2 DataFrame
 Row │ x      y
     │ Int64  String
─────┼───────────────
   1 │     1  b
   2 │     1  c
   3 │     2  a
   4 │     3  b

julia&gt; sort!(df, [:x, :y], rev=true)
4×2 DataFrame
 Row │ x      y
     │ Int64  String
─────┼───────────────
   1 │     3  b
   2 │     2  a
   3 │     1  c
   4 │     1  b

julia&gt; sort!(df, [:x, order(:y, rev=true)])
4×2 DataFrame
 Row │ x      y
     │ Int64  String
─────┼───────────────
   1 │     1  c
   2 │     1  b
   3 │     2  a
   4 │     3  b</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/6e35e296fbdef047cfdb043d54f80375331b47b5/src/dataframe/sort.jl#L2-L71">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.sortperm" href="#Base.sortperm"><code>Base.sortperm</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">sortperm(df::AbstractDataFrame, cols;
         alg::Union{Algorithm, Nothing}=nothing, lt=isless, by=identity,
         rev::Bool=false, order::Ordering=Forward)</code></pre><p>Return a permutation vector of row indices of data frame <code>df</code> that puts them in sorted order according to column(s) <code>cols</code>.</p><p><code>cols</code> can be any column selector (<code>Symbol</code>, string or integer; <code>:</code>, <code>Cols</code>, <code>All</code>, <code>Between</code>, <code>Not</code>, a regular expression, or a vector of <code>Symbol</code>s, strings or integers).</p><p>If <code>alg</code> is <code>nothing</code> (the default), the most appropriate algorithm is chosen automatically among <code>TimSort</code>, <code>MergeSort</code> and <code>RadixSort</code> depending on the type of the sorting columns and on the number of rows in <code>df</code>. If <code>rev</code> is <code>true</code>, reverse sorting is performed. To enable reverse sorting only for some columns, pass <code>order(c, rev=true)</code> in <code>cols</code>, with <code>c</code> the corresponding column index (see example below). See other methods for a description of other keyword arguments.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; df = DataFrame(x = [3, 1, 2, 1], y = [&quot;b&quot;, &quot;c&quot;, &quot;a&quot;, &quot;b&quot;])
4×2 DataFrame
 Row │ x      y
     │ Int64  String
─────┼───────────────
   1 │     3  b
   2 │     1  c
   3 │     2  a
   4 │     1  b

julia&gt; sortperm(df, :x)
4-element Vector{Int64}:
 2
 4
 3
 1

julia&gt; sortperm(df, [:x, :y])
4-element Vector{Int64}:
 4
 2
 3
 1

julia&gt; sortperm(df, [:x, :y], rev=true)
4-element Vector{Int64}:
 1
 3
 2
 4

julia&gt; sortperm(df, [:x, order(:y, rev=true)])
4-element Vector{Int64}:
 2
 4
 3
 1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/6e35e296fbdef047cfdb043d54f80375331b47b5/src/abstractdataframe/sort.jl#L415-L473">source</a></section></article><h2 id="Joining"><a class="docs-heading-anchor" href="#Joining">Joining</a><a id="Joining-1"></a><a class="docs-heading-anchor-permalink" href="#Joining" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="DataFrames.antijoin" href="#DataFrames.antijoin"><code>DataFrames.antijoin</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">antijoin(df1, df2; on, makeunique=false, validate=(false, false), matchmissing=:error)</code></pre><p>Perform an anti join of two data frame objects and return a <code>DataFrame</code> containing the result. An anti join returns the subset of rows of <code>df1</code> that do not match with the keys in <code>df2</code>.</p><p>The order of rows in the result is undefined and may change in the future releases.</p><p><strong>Arguments</strong></p><ul><li><code>df1</code>, <code>df2</code>: the <code>AbstractDataFrames</code> to be joined</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>on</code> : A column name to join <code>df1</code> and <code>df2</code> on. If the columns on which <code>df1</code> and <code>df2</code> will be joined have different names, then a <code>left=&gt;right</code> pair can be passed. It is also allowed to perform a join on multiple columns, in which case a vector of column names or column name pairs can be passed (mixing names and pairs is allowed).</li><li><code>makeunique</code> : if <code>false</code> (the default), an error will be raised if duplicate names are found in columns not joined on; if <code>true</code>, duplicate names will be suffixed with <code>_i</code> (<code>i</code> starting at 1 for the first duplicate).</li><li><code>validate</code> : whether to check that columns passed as the <code>on</code> argument  define unique keys in each input data frame (according to <code>isequal</code>).  Can be a tuple or a pair, with the first element indicating whether to  run check for <code>df1</code> and the second element for <code>df2</code>.  By default no check is performed.</li><li><code>matchmissing</code> : if equal to <code>:error</code> throw an error if <code>missing</code> is present in <code>on</code> columns; if equal to <code>:equal</code> then <code>missing</code> is allowed and missings are matched (<code>isequal</code> is used for comparisons of rows for equality)</li></ul><p>It is not allowed to join on columns that contain <code>NaN</code> or <code>-0.0</code> in real or imaginary part of the number. If you need to perform a join on such values use CategoricalArrays.jl and transform a column containing such values into a <code>CategoricalVector</code>.</p><p>When merging <code>on</code> categorical columns that differ in the ordering of their levels, the ordering of the left data frame takes precedence over the ordering of the right data frame.</p><p>See also: <a href="#DataFrames.innerjoin"><code>innerjoin</code></a>, <a href="#DataFrames.leftjoin"><code>leftjoin</code></a>, <a href="#DataFrames.rightjoin"><code>rightjoin</code></a>,           <a href="#DataFrames.outerjoin"><code>outerjoin</code></a>, <a href="#DataFrames.semijoin"><code>semijoin</code></a>, <a href="#DataFrames.crossjoin"><code>crossjoin</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; name = DataFrame(ID = [1, 2, 3], Name = [&quot;John Doe&quot;, &quot;Jane Doe&quot;, &quot;Joe Blogs&quot;])
3×2 DataFrame
 Row │ ID     Name
     │ Int64  String
─────┼──────────────────
   1 │     1  John Doe
   2 │     2  Jane Doe
   3 │     3  Joe Blogs

julia&gt; job = DataFrame(ID = [1, 2, 4], Job = [&quot;Lawyer&quot;, &quot;Doctor&quot;, &quot;Farmer&quot;])
3×2 DataFrame
 Row │ ID     Job
     │ Int64  String
─────┼───────────────
   1 │     1  Lawyer
   2 │     2  Doctor
   3 │     4  Farmer

julia&gt; antijoin(name, job, on = :ID)
1×2 DataFrame
 Row │ ID     Name
     │ Int64  String
─────┼──────────────────
   1 │     3  Joe Blogs

julia&gt; job2 = DataFrame(identifier = [1, 2, 4], Job = [&quot;Lawyer&quot;, &quot;Doctor&quot;, &quot;Farmer&quot;])
3×2 DataFrame
 Row │ identifier  Job
     │ Int64       String
─────┼────────────────────
   1 │          1  Lawyer
   2 │          2  Doctor
   3 │          4  Farmer

julia&gt; antijoin(name, job2, on = :ID =&gt; :identifier)
1×2 DataFrame
 Row │ ID     Name
     │ Int64  String
─────┼──────────────────
   1 │     3  Joe Blogs

julia&gt; antijoin(name, job2, on = [:ID =&gt; :identifier])
1×2 DataFrame
 Row │ ID     Name
     │ Int64  String
─────┼──────────────────
   1 │     3  Joe Blogs</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/6e35e296fbdef047cfdb043d54f80375331b47b5/src/join/composer.jl#L1141-L1234">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFrames.crossjoin" href="#DataFrames.crossjoin"><code>DataFrames.crossjoin</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">crossjoin(df1, df2, dfs...; makeunique = false)</code></pre><p>Perform a cross join of two or more data frame objects and return a <code>DataFrame</code> containing the result. A cross join returns the cartesian product of rows from all passed data frames, where the first passed data frame is assigned to the dimension that changes the slowest and the last data frame is assigned to the dimension that changes the fastest.</p><p><strong>Arguments</strong></p><ul><li><code>df1</code>, <code>df2</code>, <code>dfs...</code> : the <code>AbstractDataFrames</code> to be joined</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>makeunique</code> : if <code>false</code> (the default), an error will be raised if duplicate names are found in columns not joined on; if <code>true</code>, duplicate names will be suffixed with <code>_i</code> (<code>i</code> starting at 1 for the first duplicate).</li></ul><p>If more than two data frames are passed, the join is performed recursively with left associativity.</p><p>See also: <a href="#DataFrames.innerjoin"><code>innerjoin</code></a>, <a href="#DataFrames.leftjoin"><code>leftjoin</code></a>, <a href="#DataFrames.rightjoin"><code>rightjoin</code></a>,           <a href="#DataFrames.outerjoin"><code>outerjoin</code></a>, <a href="#DataFrames.semijoin"><code>semijoin</code></a>, <a href="#DataFrames.antijoin"><code>antijoin</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; df1 = DataFrame(X=1:3)
3×1 DataFrame
 Row │ X
     │ Int64
─────┼───────
   1 │     1
   2 │     2
   3 │     3

julia&gt; df2 = DataFrame(Y=[&quot;a&quot;, &quot;b&quot;])
2×1 DataFrame
 Row │ Y
     │ String
─────┼────────
   1 │ a
   2 │ b

julia&gt; crossjoin(df1, df2)
6×2 DataFrame
 Row │ X      Y
     │ Int64  String
─────┼───────────────
   1 │     1  a
   2 │     1  b
   3 │     2  a
   4 │     2  b
   5 │     3  a
   6 │     3  b</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/6e35e296fbdef047cfdb043d54f80375331b47b5/src/join/composer.jl#L1244-L1299">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFrames.innerjoin" href="#DataFrames.innerjoin"><code>DataFrames.innerjoin</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">innerjoin(df1, df2; on, makeunique=false, validate=(false, false),
          renamecols=(identity =&gt; identity), matchmissing=:error)
innerjoin(df1, df2, dfs...; on, makeunique=false,
          validate=(false, false), matchmissing=:error)</code></pre><p>Perform an inner join of two or more data frame objects and return a <code>DataFrame</code> containing the result. An inner join includes rows with keys that match in all passed data frames.</p><p>The order of rows in the result is undefined and may change in the future releases.</p><p>In the returned data frame the type of the columns on which the data frames are joined is determined by the type of these columns in <code>df1</code>. This behavior may change in future releases.</p><p><strong>Arguments</strong></p><ul><li><code>df1</code>, <code>df2</code>, <code>dfs...</code>: the <code>AbstractDataFrames</code> to be joined</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>on</code> : A column name to join <code>df1</code> and <code>df2</code> on. If the columns on which <code>df1</code> and <code>df2</code> will be joined have different names, then a <code>left=&gt;right</code> pair can be passed. It is also allowed to perform a join on multiple columns, in which case a vector of column names or column name pairs can be passed (mixing names and pairs is allowed). If more than two data frames are joined then only a column name or a vector of column names are allowed. <code>on</code> is a required argument.</li><li><code>makeunique</code> : if <code>false</code> (the default), an error will be raised if duplicate names are found in columns not joined on; if <code>true</code>, duplicate names will be suffixed with <code>_i</code> (<code>i</code> starting at 1 for the first duplicate).</li><li><code>validate</code> : whether to check that columns passed as the <code>on</code> argument define unique keys in each input data frame (according to <code>isequal</code>). Can be a tuple or a pair, with the first element indicating whether to run check for <code>df1</code> and the second element for <code>df2</code>. By default no check is performed.</li><li><code>renamecols</code> : a <code>Pair</code> specifying how columns of left and right data frames should be renamed in the resulting data frame. Each element of the pair can be a string or a <code>Symbol</code> can be passed in which case it is appended to the original column name; alternatively a function can be passed in which case it is applied to each column name, which is passed to it as a <code>String</code>. Note that <code>renamecols</code> does not affect <code>on</code> columns, whose names are always taken from the left data frame and left unchanged.</li><li><code>matchmissing</code> : if equal to <code>:error</code> throw an error if <code>missing</code> is present in <code>on</code> columns; if equal to <code>:equal</code> then <code>missing</code> is allowed and missings are matched (<code>isequal</code> is used for comparisons of rows for equality)</li></ul><p>It is not allowed to join on columns that contain <code>NaN</code> or <code>-0.0</code> in real or imaginary part of the number. If you need to perform a join on such values use CategoricalArrays.jl and transform a column containing such values into a <code>CategoricalVector</code>.</p><p>When merging <code>on</code> categorical columns that differ in the ordering of their levels, the ordering of the left data frame takes precedence over the ordering of the right data frame.</p><p>If more than two data frames are passed, the join is performed recursively with left associativity. In this case the <code>validate</code> keyword argument is applied recursively with left associativity.</p><p>See also: <a href="#DataFrames.leftjoin"><code>leftjoin</code></a>, <a href="#DataFrames.rightjoin"><code>rightjoin</code></a>, <a href="#DataFrames.outerjoin"><code>outerjoin</code></a>,           <a href="#DataFrames.semijoin"><code>semijoin</code></a>, <a href="#DataFrames.antijoin"><code>antijoin</code></a>, <a href="#DataFrames.crossjoin"><code>crossjoin</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; name = DataFrame(ID = [1, 2, 3], Name = [&quot;John Doe&quot;, &quot;Jane Doe&quot;, &quot;Joe Blogs&quot;])
3×2 DataFrame
 Row │ ID     Name
     │ Int64  String
─────┼──────────────────
   1 │     1  John Doe
   2 │     2  Jane Doe
   3 │     3  Joe Blogs

julia&gt; job = DataFrame(ID = [1, 2, 4], Job = [&quot;Lawyer&quot;, &quot;Doctor&quot;, &quot;Farmer&quot;])
3×2 DataFrame
 Row │ ID     Job
     │ Int64  String
─────┼───────────────
   1 │     1  Lawyer
   2 │     2  Doctor
   3 │     4  Farmer

julia&gt; innerjoin(name, job, on = :ID)
2×3 DataFrame
 Row │ ID     Name      Job
     │ Int64  String    String
─────┼─────────────────────────
   1 │     1  John Doe  Lawyer
   2 │     2  Jane Doe  Doctor

julia&gt; job2 = DataFrame(identifier = [1, 2, 4], Job = [&quot;Lawyer&quot;, &quot;Doctor&quot;, &quot;Farmer&quot;])
3×2 DataFrame
 Row │ identifier  Job
     │ Int64       String
─────┼────────────────────
   1 │          1  Lawyer
   2 │          2  Doctor
   3 │          4  Farmer

julia&gt; innerjoin(name, job2, on = :ID =&gt; :identifier, renamecols = &quot;_left&quot; =&gt; &quot;_right&quot;)
2×3 DataFrame
 Row │ ID     Name_left  Job_right
     │ Int64  String     String
─────┼─────────────────────────────
   1 │     1  John Doe   Lawyer
   2 │     2  Jane Doe   Doctor

julia&gt; innerjoin(name, job2, on = [:ID =&gt; :identifier], renamecols = uppercase =&gt; lowercase)
2×3 DataFrame
 Row │ ID     NAME      job
     │ Int64  String    String
─────┼─────────────────────────
   1 │     1  John Doe  Lawyer
   2 │     2  Jane Doe  Doctor</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/6e35e296fbdef047cfdb043d54f80375331b47b5/src/join/composer.jl#L434-L550">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFrames.leftjoin" href="#DataFrames.leftjoin"><code>DataFrames.leftjoin</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">leftjoin(df1, df2; on, makeunique=false, source=nothing, validate=(false, false),
         renamecols=(identity =&gt; identity), matchmissing=:error)</code></pre><p>Perform a left join of two data frame objects and return a <code>DataFrame</code> containing the result. A left join includes all rows from <code>df1</code>.</p><p>The order of rows in the result is undefined and may change in the future releases.</p><p>In the returned data frame the type of the columns on which the data frames are joined is determined by the type of these columns in <code>df1</code>. This behavior may change in future releases.</p><p><strong>Arguments</strong></p><ul><li><code>df1</code>, <code>df2</code>: the <code>AbstractDataFrames</code> to be joined</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>on</code> : A column name to join <code>df1</code> and <code>df2</code> on. If the columns on which <code>df1</code> and <code>df2</code> will be joined have different names, then a <code>left=&gt;right</code> pair can be passed. It is also allowed to perform a join on multiple columns, in which case a vector of column names or column name pairs can be passed (mixing names and pairs is allowed).</li><li><code>makeunique</code> : if <code>false</code> (the default), an error will be raised if duplicate names are found in columns not joined on; if <code>true</code>, duplicate names will be suffixed with <code>_i</code> (<code>i</code> starting at 1 for the first duplicate).</li><li><code>source</code> : Default: <code>nothing</code>. If a <code>Symbol</code> or string, adds indicator column with the given name, for whether a row appeared in only <code>df1</code> (<code>&quot;left_only&quot;</code>), only <code>df2</code> (<code>&quot;right_only&quot;</code>) or in both (<code>&quot;both&quot;</code>). If the name is already in use, the column name will be modified if <code>makeunique=true</code>.</li><li><code>validate</code> : whether to check that columns passed as the <code>on</code> argument define unique keys in each input data frame (according to <code>isequal</code>). Can be a tuple or a pair, with the first element indicating whether to run check for <code>df1</code> and the second element for <code>df2</code>. By default no check is performed.</li><li><code>renamecols</code> : a <code>Pair</code> specifying how columns of left and right data frames should be renamed in the resulting data frame. Each element of the pair can be a string or a <code>Symbol</code> can be passed in which case it is appended to the original column name; alternatively a function can be passed in which case it is applied to each column name, which is passed to it as a <code>String</code>. Note that <code>renamecols</code> does not affect <code>on</code> columns, whose names are always taken from the left data frame and left unchanged.</li><li><code>matchmissing</code> : if equal to <code>:error</code> throw an error if <code>missing</code> is present in <code>on</code> columns; if equal to <code>:equal</code> then <code>missing</code> is allowed and missings are matched (<code>isequal</code> is used for comparisons of rows for equality)</li></ul><p>All columns of the returned data table will support missing values.</p><p>It is not allowed to join on columns that contain <code>NaN</code> or <code>-0.0</code> in real or imaginary part of the number. If you need to perform a join on such values use CategoricalArrays.jl and transform a column containing such values into a <code>CategoricalVector</code>.</p><p>When merging <code>on</code> categorical columns that differ in the ordering of their levels, the ordering of the left data frame takes precedence over the ordering of the right data frame.</p><p>See also: <a href="#DataFrames.innerjoin"><code>innerjoin</code></a>, <a href="#DataFrames.rightjoin"><code>rightjoin</code></a>, <a href="#DataFrames.outerjoin"><code>outerjoin</code></a>,           <a href="#DataFrames.semijoin"><code>semijoin</code></a>, <a href="#DataFrames.antijoin"><code>antijoin</code></a>, <a href="#DataFrames.crossjoin"><code>crossjoin</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; name = DataFrame(ID = [1, 2, 3], Name = [&quot;John Doe&quot;, &quot;Jane Doe&quot;, &quot;Joe Blogs&quot;])
3×2 DataFrame
 Row │ ID     Name
     │ Int64  String
─────┼──────────────────
   1 │     1  John Doe
   2 │     2  Jane Doe
   3 │     3  Joe Blogs

julia&gt; job = DataFrame(ID = [1, 2, 4], Job = [&quot;Lawyer&quot;, &quot;Doctor&quot;, &quot;Farmer&quot;])
3×2 DataFrame
 Row │ ID     Job
     │ Int64  String
─────┼───────────────
   1 │     1  Lawyer
   2 │     2  Doctor
   3 │     4  Farmer

julia&gt; leftjoin(name, job, on = :ID)
3×3 DataFrame
 Row │ ID     Name       Job
     │ Int64  String     String?
─────┼───────────────────────────
   1 │     1  John Doe   Lawyer
   2 │     2  Jane Doe   Doctor
   3 │     3  Joe Blogs  missing

julia&gt; job2 = DataFrame(identifier = [1, 2, 4], Job = [&quot;Lawyer&quot;, &quot;Doctor&quot;, &quot;Farmer&quot;])
3×2 DataFrame
 Row │ identifier  Job
     │ Int64       String
─────┼────────────────────
   1 │          1  Lawyer
   2 │          2  Doctor
   3 │          4  Farmer

julia&gt; leftjoin(name, job2, on = :ID =&gt; :identifier, renamecols = &quot;_left&quot; =&gt; &quot;_right&quot;)
3×3 DataFrame
 Row │ ID     Name_left  Job_right
     │ Int64  String     String?
─────┼─────────────────────────────
   1 │     1  John Doe   Lawyer
   2 │     2  Jane Doe   Doctor
   3 │     3  Joe Blogs  missing

julia&gt; leftjoin(name, job2, on = [:ID =&gt; :identifier], renamecols = uppercase =&gt; lowercase)
3×3 DataFrame
 Row │ ID     NAME       job
     │ Int64  String     String?
─────┼───────────────────────────
   1 │     1  John Doe   Lawyer
   2 │     2  Jane Doe   Doctor
   3 │     3  Joe Blogs  missing</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/6e35e296fbdef047cfdb043d54f80375331b47b5/src/join/composer.jl#L576-L692">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFrames.outerjoin" href="#DataFrames.outerjoin"><code>DataFrames.outerjoin</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">outerjoin(df1, df2; on, makeunique=false, source=nothing, validate=(false, false),
          renamecols=(identity =&gt; identity), matchmissing=:error)
outerjoin(df1, df2, dfs...; on, makeunique = false,
          validate = (false, false), matchmissing=:error)</code></pre><p>Perform an outer join of two or more data frame objects and return a <code>DataFrame</code> containing the result. An outer join includes rows with keys that appear in any of the passed data frames.</p><p>The order of rows in the result is undefined and may change in the future releases.</p><p>In the returned data frame the type of the columns on which the data frames are joined is determined by the element type of these columns both <code>df1</code> and <code>df2</code>. This behavior may change in future releases.</p><p><strong>Arguments</strong></p><ul><li><code>df1</code>, <code>df2</code>, <code>dfs...</code> : the <code>AbstractDataFrames</code> to be joined</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>on</code> : A column name to join <code>df1</code> and <code>df2</code> on. If the columns on which <code>df1</code> and <code>df2</code> will be joined have different names, then a <code>left=&gt;right</code> pair can be passed. It is also allowed to perform a join on multiple columns, in which case a vector of column names or column name pairs can be passed (mixing names and pairs is allowed). If more than two data frames are joined then only a column name or a vector of column names are allowed. <code>on</code> is a required argument.</li><li><code>makeunique</code> : if <code>false</code> (the default), an error will be raised if duplicate names are found in columns not joined on; if <code>true</code>, duplicate names will be suffixed with <code>_i</code> (<code>i</code> starting at 1 for the first duplicate).</li><li><code>source</code> : Default: <code>nothing</code>. If a <code>Symbol</code> or string, adds indicator column with the given name for whether a row appeared in only <code>df1</code> (<code>&quot;left_only&quot;</code>), only <code>df2</code> (<code>&quot;right_only&quot;</code>) or in both (<code>&quot;both&quot;</code>). If the name is already in use, the column name will be modified if <code>makeunique=true</code>. This argument is only supported when joining exactly two data frames.</li><li><code>validate</code> : whether to check that columns passed as the <code>on</code> argument define unique keys in each input data frame (according to <code>isequal</code>). Can be a tuple or a pair, with the first element indicating whether to run check for <code>df1</code> and the second element for <code>df2</code>. By default no check is performed.</li><li><code>renamecols</code> : a <code>Pair</code> specifying how columns of left and right data frames should be renamed in the resulting data frame. Each element of the pair can be a string or a <code>Symbol</code> can be passed in which case it is appended to the original column name; alternatively a function can be passed in which case it is applied to each column name, which is passed to it as a <code>String</code>. Note that <code>renamecols</code> does not affect <code>on</code> columns, whose names are always taken from the left data frame and left unchanged.</li><li><code>matchmissing</code> : if equal to <code>:error</code> throw an error if <code>missing</code> is present in <code>on</code> columns; if equal to <code>:equal</code> then <code>missing</code> is allowed and missings are matched (<code>isequal</code> is used for comparisons of rows for equality)</li></ul><p>All columns of the returned data table will support missing values.</p><p>It is not allowed to join on columns that contain <code>NaN</code> or <code>-0.0</code> in real or imaginary part of the number. If you need to perform a join on such values use CategoricalArrays.jl and transform a column containing such values into a <code>CategoricalVector</code>.</p><p>When merging <code>on</code> categorical columns that differ in the ordering of their levels, the ordering of the left data frame takes precedence over the ordering of the right data frame.</p><p>If more than two data frames are passed, the join is performed recursively with left associativity. In this case the <code>indicator</code> keyword argument is not supported and <code>validate</code> keyword argument is applied recursively with left associativity.</p><p>See also: <a href="#DataFrames.innerjoin"><code>innerjoin</code></a>, <a href="#DataFrames.leftjoin"><code>leftjoin</code></a>, <a href="#DataFrames.rightjoin"><code>rightjoin</code></a>,           <a href="#DataFrames.semijoin"><code>semijoin</code></a>, <a href="#DataFrames.antijoin"><code>antijoin</code></a>, <a href="#DataFrames.crossjoin"><code>crossjoin</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; name = DataFrame(ID = [1, 2, 3], Name = [&quot;John Doe&quot;, &quot;Jane Doe&quot;, &quot;Joe Blogs&quot;])
3×2 DataFrame
 Row │ ID     Name
     │ Int64  String
─────┼──────────────────
   1 │     1  John Doe
   2 │     2  Jane Doe
   3 │     3  Joe Blogs

julia&gt; job = DataFrame(ID = [1, 2, 4], Job = [&quot;Lawyer&quot;, &quot;Doctor&quot;, &quot;Farmer&quot;])
3×2 DataFrame
 Row │ ID     Job
     │ Int64  String
─────┼───────────────
   1 │     1  Lawyer
   2 │     2  Doctor
   3 │     4  Farmer

julia&gt; outerjoin(name, job, on = :ID)
4×3 DataFrame
 Row │ ID     Name       Job
     │ Int64  String?    String?
─────┼───────────────────────────
   1 │     1  John Doe   Lawyer
   2 │     2  Jane Doe   Doctor
   3 │     3  Joe Blogs  missing
   4 │     4  missing    Farmer

julia&gt; job2 = DataFrame(identifier = [1, 2, 4], Job = [&quot;Lawyer&quot;, &quot;Doctor&quot;, &quot;Farmer&quot;])
3×2 DataFrame
 Row │ identifier  Job
     │ Int64       String
─────┼────────────────────
   1 │          1  Lawyer
   2 │          2  Doctor
   3 │          4  Farmer

julia&gt; rightjoin(name, job2, on = :ID =&gt; :identifier, renamecols = &quot;_left&quot; =&gt; &quot;_right&quot;)
3×3 DataFrame
 Row │ ID     Name_left  Job_right
     │ Int64  String?    String
─────┼─────────────────────────────
   1 │     1  John Doe   Lawyer
   2 │     2  Jane Doe   Doctor
   3 │     4  missing    Farmer

julia&gt; rightjoin(name, job2, on = [:ID =&gt; :identifier], renamecols = uppercase =&gt; lowercase)
3×3 DataFrame
 Row │ ID     NAME      job
     │ Int64  String?   String
─────┼─────────────────────────
   1 │     1  John Doe  Lawyer
   2 │     2  Jane Doe  Doctor
   3 │     4  missing   Farmer</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/6e35e296fbdef047cfdb043d54f80375331b47b5/src/join/composer.jl#L867-L995">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFrames.rightjoin" href="#DataFrames.rightjoin"><code>DataFrames.rightjoin</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">rightjoin(df1, df2; on, makeunique=false, source=nothing,
          validate=(false, false), renamecols=(identity =&gt; identity),
          matchmissing=:error)</code></pre><p>Perform a right join on two data frame objects and return a <code>DataFrame</code> containing the result. A right join includes all rows from <code>df2</code>.</p><p>The order of rows in the result is undefined and may change in the future releases.</p><p>In the returned data frame the type of the columns on which the data frames are joined is determined by the type of these columns in <code>df2</code>. This behavior may change in future releases.</p><p><strong>Arguments</strong></p><ul><li><code>df1</code>, <code>df2</code>: the <code>AbstractDataFrames</code> to be joined</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>on</code> : A column name to join <code>df1</code> and <code>df2</code> on. If the columns on which <code>df1</code> and <code>df2</code> will be joined have different names, then a <code>left=&gt;right</code> pair can be passed. It is also allowed to perform a join on multiple columns, in which case a vector of column names or column name pairs can be passed (mixing names and pairs is allowed).</li><li><code>makeunique</code> : if <code>false</code> (the default), an error will be raised if duplicate names are found in columns not joined on; if <code>true</code>, duplicate names will be suffixed with <code>_i</code> (<code>i</code> starting at 1 for the first duplicate).</li><li><code>source</code> : Default: <code>nothing</code>. If a <code>Symbol</code> or string, adds indicator column with the given name for whether a row appeared in only <code>df1</code> (<code>&quot;left_only&quot;</code>), only <code>df2</code> (<code>&quot;right_only&quot;</code>) or in both (<code>&quot;both&quot;</code>). If the name is already in use, the column name will be modified if <code>makeunique=true</code>.</li><li><code>validate</code> : whether to check that columns passed as the <code>on</code> argument define unique keys in each input data frame (according to <code>isequal</code>). Can be a tuple or a pair, with the first element indicating whether to run check for <code>df1</code> and the second element for <code>df2</code>. By default no check is performed.</li><li><code>renamecols</code> : a <code>Pair</code> specifying how columns of left and right data frames should be renamed in the resulting data frame. Each element of the pair can be a string or a <code>Symbol</code> can be passed in which case it is appended to the original column name; alternatively a function can be passed in which case it is applied to each column name, which is passed to it as a <code>String</code>. Note that <code>renamecols</code> does not affect <code>on</code> columns, whose names are always taken from the left data frame and left unchanged.</li><li><code>matchmissing</code> : if equal to <code>:error</code> throw an error if <code>missing</code> is present in <code>on</code> columns; if equal to <code>:equal</code> then <code>missing</code> is allowed and missings are matched (<code>isequal</code> is used for comparisons of rows for equality)</li></ul><p>All columns of the returned data table will support missing values.</p><p>It is not allowed to join on columns that contain <code>NaN</code> or <code>-0.0</code> in real or imaginary part of the number. If you need to perform a join on such values use CategoricalArrays.jl and transform a column containing such values into a <code>CategoricalVector</code>.</p><p>When merging <code>on</code> categorical columns that differ in the ordering of their levels, the ordering of the left data frame takes precedence over the ordering of the right data frame.</p><p>See also: <a href="#DataFrames.innerjoin"><code>innerjoin</code></a>, <a href="#DataFrames.leftjoin"><code>leftjoin</code></a>, <a href="#DataFrames.outerjoin"><code>outerjoin</code></a>,           <a href="#DataFrames.semijoin"><code>semijoin</code></a>, <a href="#DataFrames.antijoin"><code>antijoin</code></a>, <a href="#DataFrames.crossjoin"><code>crossjoin</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; name = DataFrame(ID = [1, 2, 3], Name = [&quot;John Doe&quot;, &quot;Jane Doe&quot;, &quot;Joe Blogs&quot;])
3×2 DataFrame
 Row │ ID     Name
     │ Int64  String
─────┼──────────────────
   1 │     1  John Doe
   2 │     2  Jane Doe
   3 │     3  Joe Blogs

julia&gt; job = DataFrame(ID = [1, 2, 4], Job = [&quot;Lawyer&quot;, &quot;Doctor&quot;, &quot;Farmer&quot;])
3×2 DataFrame
 Row │ ID     Job
     │ Int64  String
─────┼───────────────
   1 │     1  Lawyer
   2 │     2  Doctor
   3 │     4  Farmer

julia&gt; rightjoin(name, job, on = :ID)
3×3 DataFrame
 Row │ ID     Name      Job
     │ Int64  String?   String
─────┼─────────────────────────
   1 │     1  John Doe  Lawyer
   2 │     2  Jane Doe  Doctor
   3 │     4  missing   Farmer

julia&gt; job2 = DataFrame(identifier = [1, 2, 4], Job = [&quot;Lawyer&quot;, &quot;Doctor&quot;, &quot;Farmer&quot;])
3×2 DataFrame
 Row │ identifier  Job
     │ Int64       String
─────┼────────────────────
   1 │          1  Lawyer
   2 │          2  Doctor
   3 │          4  Farmer

julia&gt; rightjoin(name, job2, on = :ID =&gt; :identifier, renamecols = &quot;_left&quot; =&gt; &quot;_right&quot;)
3×3 DataFrame
 Row │ ID     Name_left  Job_right
     │ Int64  String?    String
─────┼─────────────────────────────
   1 │     1  John Doe   Lawyer
   2 │     2  Jane Doe   Doctor
   3 │     4  missing    Farmer

julia&gt; rightjoin(name, job2, on = [:ID =&gt; :identifier], renamecols = uppercase =&gt; lowercase)
3×3 DataFrame
 Row │ ID     NAME      job
     │ Int64  String?   String
─────┼─────────────────────────
   1 │     1  John Doe  Lawyer
   2 │     2  Jane Doe  Doctor
   3 │     4  missing   Farmer</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/6e35e296fbdef047cfdb043d54f80375331b47b5/src/join/composer.jl#L721-L838">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFrames.semijoin" href="#DataFrames.semijoin"><code>DataFrames.semijoin</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">semijoin(df1, df2; on, makeunique=false, validate=(false, false), matchmissing=:error)</code></pre><p>Perform a semi join of two data frame objects and return a <code>DataFrame</code> containing the result. A semi join returns the subset of rows of <code>df1</code> that match with the keys in <code>df2</code>.</p><p>The order of rows in the result is undefined and may change in the future releases.</p><p><strong>Arguments</strong></p><ul><li><code>df1</code>, <code>df2</code>: the <code>AbstractDataFrames</code> to be joined</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>on</code> : A column name to join <code>df1</code> and <code>df2</code> on. If the columns on which <code>df1</code> and <code>df2</code> will be joined have different names, then a <code>left=&gt;right</code> pair can be passed. It is also allowed to perform a join on multiple columns, in which case a vector of column names or column name pairs can be passed (mixing names and pairs is allowed).</li><li><code>makeunique</code> : if <code>false</code> (the default), an error will be raised if duplicate names are found in columns not joined on; if <code>true</code>, duplicate names will be suffixed with <code>_i</code> (<code>i</code> starting at 1 for the first duplicate).</li><li><code>indicator</code> : Default: <code>nothing</code>. If a <code>Symbol</code> or string, adds categorical indicator  column with the given name for whether a row appeared in only <code>df1</code> (<code>&quot;left_only&quot;</code>),  only <code>df2</code> (<code>&quot;right_only&quot;</code>) or in both (<code>&quot;both&quot;</code>). If the name is already in use,  the column name will be modified if <code>makeunique=true</code>.</li><li><code>validate</code> : whether to check that columns passed as the <code>on</code> argument  define unique keys in each input data frame (according to <code>isequal</code>).  Can be a tuple or a pair, with the first element indicating whether to  run check for <code>df1</code> and the second element for <code>df2</code>.  By default no check is performed.</li><li><code>matchmissing</code> : if equal to <code>:error</code> throw an error if <code>missing</code> is present in <code>on</code> columns; if equal to <code>:equal</code> then <code>missing</code> is allowed and missings are matched (<code>isequal</code> is used for comparisons of rows for equality)</li></ul><p>It is not allowed to join on columns that contain <code>NaN</code> or <code>-0.0</code> in real or imaginary part of the number. If you need to perform a join on such values use CategoricalArrays.jl and transform a column containing such values into a <code>CategoricalVector</code>.</p><p>When merging <code>on</code> categorical columns that differ in the ordering of their levels, the ordering of the left data frame takes precedence over the ordering of the right data frame.</p><p>See also: <a href="#DataFrames.innerjoin"><code>innerjoin</code></a>, <a href="#DataFrames.leftjoin"><code>leftjoin</code></a>, <a href="#DataFrames.rightjoin"><code>rightjoin</code></a>,           <a href="#DataFrames.outerjoin"><code>outerjoin</code></a>, <a href="#DataFrames.antijoin"><code>antijoin</code></a>, <a href="#DataFrames.crossjoin"><code>crossjoin</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; name = DataFrame(ID = [1, 2, 3], Name = [&quot;John Doe&quot;, &quot;Jane Doe&quot;, &quot;Joe Blogs&quot;])
3×2 DataFrame
 Row │ ID     Name
     │ Int64  String
─────┼──────────────────
   1 │     1  John Doe
   2 │     2  Jane Doe
   3 │     3  Joe Blogs

julia&gt; job = DataFrame(ID = [1, 2, 4], Job = [&quot;Lawyer&quot;, &quot;Doctor&quot;, &quot;Farmer&quot;])
3×2 DataFrame
 Row │ ID     Job
     │ Int64  String
─────┼───────────────
   1 │     1  Lawyer
   2 │     2  Doctor
   3 │     4  Farmer

julia&gt; semijoin(name, job, on = :ID)
2×2 DataFrame
 Row │ ID     Name
     │ Int64  String
─────┼─────────────────
   1 │     1  John Doe
   2 │     2  Jane Doe

julia&gt; job2 = DataFrame(identifier = [1, 2, 4], Job = [&quot;Lawyer&quot;, &quot;Doctor&quot;, &quot;Farmer&quot;])
3×2 DataFrame
 Row │ identifier  Job
     │ Int64       String
─────┼────────────────────
   1 │          1  Lawyer
   2 │          2  Doctor
   3 │          4  Farmer

julia&gt; semijoin(name, job2, on = :ID =&gt; :identifier)
2×2 DataFrame
 Row │ ID     Name
     │ Int64  String
─────┼─────────────────
   1 │     1  John Doe
   2 │     2  Jane Doe

julia&gt; semijoin(name, job2, on = [:ID =&gt; :identifier])
2×2 DataFrame
 Row │ ID     Name
     │ Int64  String
─────┼─────────────────
   1 │     1  John Doe
   2 │     2  Jane Doe</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/6e35e296fbdef047cfdb043d54f80375331b47b5/src/join/composer.jl#L1032-L1132">source</a></section></article><h2 id="Grouping"><a class="docs-heading-anchor" href="#Grouping">Grouping</a><a id="Grouping-1"></a><a class="docs-heading-anchor-permalink" href="#Grouping" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Base.get" href="#Base.get"><code>Base.get</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">get(gd::GroupedDataFrame, key, default)</code></pre><p>Get a group based on the values of the grouping columns.</p><p><code>key</code> may be a <code>GroupKey</code>, <code>NamedTuple</code> or <code>Tuple</code> of grouping column values (in the same order as the <code>cols</code> argument to <code>groupby</code>). It may also be an <code>AbstractDict</code>, in which case the order of the arguments does not matter.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; df = DataFrame(a = repeat([:foo, :bar, :baz], outer=[2]),
                      b = repeat([2, 1], outer=[3]),
                      c = 1:6);

julia&gt; gd = groupby(df, :a)
GroupedDataFrame with 3 groups based on key: a
First Group (2 rows): a = :foo
 Row │ a       b      c
     │ Symbol  Int64  Int64
─────┼──────────────────────
   1 │ foo         2      1
   2 │ foo         1      4
⋮
Last Group (2 rows): a = :baz
 Row │ a       b      c
     │ Symbol  Int64  Int64
─────┼──────────────────────
   1 │ baz         2      3
   2 │ baz         1      6

julia&gt; get(gd, (a=:bar,), nothing)
2×3 SubDataFrame
 Row │ a       b      c
     │ Symbol  Int64  Int64
─────┼──────────────────────
   1 │ bar         1      2
   2 │ bar         2      5

julia&gt; get(gd, (:baz,), nothing)
2×3 SubDataFrame
 Row │ a       b      c
     │ Symbol  Int64  Int64
─────┼──────────────────────
   1 │ baz         2      3
   2 │ baz         1      6

julia&gt; get(gd, (:qux,), nothing)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/6e35e296fbdef047cfdb043d54f80375331b47b5/src/groupeddataframe/groupeddataframe.jl#L864-L914">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFrames.groupby" href="#DataFrames.groupby"><code>DataFrames.groupby</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">groupby(d::AbstractDataFrame, cols; sort=false, skipmissing=false)</code></pre><p>Return a <code>GroupedDataFrame</code> representing a view of an <code>AbstractDataFrame</code> split into row groups.</p><p><strong>Arguments</strong></p><ul><li><code>df</code> : an <code>AbstractDataFrame</code> to split</li><li><code>cols</code> : data frame columns to group by. Can be any column selector (<code>Symbol</code>, string or integer; <code>:</code>, <code>Cols</code>, <code>All</code>, <code>Between</code>, <code>Not</code>, a regular expression, or a vector of <code>Symbol</code>s, strings or integers).</li><li><code>sort</code> : whether to sort groups according to the values of the grouping columns <code>cols</code>; if <code>sort=false</code> then the order of groups in the result is undefined and may change in future releases. In the current implementation groups are ordered following the order of appearance of values in the grouping columns, except when all grouping columns provide non-<code>nothing</code> <code>DataAPI.refpool</code> in which case the order of groups follows the order of values returned by <code>DataAPI.refpool</code>. As a particular application of this rule if all <code>cols</code> are <code>CategoricalVector</code>s then groups are always sorted Integer columns with a narrow range also use this this optimization, so to the order of groups when grouping on integer columns is undefined.</li><li><code>skipmissing</code> : whether to skip groups with <code>missing</code> values in one of the grouping columns <code>cols</code></li></ul><p><strong>Details</strong></p><p>An iterator over a <code>GroupedDataFrame</code> returns a <code>SubDataFrame</code> view for each grouping into <code>df</code>. Within each group, the order of rows in <code>df</code> is preserved.</p><p><code>cols</code> can be any valid data frame indexing expression. In particular if it is an empty vector then a single-group <code>GroupedDataFrame</code> is created.</p><p>A <code>GroupedDataFrame</code> also supports indexing by groups, <code>select</code>, <code>transform</code>, and <code>combine</code> (which applies a function to each group and combines the result into a data frame).</p><p><code>GroupedDataFrame</code> also supports the dictionary interface. The keys are <a href="../types/#DataFrames.GroupKey"><code>GroupKey</code></a> objects returned by <a href="#Base.keys"><code>keys(::GroupedDataFrame)</code></a>, which can also be used to get the values of the grouping columns for each group. <code>Tuples</code> and <code>NamedTuple</code>s containing the values of the grouping columns (in the same order as the <code>cols</code> argument) are also accepted as indices. Finally, an <code>AbstractDict</code> can be used to index into a grouped data frame where the keys are column names of the data frame. The order of the keys does not matter in this case.</p><p><strong>See also</strong></p><p><a href="#DataFrames.combine"><code>combine</code></a>, <a href="#DataFrames.select"><code>select</code></a>, <a href="#DataFrames.select!"><code>select!</code></a>, <a href="#DataFrames.transform"><code>transform</code></a>, <a href="#DataFrames.transform!"><code>transform!</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; df = DataFrame(a = repeat([1, 2, 3, 4], outer=[2]),
                      b = repeat([2, 1], outer=[4]),
                      c = 1:8);

julia&gt; gd = groupby(df, :a)
GroupedDataFrame with 4 groups based on key: a
First Group (2 rows): a = 1
 Row │ a      b      c
     │ Int64  Int64  Int64
─────┼─────────────────────
   1 │     1      2      1
   2 │     1      2      5
⋮
Last Group (2 rows): a = 4
 Row │ a      b      c
     │ Int64  Int64  Int64
─────┼─────────────────────
   1 │     4      1      4
   2 │     4      1      8

julia&gt; gd[1]
2×3 SubDataFrame
 Row │ a      b      c
     │ Int64  Int64  Int64
─────┼─────────────────────
   1 │     1      2      1
   2 │     1      2      5

julia&gt; last(gd)
2×3 SubDataFrame
 Row │ a      b      c
     │ Int64  Int64  Int64
─────┼─────────────────────
   1 │     4      1      4
   2 │     4      1      8

julia&gt; gd[(a=3,)]
2×3 SubDataFrame
 Row │ a      b      c
     │ Int64  Int64  Int64
─────┼─────────────────────
   1 │     3      2      3
   2 │     3      2      7

julia&gt; gd[Dict(&quot;a&quot; =&gt; 3)]
2×3 SubDataFrame
 Row │ a      b      c
     │ Int64  Int64  Int64
─────┼─────────────────────
   1 │     3      2      3
   2 │     3      2      7

julia&gt; gd[(3,)]
2×3 SubDataFrame
 Row │ a      b      c
     │ Int64  Int64  Int64
─────┼─────────────────────
   1 │     3      2      3
   2 │     3      2      7

julia&gt; k = first(keys(gd))
GroupKey: (a = 1,)

julia&gt; gd[k]
2×3 SubDataFrame
 Row │ a      b      c
     │ Int64  Int64  Int64
─────┼─────────────────────
   1 │     1      2      1
   2 │     1      2      5

julia&gt; for g in gd
           println(g)
       end
2×3 SubDataFrame
 Row │ a      b      c
     │ Int64  Int64  Int64
─────┼─────────────────────
   1 │     1      2      1
   2 │     1      2      5
2×3 SubDataFrame
 Row │ a      b      c
     │ Int64  Int64  Int64
─────┼─────────────────────
   1 │     2      1      2
   2 │     2      1      6
2×3 SubDataFrame
 Row │ a      b      c
     │ Int64  Int64  Int64
─────┼─────────────────────
   1 │     3      2      3
   2 │     3      2      7
2×3 SubDataFrame
 Row │ a      b      c
     │ Int64  Int64  Int64
─────┼─────────────────────
   1 │     4      1      4
   2 │     4      1      8</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/6e35e296fbdef047cfdb043d54f80375331b47b5/src/groupeddataframe/groupeddataframe.jl#L36-L187">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFrames.groupcols" href="#DataFrames.groupcols"><code>DataFrames.groupcols</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">groupcols(gd::GroupedDataFrame)</code></pre><p>Return a vector of <code>Symbol</code> column names in <code>parent(gd)</code> used for grouping.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/6e35e296fbdef047cfdb043d54f80375331b47b5/src/groupeddataframe/groupeddataframe.jl#L329-L333">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFrames.groupindices" href="#DataFrames.groupindices"><code>DataFrames.groupindices</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">groupindices(gd::GroupedDataFrame)</code></pre><p>Return a vector of group indices for each row of <code>parent(gd)</code>.</p><p>Rows appearing in group <code>gd[i]</code> are attributed index <code>i</code>. Rows not present in any group are attributed <code>missing</code> (this can happen if <code>skipmissing=true</code> was passed when creating <code>gd</code>, or if <code>gd</code> is a subset from a larger <a href="../types/#DataFrames.GroupedDataFrame"><code>GroupedDataFrame</code></a>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/6e35e296fbdef047cfdb043d54f80375331b47b5/src/groupeddataframe/groupeddataframe.jl#L317-L326">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.keys" href="#Base.keys"><code>Base.keys</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">keys(gd::GroupedDataFrame)</code></pre><p>Get the set of keys for each group of the <code>GroupedDataFrame</code> <code>gd</code> as a <a href="../types/#DataFrames.GroupKeys"><code>GroupKeys</code></a> object. Each key is a <a href="../types/#DataFrames.GroupKey"><code>GroupKey</code></a>, which behaves like a <code>NamedTuple</code> holding the values of the grouping columns for a given group. Unlike the equivalent <code>Tuple</code>, <code>NamedTuple</code>, and <code>AbstractDict</code>, these keys can be used to index into <code>gd</code> efficiently. The ordering of the keys is identical to the ordering of the groups of <code>gd</code> under iteration and integer indexing.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; df = DataFrame(a = repeat([:foo, :bar, :baz], outer=[4]),
                      b = repeat([2, 1], outer=[6]),
                      c = 1:12);

julia&gt; gd = groupby(df, [:a, :b])
GroupedDataFrame with 6 groups based on keys: a, b
First Group (2 rows): a = :foo, b = 2
 Row │ a       b      c
     │ Symbol  Int64  Int64
─────┼──────────────────────
   1 │ foo         2      1
   2 │ foo         2      7
⋮
Last Group (2 rows): a = :baz, b = 1
 Row │ a       b      c
     │ Symbol  Int64  Int64
─────┼──────────────────────
   1 │ baz         1      6
   2 │ baz         1     12

julia&gt; keys(gd)
6-element DataFrames.GroupKeys{GroupedDataFrame{DataFrame}}:
 GroupKey: (a = :foo, b = 2)
 GroupKey: (a = :bar, b = 1)
 GroupKey: (a = :baz, b = 2)
 GroupKey: (a = :foo, b = 1)
 GroupKey: (a = :bar, b = 2)
 GroupKey: (a = :baz, b = 1)

julia&gt; k = keys(gd)[1]
GroupKey: (a = :foo, b = 2)

julia&gt; keys(k)
2-element Vector{Symbol}:
 :a
 :b

julia&gt; values(k)  # Same as Tuple(k)
(:foo, 2)

julia&gt; NamedTuple(k)
(a = :foo, b = 2)

julia&gt; k.a
:foo

julia&gt; k[:a]
:foo

julia&gt; k[1]
:foo</code></pre><p>Keys can be used as indices to retrieve the corresponding group from their <code>GroupedDataFrame</code>:</p><pre><code class="language-julia-repl">julia&gt; gd[k]
2×3 SubDataFrame
 Row │ a       b      c
     │ Symbol  Int64  Int64
─────┼──────────────────────
   1 │ foo         2      1
   2 │ foo         2      7

julia&gt; gd[keys(gd)[1]] == gd[1]
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/6e35e296fbdef047cfdb043d54f80375331b47b5/src/groupeddataframe/groupeddataframe.jl#L742-L823">source</a></section><section><div><pre><code class="language-none">keys(dfc::DataFrameColumns)</code></pre><p>Get a vector of column names of <code>dfc</code> as <code>Symbol</code>s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/6e35e296fbdef047cfdb043d54f80375331b47b5/src/abstractdataframe/iteration.jl#L223-L227">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.parent" href="#Base.parent"><code>Base.parent</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">parent(gd::GroupedDataFrame)</code></pre><p>Return the parent data frame of <code>gd</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/6e35e296fbdef047cfdb043d54f80375331b47b5/src/groupeddataframe/groupeddataframe.jl#L267-L271">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFrames.valuecols" href="#DataFrames.valuecols"><code>DataFrames.valuecols</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">valuecols(gd::GroupedDataFrame)</code></pre><p>Return a vector of <code>Symbol</code> column names in <code>parent(gd)</code> not used for grouping.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/6e35e296fbdef047cfdb043d54f80375331b47b5/src/groupeddataframe/groupeddataframe.jl#L340-L344">source</a></section></article><h2 id="Filtering-rows"><a class="docs-heading-anchor" href="#Filtering-rows">Filtering rows</a><a id="Filtering-rows-1"></a><a class="docs-heading-anchor-permalink" href="#Filtering-rows" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Base.delete!" href="#Base.delete!"><code>Base.delete!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">delete!(df::DataFrame, inds)</code></pre><p>Delete rows specified by <code>inds</code> from a <code>DataFrame</code> <code>df</code> in place and return it.</p><p>Internally <code>deleteat!</code> is called for all columns so <code>inds</code> must be: a vector of sorted and unique integers, a boolean vector, an integer, or <code>Not</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; df = DataFrame(a=1:3, b=4:6)
3×2 DataFrame
 Row │ a      b
     │ Int64  Int64
─────┼──────────────
   1 │     1      4
   2 │     2      5
   3 │     3      6

julia&gt; delete!(df, 2)
2×2 DataFrame
 Row │ a      b
     │ Int64  Int64
─────┼──────────────
   1 │     1      4
   2 │     3      6</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/6e35e296fbdef047cfdb043d54f80375331b47b5/src/dataframe/dataframe.jl#L936-L964">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.empty" href="#Base.empty"><code>Base.empty</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">empty(df::AbstractDataFrame)</code></pre><p>Create a new <code>DataFrame</code> with the same column names and column element types as <code>df</code> but with zero rows.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/6e35e296fbdef047cfdb043d54f80375331b47b5/src/abstractdataframe/abstractdataframe.jl#L386-L391">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.empty!" href="#Base.empty!"><code>Base.empty!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">empty!(df::DataFrame)</code></pre><p>Remove all rows from <code>df</code>, making each of its columns empty.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/6e35e296fbdef047cfdb043d54f80375331b47b5/src/dataframe/dataframe.jl#L1009-L1013">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.filter" href="#Base.filter"><code>Base.filter</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">filter(fun, df::AbstractDataFrame; view::Bool=false)
filter(cols =&gt; fun, df::AbstractDataFrame; view::Bool=false)</code></pre><p>Return a data frame containing only rows from <code>df</code> for which <code>fun</code> returns <code>true</code>.</p><p>If <code>cols</code> is not specified then the predicate <code>fun</code> is passed <code>DataFrameRow</code>s.</p><p>If <code>cols</code> is specified then the predicate <code>fun</code> is passed elements of the corresponding columns as separate positional arguments, unless <code>cols</code> is an <code>AsTable</code> selector, in which case a <code>NamedTuple</code> of these arguments is passed. <code>cols</code> can be any column selector (<code>Symbol</code>, string or integer; <code>:</code>, <code>Cols</code>, <code>All</code>, <code>Between</code>, <code>Not</code>, a regular expression, or a vector of <code>Symbol</code>s, strings or integers), and column duplicates are allowed if a vector of <code>Symbol</code>s, strings, or integers is passed.</p><p>If <code>view=false</code> a freshly allocated <code>DataFrame</code> is returned. If <code>view=true</code> then a <code>SubDataFrame</code> view into <code>df</code> is returned.</p><p>Passing <code>cols</code> leads to a more efficient execution of the operation for large data frames.</p><p>See also: <a href="#Base.filter!"><code>filter!</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; df = DataFrame(x = [3, 1, 2, 1], y = [&quot;b&quot;, &quot;c&quot;, &quot;a&quot;, &quot;b&quot;])
4×2 DataFrame
 Row │ x      y
     │ Int64  String
─────┼───────────────
   1 │     3  b
   2 │     1  c
   3 │     2  a
   4 │     1  b

julia&gt; filter(row -&gt; row.x &gt; 1, df)
2×2 DataFrame
 Row │ x      y
     │ Int64  String
─────┼───────────────
   1 │     3  b
   2 │     2  a

julia&gt; filter(:x =&gt; x -&gt; x &gt; 1, df)
2×2 DataFrame
 Row │ x      y
     │ Int64  String
─────┼───────────────
   1 │     3  b
   2 │     2  a

julia&gt; filter([:x, :y] =&gt; (x, y) -&gt; x == 1 || y == &quot;b&quot;, df)
3×2 DataFrame
 Row │ x      y
     │ Int64  String
─────┼───────────────
   1 │     3  b
   2 │     1  c
   3 │     1  b

julia&gt; filter(AsTable(:) =&gt; nt -&gt; nt.x == 1 || nt.y == &quot;b&quot;, df)
3×2 DataFrame
 Row │ x      y
     │ Int64  String
─────┼───────────────
   1 │     3  b
   2 │     1  c
   3 │     1  b</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/6e35e296fbdef047cfdb043d54f80375331b47b5/src/abstractdataframe/abstractdataframe.jl#L931-L1000">source</a></section><section><div><pre><code class="language-none">filter(fun, gdf::GroupedDataFrame)
filter(cols =&gt; fun, gdf::GroupedDataFrame)</code></pre><p>Return a new <code>GroupedDataFrame</code> containing only groups for which <code>fun</code> returns <code>true</code>.</p><p>If <code>cols</code> is not specified then the predicate <code>fun</code> is called with a <code>SubDataFrame</code> for each group.</p><p>If <code>cols</code> is specified then the predicate <code>fun</code> is called for each group with views of the corresponding columns as separate positional arguments, unless <code>cols</code> is an <code>AsTable</code> selector, in which case a <code>NamedTuple</code> of these arguments is passed. <code>cols</code> can be any column selector (<code>Symbol</code>, string or integer; <code>:</code>, <code>Cols</code>, <code>All</code>, <code>Between</code>, <code>Not</code>, a regular expression, or a vector of <code>Symbol</code>s, strings or integers), and column duplicates are allowed if a vector of <code>Symbol</code>s, strings, or integers is passed.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; df = DataFrame(g=[1, 2], x=[&#39;a&#39;, &#39;b&#39;]);

julia&gt; gd = groupby(df, :g)
GroupedDataFrame with 2 groups based on key: g
First Group (1 row): g = 1
 Row │ g      x
     │ Int64  Char
─────┼─────────────
   1 │     1  a
⋮
Last Group (1 row): g = 2
 Row │ g      x
     │ Int64  Char
─────┼─────────────
   1 │     2  b

julia&gt; filter(x -&gt; x.x[1] == &#39;a&#39;, gd)
GroupedDataFrame with 1 group based on key: g
First Group (1 row): g = 1
 Row │ g      x
     │ Int64  Char
─────┼─────────────
   1 │     1  a

julia&gt; filter(:x =&gt; x -&gt; x[1] == &#39;a&#39;, gd)
GroupedDataFrame with 1 group based on key: g
First Group (1 row): g = 1
 Row │ g      x
     │ Int64  Char
─────┼─────────────
   1 │     1  a</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/6e35e296fbdef047cfdb043d54f80375331b47b5/src/groupeddataframe/groupeddataframe.jl#L923-L974">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.filter!" href="#Base.filter!"><code>Base.filter!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">filter!(fun, df::AbstractDataFrame)
filter!(cols =&gt; fun, df::AbstractDataFrame)</code></pre><p>Remove rows from data frame <code>df</code> for which <code>fun</code> returns <code>false</code>.</p><p>If <code>cols</code> is not specified then the predicate <code>fun</code> is passed <code>DataFrameRow</code>s.</p><p>If <code>cols</code> is specified then the predicate <code>fun</code> is passed elements of the corresponding columns as separate positional arguments, unless <code>cols</code> is an <code>AsTable</code> selector, in which case a <code>NamedTuple</code> of these arguments is passed. <code>cols</code> can be any column selector (<code>Symbol</code>, string or integer; <code>:</code>, <code>Cols</code>, <code>All</code>, <code>Between</code>, <code>Not</code>, a regular expression, or a vector of <code>Symbol</code>s, strings or integers), and column duplicates are allowed if a vector of <code>Symbol</code>s, strings, or integers is passed.</p><p>Passing <code>cols</code> leads to a more efficient execution of the operation for large data frames.</p><p>See also: <a href="#Base.filter"><code>filter</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; df = DataFrame(x = [3, 1, 2, 1], y = [&quot;b&quot;, &quot;c&quot;, &quot;a&quot;, &quot;b&quot;])
4×2 DataFrame
 Row │ x      y
     │ Int64  String
─────┼───────────────
   1 │     3  b
   2 │     1  c
   3 │     2  a
   4 │     1  b

julia&gt; filter!(row -&gt; row.x &gt; 1, df)
2×2 DataFrame
 Row │ x      y
     │ Int64  String
─────┼───────────────
   1 │     3  b
   2 │     2  a

julia&gt; filter!(:x =&gt; x -&gt; x == 3, df)
1×2 DataFrame
 Row │ x      y
     │ Int64  String
─────┼───────────────
   1 │     3  b

julia&gt; df = DataFrame(x = [3, 1, 2, 1], y = [&quot;b&quot;, &quot;c&quot;, &quot;a&quot;, &quot;b&quot;]);

julia&gt; filter!([:x, :y] =&gt; (x, y) -&gt; x == 1 || y == &quot;b&quot;, df)
3×2 DataFrame
 Row │ x      y
     │ Int64  String
─────┼───────────────
   1 │     3  b
   2 │     1  c
   3 │     1  b

julia&gt; df = DataFrame(x = [3, 1, 2, 1], y = [&quot;b&quot;, &quot;c&quot;, &quot;a&quot;, &quot;b&quot;]);

julia&gt; filter!(AsTable(:) =&gt; nt -&gt; nt.x == 1 || nt.y == &quot;b&quot;, df)
3×2 DataFrame
 Row │ x      y
     │ Int64  String
─────┼───────────────
   1 │     3  b
   2 │     1  c
   3 │     1  b</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/6e35e296fbdef047cfdb043d54f80375331b47b5/src/abstractdataframe/abstractdataframe.jl#L1044-L1112">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.first" href="#Base.first"><code>Base.first</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">first(df::AbstractDataFrame)</code></pre><p>Get the first row of <code>df</code> as a <code>DataFrameRow</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/6e35e296fbdef047cfdb043d54f80375331b47b5/src/abstractdataframe/abstractdataframe.jl#L459-L463">source</a></section><section><div><pre><code class="language-none">first(df::AbstractDataFrame, n::Integer)</code></pre><p>Get a data frame with the <code>n</code> first rows of <code>df</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/6e35e296fbdef047cfdb043d54f80375331b47b5/src/abstractdataframe/abstractdataframe.jl#L466-L470">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.last" href="#Base.last"><code>Base.last</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">last(df::AbstractDataFrame)</code></pre><p>Get the last row of <code>df</code> as a <code>DataFrameRow</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/6e35e296fbdef047cfdb043d54f80375331b47b5/src/abstractdataframe/abstractdataframe.jl#L473-L477">source</a></section><section><div><pre><code class="language-none">last(df::AbstractDataFrame, n::Integer)</code></pre><p>Get a data frame with the <code>n</code> last rows of <code>df</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/6e35e296fbdef047cfdb043d54f80375331b47b5/src/abstractdataframe/abstractdataframe.jl#L480-L484">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.Iterators.only" href="#Base.Iterators.only"><code>Base.Iterators.only</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">only(df::AbstractDataFrame)</code></pre><p>If <code>df</code> has a single row return it as a <code>DataFrameRow</code>; otherwise throw <code>ArgumentError</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/6e35e296fbdef047cfdb043d54f80375331b47b5/src/abstractdataframe/abstractdataframe.jl#L449-L453">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFrames.nonunique" href="#DataFrames.nonunique"><code>DataFrames.nonunique</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">nonunique(df::AbstractDataFrame)
nonunique(df::AbstractDataFrame, cols)</code></pre><p>Return a <code>Vector{Bool}</code> in which <code>true</code> entries indicate duplicate rows. A row is a duplicate if there exists a prior row with all columns containing equal values (according to <code>isequal</code>).</p><p>See also <a href="#Base.unique"><code>unique</code></a> and <a href="#Base.unique!"><code>unique!</code></a>.</p><p><strong>Arguments</strong></p><ul><li><code>df</code> : <code>AbstractDataFrame</code></li><li><code>cols</code> : a selector specifying the column(s) or their transformations to compare. Can be any column selector or transformation accepted by <a href="#DataFrames.select"><code>select</code></a>.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; df = DataFrame(i = 1:4, x = [1, 2, 1, 2])
4×2 DataFrame
 Row │ i      x
     │ Int64  Int64
─────┼──────────────
   1 │     1      1
   2 │     2      2
   3 │     3      1
   4 │     4      2

julia&gt; df = vcat(df, df)
8×2 DataFrame
 Row │ i      x
     │ Int64  Int64
─────┼──────────────
   1 │     1      1
   2 │     2      2
   3 │     3      1
   4 │     4      2
   5 │     1      1
   6 │     2      2
   7 │     3      1
   8 │     4      2

julia&gt; nonunique(df)
8-element Vector{Bool}:
 0
 0
 0
 0
 1
 1
 1
 1

julia&gt; nonunique(df, 2)
8-element Vector{Bool}:
 0
 0
 1
 1
 1
 1
 1
 1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/6e35e296fbdef047cfdb043d54f80375331b47b5/src/abstractdataframe/abstractdataframe.jl#L1175-L1238">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFrames.subset" href="#DataFrames.subset"><code>DataFrames.subset</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">subset(df::AbstractDataFrame, args...; skipmissing::Bool=false, view::Bool=false)
subset(gdf::GroupedDataFrame, args...; skipmissing::Bool=false, view::Bool=false,
       ungroup::Bool=true)</code></pre><p>Return a copy of data frame <code>df</code> or parent of <code>gdf</code> containing only rows for which all values produced by transformation(s) <code>args</code> for a given row are <code>true</code>.</p><p>Each argument passed in <code>args</code> can be either a single column selector or a <code>source_columns =&gt; function</code> transformation specifier following the rules described for <a href="#DataFrames.select"><code>select</code></a>.</p><p>Note that as opposed to <a href="#Base.filter"><code>filter</code></a> the <code>subset</code> function works on whole columns (or all rows in groups for <code>GroupedDataFrame</code>).</p><p>If <code>skipmissing=false</code> (the default) <code>args</code> are required to produce vectors containing only <code>Bool</code> values. If <code>skipmissing=true</code>, additionally <code>missing</code> is allowed and it is treated as <code>false</code> (i.e. rows for which one of the conditions returns <code>missing</code> are skipped).</p><p>If <code>view=true</code> a <code>SubDataFrame</code> view  is returned instead of a <code>DataFrame</code>.</p><p>If <code>ungroup=false</code> the resulting data frame is re-grouped based on the same grouping columns as <code>gdf</code> and a <code>GroupedDataFrame</code> is returned.</p><p>If a <code>GroupedDataFrame</code> is passed then it must include all groups present in the <code>parent</code> data frame, like in <a href="#DataFrames.select!"><code>select!</code></a>.</p><p>See also: <a href="#DataFrames.subset!"><code>subset!</code></a>, <a href="#Base.filter"><code>filter</code></a>, <a href="#DataFrames.select"><code>select</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; df = DataFrame(id=1:4, x=[true, false, true, false],
                      y=[true, true, false, false],
                      z=[true, true, missing, missing], v=[1, 2, 11, 12])
4×5 DataFrame
 Row │ id     x      y      z        v
     │ Int64  Bool   Bool   Bool?    Int64
─────┼─────────────────────────────────────
   1 │     1   true   true     true      1
   2 │     2  false   true     true      2
   3 │     3   true  false  missing     11
   4 │     4  false  false  missing     12

julia&gt; subset(df, :x)
2×5 DataFrame
 Row │ id     x     y      z        v
     │ Int64  Bool  Bool   Bool?    Int64
─────┼────────────────────────────────────
   1 │     1  true   true     true      1
   2 │     3  true  false  missing     11

julia&gt; subset(df, :v =&gt; x -&gt; x .&gt; 3)
2×5 DataFrame
 Row │ id     x      y      z        v
     │ Int64  Bool   Bool   Bool?    Int64
─────┼─────────────────────────────────────
   1 │     3   true  false  missing     11
   2 │     4  false  false  missing     12

julia&gt; subset(df, :x, :y =&gt; ByRow(!))
1×5 DataFrame
 Row │ id     x     y      z        v
     │ Int64  Bool  Bool   Bool?    Int64
─────┼────────────────────────────────────
   1 │     3  true  false  missing     11

julia&gt; subset(df, :x, :z, skipmissing=true)
1×5 DataFrame
 Row │ id     x     y     z      v
     │ Int64  Bool  Bool  Bool?  Int64
─────┼─────────────────────────────────
   1 │     1  true  true   true      1

julia&gt; subset(df, :x, :z)
ERROR: ArgumentError: missing was returned in condition number 2 but only true or false are allowed; pass skipmissing=true to skip missing values

julia&gt; subset(groupby(df, :y), :v =&gt; x -&gt; x .&gt; minimum(x))
2×5 DataFrame
 Row │ id     x      y      z        v
     │ Int64  Bool   Bool   Bool?    Int64
─────┼─────────────────────────────────────
   1 │     2  false   true     true      2
   2 │     4  false  false  missing     12</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/6e35e296fbdef047cfdb043d54f80375331b47b5/src/abstractdataframe/subset.jl#L67-L153">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFrames.subset!" href="#DataFrames.subset!"><code>DataFrames.subset!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">subset!(df::AbstractDataFrame, args...; skipmissing::Bool=false)
subset!(gdf::GroupedDataFrame{DataFrame}, args..., skipmissing::Bool=false,
        ungroup::Bool=true)</code></pre><p>Update data frame <code>df</code> or the parent of <code>gdf</code> in place to contain only rows for which all values produced by transformation(s) <code>args</code> for a given row is <code>true</code>.</p><p>Each argument passed in <code>args</code> can be either a single column selector or a <code>source_columns =&gt; function</code> transformation specifier following the rules described for <a href="#DataFrames.select"><code>select</code></a>.</p><p>Note that as opposed to <a href="#Base.filter!"><code>filter!</code></a> the <code>subset!</code> function works on whole columns (or all rows in groups for <code>GroupedDataFrame</code>).</p><p>If <code>skipmissing=false</code> (the default) <code>args</code> are required to produce vectors containing only <code>Bool</code> values. If <code>skipmissing=true</code>, additionally <code>missing</code> is allowed and it is treated as <code>false</code> (i.e. rows for which one of the conditions returns <code>missing</code> are skipped).</p><p>If <code>ungroup=false</code> the resulting data frame is re-grouped based on the same grouping columns as <code>gdf</code> and a <code>GroupedDataFrame</code> is returned.</p><p>If <code>GroupedDataFrame</code> is subsetted then it must include all groups present in the <code>parent</code> data frame, like in <a href="#DataFrames.select!"><code>select!</code></a>.</p><p>See also: <a href="#DataFrames.subset"><code>subset</code></a>, <a href="#Base.filter!"><code>filter!</code></a>, <a href="#DataFrames.select!"><code>select!</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; df = DataFrame(id=1:4, x=[true, false, true, false], y=[true, true, false, false])
4×3 DataFrame
 Row │ id     x      y
     │ Int64  Bool   Bool
─────┼─────────────────────
   1 │     1   true   true
   2 │     2  false   true
   3 │     3   true  false
   4 │     4  false  false

julia&gt; subset!(df, :x, :y =&gt; ByRow(!));

julia&gt; df
1×3 DataFrame
 Row │ id     x     y
     │ Int64  Bool  Bool
─────┼────────────────────
   1 │     3  true  false

julia&gt; df = DataFrame(id=1:4, y=[true, true, false, false], v=[1, 2, 11, 12]);

julia&gt; subset!(groupby(df, :y), :v =&gt; x -&gt; x .&gt; minimum(x));

julia&gt; df
2×3 DataFrame
 Row │ id     y      v
     │ Int64  Bool   Int64
─────┼─────────────────────
   1 │     2   true      2
   2 │     4  false     12

julia&gt; df = DataFrame(id=1:4, x=[true, false, true, false],
                      z=[true, true, missing, missing], v=1:4)
4×4 DataFrame
 Row │ id     x      z        v
     │ Int64  Bool   Bool?    Int64
─────┼──────────────────────────────
   1 │     1   true     true      1
   2 │     2  false     true      2
   3 │     3   true  missing      3
   4 │     4  false  missing      4

julia&gt; subset!(df, :x, :z)
ERROR: ArgumentError: missing was returned in condition number 2 but only true or false are allowed; pass skipmissing=true to skip missing values

julia&gt; subset!(df, :x, :z, skipmissing=true);

julia&gt; df
1×4 DataFrame
 Row │ id     x     z      v
     │ Int64  Bool  Bool?  Int64
─────┼───────────────────────────
   1 │     1  true   true      1

julia&gt; df = DataFrame(id=1:4, x=[true, false, true, false], y=[true, true, false, false],
                      z=[true, true, missing, missing], v=[1, 2, 11, 12]);

julia&gt; subset!(groupby(df, :y), :v =&gt; x -&gt; x .&gt; minimum(x));

julia&gt; df
2×5 DataFrame
 Row │ id     x      y      z        v
     │ Int64  Bool   Bool   Bool?    Int64
─────┼─────────────────────────────────────
   1 │     2  false   true     true      2
   2 │     4  false  false  missing     12</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/6e35e296fbdef047cfdb043d54f80375331b47b5/src/abstractdataframe/subset.jl#L170-L268">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.unique" href="#Base.unique"><code>Base.unique</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">unique(df::AbstractDataFrame; view::Bool=false)
unique(df::AbstractDataFrame, cols; view::Bool=false)
unique!(df::AbstractDataFrame)
unique!(df::AbstractDataFrame, cols)</code></pre><p>Return a data frame containing only the first occurrence of unique rows in <code>df</code>. When <code>cols</code> is specified, the returned <code>DataFrame</code> contains complete rows, retaining in each case the first occurrence of a given combination of values in selected columns or their transformations. <code>cols</code> can be any column selector or transformation accepted by <a href="#DataFrames.select"><code>select</code></a>.</p><p>For <code>unique</code>, if <code>view=false</code> a freshly allocated <code>DataFrame</code> is returned, and if <code>view=true</code> then a <code>SubDataFrame</code> view into <code>df</code> is returned.</p><p><code>unique!</code> updates <code>df</code> in-place and does not support the <code>view</code> keyword argument.</p><p>See also <a href="#DataFrames.nonunique"><code>nonunique</code></a>.</p><p><strong>Arguments</strong></p><ul><li><code>df</code> : the AbstractDataFrame</li><li><code>cols</code> :  column indicator (Symbol, Int, Vector{Symbol}, Regex, etc.)</li></ul><p>specifying the column(s) to compare.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; df = DataFrame(i = 1:4, x = [1, 2, 1, 2])
4×2 DataFrame
 Row │ i      x
     │ Int64  Int64
─────┼──────────────
   1 │     1      1
   2 │     2      2
   3 │     3      1
   4 │     4      2

julia&gt; df = vcat(df, df)
8×2 DataFrame
 Row │ i      x
     │ Int64  Int64
─────┼──────────────
   1 │     1      1
   2 │     2      2
   3 │     3      1
   4 │     4      2
   5 │     1      1
   6 │     2      2
   7 │     3      1
   8 │     4      2

julia&gt; unique(df)   # doesn&#39;t modify df
4×2 DataFrame
 Row │ i      x
     │ Int64  Int64
─────┼──────────────
   1 │     1      1
   2 │     2      2
   3 │     3      1
   4 │     4      2

julia&gt; unique(df, 2)
2×2 DataFrame
 Row │ i      x
     │ Int64  Int64
─────┼──────────────
   1 │     1      1
   2 │     2      2

julia&gt; unique!(df)  # modifies df
4×2 DataFrame
 Row │ i      x
     │ Int64  Int64
─────┼──────────────
   1 │     1      1
   2 │     2      2
   3 │     3      1
   4 │     4      2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/6e35e296fbdef047cfdb043d54f80375331b47b5/src/abstractdataframe/abstractdataframe.jl#L1273-L1352">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.unique!" href="#Base.unique!"><code>Base.unique!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">unique(df::AbstractDataFrame; view::Bool=false)
unique(df::AbstractDataFrame, cols; view::Bool=false)
unique!(df::AbstractDataFrame)
unique!(df::AbstractDataFrame, cols)</code></pre><p>Return a data frame containing only the first occurrence of unique rows in <code>df</code>. When <code>cols</code> is specified, the returned <code>DataFrame</code> contains complete rows, retaining in each case the first occurrence of a given combination of values in selected columns or their transformations. <code>cols</code> can be any column selector or transformation accepted by <a href="#DataFrames.select"><code>select</code></a>.</p><p>For <code>unique</code>, if <code>view=false</code> a freshly allocated <code>DataFrame</code> is returned, and if <code>view=true</code> then a <code>SubDataFrame</code> view into <code>df</code> is returned.</p><p><code>unique!</code> updates <code>df</code> in-place and does not support the <code>view</code> keyword argument.</p><p>See also <a href="#DataFrames.nonunique"><code>nonunique</code></a>.</p><p><strong>Arguments</strong></p><ul><li><code>df</code> : the AbstractDataFrame</li><li><code>cols</code> :  column indicator (Symbol, Int, Vector{Symbol}, Regex, etc.)</li></ul><p>specifying the column(s) to compare.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; df = DataFrame(i = 1:4, x = [1, 2, 1, 2])
4×2 DataFrame
 Row │ i      x
     │ Int64  Int64
─────┼──────────────
   1 │     1      1
   2 │     2      2
   3 │     3      1
   4 │     4      2

julia&gt; df = vcat(df, df)
8×2 DataFrame
 Row │ i      x
     │ Int64  Int64
─────┼──────────────
   1 │     1      1
   2 │     2      2
   3 │     3      1
   4 │     4      2
   5 │     1      1
   6 │     2      2
   7 │     3      1
   8 │     4      2

julia&gt; unique(df)   # doesn&#39;t modify df
4×2 DataFrame
 Row │ i      x
     │ Int64  Int64
─────┼──────────────
   1 │     1      1
   2 │     2      2
   3 │     3      1
   4 │     4      2

julia&gt; unique(df, 2)
2×2 DataFrame
 Row │ i      x
     │ Int64  Int64
─────┼──────────────
   1 │     1      1
   2 │     2      2

julia&gt; unique!(df)  # modifies df
4×2 DataFrame
 Row │ i      x
     │ Int64  Int64
─────┼──────────────
   1 │     1      1
   2 │     2      2
   3 │     3      1
   4 │     4      2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/6e35e296fbdef047cfdb043d54f80375331b47b5/src/abstractdataframe/abstractdataframe.jl#L1273-L1352">source</a></section></article><h2 id="Working-with-missing-values"><a class="docs-heading-anchor" href="#Working-with-missing-values">Working with missing values</a><a id="Working-with-missing-values-1"></a><a class="docs-heading-anchor-permalink" href="#Working-with-missing-values" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Missings.allowmissing" href="#Missings.allowmissing"><code>Missings.allowmissing</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">allowmissing(df::AbstractDataFrame, cols=:)</code></pre><p>Return a copy of data frame <code>df</code> with columns <code>cols</code> converted to element type <code>Union{T, Missing}</code> from <code>T</code> to allow support for missing values.</p><p><code>cols</code> can be any column selector (<code>Symbol</code>, string or integer; <code>:</code>, <code>Cols</code>, <code>All</code>, <code>Between</code>, <code>Not</code>, a regular expression, or a vector of <code>Symbol</code>s, strings or integers).</p><p>If <code>cols</code> is omitted all columns in the data frame are converted.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; df = DataFrame(a=[1, 2])
2×1 DataFrame
 Row │ a
     │ Int64
─────┼───────
   1 │     1
   2 │     2

julia&gt; allowmissing(df)
2×1 DataFrame
 Row │ a
     │ Int64?
─────┼────────
   1 │      1
   2 │      2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/6e35e296fbdef047cfdb043d54f80375331b47b5/src/abstractdataframe/abstractdataframe.jl#L1988-L2017">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFrames.allowmissing!" href="#DataFrames.allowmissing!"><code>DataFrames.allowmissing!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">allowmissing!(df::DataFrame, cols=:)</code></pre><p>Convert columns <code>cols</code> of data frame <code>df</code> from element type <code>T</code> to <code>Union{T, Missing}</code> to support missing values.</p><p><code>cols</code> can be any column selector (<code>Symbol</code>, string or integer; <code>:</code>, <code>Cols</code>, <code>All</code>, <code>Between</code>, <code>Not</code>, a regular expression, or a vector of <code>Symbol</code>s, strings or integers).</p><p>If <code>cols</code> is omitted all columns in the data frame are converted.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/6e35e296fbdef047cfdb043d54f80375331b47b5/src/dataframe/dataframe.jl#L1076-L1085">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFrames.completecases" href="#DataFrames.completecases"><code>DataFrames.completecases</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">completecases(df::AbstractDataFrame, cols=:)</code></pre><p>Return a Boolean vector with <code>true</code> entries indicating rows without missing values (complete cases) in data frame <code>df</code>.</p><p>If <code>cols</code> is provided, only missing values in the corresponding columns areconsidered. <code>cols</code> can be any column selector (<code>Symbol</code>, string or integer; <code>:</code>, <code>Cols</code>, <code>All</code>, <code>Between</code>, <code>Not</code>, a regular expression, or a vector of <code>Symbol</code>s, strings or integers).</p><p>See also: <a href="#DataFrames.dropmissing"><code>dropmissing</code></a> and <a href="#DataFrames.dropmissing!"><code>dropmissing!</code></a>. Use <code>findall(completecases(df))</code> to get the indices of the rows.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; df = DataFrame(i = 1:5,
                            x = [missing, 4, missing, 2, 1],
                            y = [missing, missing, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;])
5×3 DataFrame
 Row │ i      x        y
     │ Int64  Int64?   String?
─────┼─────────────────────────
   1 │     1  missing  missing
   2 │     2        4  missing
   3 │     3  missing  c
   4 │     4        2  d
   5 │     5        1  e

julia&gt; completecases(df)
5-element BitVector:
 0
 0
 0
 1
 1

julia&gt; completecases(df, :x)
5-element BitVector:
 0
 1
 0
 1
 1

julia&gt; completecases(df, [:x, :y])
5-element BitVector:
 0
 0
 0
 1
 1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/6e35e296fbdef047cfdb043d54f80375331b47b5/src/abstractdataframe/abstractdataframe.jl#L705-L757">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Missings.disallowmissing" href="#Missings.disallowmissing"><code>Missings.disallowmissing</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">disallowmissing(df::AbstractDataFrame, cols=:; error::Bool=true)</code></pre><p>Return a copy of data frame <code>df</code> with columns <code>cols</code> converted from element type <code>Union{T, Missing}</code> to <code>T</code> to drop support for missing values.</p><p><code>cols</code> can be any column selector (<code>Symbol</code>, string or integer; <code>:</code>, <code>Cols</code>, <code>All</code>, <code>Between</code>, <code>Not</code>, a regular expression, or a vector of <code>Symbol</code>s, strings or integers).</p><p>If <code>cols</code> is omitted all columns in the data frame are converted.</p><p>If <code>error=false</code> then columns containing a <code>missing</code> value will be skipped instead of throwing an error.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; df = DataFrame(a=Union{Int, Missing}[1, 2])
2×1 DataFrame
 Row │ a
     │ Int64?
─────┼────────
   1 │      1
   2 │      2

julia&gt; disallowmissing(df)
2×1 DataFrame
 Row │ a
     │ Int64
─────┼───────
   1 │     1
   2 │     2

julia&gt; df = DataFrame(a=[1, missing])
2×1 DataFrame
 Row │ a
     │ Int64?
─────┼─────────
   1 │       1
   2 │ missing

julia&gt; disallowmissing(df, error=false)
2×1 DataFrame
 Row │ a
     │ Int64?
─────┼─────────
   1 │       1
   2 │ missing</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/6e35e296fbdef047cfdb043d54f80375331b47b5/src/abstractdataframe/abstractdataframe.jl#L1918-L1966">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFrames.disallowmissing!" href="#DataFrames.disallowmissing!"><code>DataFrames.disallowmissing!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">disallowmissing!(df::DataFrame, cols=:; error::Bool=true)</code></pre><p>Convert columns <code>cols</code> of data frame <code>df</code> from element type <code>Union{T, Missing}</code> to <code>T</code> to drop support for missing values.</p><p><code>cols</code> can be any column selector (<code>Symbol</code>, string or integer; <code>:</code>, <code>Cols</code>, <code>All</code>, <code>Between</code>, <code>Not</code>, a regular expression, or a vector of <code>Symbol</code>s, strings or integers).</p><p>If <code>cols</code> is omitted all columns in the data frame are converted.</p><p>If <code>error=false</code> then columns containing a <code>missing</code> value will be skipped instead of throwing an error.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/6e35e296fbdef047cfdb043d54f80375331b47b5/src/dataframe/dataframe.jl#L1114-L1126">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFrames.dropmissing" href="#DataFrames.dropmissing"><code>DataFrames.dropmissing</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">dropmissing(df::AbstractDataFrame, cols=:; view::Bool=false, disallowmissing::Bool=!view)</code></pre><p>Return a data frame excluding rows with missing values in <code>df</code>.</p><p>If <code>cols</code> is provided, only missing values in the corresponding columns are considered. <code>cols</code> can be any column selector (<code>Symbol</code>, string or integer; <code>:</code>, <code>Cols</code>, <code>All</code>, <code>Between</code>, <code>Not</code>, a regular expression, or a vector of <code>Symbol</code>s, strings or integers).</p><p>If <code>view=false</code> a freshly allocated <code>DataFrame</code> is returned. If <code>view=true</code> then a <code>SubDataFrame</code> view into <code>df</code> is returned. In this case <code>disallowmissing</code> must be <code>false</code>.</p><p>If <code>disallowmissing</code> is <code>true</code> (the default when <code>view</code> is <code>false</code>) then columns specified in <code>cols</code> will be converted so as not to allow for missing values using <a href="#DataFrames.disallowmissing!"><code>disallowmissing!</code></a>.</p><p>See also: <a href="#DataFrames.completecases"><code>completecases</code></a> and <a href="#DataFrames.dropmissing!"><code>dropmissing!</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; df = DataFrame(i = 1:5,
                      x = [missing, 4, missing, 2, 1],
                      y = [missing, missing, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;])
5×3 DataFrame
 Row │ i      x        y
     │ Int64  Int64?   String?
─────┼─────────────────────────
   1 │     1  missing  missing
   2 │     2        4  missing
   3 │     3  missing  c
   4 │     4        2  d
   5 │     5        1  e

julia&gt; dropmissing(df)
2×3 DataFrame
 Row │ i      x      y
     │ Int64  Int64  String
─────┼──────────────────────
   1 │     4      2  d
   2 │     5      1  e

julia&gt; dropmissing(df, disallowmissing=false)
2×3 DataFrame
 Row │ i      x       y
     │ Int64  Int64?  String?
─────┼────────────────────────
   1 │     4       2  d
   2 │     5       1  e

julia&gt; dropmissing(df, :x)
3×3 DataFrame
 Row │ i      x      y
     │ Int64  Int64  String?
─────┼───────────────────────
   1 │     2      4  missing
   2 │     4      2  d
   3 │     5      1  e

julia&gt; dropmissing(df, [:x, :y])
2×3 DataFrame
 Row │ i      x      y
     │ Int64  Int64  String
─────┼──────────────────────
   1 │     4      2  d
   2 │     5      1  e</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/6e35e296fbdef047cfdb043d54f80375331b47b5/src/abstractdataframe/abstractdataframe.jl#L776-L843">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFrames.dropmissing!" href="#DataFrames.dropmissing!"><code>DataFrames.dropmissing!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">dropmissing!(df::AbstractDataFrame, cols=:; disallowmissing::Bool=true)</code></pre><p>Remove rows with missing values from data frame <code>df</code> and return it.</p><p>If <code>cols</code> is provided, only missing values in the corresponding columns are considered. <code>cols</code> can be any column selector (<code>Symbol</code>, string or integer; <code>:</code>, <code>Cols</code>, <code>All</code>, <code>Between</code>, <code>Not</code>, a regular expression, or a vector of <code>Symbol</code>s, strings or integers).</p><p>If <code>disallowmissing</code> is <code>true</code> (the default) then the <code>cols</code> columns will get converted using <a href="#DataFrames.disallowmissing!"><code>disallowmissing!</code></a>.</p><p>See also: <a href="#DataFrames.dropmissing"><code>dropmissing</code></a> and <a href="#DataFrames.completecases"><code>completecases</code></a>.</p><pre><code class="language-julia-repl">julia&gt; df = DataFrame(i = 1:5,
                      x = [missing, 4, missing, 2, 1],
                      y = [missing, missing, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;])
5×3 DataFrame
 Row │ i      x        y
     │ Int64  Int64?   String?
─────┼─────────────────────────
   1 │     1  missing  missing
   2 │     2        4  missing
   3 │     3  missing  c
   4 │     4        2  d
   5 │     5        1  e

julia&gt; dropmissing!(copy(df))
2×3 DataFrame
 Row │ i      x      y
     │ Int64  Int64  String
─────┼──────────────────────
   1 │     4      2  d
   2 │     5      1  e

julia&gt; dropmissing!(copy(df), disallowmissing=false)
2×3 DataFrame
 Row │ i      x       y
     │ Int64  Int64?  String?
─────┼────────────────────────
   1 │     4       2  d
   2 │     5       1  e

julia&gt; dropmissing!(copy(df), :x)
3×3 DataFrame
 Row │ i      x      y
     │ Int64  Int64  String?
─────┼───────────────────────
   1 │     2      4  missing
   2 │     4      2  d
   3 │     5      1  e

julia&gt; dropmissing!(df, [:x, :y])
2×3 DataFrame
 Row │ i      x      y
     │ Int64  Int64  String
─────┼──────────────────────
   1 │     4      2  d
   2 │     5      1  e</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/6e35e296fbdef047cfdb043d54f80375331b47b5/src/abstractdataframe/abstractdataframe.jl#L860-L920">source</a></section></article><h2 id="Iteration"><a class="docs-heading-anchor" href="#Iteration">Iteration</a><a id="Iteration-1"></a><a class="docs-heading-anchor-permalink" href="#Iteration" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Base.eachcol" href="#Base.eachcol"><code>Base.eachcol</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">eachcol(df::AbstractDataFrame)</code></pre><p>Return a <code>DataFrameColumns</code> object that is a vector-like that allows iterating an <code>AbstractDataFrame</code> column by column.</p><p>Indexing into <code>DataFrameColumns</code> objects using integer, <code>Symbol</code> or string returns the corresponding column (without copying). Indexing into <code>DataFrameColumns</code> objects using a multiple column selector returns a subsetted <code>DataFrameColumns</code> object with a new parent containing only the selected columns (without copying).</p><p><code>DataFrameColumns</code> supports most of the <code>AbstractVector</code> API. The key differences are that it is read-only and that the <code>keys</code> function returns a vector of <code>Symbol</code>s (and not integers as for normal vectors).</p><p>In particular <code>findnext</code>, <code>findprev</code>, <code>findfirst</code>, <code>findlast</code>, and <code>findall</code> functions are supported, and in <code>findnext</code> and <code>findprev</code> functions it is allowed to pass an integer, string, or <code>Symbol</code> as a reference index.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; df = DataFrame(x=1:4, y=11:14)
4×2 DataFrame
 Row │ x      y
     │ Int64  Int64
─────┼──────────────
   1 │     1     11
   2 │     2     12
   3 │     3     13
   4 │     4     14

julia&gt; eachcol(df)
4×2 DataFrameColumns
 Row │ x      y
     │ Int64  Int64
─────┼──────────────
   1 │     1     11
   2 │     2     12
   3 │     3     13
   4 │     4     14

julia&gt; collect(eachcol(df))
2-element Vector{AbstractVector{T} where T}:
 [1, 2, 3, 4]
 [11, 12, 13, 14]

julia&gt; map(eachcol(df)) do col
           maximum(col) - minimum(col)
       end
2-element Vector{Int64}:
 3
 3

julia&gt; sum.(eachcol(df))
2-element Vector{Int64}:
 10
 50</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/6e35e296fbdef047cfdb043d54f80375331b47b5/src/abstractdataframe/iteration.jl#L125-L172">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.eachrow" href="#Base.eachrow"><code>Base.eachrow</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">eachrow(df::AbstractDataFrame)</code></pre><p>Return a <code>DataFrameRows</code> that iterates a data frame row by row, with each row represented as a <code>DataFrameRow</code>.</p><p>Because <code>DataFrameRow</code>s have an <code>eltype</code> of <code>Any</code>, use <code>copy(dfr::DataFrameRow)</code> to obtain a named tuple, which supports iteration and property access like a <code>DataFrameRow</code>, but also passes information on the <code>eltypes</code> of the columns of <code>df</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; df = DataFrame(x=1:4, y=11:14)
4×2 DataFrame
 Row │ x      y
     │ Int64  Int64
─────┼──────────────
   1 │     1     11
   2 │     2     12
   3 │     3     13
   4 │     4     14

julia&gt; eachrow(df)
4×2 DataFrameRows
 Row │ x      y
     │ Int64  Int64
─────┼──────────────
   1 │     1     11
   2 │     2     12
   3 │     3     13
   4 │     4     14

julia&gt; copy.(eachrow(df))
4-element Vector{NamedTuple{(:x, :y), Tuple{Int64, Int64}}}:
 (x = 1, y = 11)
 (x = 2, y = 12)
 (x = 3, y = 13)
 (x = 4, y = 14)

julia&gt; eachrow(view(df, [4, 3], [2, 1]))
2×2 DataFrameRows
 Row │ y      x
     │ Int64  Int64
─────┼──────────────
   1 │    14      4
   2 │    13      3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/6e35e296fbdef047cfdb043d54f80375331b47b5/src/abstractdataframe/iteration.jl#L27-L74">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.values" href="#Base.values"><code>Base.values</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">values(dfc::DataFrameColumns)</code></pre><p>Get a vector of columns from <code>dfc</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/6e35e296fbdef047cfdb043d54f80375331b47b5/src/abstractdataframe/iteration.jl#L230-L234">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.pairs" href="#Base.pairs"><code>Base.pairs</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">pairs(dfc::DataFrameColumns)</code></pre><p>Return an iterator of pairs associating the name of each column of <code>dfc</code> with the corresponding column vector, i.e. <code>name =&gt; col</code> where <code>name</code> is the column name of the column <code>col</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/6e35e296fbdef047cfdb043d54f80375331b47b5/src/abstractdataframe/iteration.jl#L237-L243">source</a></section></article><h2 id="Equality"><a class="docs-heading-anchor" href="#Equality">Equality</a><a id="Equality-1"></a><a class="docs-heading-anchor-permalink" href="#Equality" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Base.isapprox" href="#Base.isapprox"><code>Base.isapprox</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">isapprox(df1::AbstractDataFrame, df2::AbstractDataFrame;
         rtol::Real=atol&gt;0 ? 0 : √eps, atol::Real=0,
         nans::Bool=false, norm::Function=norm)</code></pre><p>Inexact equality comparison. <code>df1</code> and <code>df2</code> must have the same size and column names. Return  <code>true</code> if <code>isapprox</code> with given keyword arguments applied to all pairs of columns stored in <code>df1</code> and <code>df2</code> returns <code>true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/6e35e296fbdef047cfdb043d54f80375331b47b5/src/abstractdataframe/abstractdataframe.jl#L422-L430">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../types/">« Types</a><a class="docs-footer-nextpage" href="../indexing/">Indexing »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Saturday 1 May 2021 16:29">Saturday 1 May 2021</span>. Using Julia version 1.6.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
