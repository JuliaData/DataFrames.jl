var documenterSearchIndex = {"docs": [

{
    "location": "index.html#",
    "page": "Introduction",
    "title": "Introduction",
    "category": "page",
    "text": ""
},

{
    "location": "index.html#DataFrames.jl-1",
    "page": "Introduction",
    "title": "DataFrames.jl",
    "category": "section",
    "text": "Welcome to the DataFrames documentation!This resource aims to teach you everything you need to know to get up and running with tabular data manipulation using the DataFrames.jl package and the Julia language.If there is something you expect DataFrames to be capable of, but cannot figure out how to do, please reach out with questions in Domains/Data on Discourse.Please report bugs by opening an issue.You can follow the source links throughout the documentation to jump right to the source files on GitHub to make pull requests for improving the documentation and function capabilities.Please review DataFrames contributing guidelines before submitting your first PR!Information on specific versions can be found on the Release page."
},

{
    "location": "index.html#Package-Manual-1",
    "page": "Introduction",
    "title": "Package Manual",
    "category": "section",
    "text": "Pages = [\"man/getting_started.md\",\n         \"man/joins.md\",\n         \"man/split_apply_combine.md\",\n         \"man/reshaping_and_pivoting.md\",\n         \"man/sorting.md\",\n         \"man/categorical.md\",\n         \"man/missing.md\",\n         \"man/querying_frameworks.md\"]\nDepth = 2"
},

{
    "location": "index.html#API-1",
    "page": "Introduction",
    "title": "API",
    "category": "section",
    "text": "Only exported (i.e. available for use without DataFrames. qualifier after loading the DataFrames.jl package with using DataFrames) types and functions are considered a part of the public API of the DataFrames.jl package. In general all such objects are documented in this manual (in case some documentation is missing please kindly report an issue here).All types and functions that are part of public API are guaranteed to go through a deprecation period before being changed or removed.Please be warned that while Julia allows you to access internal functions or types of DataFrames.jl these can change without warning between versions of DataFrames.jl. In particular it is not safe to directly access fields of types that are a part of public API of the DataFrames.jl package using e.g. the getfield function. Whenever some operation on fields of defined types is considered allowed an appropriate exported function should be used instead.Pages = [\"lib/types.md\", \"lib/functions.md\", \"lib/indexing.md\"]\nDepth = 2"
},

{
    "location": "index.html#Index-1",
    "page": "Introduction",
    "title": "Index",
    "category": "section",
    "text": "Pages = [\"lib/types.md\", \"lib/functions.md\"]"
},

{
    "location": "man/getting_started.html#",
    "page": "Getting Started",
    "title": "Getting Started",
    "category": "page",
    "text": ""
},

{
    "location": "man/getting_started.html#Getting-Started-1",
    "page": "Getting Started",
    "title": "Getting Started",
    "category": "section",
    "text": ""
},

{
    "location": "man/getting_started.html#Installation-1",
    "page": "Getting Started",
    "title": "Installation",
    "category": "section",
    "text": "The DataFrames package is available through the Julia package system and can be installed using the following commands:using Pkg\nPkg.add(\"DataFrames\")Throughout the rest of this tutorial, we will assume that you have installed the DataFrames package and have already typed using DataFrames to bring all of the relevant variables into your current namespace.note: Note\nBy default Jupyter Notebook will limit the number of rows and columns when displaying a data frame to roughly fit the screen size (like in the REPL).You can override this behavior by setting the ENV[\"COLUMNS\"] or ENV[\"LINES\"] variables to hold the maximum width and height of output in characters respectively before using the notebook function.Alternatively, you may want to set the maximum number of data frame rows to print to 100 and the maximum output width in characters to 1000 for every Julia session using some Jupyter kernel file (numbers 100 and 1000 are only examples and can be adjusted). In such case add a \"COLUMNS\": \"1000\", \"LINES\": \"100\" entry to the \"env\" variable in this Jupyter kernel file. See here for information about location and specification of Jupyter kernels."
},

{
    "location": "man/getting_started.html#The-DataFrame-Type-1",
    "page": "Getting Started",
    "title": "The DataFrame Type",
    "category": "section",
    "text": "Objects of the DataFrame type represent a data table as a series of vectors, each corresponding to a column or variable. The simplest way of constructing a DataFrame is to pass column vectors using keyword arguments or pairs:julia> using DataFrames\n\njulia> df = DataFrame(A = 1:4, B = [\"M\", \"F\", \"F\", \"M\"])\n4×2 DataFrame\n│ Row │ A     │ B      │\n│     │ Int64 │ String │\n├─────┼───────┼────────┤\n│ 1   │ 1     │ M      │\n│ 2   │ 2     │ F      │\n│ 3   │ 3     │ F      │\n│ 4   │ 4     │ M      │\nColumns can be accessed via df.col or df[:col]. The latter syntax is more flexible as it allows passing a variable holding the name of the column, and not only a literal name. Note that column names are symbols (:col or Symbol(\"col\")) rather than strings (\"col\"). Columns can also be accessed using an integer index specifying their position.julia> df.A\n4-element Array{Int64,1}:\n 1\n 2\n 3\n 4\n\njulia> df.A === df[:A]\ntrue\n\njulia> df.A === df[1]\ntrue\n\njulia> firstcolumn = :A\n:A\n\njulia> df[firstcolumn] === df.A\ntrueColumn names can be obtained using the names function:julia> names(df)\n2-element Array{Symbol,1}:\n :A\n :B"
},

{
    "location": "man/getting_started.html#Constructing-Column-by-Column-1",
    "page": "Getting Started",
    "title": "Constructing Column by Column",
    "category": "section",
    "text": "It is also possible to start with an empty DataFrame and add columns to it one by one:julia> df = DataFrame()\n0×0 DataFrame\n\n\njulia> df.A = 1:8\n1:8\n\njulia> df.B = [\"M\", \"F\", \"F\", \"M\", \"F\", \"M\", \"M\", \"F\"]\n8-element Array{String,1}:\n \"M\"\n \"F\"\n \"F\"\n \"M\"\n \"F\"\n \"M\"\n \"M\"\n \"F\"\n\njulia> df\n8×2 DataFrame\n│ Row │ A     │ B      │\n│     │ Int64 │ String │\n├─────┼───────┼────────┤\n│ 1   │ 1     │ M      │\n│ 2   │ 2     │ F      │\n│ 3   │ 3     │ F      │\n│ 4   │ 4     │ M      │\n│ 5   │ 5     │ F      │\n│ 6   │ 6     │ M      │\n│ 7   │ 7     │ M      │\n│ 8   │ 8     │ F      │\nThe DataFrame we build in this way has 8 rows and 2 columns. This can be checked using the size function:julia> size(df, 1)\n8\n\njulia> size(df, 2)\n2\n\njulia> size(df)\n(8, 2)\n"
},

{
    "location": "man/getting_started.html#Constructing-Row-by-Row-1",
    "page": "Getting Started",
    "title": "Constructing Row by Row",
    "category": "section",
    "text": "It is also possible to fill a DataFrame row by row. Let us construct an empty data frame with two columns (note that the first column can only contain integers and the second one can only contain strings):julia> df = DataFrame(A = Int[], B = String[])\n0×2 DataFrameRows can then be added as tuples or vectors, where the order of elements matches that of columns:julia> push!(df, (1, \"M\"))\n1×2 DataFrame\n│ Row │ A     │ B      │\n│     │ Int64 │ String │\n├─────┼───────┼────────┤\n│ 1   │ 1     │ M      │\n\njulia> push!(df, [2, \"N\"])\n2×2 DataFrame\n│ Row │ A     │ B      │\n│     │ Int64 │ String │\n├─────┼───────┼────────┤\n│ 1   │ 1     │ M      │\n│ 2   │ 2     │ N      │Rows can also be added as Dicts, where the dictionary keys match the column names:julia> push!(df, Dict(:B => \"F\", :A => 3))\n3×2 DataFrame\n│ Row │ A     │ B      │\n│     │ Int64 │ String │\n├─────┼───────┼────────┤\n│ 1   │ 1     │ M      │\n│ 2   │ 2     │ N      │\n│ 3   │ 3     │ F      │Note that constructing a DataFrame row by row is significantly less performant than constructing it all at once, or column by column. For many use-cases this will not matter, but for very large DataFrames  this may be a consideration."
},

{
    "location": "man/getting_started.html#Constructing-from-another-table-type-1",
    "page": "Getting Started",
    "title": "Constructing from another table type",
    "category": "section",
    "text": "DataFrames supports the Tables.jl interface for interacting with tabular data. This means that a DataFrame can be used as a \"source\" to any package that expects a Tables.jl interface input, (file format packages, data manipulation packages, etc.). A DataFrame can also be a sink for any Tables.jl interface input. Some example uses are:df = DataFrame(a=[1, 2, 3], b=[:a, :b, :c])\n\n# write DataFrame out to CSV file\nCSV.write(\"dataframe.csv\", df)\n\n# store DataFrame in an SQLite database table\nSQLite.load!(df, db, \"dataframe_table\")\n\n# transform a DataFrame through Query.jl package\ndf = df |> @map({a=_.a + 1, _.b}) |> DataFrame"
},

{
    "location": "man/getting_started.html#Working-with-Data-Frames-1",
    "page": "Getting Started",
    "title": "Working with Data Frames",
    "category": "section",
    "text": ""
},

{
    "location": "man/getting_started.html#Examining-the-Data-1",
    "page": "Getting Started",
    "title": "Examining the Data",
    "category": "section",
    "text": "The default printing of DataFrame objects only includes a sample of rows and columns that fits on screen:julia> df = DataFrame(A = 1:2:1000, B = repeat(1:10, inner=50), C = 1:500)\n500×3 DataFrame\n│ Row │ A     │ B     │ C     │\n│     │ Int64 │ Int64 │ Int64 │\n├─────┼───────┼───────┼───────┤\n│ 1   │ 1     │ 1     │ 1     │\n│ 2   │ 3     │ 1     │ 2     │\n│ 3   │ 5     │ 1     │ 3     │\n│ 4   │ 7     │ 1     │ 4     │\n⋮\n│ 496 │ 991   │ 10    │ 496   │\n│ 497 │ 993   │ 10    │ 497   │\n│ 498 │ 995   │ 10    │ 498   │\n│ 499 │ 997   │ 10    │ 499   │\n│ 500 │ 999   │ 10    │ 500   │Printing options can be adjusted by calling the show function manually: show(df, allrows=true) prints all rows even if they do not fit on screen and show(df, allcols=true) does the same for columns.The first and last functions can be used to look at the first and last rows of a data frame (respectively):julia> first(df, 6)\n6×3 DataFrame\n│ Row │ A     │ B     │ C     │\n│     │ Int64 │ Int64 │ Int64 │\n├─────┼───────┼───────┼───────┤\n│ 1   │ 1     │ 1     │ 1     │\n│ 2   │ 3     │ 1     │ 2     │\n│ 3   │ 5     │ 1     │ 3     │\n│ 4   │ 7     │ 1     │ 4     │\n│ 5   │ 9     │ 1     │ 5     │\n│ 6   │ 11    │ 1     │ 6     │\n\njulia> last(df, 6)\n6×3 DataFrame\n│ Row │ A     │ B     │ C     │\n│     │ Int64 │ Int64 │ Int64 │\n├─────┼───────┼───────┼───────┤\n│ 1   │ 989   │ 10    │ 495   │\n│ 2   │ 991   │ 10    │ 496   │\n│ 3   │ 993   │ 10    │ 497   │\n│ 4   │ 995   │ 10    │ 498   │\n│ 5   │ 997   │ 10    │ 499   │\n│ 6   │ 999   │ 10    │ 500   │Also notice that when DataFrame is printed to the console or rendered in HTML (e.g. in Jupyter Notebook) you get an information about type of elements held in its columns. For example in this case:julia> DataFrame(a = 1:2, b = [1.0, missing],\n                 c = categorical(\'a\':\'b\'), d = [1//2, missing])\n2×4 DataFrame\n│ Row │ a     │ b        │ c            │ d         │\n│     │ Int64 │ Float64⍰ │ Categorical… │ Rationa…⍰ │\n├─────┼───────┼──────────┼──────────────┼───────────┤\n│ 1   │ 1     │ 1.0      │ \'a\'          │ 1//2      │\n│ 2   │ 2     │ missing  │ \'b\'          │ missing   │we can observe that:the first column :a can hold elements of type Int64;\nthe second column :b can hold Float64 or Missing, which is indicated by ⍰ printed after the name of type;\nthe third column :c can hold categorical data; here we notice …, which indicates that the actual name of the type was long and got truncated;\nthe type information in fourth column :d presents a situation where the name is both truncated and the type allows Missing."
},

{
    "location": "man/getting_started.html#Taking-a-Subset-1",
    "page": "Getting Started",
    "title": "Taking a Subset",
    "category": "section",
    "text": "Specific subsets of a data frame can be extracted using the indexing syntax, similar to matrices. The colon : indicates that all items (rows or columns depending on its position) should be retained:julia> df[1:3, :]\n3×3 DataFrame\n│ Row │ A     │ B     │ C     │\n│     │ Int64 │ Int64 │ Int64 │\n├─────┼───────┼───────┼───────┤\n│ 1   │ 1     │ 1     │ 1     │\n│ 2   │ 3     │ 1     │ 2     │\n│ 3   │ 5     │ 1     │ 3     │\n\njulia> df[[1, 5, 10], :]\n3×3 DataFrame\n│ Row │ A     │ B     │ C     │\n│     │ Int64 │ Int64 │ Int64 │\n├─────┼───────┼───────┼───────┤\n│ 1   │ 1     │ 1     │ 1     │\n│ 2   │ 9     │ 1     │ 5     │\n│ 3   │ 19    │ 1     │ 10    │\n\njulia> df[:, [:A, :B]]\n500×2 DataFrame\n│ Row │ A     │ B     │\n│     │ Int64 │ Int64 │\n├─────┼───────┼───────┤\n│ 1   │ 1     │ 1     │\n│ 2   │ 3     │ 1     │\n│ 3   │ 5     │ 1     │\n│ 4   │ 7     │ 1     │\n⋮\n│ 496 │ 991   │ 10    │\n│ 497 │ 993   │ 10    │\n│ 498 │ 995   │ 10    │\n│ 499 │ 997   │ 10    │\n│ 500 │ 999   │ 10    │\n\njulia> df[1:3, [:B, :A]]\n3×2 DataFrame\n│ Row │ B     │ A     │\n│     │ Int64 │ Int64 │\n├─────┼───────┼───────┤\n│ 1   │ 1     │ 1     │\n│ 2   │ 1     │ 3     │\n│ 3   │ 1     │ 5     │\n\njulia> df[[3, 1], [:C]]\n2×1 DataFrame\n│ Row │ C     │\n│     │ Int64 │\n├─────┼───────┤\n│ 1   │ 3     │\n│ 2   │ 1     │Do note that df[[:A]] and df[:, [:A]] return a DataFrame object, while df[:A] and df[:, :A] return a vector:julia> df[[:A]]\n500×1 DataFrame\n│ Row │ A     │\n│     │ Int64 │\n├─────┼───────┤\n│ 1   │ 1     │\n│ 2   │ 3     │\n│ 3   │ 5     │\n│ 4   │ 7     │\n⋮\n│ 496 │ 991   │\n│ 497 │ 993   │\n│ 498 │ 995   │\n│ 499 │ 997   │\n│ 500 │ 999   │\n\njulia> df[[:A]] == df[:, [:A]]\ntrue\n\njulia> df[:A]\n500-element Array{Int64,1}:\n   1\n   3\n   5\n   7\n   9\n  11\n   ⋮\n 991\n 993\n 995\n 997\n 999\n\njulia> df[:A] == df[:, :A]\ntrueIn the first cases, [:A] is a vector, indicating that the resulting object should be a DataFrame, since a vector can contain one or more column names. On the other hand, :A is a single symbol, indicating that a single column vector should be extracted.The indexing syntax can also be used to select rows based on conditions on variables:julia> df[df.A .> 500, :]\n250×3 DataFrame\n│ Row │ A     │ B     │ C     │\n│     │ Int64 │ Int64 │ Int64 │\n├─────┼───────┼───────┼───────┤\n│ 1   │ 501   │ 6     │ 251   │\n│ 2   │ 503   │ 6     │ 252   │\n│ 3   │ 505   │ 6     │ 253   │\n│ 4   │ 507   │ 6     │ 254   │\n⋮\n│ 246 │ 991   │ 10    │ 496   │\n│ 247 │ 993   │ 10    │ 497   │\n│ 248 │ 995   │ 10    │ 498   │\n│ 249 │ 997   │ 10    │ 499   │\n│ 250 │ 999   │ 10    │ 500   │\n\njulia> df[(df.A .> 500) .& (300 .< df.C .< 400), :]\n99×3 DataFrame\n│ Row │ A     │ B     │ C     │\n│     │ Int64 │ Int64 │ Int64 │\n├─────┼───────┼───────┼───────┤\n│ 1   │ 601   │ 7     │ 301   │\n│ 2   │ 603   │ 7     │ 302   │\n│ 3   │ 605   │ 7     │ 303   │\n│ 4   │ 607   │ 7     │ 304   │\n⋮\n│ 95  │ 789   │ 8     │ 395   │\n│ 96  │ 791   │ 8     │ 396   │\n│ 97  │ 793   │ 8     │ 397   │\n│ 98  │ 795   │ 8     │ 398   │\n│ 99  │ 797   │ 8     │ 399   │While the DataFrames package provides basic data manipulation capabilities, users are encouraged to use querying frameworks for more convenient and powerful operations:the Query.jl package provides a LINQ-like interface to a large number of data sources\nthe DataFramesMeta.jl package provides interfaces similar to LINQ and dplyrSee the Data manipulation frameworks section for more information."
},

{
    "location": "man/getting_started.html#Summarizing-Data-1",
    "page": "Getting Started",
    "title": "Summarizing Data",
    "category": "section",
    "text": "The describe function returns a data frame summarizing the elementary statistics and information about each column:julia> df = DataFrame(A = 1:4, B = [\"M\", \"F\", \"F\", \"M\"])\n\njulia> describe(df)\n2×8 DataFrame\n│ Row │ variable │ mean   │ min │ median │ max │ nunique │ nmissing │ eltype   │\n│     │ Symbol   │ Union… │ Any │ Union… │ Any │ Union…  │ Nothing  │ DataType │\n├─────┼──────────┼────────┼─────┼────────┼─────┼─────────┼──────────┼──────────┤\n│ 1   │ A        │ 2.5    │ 1   │ 2.5    │ 4   │         │          │ Int64    │\n│ 2   │ B        │        │ F   │        │ M   │ 2       │          │ String   │\nOf course, one can also compute descrptive statistics directly on individual columns:julia> using Statistics\n\njulia> mean(df.A)\n2.5"
},

{
    "location": "man/getting_started.html#Column-Wise-Operations-1",
    "page": "Getting Started",
    "title": "Column-Wise Operations",
    "category": "section",
    "text": "We can also apply a function to each column of a DataFrame with the aggregate function. For example:julia> df = DataFrame(A = 1:4, B = 4.0:-1.0:1.0)\n4×2 DataFrame\n│ Row │ A     │ B       │\n│     │ Int64 │ Float64 │\n├─────┼───────┼─────────┤\n│ 1   │ 1     │ 4.0     │\n│ 2   │ 2     │ 3.0     │\n│ 3   │ 3     │ 2.0     │\n│ 4   │ 4     │ 1.0     │\n\njulia> aggregate(df, sum)\n1×2 DataFrame\n│ Row │ A_sum │ B_sum   │\n│     │ Int64 │ Float64 │\n├─────┼───────┼─────────┤\n│ 1   │ 10    │ 10.0    │\n\njulia> aggregate(df, [sum, prod])\n1×4 DataFrame\n│ Row │ A_sum │ B_sum   │ A_prod │ B_prod  │\n│     │ Int64 │ Float64 │ Int64  │ Float64 │\n├─────┼───────┼─────────┼────────┼─────────┤\n│ 1   │ 10    │ 10.0    │ 24     │ 24.0    │"
},

{
    "location": "man/getting_started.html#Handling-of-Columns-Stored-in-a-DataFrame-1",
    "page": "Getting Started",
    "title": "Handling of Columns Stored in a DataFrame",
    "category": "section",
    "text": "Functions that transform a DataFrame to produce a new DataFrame always perform a copy of the columns by default, for example:julia> df = DataFrame(A = 1:4, B = 4.0:-1.0:1.0)\n4×2 DataFrame\n│ Row │ A     │ B       │\n│     │ Int64 │ Float64 │\n├─────┼───────┼─────────┤\n│ 1   │ 1     │ 4.0     │\n│ 2   │ 2     │ 3.0     │\n│ 3   │ 3     │ 2.0     │\n│ 4   │ 4     │ 1.0     │\n\njulia> df2 = copy(df);\n\njulia> df2.A === df.A\nfalseOn the other hand, in-place functions, whose names end with !, may mutate the column vectors of the DataFrame they take as an argument, for example:julia> x = [3, 1, 2];\n\njulia> df = DataFrame(x=x)\n3×1 DataFrame\n│ Row │ x     │\n│     │ Int64 │\n├─────┼───────┤\n│ 1   │ 3     │\n│ 2   │ 1     │\n│ 3   │ 2     │\n\njulia> sort!(df)\n3×1 DataFrame\n│ Row │ x     │\n│     │ Int64 │\n├─────┼───────┤\n│ 1   │ 1     │\n│ 2   │ 2     │\n│ 3   │ 3     │\n\njulia> x\n3-element Array{Int64,1}:\n 1\n 2\n 3\n\njulia> df.x[1] = 100\n100\n\njulia> df\n3×1 DataFrame\n│ Row │ x     │\n│     │ Int64 │\n├─────┼───────┤\n│ 1   │ 100   │\n│ 2   │ 2     │\n│ 3   │ 3     │\n\njulia> x\n3-element Array{Int64,1}:\n 100\n   2\n   3In-place functions are safe to call, except when a view of the DataFrame (created via a view, @view or groupby) or when a DataFrame created with copycols=false (or with the DataFrame! function) are in use.It is possible to have a direct access to a column col of a DataFrame df using the syntaxes df.col, df[:col], via the eachcol function, by accessing a parent of a view of a column of a DataFrame, or simply by storing the reference to the column vector before the DataFrame was created with copycols=false (or with the DataFrame! function).julia> x = [3, 1, 2];\n\njulia> df = DataFrame(x=x)\n3×1 DataFrame\n│ Row │ x     │\n│     │ Int64 │\n├─────┼───────┤\n│ 1   │ 3     │\n│ 2   │ 1     │\n│ 3   │ 2     │\n\njulia> df.x == x\ntrue\n\njulia> df[1] !== x\ntrue\n\njulia> eachcol(df, false)[1] === df.x\ntrueNote that a column obtained from a DataFrame using one of these methods should not be mutated without caution.The exact rules of handling columns of a DataFrame are explained in The design of handling of columns of a DataFrame section of the manual."
},

{
    "location": "man/getting_started.html#Importing-and-Exporting-Data-(I/O)-1",
    "page": "Getting Started",
    "title": "Importing and Exporting Data (I/O)",
    "category": "section",
    "text": "For reading and writing tabular data from CSV and other delimited text files, use the CSV.jl package.If you have not used the CSV.jl package before then you may need to install it first:using Pkg\nPkg.add(\"CSV\")The CSV.jl functions are not loaded automatically and must be imported into the session.using CSVA dataset can now be read from a CSV file at path input usingCSV.read(input)A DataFrame can be written to a CSV file at path output usingdf = DataFrame(x = 1, y = 2)\nCSV.write(output, df)The behavior of CSV functions can be adapted via keyword arguments. For more information, see ?CSV.read and ?CSV.write, or checkout the online CSV.jl documentation."
},

{
    "location": "man/joins.html#",
    "page": "Joins",
    "title": "Joins",
    "category": "page",
    "text": ""
},

{
    "location": "man/joins.html#Database-Style-Joins-1",
    "page": "Joins",
    "title": "Database-Style Joins",
    "category": "section",
    "text": "We often need to combine two or more data sets together to provide a complete picture of the topic we are studying. For example, suppose that we have the following two data sets:julia> using DataFrames\n\njulia> people = DataFrame(ID = [20, 40], Name = [\"John Doe\", \"Jane Doe\"])\n2×2 DataFrame\n│ Row │ ID    │ Name     │\n│     │ Int64 │ String   │\n├─────┼───────┼──────────┤\n│ 1   │ 20    │ John Doe │\n│ 2   │ 40    │ Jane Doe │\n\njulia> jobs = DataFrame(ID = [20, 40], Job = [\"Lawyer\", \"Doctor\"])\n2×2 DataFrame\n│ Row │ ID    │ Job    │\n│     │ Int64 │ String │\n├─────┼───────┼────────┤\n│ 1   │ 20    │ Lawyer │\n│ 2   │ 40    │ Doctor │\nWe might want to work with a larger data set that contains both the names and jobs for each ID. We can do this using the join function:julia> join(people, jobs, on = :ID)\n2×3 DataFrame\n│ Row │ ID    │ Name     │ Job    │\n│     │ Int64 │ String   │ String │\n├─────┼───────┼──────────┼────────┤\n│ 1   │ 20    │ John Doe │ Lawyer │\n│ 2   │ 40    │ Jane Doe │ Doctor │\nIn relational database theory, this operation is generally referred to as a join. The columns used to determine which rows should be combined during a join are called keys.There are seven kinds of joins supported by the DataFrames package:Inner: The output contains rows for values of the key that exist in both the first (left) and second (right) arguments to join.\nLeft: The output contains rows for values of the key that exist in the first (left) argument to join, whether or not that value exists in the second (right) argument.\nRight: The output contains rows for values of the key that exist in the second (right) argument to join, whether or not that value exists in the first (left) argument.\nOuter: The output contains rows for values of the key that exist in the first (left) or second (right) argument to join.\nSemi: Like an inner join, but output is restricted to columns from the first (left) argument to join.\nAnti: The output contains rows for values of the key that exist in the first (left) but not the second (right) argument to join. As with semi joins, output is restricted to columns from the first (left) argument.\nCross: The output is the cartesian product of rows from the first (left) and second (right) arguments to join.See the Wikipedia page on SQL joins for more information.You can control the kind of join that join performs using the kind keyword argument:julia> jobs = DataFrame(ID = [20, 60], Job = [\"Lawyer\", \"Astronaut\"])\n2×2 DataFrame\n│ Row │ ID    │ Job       │\n│     │ Int64 │ String    │\n├─────┼───────┼───────────┤\n│ 1   │ 20    │ Lawyer    │\n│ 2   │ 60    │ Astronaut │\n\njulia> join(people, jobs, on = :ID, kind = :inner)\n1×3 DataFrame\n│ Row │ ID    │ Name     │ Job    │\n│     │ Int64 │ String   │ String │\n├─────┼───────┼──────────┼────────┤\n│ 1   │ 20    │ John Doe │ Lawyer │\n\njulia> join(people, jobs, on = :ID, kind = :left)\n2×3 DataFrame\n│ Row │ ID    │ Name     │ Job     │\n│     │ Int64 │ String   │ String⍰ │\n├─────┼───────┼──────────┼─────────┤\n│ 1   │ 20    │ John Doe │ Lawyer  │\n│ 2   │ 40    │ Jane Doe │ missing │\n\njulia> join(people, jobs, on = :ID, kind = :right)\n2×3 DataFrame\n│ Row │ ID    │ Name     │ Job       │\n│     │ Int64 │ String⍰  │ String    │\n├─────┼───────┼──────────┼───────────┤\n│ 1   │ 20    │ John Doe │ Lawyer    │\n│ 2   │ 60    │ missing  │ Astronaut │\n\njulia> join(people, jobs, on = :ID, kind = :outer)\n3×3 DataFrame\n│ Row │ ID    │ Name     │ Job       │\n│     │ Int64 │ String⍰  │ String⍰   │\n├─────┼───────┼──────────┼───────────┤\n│ 1   │ 20    │ John Doe │ Lawyer    │\n│ 2   │ 40    │ Jane Doe │ missing   │\n│ 3   │ 60    │ missing  │ Astronaut │\n\njulia> join(people, jobs, on = :ID, kind = :semi)\n1×2 DataFrame\n│ Row │ ID    │ Name     │\n│     │ Int64 │ String   │\n├─────┼───────┼──────────┤\n│ 1   │ 20    │ John Doe │\n\njulia> join(people, jobs, on = :ID, kind = :anti)\n1×2 DataFrame\n│ Row │ ID    │ Name     │\n│     │ Int64 │ String   │\n├─────┼───────┼──────────┤\n│ 1   │ 40    │ Jane Doe │\nCross joins are the only kind of join that does not use a key:julia> join(people, jobs, kind = :cross, makeunique = true)\n4×4 DataFrame\n│ Row │ ID    │ Name     │ ID_1  │ Job       │\n│     │ Int64 │ String   │ Int64 │ String    │\n├─────┼───────┼──────────┼───────┼───────────┤\n│ 1   │ 20    │ John Doe │ 20    │ Lawyer    │\n│ 2   │ 20    │ John Doe │ 60    │ Astronaut │\n│ 3   │ 40    │ Jane Doe │ 20    │ Lawyer    │\n│ 4   │ 40    │ Jane Doe │ 60    │ Astronaut │\nIn order to join data tables on keys which have different names in the left and right tables, you may pass (left, right) tuples or left => right pairs as on argument:julia> a = DataFrame(ID = [20, 40], Name = [\"John Doe\", \"Jane Doe\"])\n2×2 DataFrame\n│ Row │ ID    │ Name     │\n│     │ Int64 │ String   │\n├─────┼───────┼──────────┤\n│ 1   │ 20    │ John Doe │\n│ 2   │ 40    │ Jane Doe │\n\njulia> b = DataFrame(IDNew = [20, 40], Job = [\"Lawyer\", \"Doctor\"])\n2×2 DataFrame\n│ Row │ IDNew │ Job    │\n│     │ Int64 │ String │\n├─────┼───────┼────────┤\n│ 1   │ 20    │ Lawyer │\n│ 2   │ 40    │ Doctor │\n\njulia> join(a, b, on = :ID => :IDNew, kind = :inner)\n2×3 DataFrame\n│ Row │ ID    │ Name     │ Job    │\n│     │ Int64 │ String   │ String │\n├─────┼───────┼──────────┼────────┤\n│ 1   │ 20    │ John Doe │ Lawyer │\n│ 2   │ 40    │ Jane Doe │ Doctor │\nHere is another example with multiple columns:julia> a = DataFrame(City = [\"Amsterdam\", \"London\", \"London\", \"New York\", \"New York\"],\n                     Job = [\"Lawyer\", \"Lawyer\", \"Lawyer\", \"Doctor\", \"Doctor\"],\n                     Category = [1, 2, 3, 4, 5])\n5×3 DataFrame\n│ Row │ City      │ Job    │ Category │\n│     │ String    │ String │ Int64    │\n├─────┼───────────┼────────┼──────────┤\n│ 1   │ Amsterdam │ Lawyer │ 1        │\n│ 2   │ London    │ Lawyer │ 2        │\n│ 3   │ London    │ Lawyer │ 3        │\n│ 4   │ New York  │ Doctor │ 4        │\n│ 5   │ New York  │ Doctor │ 5        │\n\njulia> b = DataFrame(Location = [\"Amsterdam\", \"London\", \"London\", \"New York\", \"New York\"],\n                     Work = [\"Lawyer\", \"Lawyer\", \"Lawyer\", \"Doctor\", \"Doctor\"],\n                     Name = [\"a\", \"b\", \"c\", \"d\", \"e\"])\n5×3 DataFrame\n│ Row │ Location  │ Work   │ Name   │\n│     │ String    │ String │ String │\n├─────┼───────────┼────────┼────────┤\n│ 1   │ Amsterdam │ Lawyer │ a      │\n│ 2   │ London    │ Lawyer │ b      │\n│ 3   │ London    │ Lawyer │ c      │\n│ 4   │ New York  │ Doctor │ d      │\n│ 5   │ New York  │ Doctor │ e      │\n\njulia> join(a, b, on = [(:City, :Location), (:Job, :Work)])\n9×4 DataFrame\n│ Row │ City      │ Job    │ Category │ Name   │\n│     │ String    │ String │ Int64    │ String │\n├─────┼───────────┼────────┼──────────┼────────┤\n│ 1   │ Amsterdam │ Lawyer │ 1        │ a      │\n│ 2   │ London    │ Lawyer │ 2        │ b      │\n│ 3   │ London    │ Lawyer │ 2        │ c      │\n│ 4   │ London    │ Lawyer │ 3        │ b      │\n│ 5   │ London    │ Lawyer │ 3        │ c      │\n│ 6   │ New York  │ Doctor │ 4        │ d      │\n│ 7   │ New York  │ Doctor │ 4        │ e      │\n│ 8   │ New York  │ Doctor │ 5        │ d      │\n│ 9   │ New York  │ Doctor │ 5        │ e      │\nAdditionally, notice that in the last join rows 2 and 3 had the same values on on variables in both joined DataFrames. In such a situation :inner, :outer, :left and :right joins will produce all combinations of matching rows. In our example rows from 2 to 5 were created as a result. The same behavior can be observed for rows 4 and 5 in both joined DataFrames.In order to check that columns passed as the on argument define unique keys (according to isequal) in each input data frame you can set the validate keyword argument to a two-element tuple or a pair of Bool values, with each element indicating whether to run check for the corresponding data frame. Here is an example for the join operation described above:julia> join(a, b, on = [(:City, :Location), (:Job, :Work)], validate=(true, true))\nERROR: ArgumentError: Merge key(s) are not unique in both df1 and df2. First duplicate in df1 at 3. First duplicate in df2 at 3Finally, using the indicator keyword argument you can add a column to the resulting data frame indicating whether the given row appeared only in the left, the right or both data frames. Here is an example:julia> a = DataFrame(ID = [20, 40], Name = [\"John\", \"Jane\"])\n2×2 DataFrame\n│ Row │ ID    │ Name   │\n│     │ Int64 │ String │\n├─────┼───────┼────────┤\n│ 1   │ 20    │ John   │\n│ 2   │ 40    │ Jane   │\n\njulia> b = DataFrame(ID = [20, 60], Job = [\"Lawyer\", \"Doctor\"])\n2×2 DataFrame\n│ Row │ ID    │ Job    │\n│     │ Int64 │ String │\n├─────┼───────┼────────┤\n│ 1   │ 20    │ Lawyer │\n│ 2   │ 60    │ Doctor │\n\njulia> join(a, b, on=:ID, validate=(true, true), indicator=:source, kind=:outer)\n3×4 DataFrame\n│ Row │ ID    │ Name    │ Job     │ source       │\n│     │ Int64 │ String⍰ │ String⍰ │ Categorical… │\n├─────┼───────┼─────────┼─────────┼──────────────┤\n│ 1   │ 20    │ John    │ Lawyer  │ both         │\n│ 2   │ 40    │ Jane    │ missing │ left_only    │\n│ 3   │ 60    │ missing │ Doctor  │ right_only   │Note that this time we also used the validate keyword argument and it did not produce errors as the keys defined in both source data frames were unique."
},

{
    "location": "man/split_apply_combine.html#",
    "page": "Split-apply-combine",
    "title": "Split-apply-combine",
    "category": "page",
    "text": ""
},

{
    "location": "man/split_apply_combine.html#The-Split-Apply-Combine-Strategy-1",
    "page": "Split-apply-combine",
    "title": "The Split-Apply-Combine Strategy",
    "category": "section",
    "text": "Many data analysis tasks involve splitting a data set into groups, applying some functions to each of the groups and then combining the results. A standardized framework for handling this sort of computation is described in the paper \"The Split-Apply-Combine Strategy for Data Analysis\", written by Hadley Wickham.The DataFrames package supports the split-apply-combine strategy through the by function, which is a shorthand for groupby followed by map and/or combine. by takes in three arguments: (1) a DataFrame, (2) one or more columns to split the DataFrame on, and (3) a specification of one or more functions to apply to each subset of the DataFrame. This specification can be of the following forms:a col => function pair indicating that function should be called with the vector of values for column col, which can be a column name or index\na cols => function pair indicating that function should be called with a named tuple holding columns cols, which can be a tuple or vector of names or indices\nseveral such pairs, either as positional arguments or as keyword arguments (mixing is not allowed), producing each a single separate column; keyword argument names are used as column names\nequivalently, a (named) tuple or vector of such pairs\na function which will be called with a SubDataFrame corresponding to each group; this form should be avoided due to its poor performanceIn all of these cases, the function can return either a single row or multiple rows, with a single or multiple columns:a single value produces a single row and column per group\na named tuple or DataFrameRow produces a single row and one column per field\na vector produces a single column with one row per entry\na named tuple of vectors produces one column per field with one row per entry in the vectors\na DataFrame or a matrix produces as many rows and columns as it contains; note that returning a DataFrame should be avoided due to its poor performance when the number of groups is largeThe kind of return value and the number and names of columns must be the same for all groups.As a special case, if multiple pairs or a tuple of vectors or pairs is passed (forms 3 and 4 above), each function is required to return a single value or vector, which will produce each a separate column.The name for the resulting column can be chosen either by passing a named tuple of pairs, or by returning a named tuple or a data frame. If no name is provided, it is generated automatically. For functions taking a single column (first form), the input column name is concatenated with the function name: for standard functions like mean this will produce columns with names like SepalLength_mean; for anonymous functions like x -> 2 * sqrt(x), the produced columns will be SepalLength_function. For functions taking multiple columns (second form), names are x1, x2, etc.We show several examples of the by function applied to the iris dataset below:julia> using DataFrames, CSV, Statistics\n\njulia> iris = CSV.read(joinpath(dirname(pathof(DataFrames)), \"../docs/src/assets/iris.csv\"));\n\njulia> first(iris, 6)\n6×5 DataFrame\n│ Row │ SepalLength │ SepalWidth │ PetalLength │ PetalWidth │ Species       │\n│     │ Float64⍰    │ Float64⍰   │ Float64⍰    │ Float64⍰   │ Categorical…⍰ │\n├─────┼─────────────┼────────────┼─────────────┼────────────┼───────────────┤\n│ 1   │ 5.1         │ 3.5        │ 1.4         │ 0.2        │ setosa        │\n│ 2   │ 4.9         │ 3.0        │ 1.4         │ 0.2        │ setosa        │\n│ 3   │ 4.7         │ 3.2        │ 1.3         │ 0.2        │ setosa        │\n│ 4   │ 4.6         │ 3.1        │ 1.5         │ 0.2        │ setosa        │\n│ 5   │ 5.0         │ 3.6        │ 1.4         │ 0.2        │ setosa        │\n│ 6   │ 5.4         │ 3.9        │ 1.7         │ 0.4        │ setosa        │\n\njulia> last(iris, 6)\n6×5 DataFrame\n│ Row │ SepalLength │ SepalWidth │ PetalLength │ PetalWidth │ Species       │\n│     │ Float64⍰    │ Float64⍰   │ Float64⍰    │ Float64⍰   │ Categorical…⍰ │\n├─────┼─────────────┼────────────┼─────────────┼────────────┼───────────────┤\n│ 1   │ 6.7         │ 3.3        │ 5.7         │ 2.5        │ virginica     │\n│ 2   │ 6.7         │ 3.0        │ 5.2         │ 2.3        │ virginica     │\n│ 3   │ 6.3         │ 2.5        │ 5.0         │ 1.9        │ virginica     │\n│ 4   │ 6.5         │ 3.0        │ 5.2         │ 2.0        │ virginica     │\n│ 5   │ 6.2         │ 3.4        │ 5.4         │ 2.3        │ virginica     │\n│ 6   │ 5.9         │ 3.0        │ 5.1         │ 1.8        │ virginica     │\n\njulia> by(iris, :Species, :PetalLength => mean)\n3×2 DataFrame\n│ Row │ Species    │ PetalLength_mean │\n│     │ String⍰    │ Float64          │\n├─────┼────────────┼──────────────────┤\n│ 1   │ setosa     │ 1.462            │\n│ 2   │ versicolor │ 4.26             │\n│ 3   │ virginica  │ 5.552            │\n\njulia> by(iris, :Species, N = :Species => length) # Chosen column is arbitrary\n3×2 DataFrame\n│ Row │ Species       │ N     │\n│     │ Categorical…⍰ │ Int64 │\n├─────┼───────────────┼───────┤\n│ 1   │ setosa        │ 50    │\n│ 2   │ versicolor    │ 50    │\n│ 3   │ virginica     │ 50    │\n\njulia> by(iris, :Species, N = :Species => length, mean = :PetalLength => mean) # Column for length is arbitrary\n3×3 DataFrame\n│ Row │ Species    │ N     │ mean    │\n│     │ String⍰    │ Int64 │ Float64 │\n├─────┼────────────┼───────┼─────────┤\n│ 1   │ setosa     │ 50    │ 1.462   │\n│ 2   │ versicolor │ 50    │ 4.26    │\n│ 3   │ virginica  │ 50    │ 5.552   │\n\njulia> by(iris, :Species, [:PetalLength, :SepalLength] =>\n              x -> (a=mean(x.PetalLength)/mean(x.SepalLength), b=sum(x.PetalLength)))\n3×3 DataFrame\n│ Row │ Species    │ a        │ b       │\n│     │ String⍰    │ Float64  │ Float64 │\n├─────┼────────────┼──────────┼─────────┤\n│ 1   │ setosa     │ 0.29205  │ 73.1    │\n│ 2   │ versicolor │ 0.717655 │ 213.0   │\n│ 3   │ virginica  │ 0.842744 │ 277.6   │The by function also supports the do block form. However, as noted above, this form is slow and should therefore be avoided when performance matters.julia> by(iris, :Species) do df\n          (m = mean(df.PetalLength), s² = var(df.PetalLength))\n       end\n3×3 DataFrame\n│ Row │ Species       │ m       │ s²        │\n│     │ Categorical…⍰ │ Float64 │ Float64   │\n├─────┼───────────────┼─────────┼───────────┤\n│ 1   │ setosa        │ 1.462   │ 0.0301592 │\n│ 2   │ versicolor    │ 4.26    │ 0.220816  │\n│ 3   │ virginica     │ 5.552   │ 0.304588  │A second approach to the Split-Apply-Combine strategy is implemented in the aggregate function, which also takes three arguments: (1) a DataFrame, (2) one or more columns to split the DataFrame on, and (3) one or more functions that are used to compute a summary of each subset of the DataFrame. Each function is applied to each column that was not used to split the DataFrame, creating new columns of the form $name_$function like with by (see above). We show several examples of the aggregate function applied to the iris dataset below:julia> aggregate(iris, :Species, length)\n3×5 DataFrame\n│ Row │ Species       │ SepalLength_length │ SepalWidth_length │ PetalLength_length │ PetalWidth_length │\n│     │ Categorical…⍰ │ Int64              │ Int64             │ Int64              │ Int64             │\n├─────┼───────────────┼────────────────────┼───────────────────┼────────────────────┼───────────────────┤\n│ 1   │ setosa        │ 50                 │ 50                │ 50                 │ 50                │\n│ 2   │ versicolor    │ 50                 │ 50                │ 50                 │ 50                │\n│ 3   │ virginica     │ 50                 │ 50                │ 50                 │ 50                │\n\njulia> aggregate(iris, :Species, [sum, mean])\n3×9 DataFrame. Omitted printing of 2 columns\n│ Row │ Species       │ SepalLength_sum │ SepalWidth_sum │ PetalLength_sum │ PetalWidth_sum │ SepalLength_mean │ SepalWidth_mean │\n│     │ Categorical…⍰ │ Float64         │ Float64        │ Float64         │ Float64        │ Float64          │ Float64         │\n├─────┼───────────────┼─────────────────┼────────────────┼─────────────────┼────────────────┼──────────────────┼─────────────────┤\n│ 1   │ setosa        │ 250.3           │ 171.4          │ 73.1            │ 12.3           │ 5.006            │ 3.428           │\n│ 2   │ versicolor    │ 296.8           │ 138.5          │ 213.0           │ 66.3           │ 5.936            │ 2.77            │\n│ 3   │ virginica     │ 329.4           │ 148.7          │ 277.6           │ 101.3          │ 6.588            │ 2.974           │If you only want to split the data set into subsets, use the groupby function:julia> for subdf in groupby(iris, :Species)\n           println(size(subdf, 1))\n       end\n50\n50\n50"
},

{
    "location": "man/reshaping_and_pivoting.html#",
    "page": "Reshaping",
    "title": "Reshaping",
    "category": "page",
    "text": ""
},

{
    "location": "man/reshaping_and_pivoting.html#Reshaping-and-Pivoting-Data-1",
    "page": "Reshaping",
    "title": "Reshaping and Pivoting Data",
    "category": "section",
    "text": "Reshape data from wide to long format using the stack function:julia> using DataFrames, CSV\n\njulia> iris = CSV.read(joinpath(dirname(pathof(DataFrames)), \"../test/data/iris.csv\"));\n\njulia> first(iris, 6)\n6×5 DataFrame\n│ Row │ SepalLength │ SepalWidth │ PetalLength │ PetalWidth │ Species       │\n│     │ Float64⍰    │ Float64⍰   │ Float64⍰    │ Float64⍰   │ Categorical…⍰ │\n├─────┼─────────────┼────────────┼─────────────┼────────────┼───────────────┤\n│ 1   │ 5.1         │ 3.5        │ 1.4         │ 0.2        │ setosa        │\n│ 2   │ 4.9         │ 3.0        │ 1.4         │ 0.2        │ setosa        │\n│ 3   │ 4.7         │ 3.2        │ 1.3         │ 0.2        │ setosa        │\n│ 4   │ 4.6         │ 3.1        │ 1.5         │ 0.2        │ setosa        │\n│ 5   │ 5.0         │ 3.6        │ 1.4         │ 0.2        │ setosa        │\n│ 6   │ 5.4         │ 3.9        │ 1.7         │ 0.4        │ setosa        │\n\njulia> last(iris, 6)\n6×5 DataFrame\n│ Row │ SepalLength │ SepalWidth │ PetalLength │ PetalWidth │ Species       │\n│     │ Float64⍰    │ Float64⍰   │ Float64⍰    │ Float64⍰   │ Categorical…⍰ │\n├─────┼─────────────┼────────────┼─────────────┼────────────┼───────────────┤\n│ 1   │ 6.7         │ 3.3        │ 5.7         │ 2.5        │ virginica     │\n│ 2   │ 6.7         │ 3.0        │ 5.2         │ 2.3        │ virginica     │\n│ 3   │ 6.3         │ 2.5        │ 5.0         │ 1.9        │ virginica     │\n│ 4   │ 6.5         │ 3.0        │ 5.2         │ 2.0        │ virginica     │\n│ 5   │ 6.2         │ 3.4        │ 5.4         │ 2.3        │ virginica     │\n│ 6   │ 5.9         │ 3.0        │ 5.1         │ 1.8        │ virginica     │\n\njulia> d = stack(iris, 1:4);\n\njulia> first(d, 6)\n6×3 DataFrame\n│ Row │ variable    │ value    │ Species       │\n│     │ Symbol      │ Float64⍰ │ Categorical…⍰ │\n├─────┼─────────────┼──────────┼───────────────┤\n│ 1   │ SepalLength │ 5.1      │ setosa        │\n│ 2   │ SepalLength │ 4.9      │ setosa        │\n│ 3   │ SepalLength │ 4.7      │ setosa        │\n│ 4   │ SepalLength │ 4.6      │ setosa        │\n│ 5   │ SepalLength │ 5.0      │ setosa        │\n│ 6   │ SepalLength │ 5.4      │ setosa        │\n\njulia> last(d, 6)\n6×3 DataFrame\n│ Row │ variable   │ value    │ Species       │\n│     │ Symbol     │ Float64⍰ │ Categorical…⍰ │\n├─────┼────────────┼──────────┼───────────────┤\n│ 1   │ PetalWidth │ 2.5      │ virginica     │\n│ 2   │ PetalWidth │ 2.3      │ virginica     │\n│ 3   │ PetalWidth │ 1.9      │ virginica     │\n│ 4   │ PetalWidth │ 2.0      │ virginica     │\n│ 5   │ PetalWidth │ 2.3      │ virginica     │\n│ 6   │ PetalWidth │ 1.8      │ virginica     │The second optional argument to stack indicates the columns to be stacked. These are normally referred to as the measured variables. Column names can also be given:julia> d = stack(iris, [:SepalLength, :SepalWidth, :PetalLength, :PetalWidth]);\n\njulia> first(d, 6)\n6×3 DataFrame\n│ Row │ variable    │ value    │ Species       │\n│     │ Symbol      │ Float64⍰ │ Categorical…⍰ │\n├─────┼─────────────┼──────────┼───────────────┤\n│ 1   │ SepalLength │ 5.1      │ setosa        │\n│ 2   │ SepalLength │ 4.9      │ setosa        │\n│ 3   │ SepalLength │ 4.7      │ setosa        │\n│ 4   │ SepalLength │ 4.6      │ setosa        │\n│ 5   │ SepalLength │ 5.0      │ setosa        │\n│ 6   │ SepalLength │ 5.4      │ setosa        │\n\njulia> last(d, 6)\n6×3 DataFrame\n│ Row │ variable   │ value    │ Species       │\n│     │ Symbol     │ Float64⍰ │ Categorical…⍰ │\n├─────┼────────────┼──────────┼───────────────┤\n│ 1   │ PetalWidth │ 2.5      │ virginica     │\n│ 2   │ PetalWidth │ 2.3      │ virginica     │\n│ 3   │ PetalWidth │ 1.9      │ virginica     │\n│ 4   │ PetalWidth │ 2.0      │ virginica     │\n│ 5   │ PetalWidth │ 2.3      │ virginica     │\n│ 6   │ PetalWidth │ 1.8      │ virginica     │\nNote that all columns can be of different types. Type promotion follows the rules of vcat.The stacked DataFrame that results includes all of the columns not specified to be stacked. These are repeated for each stacked column. These are normally refered to as identifier (id) columns. In addition to the id columns, two additional columns labeled :variable and :values contain the column identifier and the stacked columns.A third optional argument to stack represents the id columns that are repeated. This makes it easier to specify which variables you want included in the long format:julia> d = stack(iris, [:SepalLength, :SepalWidth], :Species);\n\njulia> first(d, 6)\n6×3 DataFrame\n│ Row │ variable    │ value    │ Species       │\n│     │ Symbol      │ Float64⍰ │ Categorical…⍰ │\n├─────┼─────────────┼──────────┼───────────────┤\n│ 1   │ SepalLength │ 5.1      │ setosa        │\n│ 2   │ SepalLength │ 4.9      │ setosa        │\n│ 3   │ SepalLength │ 4.7      │ setosa        │\n│ 4   │ SepalLength │ 4.6      │ setosa        │\n│ 5   │ SepalLength │ 5.0      │ setosa        │\n│ 6   │ SepalLength │ 5.4      │ setosa        │\n\njulia> last(d, 6)\n6×3 DataFrame\n│ Row │ variable   │ value    │ Species       │\n│     │ Symbol     │ Float64⍰ │ Categorical…⍰ │\n├─────┼────────────┼──────────┼───────────────┤\n│ 1   │ SepalWidth │ 3.3      │ virginica     │\n│ 2   │ SepalWidth │ 3.0      │ virginica     │\n│ 3   │ SepalWidth │ 2.5      │ virginica     │\n│ 4   │ SepalWidth │ 3.0      │ virginica     │\n│ 5   │ SepalWidth │ 3.4      │ virginica     │\n│ 6   │ SepalWidth │ 3.0      │ virginica     │melt is an alternative function to reshape from wide to long format. It is based on stack, but it prefers specification of the id columns as:julia> d = melt(iris, :Species);\n\njulia> first(d, 6)\n6×3 DataFrame\n│ Row │ variable    │ value    │ Species       │\n│     │ Symbol      │ Float64⍰ │ Categorical…⍰ │\n├─────┼─────────────┼──────────┼───────────────┤\n│ 1   │ SepalLength │ 5.1      │ setosa        │\n│ 2   │ SepalLength │ 4.9      │ setosa        │\n│ 3   │ SepalLength │ 4.7      │ setosa        │\n│ 4   │ SepalLength │ 4.6      │ setosa        │\n│ 5   │ SepalLength │ 5.0      │ setosa        │\n│ 6   │ SepalLength │ 5.4      │ setosa        │\n\njulia> last(d, 6)\n6×3 DataFrame\n│ Row │ variable   │ value    │ Species       │\n│     │ Symbol     │ Float64⍰ │ Categorical…⍰ │\n├─────┼────────────┼──────────┼───────────────┤\n│ 1   │ PetalWidth │ 2.5      │ virginica     │\n│ 2   │ PetalWidth │ 2.3      │ virginica     │\n│ 3   │ PetalWidth │ 1.9      │ virginica     │\n│ 4   │ PetalWidth │ 2.0      │ virginica     │\n│ 5   │ PetalWidth │ 2.3      │ virginica     │\n│ 6   │ PetalWidth │ 1.8      │ virginica     │unstack converts from a long format to a wide format. The default is requires specifying which columns are an id variable, column variable names, and column values:julia> iris[:id] = 1:size(iris, 1)\n1:150\n\njulia> longdf = melt(iris, [:Species, :id]);\n\njulia> first(longdf, 6)\n6×4 DataFrame\n│ Row │ variable    │ value    │ Species       │ id    │\n│     │ Symbol      │ Float64⍰ │ Categorical…⍰ │ Int64 │\n├─────┼─────────────┼──────────┼───────────────┼───────┤\n│ 1   │ SepalLength │ 5.1      │ setosa        │ 1     │\n│ 2   │ SepalLength │ 4.9      │ setosa        │ 2     │\n│ 3   │ SepalLength │ 4.7      │ setosa        │ 3     │\n│ 4   │ SepalLength │ 4.6      │ setosa        │ 4     │\n│ 5   │ SepalLength │ 5.0      │ setosa        │ 5     │\n│ 6   │ SepalLength │ 5.4      │ setosa        │ 6     │\n\njulia> last(longdf, 6)\n6×4 DataFrame\n│ Row │ variable   │ value    │ Species       │ id    │\n│     │ Symbol     │ Float64⍰ │ Categorical…⍰ │ Int64 │\n├─────┼────────────┼──────────┼───────────────┼───────┤\n│ 1   │ PetalWidth │ 2.5      │ virginica     │ 145   │\n│ 2   │ PetalWidth │ 2.3      │ virginica     │ 146   │\n│ 3   │ PetalWidth │ 1.9      │ virginica     │ 147   │\n│ 4   │ PetalWidth │ 2.0      │ virginica     │ 148   │\n│ 5   │ PetalWidth │ 2.3      │ virginica     │ 149   │\n│ 6   │ PetalWidth │ 1.8      │ virginica     │ 150   │\n\njulia> widedf = unstack(longdf, :id, :variable, :value);\n\njulia> first(widedf, 6)\n6×5 DataFrame\n│ Row │ id    │ PetalLength │ PetalWidth │ SepalLength │ SepalWidth │\n│     │ Int64 │ Float64⍰    │ Float64⍰   │ Float64⍰    │ Float64⍰   │\n├─────┼───────┼─────────────┼────────────┼─────────────┼────────────┤\n│ 1   │ 1     │ 1.4         │ 0.2        │ 5.1         │ 3.5        │\n│ 2   │ 2     │ 1.4         │ 0.2        │ 4.9         │ 3.0        │\n│ 3   │ 3     │ 1.3         │ 0.2        │ 4.7         │ 3.2        │\n│ 4   │ 4     │ 1.5         │ 0.2        │ 4.6         │ 3.1        │\n│ 5   │ 5     │ 1.4         │ 0.2        │ 5.0         │ 3.6        │\n│ 6   │ 6     │ 1.7         │ 0.4        │ 5.4         │ 3.9        │\n\njulia> last(widedf, 6)\n6×5 DataFrame\n│ Row │ id    │ PetalLength │ PetalWidth │ SepalLength │ SepalWidth │\n│     │ Int64 │ Float64⍰    │ Float64⍰   │ Float64⍰    │ Float64⍰   │\n├─────┼───────┼─────────────┼────────────┼─────────────┼────────────┤\n│ 1   │ 145   │ 5.7         │ 2.5        │ 6.7         │ 3.3        │\n│ 2   │ 146   │ 5.2         │ 2.3        │ 6.7         │ 3.0        │\n│ 3   │ 147   │ 5.0         │ 1.9        │ 6.3         │ 2.5        │\n│ 4   │ 148   │ 5.2         │ 2.0        │ 6.5         │ 3.0        │\n│ 5   │ 149   │ 5.4         │ 2.3        │ 6.2         │ 3.4        │\n│ 6   │ 150   │ 5.1         │ 1.8        │ 5.9         │ 3.0        │If the remaining columns are unique, you can skip the id variable and use:julia> longdf = melt(iris, [:Species, :id]);\n\njulia> first(longdf, 6)\n6×4 DataFrame\n│ Row │ variable    │ value    │ Species       │ id    │\n│     │ Symbol      │ Float64⍰ │ Categorical…⍰ │ Int64 │\n├─────┼─────────────┼──────────┼───────────────┼───────┤\n│ 1   │ SepalLength │ 5.1      │ setosa        │ 1     │\n│ 2   │ SepalLength │ 4.9      │ setosa        │ 2     │\n│ 3   │ SepalLength │ 4.7      │ setosa        │ 3     │\n│ 4   │ SepalLength │ 4.6      │ setosa        │ 4     │\n│ 5   │ SepalLength │ 5.0      │ setosa        │ 5     │\n│ 6   │ SepalLength │ 5.4      │ setosa        │ 6     │\n\njulia> widedf = unstack(longdf, :variable, :value);\n\njulia> first(widedf, 6)\n6×6 DataFrame\n│ Row │ Species       │ id    │ PetalLength │ PetalWidth │ SepalLength │ SepalWidth │\n│     │ Categorical…⍰ │ Int64 │ Float64⍰    │ Float64⍰   │ Float64⍰    │ Float64⍰   │\n├─────┼───────────────┼───────┼─────────────┼────────────┼─────────────┼────────────┤\n│ 1   │ setosa        │ 1     │ 1.4         │ 0.2        │ 5.1         │ 3.5        │\n│ 2   │ setosa        │ 2     │ 1.4         │ 0.2        │ 4.9         │ 3.0        │\n│ 3   │ setosa        │ 3     │ 1.3         │ 0.2        │ 4.7         │ 3.2        │\n│ 4   │ setosa        │ 4     │ 1.5         │ 0.2        │ 4.6         │ 3.1        │\n│ 5   │ setosa        │ 5     │ 1.4         │ 0.2        │ 5.0         │ 3.6        │\n│ 6   │ setosa        │ 6     │ 1.7         │ 0.4        │ 5.4         │ 3.9        │You can even skip passing the :variable and :value values as positional arguments, as they will be used by default, and write:julia> widedf = unstack(longdf);\n\njulia> first(widedf, 6)\n6×6 DataFrame\n│ Row │ Species       │ id    │ PetalLength │ PetalWidth │ SepalLength │ SepalWidth │\n│     │ Categorical…⍰ │ Int64 │ Float64⍰    │ Float64⍰   │ Float64⍰    │ Float64⍰   │\n├─────┼───────────────┼───────┼─────────────┼────────────┼─────────────┼────────────┤\n│ 1   │ setosa        │ 1     │ 1.4         │ 0.2        │ 5.1         │ 3.5        │\n│ 2   │ setosa        │ 2     │ 1.4         │ 0.2        │ 4.9         │ 3.0        │\n│ 3   │ setosa        │ 3     │ 1.3         │ 0.2        │ 4.7         │ 3.2        │\n│ 4   │ setosa        │ 4     │ 1.5         │ 0.2        │ 4.6         │ 3.1        │\n│ 5   │ setosa        │ 5     │ 1.4         │ 0.2        │ 5.0         │ 3.6        │\n│ 6   │ setosa        │ 6     │ 1.7         │ 0.4        │ 5.4         │ 3.9        │stackdf and meltdf are two additional functions that work like stack and melt, but they provide a view into the original wide DataFrame. Here is an example:julia> d = stackdf(iris);\n\njulia> first(d, 6)\n6×4 DataFrame\n│ Row │ variable    │ value    │ Species       │ id    │\n│     │ Symbol      │ Float64⍰ │ Categorical…⍰ │ Int64 │\n├─────┼─────────────┼──────────┼───────────────┼───────┤\n│ 1   │ SepalLength │ 5.1      │ setosa        │ 1     │\n│ 2   │ SepalLength │ 4.9      │ setosa        │ 2     │\n│ 3   │ SepalLength │ 4.7      │ setosa        │ 3     │\n│ 4   │ SepalLength │ 4.6      │ setosa        │ 4     │\n│ 5   │ SepalLength │ 5.0      │ setosa        │ 5     │\n│ 6   │ SepalLength │ 5.4      │ setosa        │ 6     │\n\njulia> last(d, 6)\n6×4 DataFrame\n│ Row │ variable   │ value    │ Species       │ id    │\n│     │ Symbol     │ Float64⍰ │ Categorical…⍰ │ Int64 │\n├─────┼────────────┼──────────┼───────────────┼───────┤\n│ 1   │ PetalWidth │ 2.5      │ virginica     │ 145   │\n│ 2   │ PetalWidth │ 2.3      │ virginica     │ 146   │\n│ 3   │ PetalWidth │ 1.9      │ virginica     │ 147   │\n│ 4   │ PetalWidth │ 2.0      │ virginica     │ 148   │\n│ 5   │ PetalWidth │ 2.3      │ virginica     │ 149   │\n│ 6   │ PetalWidth │ 1.8      │ virginica     │ 150   │This saves memory. To create the view, several AbstractVectors are defined::variable column – EachRepeatedVector   This repeats the variables N times where N is the number of rows of the original AbstractDataFrame.:value column – StackedVector   This is provides a view of the original columns stacked together.Id columns – RepeatedVector   This repeats the original columns N times where N is the number of columns stacked.None of these reshaping functions perform any aggregation. To do aggregation, use the split-apply-combine functions in combination with reshaping. Here is an example:julia> d = melt(iris, :Species);\n\njulia> first(d, 6)\n6×3 DataFrame\n│ Row │ variable    │ value    │ Species       │\n│     │ Symbol      │ Float64⍰ │ Categorical…⍰ │\n├─────┼─────────────┼──────────┼───────────────┤\n│ 1   │ SepalLength │ 5.1      │ setosa        │\n│ 2   │ SepalLength │ 4.9      │ setosa        │\n│ 3   │ SepalLength │ 4.7      │ setosa        │\n│ 4   │ SepalLength │ 4.6      │ setosa        │\n│ 5   │ SepalLength │ 5.0      │ setosa        │\n│ 6   │ SepalLength │ 5.4      │ setosa        │\n\njulia> x = by(d, [:variable, :Species], df -> DataFrame(vsum = mean(df[:value])));\n\njulia> first(x, 6)\n\n6×3 DataFrame\n│ Row │ variable    │ Species       │ vsum    │\n│     │ Symbol      │ Categorical…⍰ │ Float64 │\n├─────┼─────────────┼───────────────┼─────────┤\n│ 1   │ SepalLength │ setosa        │ 5.006   │\n│ 2   │ SepalLength │ versicolor    │ 5.936   │\n│ 3   │ SepalLength │ virginica     │ 6.588   │\n│ 4   │ SepalWidth  │ setosa        │ 3.428   │\n│ 5   │ SepalWidth  │ versicolor    │ 2.77    │\n│ 6   │ SepalWidth  │ virginica     │ 2.974   │\n\njulia> first(unstack(x, :Species, :vsum), 6)\n5×4 DataFrame\n│ Row │ variable    │ setosa   │ versicolor │ virginica │\n│     │ Symbol      │ Float64⍰ │ Float64⍰   │ Float64⍰  │\n├─────┼─────────────┼──────────┼────────────┼───────────┤\n│ 1   │ PetalLength │ 1.462    │ 4.26       │ 5.552     │\n│ 2   │ PetalWidth  │ 0.246    │ 1.326      │ 2.026     │\n│ 3   │ SepalLength │ 5.006    │ 5.936      │ 6.588     │\n│ 4   │ SepalWidth  │ 3.428    │ 2.77       │ 2.974     │\n│ 5   │ id          │ 25.5     │ 75.5       │ 125.5     │"
},

{
    "location": "man/sorting.html#",
    "page": "Sorting",
    "title": "Sorting",
    "category": "page",
    "text": ""
},

{
    "location": "man/sorting.html#Sorting-1",
    "page": "Sorting",
    "title": "Sorting",
    "category": "section",
    "text": "Sorting is a fundamental component of data analysis. Basic sorting is trivial: just calling sort! will sort all columns, in place:julia> using DataFrames, CSV\n\njulia> iris = CSV.read(joinpath(dirname(pathof(DataFrames)), \"../docs/src/assets/iris.csv\"));\n\njulia> first(iris, 4)\n4×5 DataFrame\n│ Row │ SepalLength │ SepalWidth │ PetalLength │ PetalWidth │ Species     │\n│     │ Float64⍰    │ Float64⍰   │ Float64⍰    │ Float64⍰   │ String⍰     │\n├─────┼─────────────┼────────────┼─────────────┼────────────┼─────────────┤\n│ 1   │ 5.1         │ 3.5        │ 1.4         │ 0.2        │ Iris-setosa │\n│ 2   │ 4.9         │ 3.0        │ 1.4         │ 0.2        │ Iris-setosa │\n│ 3   │ 4.7         │ 3.2        │ 1.3         │ 0.2        │ Iris-setosa │\n│ 4   │ 4.6         │ 3.1        │ 1.5         │ 0.2        │ Iris-setosa │\n\njulia> last(iris, 4)\n4×5 DataFrame\n│ Row │ SepalLength │ SepalWidth │ PetalLength │ PetalWidth │ Species        │\n│     │ Float64⍰    │ Float64⍰   │ Float64⍰    │ Float64⍰   │ String⍰        │\n├─────┼─────────────┼────────────┼─────────────┼────────────┼────────────────┤\n│ 1   │ 6.3         │ 2.5        │ 5.0         │ 1.9        │ Iris-virginica │\n│ 2   │ 6.5         │ 3.0        │ 5.2         │ 2.0        │ Iris-virginica │\n│ 3   │ 6.2         │ 3.4        │ 5.4         │ 2.3        │ Iris-virginica │\n│ 4   │ 5.9         │ 3.0        │ 5.1         │ 1.8        │ Iris-virginica │\n\njulia> sort!(iris);\n\njulia> first(iris, 4)\n4×5 DataFrame\n│ Row │ SepalLength │ SepalWidth │ PetalLength │ PetalWidth │ Species     │\n│     │ Float64⍰    │ Float64⍰   │ Float64⍰    │ Float64⍰   │ String⍰     │\n├─────┼─────────────┼────────────┼─────────────┼────────────┼─────────────┤\n│ 1   │ 4.3         │ 3.0        │ 1.1         │ 0.1        │ Iris-setosa │\n│ 2   │ 4.4         │ 2.9        │ 1.4         │ 0.2        │ Iris-setosa │\n│ 3   │ 4.4         │ 3.0        │ 1.3         │ 0.2        │ Iris-setosa │\n│ 4   │ 4.4         │ 3.2        │ 1.3         │ 0.2        │ Iris-setosa │\n\njulia> last(iris, 4)\n4×5 DataFrame\n│ Row │ SepalLength │ SepalWidth │ PetalLength │ PetalWidth │ Species        │\n│     │ Float64⍰    │ Float64⍰   │ Float64⍰    │ Float64⍰   │ String⍰        │\n├─────┼─────────────┼────────────┼─────────────┼────────────┼────────────────┤\n│ 1   │ 7.7         │ 2.8        │ 6.7         │ 2.0        │ Iris-virginica │\n│ 2   │ 7.7         │ 3.0        │ 6.1         │ 2.3        │ Iris-virginica │\n│ 3   │ 7.7         │ 3.8        │ 6.7         │ 2.2        │ Iris-virginica │\n│ 4   │ 7.9         │ 3.8        │ 6.4         │ 2.0        │ Iris-virginica │Observe that all columns are taken into account lexicographically when sorting the DataFrame.You can also call the sort function to create a new DataFrame with freshly allocated sorted vectors.In sorting DataFrames, you may want to sort different columns with different options. Here are some examples showing most of the possible options:julia> sort!(iris, rev = true);\n\njulia> first(iris, 4)\n4×5 DataFrame\n│ Row │ SepalLength │ SepalWidth │ PetalLength │ PetalWidth │ Species        │\n│     │ Float64⍰    │ Float64⍰   │ Float64⍰    │ Float64⍰   │ String⍰        │\n├─────┼─────────────┼────────────┼─────────────┼────────────┼────────────────┤\n│ 1   │ 7.9         │ 3.8        │ 6.4         │ 2.0        │ Iris-virginica │\n│ 2   │ 7.7         │ 3.8        │ 6.7         │ 2.2        │ Iris-virginica │\n│ 3   │ 7.7         │ 3.0        │ 6.1         │ 2.3        │ Iris-virginica │\n│ 4   │ 7.7         │ 2.8        │ 6.7         │ 2.0        │ Iris-virginica │\n\njulia> last(iris, 4)\n4×5 DataFrame\n│ Row │ SepalLength │ SepalWidth │ PetalLength │ PetalWidth │ Species     │\n│     │ Float64⍰    │ Float64⍰   │ Float64⍰    │ Float64⍰   │ String⍰     │\n├─────┼─────────────┼────────────┼─────────────┼────────────┼─────────────┤\n│ 1   │ 4.4         │ 3.2        │ 1.3         │ 0.2        │ Iris-setosa │\n│ 2   │ 4.4         │ 3.0        │ 1.3         │ 0.2        │ Iris-setosa │\n│ 3   │ 4.4         │ 2.9        │ 1.4         │ 0.2        │ Iris-setosa │\n│ 4   │ 4.3         │ 3.0        │ 1.1         │ 0.1        │ Iris-setosa │\n\njulia> sort!(iris, [:Species, :SepalWidth]);\n\njulia> first(iris, 4)\n4×5 DataFrame\n│ Row │ SepalLength │ SepalWidth │ PetalLength │ PetalWidth │ Species     │\n│     │ Float64⍰    │ Float64⍰   │ Float64⍰    │ Float64⍰   │ String⍰     │\n├─────┼─────────────┼────────────┼─────────────┼────────────┼─────────────┤\n│ 1   │ 4.5         │ 2.3        │ 1.3         │ 0.3        │ Iris-setosa │\n│ 2   │ 4.4         │ 2.9        │ 1.4         │ 0.2        │ Iris-setosa │\n│ 3   │ 5.0         │ 3.0        │ 1.6         │ 0.2        │ Iris-setosa │\n│ 4   │ 4.9         │ 3.0        │ 1.4         │ 0.2        │ Iris-setosa │\n\njulia> last(iris, 4)\n4×5 DataFrame\n│ Row │ SepalLength │ SepalWidth │ PetalLength │ PetalWidth │ Species        │\n│     │ Float64⍰    │ Float64⍰   │ Float64⍰    │ Float64⍰   │ String⍰        │\n├─────┼─────────────┼────────────┼─────────────┼────────────┼────────────────┤\n│ 1   │ 6.2         │ 3.4        │ 5.4         │ 2.3        │ Iris-virginica │\n│ 2   │ 7.2         │ 3.6        │ 6.1         │ 2.5        │ Iris-virginica │\n│ 3   │ 7.9         │ 3.8        │ 6.4         │ 2.0        │ Iris-virginica │\n│ 4   │ 7.7         │ 3.8        │ 6.7         │ 2.2        │ Iris-virginica │\n\njulia> sort!(iris, (order(:Species, by=length), order(:SepalLength, rev=true)));\n\njulia> first(iris, 4)\n4×5 DataFrame\n│ Row │ SepalLength │ SepalWidth │ PetalLength │ PetalWidth │ Species     │\n│     │ Float64⍰    │ Float64⍰   │ Float64⍰    │ Float64⍰   │ String⍰     │\n├─────┼─────────────┼────────────┼─────────────┼────────────┼─────────────┤\n│ 1   │ 5.8         │ 4.0        │ 1.2         │ 0.2        │ Iris-setosa │\n│ 2   │ 5.7         │ 3.8        │ 1.7         │ 0.3        │ Iris-setosa │\n│ 3   │ 5.7         │ 4.4        │ 1.5         │ 0.4        │ Iris-setosa │\n│ 4   │ 5.5         │ 3.5        │ 1.3         │ 0.2        │ Iris-setosa │\n\njulia> last(iris, 4)\n4×5 DataFrame\n│ Row │ SepalLength │ SepalWidth │ PetalLength │ PetalWidth │ Species         │\n│     │ Float64⍰    │ Float64⍰   │ Float64⍰    │ Float64⍰   │ String⍰         │\n├─────┼─────────────┼────────────┼─────────────┼────────────┼─────────────────┤\n│ 1   │ 5.1         │ 2.5        │ 3.0         │ 1.1        │ Iris-versicolor │\n│ 2   │ 5.0         │ 2.0        │ 3.5         │ 1.0        │ Iris-versicolor │\n│ 3   │ 5.0         │ 2.3        │ 3.3         │ 1.0        │ Iris-versicolor │\n│ 4   │ 4.9         │ 2.4        │ 3.3         │ 1.0        │ Iris-versicolor │Keywords used above include rev (to sort in reverse), and by (to apply a function to values before comparing them). Each keyword can either be a single value, or can be a tuple or a vector, with values corresponding to individual columns.As an alternative to using a vector or tuple values you can use order to specify an ordering for a particular column within a set of columns.The following two examples show two ways to sort the iris dataset with the same result: :Species will be ordered in reverse order, and within groups, rows will be sorted by increasing :PetalLength:julia> sort!(iris, (:Species, :PetalLength), rev=(true, false));\n\njulia> julia> sort!(iris, (:Species, :PetalLength), rev=(true, false));\n\njulia> first(iris, 4)\n4×5 DataFrame\n│ Row │ SepalLength │ SepalWidth │ PetalLength │ PetalWidth │ Species        │\n│     │ Float64⍰    │ Float64⍰   │ Float64⍰    │ Float64⍰   │ String⍰        │\n├─────┼─────────────┼────────────┼─────────────┼────────────┼────────────────┤\n│ 1   │ 4.9         │ 2.5        │ 4.5         │ 1.7        │ Iris-virginica │\n│ 2   │ 6.2         │ 2.8        │ 4.8         │ 1.8        │ Iris-virginica │\n│ 3   │ 6.0         │ 3.0        │ 4.8         │ 1.8        │ Iris-virginica │\n│ 4   │ 6.3         │ 2.7        │ 4.9         │ 1.8        │ Iris-virginica │\n\njulia> last(iris, 4)\n4×5 DataFrame\n│ Row │ SepalLength │ SepalWidth │ PetalLength │ PetalWidth │ Species     │\n│     │ Float64⍰    │ Float64⍰   │ Float64⍰    │ Float64⍰   │ String⍰     │\n├─────┼─────────────┼────────────┼─────────────┼────────────┼─────────────┤\n│ 1   │ 5.4         │ 3.9        │ 1.7         │ 0.4        │ Iris-setosa │\n│ 2   │ 5.1         │ 3.3        │ 1.7         │ 0.5        │ Iris-setosa │\n│ 3   │ 5.1         │ 3.8        │ 1.9         │ 0.4        │ Iris-setosa │\n│ 4   │ 4.8         │ 3.4        │ 1.9         │ 0.2        │ Iris-setosa │\n\njulia> sort!(iris, (order(:Species, rev=true), :PetalLength));\n\njulia> first(iris, 4)\n4×5 DataFrame\n│ Row │ SepalLength │ SepalWidth │ PetalLength │ PetalWidth │ Species        │\n│     │ Float64⍰    │ Float64⍰   │ Float64⍰    │ Float64⍰   │ String⍰        │\n├─────┼─────────────┼────────────┼─────────────┼────────────┼────────────────┤\n│ 1   │ 4.9         │ 2.5        │ 4.5         │ 1.7        │ Iris-virginica │\n│ 2   │ 6.2         │ 2.8        │ 4.8         │ 1.8        │ Iris-virginica │\n│ 3   │ 6.0         │ 3.0        │ 4.8         │ 1.8        │ Iris-virginica │\n│ 4   │ 6.3         │ 2.7        │ 4.9         │ 1.8        │ Iris-virginica │\n\njulia> last(iris, 4)\n4×5 DataFrame\n│ Row │ SepalLength │ SepalWidth │ PetalLength │ PetalWidth │ Species     │\n│     │ Float64⍰    │ Float64⍰   │ Float64⍰    │ Float64⍰   │ String⍰     │\n├─────┼─────────────┼────────────┼─────────────┼────────────┼─────────────┤\n│ 1   │ 5.4         │ 3.9        │ 1.7         │ 0.4        │ Iris-setosa │\n│ 2   │ 5.1         │ 3.3        │ 1.7         │ 0.5        │ Iris-setosa │\n│ 3   │ 5.1         │ 3.8        │ 1.9         │ 0.4        │ Iris-setosa │\n│ 4   │ 4.8         │ 3.4        │ 1.9         │ 0.2        │ Iris-setosa │"
},

{
    "location": "man/categorical.html#",
    "page": "Categorical Data",
    "title": "Categorical Data",
    "category": "page",
    "text": ""
},

{
    "location": "man/categorical.html#Categorical-Data-1",
    "page": "Categorical Data",
    "title": "Categorical Data",
    "category": "section",
    "text": "Often, we have to deal with factors that take on a small number of levels:julia> v = [\"Group A\", \"Group A\", \"Group A\", \"Group B\", \"Group B\", \"Group B\"]\n6-element Array{String,1}:\n \"Group A\"\n \"Group A\"\n \"Group A\"\n \"Group B\"\n \"Group B\"\n \"Group B\"\nThe naive encoding used in an Array represents every entry of this vector as a full string. In contrast, we can represent the data more efficiently by replacing the strings with indices into a small pool of levels. This is what the CategoricalArray type does:julia> using CategoricalArrays\n\njulia> cv = CategoricalArray(v)\n6-element CategoricalArray{String,1,UInt32}:\n \"Group A\"\n \"Group A\"\n \"Group A\"\n \"Group B\"\n \"Group B\"\n \"Group B\"\nCategoricalArrays support missing values.julia> cv = CategoricalArray([\"Group A\", missing, \"Group A\",\n                              \"Group B\", \"Group B\", missing])\n6-element CategoricalArray{Union{Missing, String},1,UInt32}:\n \"Group A\"\n missing\n \"Group A\"\n \"Group B\"\n \"Group B\"\n missingIn addition to representing repeated data efficiently, the CategoricalArray type allows us to determine efficiently the allowed levels of the variable at any time using the levels function (note that levels may or may not be actually used in the data):julia> levels(cv)\n2-element Array{String,1}:\n \"Group A\"\n \"Group B\"\nThe levels! function also allows changing the order of appearance of the levels, which can be useful for display purposes or when working with ordered variables.julia> levels!(cv, [\"Group B\", \"Group A\"]);\n\njulia> levels(cv)\n2-element Array{String,1}:\n \"Group B\"\n \"Group A\"\n\njulia> sort(cv)\n6-element CategoricalArray{Union{Missing, String},1,UInt32}:\n \"Group B\"\n \"Group B\"\n \"Group A\"\n \"Group A\"\n missing\n missing\nBy default, a CategoricalArray is able to represent 2<sup>32</sup> different levels. You can use less memory by calling the compress function:julia> cv = compress(cv)\n6-element CategoricalArray{Union{Missing, String},1,UInt8}:\n \"Group A\"\n missing\n \"Group A\"\n \"Group B\"\n \"Group B\"\n missing\nInstead of using the CategoricalArray constructor directly you can use categorical function. It additionally accepts one positional argument compress which when set to true is equivalent to calling compress on the new vector:julia> cv1 = categorical([\"A\", \"B\"], true)\n2-element CategoricalArray{String,1,UInt8}:\n \"A\"\n \"B\"If the ordered keyword argument is set to true, the resulting CategoricalArray will be ordered, which means that its levels can be tested for order (rather than throwing an error):julia> cv2 = categorical([\"A\", \"B\"], true, ordered=true)\n2-element CategoricalArray{String,1,UInt8}:\n \"A\"\n \"B\"\n\njulia> cv1[1] < cv1[2]\nERROR: ArgumentError: Unordered CategoricalValue objects cannot be tested for order using <. Use isless instead, or call the ordered! function on the parent array to change this\n\njulia> cv2[1] < cv2[2]\ntrueYou can check if a CategoricalArray is ordered using the isordered function and change between ordered and unordered using ordered! function.julia> isordered(cv1)\nfalse\n\njulia> ordered!(cv1, true)\n2-element CategoricalArray{String,1,UInt8}:\n \"A\"\n \"B\"\n\njulia> isordered(cv1)\ntrue\n\njulia> cv1[1] < cv1[2]\ntrueOften, you will have factors encoded inside a DataFrame with Vector columns instead of CategoricalVector columns. You can convert one or more columns of the DataFrame using the categorical! function, which modifies the input DataFrame in-place. Compression can be applied by setting the compress keyword argument to true.julia> using DataFrames\n\njulia> df = DataFrame(A = [\"A\", \"B\", \"C\", \"D\", \"D\", \"A\"],\n                      B = [\"X\", \"X\", \"X\", \"Y\", \"Y\", \"Y\"])\n6×2 DataFrame\n│ Row │ A      │ B      │\n│     │ String │ String │\n├─────┼────────┼────────┤\n│ 1   │ A      │ X      │\n│ 2   │ B      │ X      │\n│ 3   │ C      │ X      │\n│ 4   │ D      │ Y      │\n│ 5   │ D      │ Y      │\n│ 6   │ A      │ Y      │\n\njulia> eltypes(df)\n2-element Array{DataType,1}:\n String\n String\n\njulia> categorical!(df, :A) # change the column `:A` to be categorical\n6×2 DataFrame\n│ Row │ A            │ B      │\n│     │ Categorical… │ String │\n├─────┼──────────────┼────────┤\n│ 1   │ A            │ X      │\n│ 2   │ B            │ X      │\n│ 3   │ C            │ X      │\n│ 4   │ D            │ Y      │\n│ 5   │ D            │ Y      │\n│ 6   │ A            │ Y      │\n\njulia> eltypes(df)\n2-element Array{DataType,1}:\n CategoricalString{UInt32}\n StringIf columns are not specified, all columns with an AbstractString element type are converted to be categorical. In the example below we also enable compression:julia> categorical!(df, compress=true)\n6×2 DataFrame\n│ Row │ A            │ B            │\n│     │ Categorical… │ Categorical… │\n├─────┼──────────────┼──────────────┤\n│ 1   │ A            │ X            │\n│ 2   │ B            │ X            │\n│ 3   │ C            │ X            │\n│ 4   │ D            │ Y            │\n│ 5   │ D            │ Y            │\n│ 6   │ A            │ Y            │\n\njulia> eltypes(df)\n2-element Array{DataType,1}:\n CategoricalString{UInt8}\n CategoricalString{UInt8}\nUsing categorical arrays is important for working with the GLM package. When fitting regression models, CategoricalVector columns in the input are translated into 0/1 indicator columns in the ModelMatrix with one column for each of the levels of the CategoricalVector. This allows one to analyze categorical data efficiently.See the CategoricalArrays package for more information regarding categorical arrays."
},

{
    "location": "man/missing.html#",
    "page": "Missing Data",
    "title": "Missing Data",
    "category": "page",
    "text": ""
},

{
    "location": "man/missing.html#Missing-Data-1",
    "page": "Missing Data",
    "title": "Missing Data",
    "category": "section",
    "text": "In Julia, missing values in data are represented using the special object missing, which is the single instance of the type Missing.julia> missing\r\nmissing\r\n\r\njulia> typeof(missing)\r\nMissing\r\nThe Missing type lets users create Vectors and DataFrame columns with missing values. Here we create a vector with a missing value and the element-type of the returned vector is Union{Missing, Int64}.julia> x = [1, 2, missing]\r\n3-element Array{Union{Missing, Int64},1}:\r\n 1\r\n 2\r\n  missing\r\n\r\njulia> eltype(x)\r\nUnion{Missing, Int64}\r\n\r\njulia> Union{Missing, Int}\r\nUnion{Missing, Int64}\r\n\r\njulia> eltype(x) == Union{Missing, Int}\r\ntrue\r\nmissing values can be excluded when performing operations by using skipmissing, which returns a memory-efficient iterator.julia> skipmissing(x)\r\nBase.SkipMissing{Array{Union{Missing, Int64},1}}(Union{Missing, Int64}[1, 2, missing])\r\nThe output of skipmissing can be passed directly into functions as an argument. For example, we can find the sum of all non-missing values or collect the non-missing values into a new missing-free vector.julia> sum(skipmissing(x))\r\n3\r\n\r\njulia> collect(skipmissing(x))\r\n2-element Array{Int64,1}:\r\n 1\r\n 2\r\nThe function coalesce can be used to replace missing values with another value (note the dot, indicating that the replacement should be applied to all entries in x):julia> coalesce.(x, 0)\r\n3-element Array{Int64,1}:\r\n 1\r\n 2\r\n 0\r\nThe functions dropmissing and dropmissing! can be used to remove the rows containing missing values from a DataFrame and either create a new DataFrame or mutate the original in-place respectively.julia> df = DataFrame(i = 1:5,\r\n                      x = [missing, 4, missing, 2, 1],\r\n                      y = [missing, missing, \"c\", \"d\", \"e\"])\r\n\r\njulia> dropmissing(df)\r\n2×3 DataFrame\r\n│ Row │ i     │ x      │ y       │\r\n│     │ Int64 │ Int64⍰ │ String⍰ │\r\n├─────┼───────┼────────┼─────────┤\r\n│ 1   │ 4     │ 2      │ d       │\r\n│ 2   │ 5     │ 1      │ e       │One can specify the column(s) in which to search for rows containing missing values to be removed.julia> dropmissing(df, :x)\r\n3×3 DataFrame\r\n│ Row │ i     │ x      │ y       │\r\n│     │ Int64 │ Int64⍰ │ String⍰ │\r\n├─────┼───────┼────────┼─────────┤\r\n│ 1   │ 2     │ 4      │ missing │\r\n│ 2   │ 4     │ 2      │ d       │\r\n│ 3   │ 5     │ 1      │ e       │By default the dropmissing and dropmissing! functions keep the Union{T,Missing} element type in columns selected for row removal. To remove the Missing part, if present, set the disallowmissing option to true (it will become the default behavior in the future).julia> dropmissing(df, disallowmissing=true)\r\n2×3 DataFrame\r\n│ Row │ i     │ x     │ y      │\r\n│     │ Int64 │ Int64 │ String │\r\n├─────┼───────┼───────┼────────┤\r\n│ 1   │ 4     │ 2     │ d      │\r\n│ 2   │ 5     │ 1     │ e      │The Missings.jl package provides a few convenience functions to work with missing values.The function Missings.replace returns an iterator which replaces missing elements with another value:julia> using Missings\r\n\r\njulia> Missings.replace(x, 1)\r\nMissings.EachReplaceMissing{Array{Union{Missing, Int64},1},Int64}(Union{Missing, Int64}[1, 2, missing], 1)\r\n\r\njulia> collect(Missings.replace(x, 1))\r\n3-element Array{Int64,1}:\r\n 1\r\n 2\r\n 1\r\n\r\njulia> collect(Missings.replace(x, 1)) == coalesce.(x, 1)\r\ntrue\r\nThe function Missings.T returns the element-type T in Union{T, Missing}.julia> eltype(x)\r\nUnion{Int64, Missing}\r\n\r\njulia> Missings.T(eltype(x))\r\nInt64\r\nThe missings function constructs Vectors and Arrays supporting missing values, using the optional first argument to specify the element-type.julia> missings(1)\r\n1-element Array{Missing,1}:\r\n missing\r\n\r\njulia> missings(3)\r\n3-element Array{Missing,1}:\r\n missing\r\n missing\r\n missing\r\n\r\njulia> missings(1, 3)\r\n1×3 Array{Missing,2}:\r\n missing  missing  missing\r\n\r\njulia> missings(Int, 1, 3)\r\n1×3 Array{Union{Missing, Int64},2}:\r\n missing  missing  missing\r\nSee the Julia manual for more information about missing values."
},

{
    "location": "man/querying_frameworks.html#",
    "page": "Data manipulation frameworks",
    "title": "Data manipulation frameworks",
    "category": "page",
    "text": ""
},

{
    "location": "man/querying_frameworks.html#Data-manipulation-frameworks-1",
    "page": "Data manipulation frameworks",
    "title": "Data manipulation frameworks",
    "category": "section",
    "text": "Two popular frameworks provide convenience methods to manipulate DataFrames: DataFramesMeta.jl and Query.jl. They implement a functionality similar to dplyr or LINQ."
},

{
    "location": "man/querying_frameworks.html#DataFramesMeta.jl-1",
    "page": "Data manipulation frameworks",
    "title": "DataFramesMeta.jl",
    "category": "section",
    "text": "The DataFramesMeta.jl package provides a convenient yet fast macro-based interface to work with DataFrames.First install the DataFramesMeta.jl package:using Pkg\nPkg.add(\"DataFramesMeta\")The major benefit of the package is that it allows you to refer to columns of a DataFrame as Symbols. Therefore instead of writing verylongdataframename.variable you can simply write :variable in expressions. Additionally you can chain a sequence of transformations of a DataFrame using the @linq macro.Here is a minimal example of usage of the package. Observe that we refer to names of columns using only their names and that chaining is performed using the @linq macro and the |> operator:julia> using DataFrames, DataFramesMeta\n\njulia> df = DataFrame(name=[\"John\", \"Sally\", \"Roger\"],\n                      age=[54., 34., 79.],\n                      children=[0, 2, 4])\n3×3 DataFrame\n│ Row │ name   │ age     │ children │\n│     │ String │ Float64 │ Int64    │\n├─────┼────────┼─────────┼──────────┤\n│ 1   │ John   │ 54.0    │ 0        │\n│ 2   │ Sally  │ 34.0    │ 2        │\n│ 3   │ Roger  │ 79.0    │ 4        │\n\njulia> @linq df |>\n           where(:age .> 40) |>\n           select(number_of_children=:children, :name)\n2×2 DataFrame\n│ Row │ number_of_children │ name   │\n│     │ Int64              │ String │\n├─────┼────────────────────┼────────┤\n│ 1   │ 0                  │ John   │\n│ 2   │ 4                  │ Roger  │In the following examples we show that DataFramesMeta.jl also supports the split-apply-combine pattern:julia> df = DataFrame(key=repeat(1:3, 4), value=1:12)\n12×2 DataFrame\n│ Row │ key   │ value │\n│     │ Int64 │ Int64 │\n├─────┼───────┼───────┤\n│ 1   │ 1     │ 1     │\n│ 2   │ 2     │ 2     │\n│ 3   │ 3     │ 3     │\n│ 4   │ 1     │ 4     │\n│ 5   │ 2     │ 5     │\n│ 6   │ 3     │ 6     │\n│ 7   │ 1     │ 7     │\n│ 8   │ 2     │ 8     │\n│ 9   │ 3     │ 9     │\n│ 10  │ 1     │ 10    │\n│ 11  │ 2     │ 11    │\n│ 12  │ 3     │ 12    │\n\njulia> @linq df |>\n           where(:value .> 3) |>\n           by(:key, min=minimum(:value), max=maximum(:value)) |>\n           select(:key, range=:max - :min)\n3×2 DataFrame\n│ Row │ key   │ range │\n│     │ Int64 │ Int64 │\n├─────┼───────┼───────┤\n│ 1   │ 1     │ 6     │\n│ 2   │ 2     │ 6     │\n│ 3   │ 3     │ 6     │\n\njulia> @linq df |>\n           groupby(:key) |>\n           transform(value0 = :value .- minimum(:value))\n12×3 DataFrame\n│ Row │ key   │ value │ value0 │\n│     │ Int64 │ Int64 │ Int64  │\n├─────┼───────┼───────┼────────┤\n│ 1   │ 1     │ 1     │ 0      │\n│ 2   │ 1     │ 4     │ 3      │\n│ 3   │ 1     │ 7     │ 6      │\n│ 4   │ 1     │ 10    │ 9      │\n│ 5   │ 2     │ 2     │ 0      │\n│ 6   │ 2     │ 5     │ 3      │\n│ 7   │ 2     │ 8     │ 6      │\n│ 8   │ 2     │ 11    │ 9      │\n│ 9   │ 3     │ 3     │ 0      │\n│ 10  │ 3     │ 6     │ 3      │\n│ 11  │ 3     │ 9     │ 6      │\n│ 12  │ 3     │ 12    │ 9      │You can find more details about how this package can be used on the DataFramesMeta.jl GitHub page."
},

{
    "location": "man/querying_frameworks.html#Query.jl-1",
    "page": "Data manipulation frameworks",
    "title": "Query.jl",
    "category": "section",
    "text": "The Query.jl package provides advanced data manipulation capabilities for DataFrames (and many other data structures). This section provides a short introduction to the package, the Query.jl documentation has a more comprehensive documentation of the package.To get started, install the Query.jl package:using Pkg\nPkg.add(\"Query\")A query is started with the @from macro and consists of a series of query commands. Query.jl provides commands that can filter, project, join, flatten and group data from a DataFrame. A query can return an iterator, or one can materialize the results of a query into a variety of data structures, including a new DataFrame.A simple example of a query looks like this:julia> using DataFrames, Query\n\njulia> df = DataFrame(name=[\"John\", \"Sally\", \"Roger\"],\n                      age=[54., 34., 79.],\n                      children=[0, 2, 4])\n3×3 DataFrame\n│ Row │ name   │ age     │ children │\n│     │ String │ Float64 │ Int64    │\n├─────┼────────┼─────────┼──────────┤\n│ 1   │ John   │ 54.0    │ 0        │\n│ 2   │ Sally  │ 34.0    │ 2        │\n│ 3   │ Roger  │ 79.0    │ 4        │\n\njulia> q1 = @from i in df begin\n            @where i.age > 40\n            @select {number_of_children=i.children, i.name}\n            @collect DataFrame\n       end\n2×2 DataFrame\n│ Row │ number_of_children │ name   │\n│     │ Int64              │ String │\n├─────┼────────────────────┼────────┤\n│ 1   │ 0                  │ John   │\n│ 2   │ 4                  │ Roger  │The query starts with the @from macro. The first argument i is the name of the range variable that will be used to refer to an individual row in later query commands. The next argument df is the data source that one wants to query. The @where command in this query will filter the source data by applying the filter condition i.age > 40. This filters out any rows in which the age column is not larger than 40. The @select command then projects the columns of the source data onto a new column structure. The example here applies three specific modifications: 1) it only keeps a subset of the columns in the source DataFrame, i.e. the age column will not be part of the transformed data; 2) it changes the order of the two columns that are selected; and 3) it renames one of the columns that is selected from children to number_of_children. The example query uses the {} syntax to achieve this. A {} in a Query.jl expression instantiates a new NamedTuple, i.e. it is a shortcut for writing @NT(number_of_children=>i.children, name=>i.name). The @collect statement determines the data structure that the query returns. In this example the results are returned as a DataFrame.A query without a @collect statement returns a standard julia iterator that can be used with any normal julia language construct that can deal with iterators. The following code returns a julia iterator for the query results:julia> q2 = @from i in df begin\n                   @where i.age > 40\n                   @select {number_of_children=i.children, i.name}\n              end; # suppress printing the iterator type\nOne can loop over the results using a standard julia for statement:julia> total_children = 0\n0\n\njulia> for i in q2\n           global total_children += i.number_of_children\n       end\n\njulia> total_children\n4\nOr one can use a comprehension to extract the name of a subset of rows:julia> y = [i.name for i in q2 if i.number_of_children > 0]\n1-element Array{String,1}:\n \"Roger\"\nThe last example (extracting only the name and applying a second filter) could of course be completely expressed as a query expression:julia> q3 = @from i in df begin\n            @where i.age > 40 && i.children > 0\n            @select i.name\n            @collect\n       end\n1-element Array{String,1}:\n \"Roger\"\nA query that ends with a @collect statement without a specific type will materialize the query results into an array. Note also the difference in the @select statement: The previous queries all used the {} syntax in the @select statement to project results into a tabular format. The last query instead just selects a single value from each row in the @select statement.These examples only scratch the surface of what one can do with Query.jl, and the interested reader is referred to the Query.jl documentation for more information."
},

{
    "location": "lib/types.html#",
    "page": "Types",
    "title": "Types",
    "category": "page",
    "text": "CurrentModule = DataFrames"
},

{
    "location": "lib/types.html#Types-1",
    "page": "Types",
    "title": "Types",
    "category": "section",
    "text": "Pages = [\"types.md\"]"
},

{
    "location": "lib/types.html#Type-hierarchy-design-1",
    "page": "Types",
    "title": "Type hierarchy design",
    "category": "section",
    "text": "AbstractDataFrame is an abstract type that provides an interface for data frame types. It is not intended as a fully generic interface for working with tabular data, which is the role of interfaces defined by Tables.jl instead.DataFrame is the most fundamental subtype of AbstractDataFrame, which stores a set of columns as AbstractVector objects.SubDataFrame is an AbstractDataFrame subtype representing a view into a DataFrame. It stores only a reference to the parent DataFrame and information about which rows and columns from the parent are selected (both as integer indices referring to the parent). Typically it is created using the view function or is returned by indexing into a GroupedDataFrame object.GroupedDataFrame is a type that stores the result of a  grouping operation performed on an AbstractDataFrame. It is intended to be created as a result of a call to the groupby function.DataFrameRow is a view into a single row of an AbstractDataFrame. It stores only a reference to a parent DataFrame and information about which row and columns from the parent are selected (both as integer indices referring to the parent) The DataFrameRow type supports iteration over columns of the row and is similar in functionality to the NamedTuple type, but allows for modification of data stored in the parent DataFrame and reflects changes done to the parent after the creation of the view. Typically objects of the DataFrameRow type are encountered when returned by the eachrow function, or when accessing a single row of a DataFrame or SubDataFrame via getindex or view.The eachrow function returns a value of the DataFrameRows type, which serves as an iterator over rows of an AbstractDataFrame, returning DataFrameRow objects.Similarly, the eachcol function returns a value of the DataFrameColumns type, which serves as an iterator over columns of an AbstractDataFrame. The return value can have two concrete types:If the eachcol function is called with the names argument set to true then it returns a value of the DataFrameColumns{<:AbstractDataFrame, Pair{Symbol, AbstractVector}} type, which is an iterator returning a pair containing the column name and the column vector.\nIf the eachcol function is called with names argument set to false (the default) then it returns a value of the DataFrameColumns{<:AbstractDataFrame, AbstractVector} type, which is an iterator returning the column vector only.The DataFrameRows and DataFrameColumns types are subtypes of AbstractVector and support its interface with the exception that they are read only. Note that they are not exported and should not be constructed directly, but using the eachrow and eachcol functions.The RepeatedVector and StackedVector types are subtypes of AbstractVector and support its interface with the exception that they are read only. Note that they are not exported and should not be constructed directly, but they are columns of a DataFrame returned by stackdf and meltdf."
},

{
    "location": "lib/types.html#man-columnhandling-1",
    "page": "Types",
    "title": "The design of handling of columns of a DataFrame",
    "category": "section",
    "text": "When a DataFrame is constructed columns are copied by default. You can disable this behavior by setting copycols keyword argument to false or by using the DataFrame! function. The exception is if an AbstractRange is passed as a column, then it is always collected to a Vector.Also functions that transform a DataFrame to produce a new DataFrame perform a copy of the columns, unless they are passed copycols=false (available only for functions that could perform a transformation without copying the columns). Examples of such functions are vcat, hcat, filter, dropmissing, join, getindex, copy or the DataFrame constructor mentioned above.On the contrary, functions that create a view of a DataFrame do not by definition make copies of the columns, and therefore require particular caution. This includes view, which returns a SubDataFrame or a DataFrameRow, and groupby, which returns a GroupedDataFrame.A partial exception to this rule are the stackdf and meltdf functions which create a DataFrame that contains views of the columns from the source DataFrame.In-place functions whose names end with ! (like sort! or dropmissing!, setindex!, push!, append!) may mutate the column vectors of the DataFrame they take as an argument. These functions are safe to call due to the rules described above, except when a view of the DataFrame is in use (via a SubDataFrame, a DataFrameRow or a GroupedDataFrame). In the latter case, calling such a function on the parent might corrupt the view, which make trigger errors, silently return invalid data or even cause Julia to crash. The same caution applies when DataFrame was created using columns of another DataFrame without copying (for instance when copycols=false in functions such as DataFrame or hcat).It is possible to have a direct access to a column col of a DataFrame df (e.g. this can be useful in performance critical code to avoid copying), using one of the following methods:via the getproperty function using the syntax df.col;\nvia the getindex function using the syntax df[:col] (note this is in contrast to df[:, :col] which copies);\nby creating a DataFrameColumns object using the eachcol function;\nby calling the parent function on a view of a column of the DataFrame, e.g. parent(@view df[:, :col]);\nby storing the reference to the column before creating a DataFrame with copycols=false;A column obtained from a DataFrame using one of the above methods should not be mutated without caution because:resizing a column vector will corrupt its parent DataFrame and any associated views as methods only check the length of the column when it is added to the DataFrame and later assume that all columns have the same length;\nreordering values in a column vector (e.g. using sort!) will break the consistency of rows with other columns, which will also affect views (if any);\nchanging values contained in a column vector is acceptable as long as it is not used as a grouping column in a GroupedDataFrame created based on the DataFrame."
},

{
    "location": "lib/types.html#DataFrames.AbstractDataFrame",
    "page": "Types",
    "title": "DataFrames.AbstractDataFrame",
    "category": "type",
    "text": "AbstractDataFrame\n\nAn abstract type for which all concrete types expose an interface for working with tabular data.\n\nCommon methods\n\nAn AbstractDataFrame is a two-dimensional table with Symbols for column names. An AbstractDataFrame is also similar to an Associative type in that it allows indexing by a key (the columns).\n\nThe following are normally implemented for AbstractDataFrames:\n\ndescribe : summarize columns\nsummary : show number of rows and columns\nhcat : horizontal concatenation\nvcat : vertical concatenation\nrepeat : repeat rows\nnames : columns names\nnames! : set columns names\nrename! : rename columns names based on keyword arguments\neltypes : eltype of each column\nlength : number of columns\nsize : (nrows, ncols)\nfirst : first n rows\nlast : last n rows\nconvert : convert to an array\ncompletecases : boolean vector of complete cases (rows with no missings)\ndropmissing : remove rows with missing values\ndropmissing! : remove rows with missing values in-place\nnonunique : indexes of duplicate rows\nunique! : remove duplicate rows\nsimilar : a DataFrame with similar columns as d\nfilter : remove rows\nfilter! : remove rows in-place\n\nIndexing\n\nTable columns are accessed (getindex) by a single index that can be a symbol identifier, an integer, or a vector of each. If a single column is selected, just the column object is returned. If multiple columns are selected, some AbstractDataFrame is returned.\n\nd[:colA]\nd[3]\nd[[:colA, :colB]]\nd[[1:3; 5]]\n\nRows and columns can be indexed like a Matrix with the added feature of indexing columns by name.\n\nd[1:3, :colA]\nd[3,3]\nd[3,:]\nd[3,[:colA, :colB]]\nd[:, [:colA, :colB]]\nd[[1:3; 5], :]\n\nsetindex works similarly.\n\n\n\n\n\n"
},

{
    "location": "lib/types.html#DataFrames.DataFrame",
    "page": "Types",
    "title": "DataFrames.DataFrame",
    "category": "type",
    "text": "DataFrame <: AbstractDataFrame\n\nAn AbstractDataFrame that stores a set of named columns\n\nThe columns are normally AbstractVectors stored in memory, particularly a Vector or CategoricalVector.\n\nConstructors\n\nDataFrame(columns::Vector, names::Vector{Symbol};\n          makeunique::Bool=false, copycols::Bool=true)\nDataFrame(columns::NTuple{N,AbstractVector}, names::NTuple{N,Symbol};\n          makeunique::Bool=false, copycols::Bool=true)\nDataFrame(columns::Matrix, names::Vector{Symbol}; makeunique::Bool=false)\nDataFrame(kwargs...)\nDataFrame(pairs::NTuple{N, Pair{Symbol, AbstractVector}}; copycols::Bool=true)\nDataFrame() # an empty DataFrame\nDataFrame(column_eltypes::Vector, names::AbstractVector{Symbol}, nrows::Integer=0;\n          makeunique::Bool=false)\nDataFrame(ds::AbstractDict; copycols::Bool=true)\nDataFrame(table; makeunique::Bool=false, copycols::Bool=true)\nDataFrame(::Union{DataFrame, SubDataFrame}; copycols::Bool=true)\nDataFrame(::GroupedDataFrame)\n\nArguments\n\ncolumns : a Vector with each column as contents or a Matrix\nnames : the column names\nmakeunique : if false (the default), an error will be raised if duplicates in names are found; if true, duplicate names will be suffixed with _i (i starting at 1 for the first duplicate).\nkwargs : the key gives the column names, and the value is the column contents; note that the copycols keyword argument indicates if if vectors passed as columns should be copied so it is not possible to create a column whose name is :copycols using this constructor\nt : elemental type of all columns\nnrows, ncols : number of rows and columns\ncolumn_eltypes : element type of each column\ncategorical : a vector of Bool indicating which columns should be converted to                 CategoricalVector\nds : AbstractDict of columns\ntable : any type that implements the Tables.jl interface; in particular a tuple or vector of Pair{Symbol, <:AbstractVector}} objects is a table.\ncopycols : whether vectors passed as columns should be copied; note that DataFrame(kwargs...) does not support this keyword argument and always copies columns.\n\nAll columns in columns should have the same length.\n\nNotes\n\nThe DataFrame constructor by default copies all columns vectors passed to it. Pass copycols=false to reuse vectors without copying them\n\nIf a column is passed to a DataFrame constructor or is assigned as a whole using setindex! then its reference is stored in the DataFrame. An exception to this rule is assignment of an AbstractRange as a column, in which case the range is collected to a Vector.\n\nBecause column types can vary, a DataFrame is not type stable. For performance-critical code, do not index into a DataFrame inside of loops.\n\nExamples\n\ndf = DataFrame()\nv = [\"x\",\"y\",\"z\"][rand(1:3, 10)]\ndf1 = DataFrame(Any[collect(1:10), v, rand(10)], [:A, :B, :C])\ndf2 = DataFrame(A = 1:10, B = v, C = rand(10))\nsummary(df1)\ndescribe(df2)\nfirst(df1, 10)\ndf1[:A] + df2[:C]\ndf1[1:4, 1:2]\ndf1[[:A,:C]]\ndf1[1:2, [:A,:C]]\ndf1[:, [:A,:C]]\ndf1[:, [1,3]]\ndf1[1:4, :]\ndf1[1:4, :C]\ndf1[1:4, :C] = 40. * df1[1:4, :C]\n[df1; df2]  # vcat\n[df1 df2]  # hcat\nsize(df1)\n\n\n\n\n\n"
},

{
    "location": "lib/types.html#DataFrames.DataFrameRow",
    "page": "Types",
    "title": "DataFrames.DataFrameRow",
    "category": "type",
    "text": "DataFrameRow{<:AbstractDataFrame,<:AbstractIndex}\n\nA view of one row of an AbstractDataFrame.\n\nA DataFrameRow is returned by getindex or view functions when one row and a selection of columns are requested, or when iterating the result of the call to the eachrow function.\n\nThe DataFrameRow constructor can also be called directly:\n\nDataFrameRow(parent::AbstractDataFrame, row::Integer, cols=:)\n\nA DataFrameRow supports the iteration interface and can therefore be passed to functions that expect a collection as an argument.\n\nIndexing is one-dimensional like specifying a column of a DataFrame. You can also access the data in a DataFrameRow using the getproperty and setproperty! functions and convert it to a NamedTuple using the copy function.\n\nIt is possible to create a DataFrameRow with duplicate columns. All such columns will have a reference to the same entry in the parent DataFrame.\n\nIf the selection of columns in a parent data frame is passed as : (a colon) then DataFrameRow will always have all columns from the parent, even if they are added or removed after its creation.\n\nExamples\n\ndf = DataFrame(a = repeat([1, 2, 3, 4], outer=[2]),\n               b = repeat([2, 1], outer=[4]),\n               c = randn(8))\nsdf1 = view(df, 2, :)\nsdf2 = @view df[end, [:a]]\nsdf3 = eachrow(df)[1]\nsdf4 = DataFrameRow(df, 2, 1:2)\nsdf5 = DataFrameRow(df, 1)\n\n\n\n\n\n"
},

{
    "location": "lib/types.html#DataFrames.GroupedDataFrame",
    "page": "Types",
    "title": "DataFrames.GroupedDataFrame",
    "category": "type",
    "text": "GroupedDataFrame\n\nThe result of a groupby operation on an AbstractDataFrame; a view into the AbstractDataFrame grouped by rows.\n\nNot meant to be constructed directly, see groupby.\n\n\n\n\n\n"
},

{
    "location": "lib/types.html#DataFrames.SubDataFrame",
    "page": "Types",
    "title": "DataFrames.SubDataFrame",
    "category": "type",
    "text": "SubDataFrame{<:AbstractDataFrame,<:AbstractIndex,<:AbstractVector{Int}} <: AbstractDataFrame\n\nA view of an AbstractDataFrame. It is returned by a call to the view function on an AbstractDataFrame if a collections of rows and columns are specified.\n\nA SubDataFrame is an AbstractDataFrame, so expect that most DataFrame functions should work. Such methods include describe, summary, nrow, size, by, stack, and join.\n\nIndexing is just like a DataFrame except that it is possible to create a SubDataFrame with duplicate columns. All such columns will have a reference to the same entry in the parent DataFrame.\n\nIf the selection of columns in a parent data frame is passed as : (a colon) then SubDataFrame will always have all columns from the parent, even if they are added or removed after its creation.\n\nExamples\n\ndf = DataFrame(a = repeat([1, 2, 3, 4], outer=[2]),\n               b = repeat([2, 1], outer=[4]),\n               c = randn(8))\nsdf1 = view(df, 2:3) # column subsetting\nsdf2 = @view df[end:-1:1, [1,3]]  # row and column subsetting\nsdf3 = groupby(df, :a)[1]  # indexing a GroupedDataFrame returns a SubDataFrame\n\n\n\n\n\n"
},

{
    "location": "lib/types.html#DataFrames.DataFrameRows",
    "page": "Types",
    "title": "DataFrames.DataFrameRows",
    "category": "type",
    "text": "DataFrameRows{D<:AbstractDataFrame,S<:AbstractIndex} <: AbstractVector{DataFrameRow{D,S}}\n\nIterator over rows of an AbstractDataFrame, with each row represented as a DataFrameRow.\n\nA value of this type is returned by the eachrow function.\n\n\n\n\n\n"
},

{
    "location": "lib/types.html#DataFrames.DataFrameColumns",
    "page": "Types",
    "title": "DataFrames.DataFrameColumns",
    "category": "type",
    "text": "DataFrameColumns{<:AbstractDataFrame, V} <: AbstractVector{V}\n\nIterator over columns of an AbstractDataFrame constructed using eachcol(df, true) if V is a Pair{Symbol,AbstractVector}. Then each returned value is a pair consisting of column name and column vector. If V is an AbstractVector (a value returned by eachcol(df, false)) then each returned value is a column vector.\n\n\n\n\n\n"
},

{
    "location": "lib/types.html#DataFrames.RepeatedVector",
    "page": "Types",
    "title": "DataFrames.RepeatedVector",
    "category": "type",
    "text": "RepeatedVector{T} <: AbstractVector{T}\n\nAn AbstractVector that is a view into another AbstractVector with repeated elements\n\nNOTE: Not exported.\n\nConstructor\n\nRepeatedVector(parent::AbstractVector, inner::Int, outer::Int)\n\nArguments\n\nparent : the AbstractVector that\'s repeated\ninner : the numer of times each element is repeated\nouter : the numer of times the whole vector is repeated after expanded by inner\n\ninner and outer have the same meaning as similarly named arguments to repeat.\n\nExamples\n\nRepeatedVector([1,2], 3, 1)   # [1,1,1,2,2,2]\nRepeatedVector([1,2], 1, 3)   # [1,2,1,2,1,2]\nRepeatedVector([1,2], 2, 2)   # [1,2,1,2,1,2,1,2]\n\n\n\n\n\n"
},

{
    "location": "lib/types.html#DataFrames.StackedVector",
    "page": "Types",
    "title": "DataFrames.StackedVector",
    "category": "type",
    "text": "StackedVector <: AbstractVector{Any}\n\nAn AbstractVector{Any} that is a linear, concatenated view into another set of AbstractVectors\n\nNOTE: Not exported.\n\nConstructor\n\nStackedVector(d::AbstractVector...)\n\nArguments\n\nd... : one or more AbstractVectors\n\nExamples\n\nStackedVector(Any[[1,2], [9,10], [11,12]])  # [1,2,9,10,11,12]\n\n\n\n\n\n"
},

{
    "location": "lib/types.html#Types-specification-1",
    "page": "Types",
    "title": "Types specification",
    "category": "section",
    "text": "AbstractDataFrame\nDataFrame\nDataFrameRow\nGroupedDataFrame\nSubDataFrame\nDataFrameRows\nDataFrameColumns\nRepeatedVector\nStackedVector"
},

{
    "location": "lib/functions.html#",
    "page": "Functions",
    "title": "Functions",
    "category": "page",
    "text": "CurrentModule = DataFrames"
},

{
    "location": "lib/functions.html#Functions-1",
    "page": "Functions",
    "title": "Functions",
    "category": "section",
    "text": "Pages = [\"functions.md\"]"
},

{
    "location": "lib/functions.html#DataFrames.aggregate",
    "page": "Functions",
    "title": "DataFrames.aggregate",
    "category": "function",
    "text": "Split-apply-combine that applies a set of functions over columns of an AbstractDataFrame or GroupedDataFrame\n\naggregate(d::AbstractDataFrame, cols, fs)\naggregate(gd::GroupedDataFrame, fs)\n\nArguments\n\nd : an AbstractDataFrame\ngd : a GroupedDataFrame\ncols : a column indicator (Symbol, Int, Vector{Symbol}, etc.)\nfs : a function or vector of functions to be applied to vectors within groups; expects each argument to be a column vector\n\nEach fs should return a value or vector. All returns must be the same length.\n\nReturns\n\n::DataFrame\n\nExamples\n\njulia> using Statistics\n\njulia> df = DataFrame(a = repeat([1, 2, 3, 4], outer=[2]),\n                      b = repeat([2, 1], outer=[4]),\n                      c = 1:8);\n\njulia> aggregate(df, :a, sum)\n4×3 DataFrame\n│ Row │ a     │ b_sum │ c_sum │\n│     │ Int64 │ Int64 │ Int64 │\n├─────┼───────┼───────┼───────┤\n│ 1   │ 1     │ 4     │ 6     │\n│ 2   │ 2     │ 2     │ 8     │\n│ 3   │ 3     │ 4     │ 10    │\n│ 4   │ 4     │ 2     │ 12    │\n\njulia> aggregate(df, :a, [sum, x->mean(skipmissing(x))])\n4×5 DataFrame\n│ Row │ a     │ b_sum │ c_sum │ b_function │ c_function │\n│     │ Int64 │ Int64 │ Int64 │ Float64    │ Float64    │\n├─────┼───────┼───────┼───────┼────────────┼────────────┤\n│ 1   │ 1     │ 4     │ 6     │ 2.0        │ 3.0        │\n│ 2   │ 2     │ 2     │ 8     │ 1.0        │ 4.0        │\n│ 3   │ 3     │ 4     │ 10    │ 2.0        │ 5.0        │\n│ 4   │ 4     │ 2     │ 12    │ 1.0        │ 6.0        │\n\njulia> aggregate(groupby(df, :a), [sum, x->mean(skipmissing(x))])\n4×5 DataFrame\n│ Row │ a     │ b_sum │ c_sum │ b_function │ c_function │\n│     │ Int64 │ Int64 │ Int64 │ Float64    │ Float64    │\n├─────┼───────┼───────┼───────┼────────────┼────────────┤\n│ 1   │ 1     │ 4     │ 6     │ 2.0        │ 3.0        │\n│ 2   │ 2     │ 2     │ 8     │ 1.0        │ 4.0        │\n│ 3   │ 3     │ 4     │ 10    │ 2.0        │ 5.0        │\n│ 4   │ 4     │ 2     │ 12    │ 1.0        │ 6.0        │\n\n\n\n\n\n"
},

{
    "location": "lib/functions.html#DataFrames.by",
    "page": "Functions",
    "title": "DataFrames.by",
    "category": "function",
    "text": "by(d::AbstractDataFrame, keys, cols => f...; sort::Bool = false)\nby(d::AbstractDataFrame, keys; (colname = cols => f)..., sort::Bool = false)\nby(d::AbstractDataFrame, keys, f; sort::Bool = false)\nby(f, d::AbstractDataFrame, keys; sort::Bool = false)\n\nSplit-apply-combine in one step: apply f to each grouping in d based on grouping columns keys, and return a DataFrame.\n\nkeys can be either a single column index, or a vector thereof.\n\nIf the last argument(s) consist(s) in one or more cols => f pair(s), or if colname = cols => f keyword arguments are provided, cols must be a column name or index, or a vector or tuple thereof, and f must be a callable. A pair or a (named) tuple of pairs can also be provided as the first or last argument. If cols is a single column index, f is called with a SubArray view into that column for each group; else, f is called with a named tuple holding SubArray views into these columns.\n\nIf the last argument is a callable f, it is passed a SubDataFrame view for each group, and the returned DataFrame then consists of the returned rows plus the grouping columns. Note that this second form is much slower than the first one due to type instability. A method is defined with f as the first argument, so do-block notation can be used.\n\nf can return a single value, a row or multiple rows. The type of the returned value determines the shape of the resulting data frame:\n\nA single value gives a data frame with a single column and one row per group.\nA named tuple of single values or a DataFrameRow gives a data frame with one column for each field and one row per group.\nA vector gives a data frame with a single column and as many rows for each group as the length of the returned vector for that group.\nA data frame, a named tuple of vectors or a matrix gives a data frame with the same columns and as many rows for each group as the rows returned for that group.\n\nf must always return the same kind of object (as defined in the above list) for all groups, and if a named tuple or data frame, with the same fields or columns. Named tuples cannot mix single values and vectors. Due to type instability, returning a single value or a named tuple is dramatically faster than returning a data frame.\n\nAs a special case, if multiple pairs are passed as last arguments, each function is required to return a single value or vector, which will produce each a separate column.\n\nIn all cases, the resulting data frame contains all the grouping columns in addition to those generated by the application of f. Column names are automatically generated when necessary: for functions operating on a single column and returning a single value or vector, the function name is appended to the input colummn name; for other functions, columns are called x1, x2 and so on. The resulting data frame will be sorted on keys if sort=true. Otherwise, ordering of rows is undefined.\n\nOptimized methods are used when standard summary functions (sum, prod, minimum, maximum, mean, var, std, first, last and length) are specified using the pair syntax (e.g.col => sum). When computing thesumormeanover floating point columns, results will be less accurate than the standard [sum](@ref) function (which uses pairwise summation). Usecol => x -> sum(x)` to avoid the optimized method and use the slower, more accurate one.\n\nby(d, cols, f) is equivalent to combine(f, groupby(d, cols)) and to the less efficient combine(map(f, groupby(d, cols))).\n\nExamples\n\njulia> df = DataFrame(a = repeat([1, 2, 3, 4], outer=[2]),\n                      b = repeat([2, 1], outer=[4]),\n                      c = 1:8);\n\njulia> by(df, :a, :c => sum)\n4×2 DataFrame\n│ Row │ a     │ c_sum │\n│     │ Int64 │ Int64 │\n├─────┼───────┼───────┤\n│ 1   │ 1     │ 6     │\n│ 2   │ 2     │ 8     │\n│ 3   │ 3     │ 10    │\n│ 4   │ 4     │ 12    │\n\njulia> by(df, :a, d -> sum(d.c)) # Slower variant\n4×2 DataFrame\n│ Row │ a     │ x1    │\n│     │ Int64 │ Int64 │\n├─────┼───────┼───────┤\n│ 1   │ 1     │ 6     │\n│ 2   │ 2     │ 8     │\n│ 3   │ 3     │ 10    │\n│ 4   │ 4     │ 12    │\n\njulia> by(df, :a) do d # do syntax for the slower variant\n           sum(d.c)\n       end\n4×2 DataFrame\n│ Row │ a     │ x1    │\n│     │ Int64 │ Int64 │\n├─────┼───────┼───────┤\n│ 1   │ 1     │ 6     │\n│ 2   │ 2     │ 8     │\n│ 3   │ 3     │ 10    │\n│ 4   │ 4     │ 12    │\n\njulia> by(df, :a, :c => x -> 2 .* x)\n8×2 DataFrame\n│ Row │ a     │ c_function │\n│     │ Int64 │ Int64      │\n├─────┼───────┼────────────┤\n│ 1   │ 1     │ 2          │\n│ 2   │ 1     │ 10         │\n│ 3   │ 2     │ 4          │\n│ 4   │ 2     │ 12         │\n│ 5   │ 3     │ 6          │\n│ 6   │ 3     │ 14         │\n│ 7   │ 4     │ 8          │\n│ 8   │ 4     │ 16         │\n\njulia> by(df, :a, c_sum = :c => sum, c_sum2 = :c => x -> sum(x.^2))\n4×3 DataFrame\n│ Row │ a     │ c_sum │ c_sum2 │\n│     │ Int64 │ Int64 │ Int64  │\n├─────┼───────┼───────┼────────┤\n│ 1   │ 1     │ 6     │ 26     │\n│ 2   │ 2     │ 8     │ 40     │\n│ 3   │ 3     │ 10    │ 58     │\n│ 4   │ 4     │ 12    │ 80     │\n\njulia> by(df, :a, (:b, :c) => x -> (minb = minimum(x.b), sumc = sum(x.c)))\n4×3 DataFrame\n│ Row │ a     │ minb  │ sumc  │\n│     │ Int64 │ Int64 │ Int64 │\n├─────┼───────┼───────┼───────┤\n│ 1   │ 1     │ 2     │ 6     │\n│ 2   │ 2     │ 1     │ 8     │\n│ 3   │ 3     │ 2     │ 10    │\n│ 4   │ 4     │ 1     │ 12    │\n\n\n\n\n\n"
},

{
    "location": "lib/functions.html#DataFrames.combine",
    "page": "Functions",
    "title": "DataFrames.combine",
    "category": "function",
    "text": "combine(gd::GroupedDataFrame, cols => f...)\ncombine(gd::GroupedDataFrame; (colname = cols => f)...)\ncombine(gd::GroupedDataFrame, f)\ncombine(f, gd::GroupedDataFrame)\n\nTransform a GroupedDataFrame into a DataFrame.\n\nIf the last argument(s) consist(s) in one or more cols => f pair(s), or if colname = cols => f keyword arguments are provided, cols must be a column name or index, or a vector or tuple thereof, and f must be a callable. A pair or a (named) tuple of pairs can also be provided as the first or last argument. If cols is a single column index, f is called with a SubArray view into that column for each group; else, f is called with a named tuple holding SubArray views into these columns.\n\nIf the last argument is a callable f, it is passed a SubDataFrame view for each group, and the returned DataFrame then consists of the returned rows plus the grouping columns. Note that this second form is much slower than the first one due to type instability. A method is defined with f as the first argument, so do-block notation can be used.\n\nf can return a single value, a row or multiple rows. The type of the returned value determines the shape of the resulting data frame:\n\nA single value gives a data frame with a single column and one row per group.\nA named tuple of single values or a DataFrameRow gives a data frame with one column for each field and one row per group.\nA vector gives a data frame with a single column and as many rows for each group as the length of the returned vector for that group.\nA data frame, a named tuple of vectors or a matrix gives a data frame with the same columns and as many rows for each group as the rows returned for that group.\n\nf must always return the same kind of object (as defined in the above list) for all groups, and if a named tuple or data frame, with the same fields or columns. Named tuples cannot mix single values and vectors. Due to type instability, returning a single value or a named tuple is dramatically faster than returning a data frame.\n\nAs a special case, if a tuple or vector of pairs is passed as the first argument, each function is required to return a single value or vector, which will produce each a separate column.\n\nIn all cases, the resulting data frame contains all the grouping columns in addition to those generated by the application of f. Column names are automatically generated when necessary: for functions operating on a single column and returning a single value or vector, the function name is appended to the input column name; for other functions, columns are called x1, x2 and so on. The resulting data frame will be sorted if sort=true was passed to the groupby call from which gd was constructed. Otherwise, ordering of rows is undefined.\n\nOptimized methods are used when standard summary functions (sum, prod, minimum, maximum, mean, var, std, first, last and length) are specified using the pair syntax (e.g.col => sum). When computing thesumormeanover floating point columns, results will be less accurate than the standard [sum](@ref) function (which uses pairwise summation). Usecol => x -> sum(x)` to avoid the optimized method and use the slower, more accurate one.\n\nExamples\n\njulia> df = DataFrame(a = repeat([1, 2, 3, 4], outer=[2]),\n                      b = repeat([2, 1], outer=[4]),\n                      c = 1:8);\n\njulia> gd = groupby(df, :a);\n\njulia> combine(gd, :c => sum)\n4×2 DataFrame\n│ Row │ a     │ c_sum │\n│     │ Int64 │ Int64 │\n├─────┼───────┼───────┤\n│ 1   │ 1     │ 6     │\n│ 2   │ 2     │ 8     │\n│ 3   │ 3     │ 10    │\n│ 4   │ 4     │ 12    │\n\njulia> combine(:c => sum, gd)\n4×2 DataFrame\n│ Row │ a     │ c_sum │\n│     │ Int64 │ Int64 │\n├─────┼───────┼───────┤\n│ 1   │ 1     │ 6     │\n│ 2   │ 2     │ 8     │\n│ 3   │ 3     │ 10    │\n│ 4   │ 4     │ 12    │\n\njulia> combine(df -> sum(df.c), gd) # Slower variant\n4×2 DataFrame\n│ Row │ a     │ x1    │\n│     │ Int64 │ Int64 │\n├─────┼───────┼───────┤\n│ 1   │ 1     │ 6     │\n│ 2   │ 2     │ 8     │\n│ 3   │ 3     │ 10    │\n│ 4   │ 4     │ 12    │\n\nSee by for more examples.\n\nSee also\n\nby(f, df, cols) is a shorthand for combine(f, groupby(df, cols)).\n\nmap: combine(f, groupby(df, cols)) is a more efficient equivalent of combine(map(f, groupby(df, cols))).\n\n\n\n\n\n"
},

{
    "location": "lib/functions.html#DataFrames.groupby",
    "page": "Functions",
    "title": "DataFrames.groupby",
    "category": "function",
    "text": "A view of an AbstractDataFrame split into row groups\n\ngroupby(d::AbstractDataFrame, cols; sort = false, skipmissing = false)\ngroupby(cols; sort = false, skipmissing = false)\n\nArguments\n\nd : an AbstractDataFrame to split (optional, see Returns)\ncols : data table columns to group by\nsort : whether to sort rows according to the values of the grouping columns cols\nskipmissing : whether to skip rows with missing values in one of the grouping columns cols\n\nReturns\n\nA GroupedDataFrame : a grouped view into d\n\nDetails\n\nAn iterator over a GroupedDataFrame returns a SubDataFrame view for each grouping into d. A GroupedDataFrame also supports indexing by groups, map (which applies a function to each group) and combine (which applies a function to each group and combines the result into a data frame).\n\nSee the following for additional split-apply-combine operations:\n\nby : split-apply-combine using functions\naggregate : split-apply-combine; applies functions in the form of a cross product\nmap : apply a function to each group of a GroupedDataFrame (without combining)\ncombine : combine a GroupedDataFrame, optionally applying a function to each group\n\nExamples\n\njulia> df = DataFrame(a = repeat([1, 2, 3, 4], outer=[2]),\n                      b = repeat([2, 1], outer=[4]),\n                      c = 1:8);\n\njulia> gd = groupby(df, :a)\nGroupedDataFrame with 4 groups based on key: a\nFirst Group (2 rows): a = 1\n│ Row │ a     │ b     │ c     │\n│     │ Int64 │ Int64 │ Int64 │\n├─────┼───────┼───────┼───────┤\n│ 1   │ 1     │ 2     │ 1     │\n│ 2   │ 1     │ 2     │ 5     │\n⋮\nLast Group (2 rows): a = 4\n│ Row │ a     │ b     │ c     │\n│     │ Int64 │ Int64 │ Int64 │\n├─────┼───────┼───────┼───────┤\n│ 1   │ 4     │ 1     │ 4     │\n│ 2   │ 4     │ 1     │ 8     │\n\njulia> gd[1]\n2×3 SubDataFrame\n│ Row │ a     │ b     │ c     │\n│     │ Int64 │ Int64 │ Int64 │\n├─────┼───────┼───────┼───────┤\n│ 1   │ 1     │ 2     │ 1     │\n│ 2   │ 1     │ 2     │ 5     │\n\njulia> last(gd)\n2×3 SubDataFrame\n│ Row │ a     │ b     │ c     │\n│     │ Int64 │ Int64 │ Int64 │\n├─────┼───────┼───────┼───────┤\n│ 1   │ 4     │ 1     │ 4     │\n│ 2   │ 4     │ 1     │ 8     │\n\njulia> for g in gd\n           println(g)\n       end\n2×3 SubDataFrame\n│ Row │ a     │ b     │ c     │\n│     │ Int64 │ Int64 │ Int64 │\n├─────┼───────┼───────┼───────┤\n│ 1   │ 1     │ 2     │ 1     │\n│ 2   │ 1     │ 2     │ 5     │\n2×3 SubDataFrame\n│ Row │ a     │ b     │ c     │\n│     │ Int64 │ Int64 │ Int64 │\n├─────┼───────┼───────┼───────┤\n│ 1   │ 2     │ 1     │ 2     │\n│ 2   │ 2     │ 1     │ 6     │\n2×3 SubDataFrame\n│ Row │ a     │ b     │ c     │\n│     │ Int64 │ Int64 │ Int64 │\n├─────┼───────┼───────┼───────┤\n│ 1   │ 3     │ 2     │ 3     │\n│ 2   │ 3     │ 2     │ 7     │\n2×3 SubDataFrame\n│ Row │ a     │ b     │ c     │\n│     │ Int64 │ Int64 │ Int64 │\n├─────┼───────┼───────┼───────┤\n│ 1   │ 4     │ 1     │ 4     │\n│ 2   │ 4     │ 1     │ 8     │\n\n\n\n\n\n"
},

{
    "location": "lib/functions.html#DataFrames.groupindices",
    "page": "Functions",
    "title": "DataFrames.groupindices",
    "category": "function",
    "text": "groupindices(gd::GroupedDataFrame)\n\nReturn a vector of group indices for each row of parent(gd).\n\nRows appearing in group gd[i] are attributed index i. Rows not present in any group are attributed missing (this can happen if skipmissing=true was passed when creating gd, or if gd is a subset from a larger GroupedDataFrame).\n\n\n\n\n\n"
},

{
    "location": "lib/functions.html#DataFrames.groupvars",
    "page": "Functions",
    "title": "DataFrames.groupvars",
    "category": "function",
    "text": "groupvars(gd::GroupedDataFrame)\n\nReturn a vector of column names in parent(gd) used for grouping.\n\n\n\n\n\n"
},

{
    "location": "lib/functions.html#Base.join",
    "page": "Functions",
    "title": "Base.join",
    "category": "function",
    "text": "join(df1, df2; on = Symbol[], kind = :inner, makeunique = false,\n     indicator = nothing, validate = (false, false))\n\nJoin two DataFrame objects\n\nArguments\n\ndf1, df2 : the two AbstractDataFrames to be joined\n\nKeyword Arguments\n\non : A column, or vector of columns to join df1 and df2 on. If the column(s)   that df1 and df2 will be joined on have different names, then the columns   should be (left, right) tuples or left => right pairs, or a vector of   such tuples or pairs. on is a required argument for all joins except for   kind = :cross\nkind : the type of join, options include:\n:inner : only include rows with keys that match in both df1 and df2, the default\n:outer : include all rows from df1 and df2\n:left : include all rows from df1\n:right : include all rows from df2\n:semi : return rows of df1 that match with the keys in df2\n:anti : return rows of df1 that do not match with the keys in df2\n:cross : a full Cartesian product of the key combinations; every row of df1 is matched with every row of df2\n\nmakeunique : if false (the default), an error will be raised if duplicate names are found in columns not joined on; if true, duplicate names will be suffixed with _i (i starting at 1 for the first duplicate).\nindicator : Default: nothing. If a Symbol, adds categorical indicator  column named Symbol for whether a row appeared in only df1 (\"left_only\"),  only df2 (\"right_only\") or in both (\"both\"). If Symbol is already in use,  the column name will be modified if makeunique=true.\nvalidate : whether to check that columns passed as the on argument  define unique keys in each input data frame (according to isequal).  Can be a tuple or a pair, with the first element indicating whether to  run check for df1 and the second element for df2.  By default no check is performed.\n\nFor the three join operations that may introduce missing values (:outer, :left, and :right), all columns of the returned data table will support missing values.\n\nWhen merging on categorical columns that differ in the ordering of their levels, the ordering of the left DataFrame takes precedence over the ordering of the right DataFrame\n\nResult\n\n::DataFrame : the joined DataFrame\n\nExamples\n\nname = DataFrame(ID = [1, 2, 3], Name = [\"John Doe\", \"Jane Doe\", \"Joe Blogs\"])\njob = DataFrame(ID = [1, 2, 4], Job = [\"Lawyer\", \"Doctor\", \"Farmer\"])\n\njoin(name, job, on = :ID)\njoin(name, job, on = :ID, kind = :outer)\njoin(name, job, on = :ID, kind = :left)\njoin(name, job, on = :ID, kind = :right)\njoin(name, job, on = :ID, kind = :semi)\njoin(name, job, on = :ID, kind = :anti)\njoin(name, job, kind = :cross)\n\njob2 = DataFrame(identifier = [1, 2, 4], Job = [\"Lawyer\", \"Doctor\", \"Farmer\"])\njoin(name, job2, on = (:ID, :identifier))\njoin(name, job2, on = :ID => :identifier)\n\n\n\n\n\n"
},

{
    "location": "lib/functions.html#Base.map",
    "page": "Functions",
    "title": "Base.map",
    "category": "function",
    "text": "map(cols => f, gd::GroupedDataFrame)\nmap(f, gd::GroupedDataFrame)\n\nApply a function to each group of rows and return a GroupedDataFrame.\n\nIf the first argument is a cols => f pair, cols must be a column name or index, or a vector or tuple thereof, and f must be a callable. If cols is a single column index, f is called with a SubArray view into that column for each group; else, f is called with a named tuple holding SubArray views into these columns.\n\nIf the first argument is a vector, tuple or named tuple of such pairs, each pair is handled as described above. If a named tuple, field names are used to name each generated column.\n\nIf the first argument is a callable, it is passed a SubDataFrame view for each group, and the returned DataFrame then consists of the returned rows plus the grouping columns. Note that this second form is much slower than the first one due to type instability.\n\nf can return a single value, a row or multiple rows. The type of the returned value determines the shape of the resulting data frame:\n\nA single value gives a data frame with a single column and one row per group.\nA named tuple of single values or a DataFrameRow gives a data frame with one column for each field and one row per group.\nA vector gives a data frame with a single column and as many rows for each group as the length of the returned vector for that group.\nA data frame, a named tuple of vectors or a matrix gives a data frame with the same columns and as many rows for each group as the rows returned for that group.\n\nf must always return the same kind of object (as defined in the above list) for all groups, and if a named tuple or data frame, with the same fields or columns. Named tuples cannot mix single values and vectors. Due to type instability, returning a single value or a named tuple is dramatically faster than returning a data frame.\n\nAs a special case, if a tuple or vector of pairs is passed as the first argument, each function is required to return a single value or vector, which will produce each a separate column.\n\nIn all cases, the resulting GroupedDataFrame contains all the grouping columns in addition to those generated by the application of f. Column names are automatically generated when necessary: for functions operating on a single column and returning a single value or vector, the function name is appended to the input column name; for other functions, columns are called x1, x2 and so on.\n\nOptimized methods are used when standard summary functions (sum, prod, minimum, maximum, mean, var, std, first, last and length) are specified using the pair syntax (e.g.col => sum). When computing thesumormeanover floating point columns, results will be less accurate than the standard [sum](@ref) function (which uses pairwise summation). Usecol => x -> sum(x)` to avoid the optimized method and use the slower, more accurate one.\n\nExamples\n\njulia> df = DataFrame(a = repeat([1, 2, 3, 4], outer=[2]),\n                      b = repeat([2, 1], outer=[4]),\n                      c = 1:8);\n\njulia> gd = groupby(df, :a);\n\njulia> map(:c => sum, gd)\nGroupedDataFrame{DataFrame} with 4 groups based on key: :a\nFirst Group: 1 row\n│ Row │ a     │ c_sum │\n│     │ Int64 │ Int64 │\n├─────┼───────┼───────┤\n│ 1   │ 1     │ 6     │\n⋮\nLast Group: 1 row\n│ Row │ a     │ c_sum │\n│     │ Int64 │ Int64 │\n├─────┼───────┼───────┤\n│ 1   │ 4     │ 12    │\n\njulia> map(df -> sum(df.c), gd) # Slower variant\nGroupedDataFrame{DataFrame} with 4 groups based on key: :a\nFirst Group: 1 row\n│ Row │ a     │ x1    │\n│     │ Int64 │ Int64 │\n├─────┼───────┼───────┤\n│ 1   │ 1     │ 6     │\n⋮\nLast Group: 1 row\n│ Row │ a     │ x1    │\n│     │ Int64 │ Int64 │\n├─────┼───────┼───────┤\n│ 1   │ 4     │ 12    │\n\nSee by for more examples.\n\nSee also\n\ncombine(f, gd) returns a DataFrame rather than a GroupedDataFrame\n\n\n\n\n\n"
},

{
    "location": "lib/functions.html#DataFrames.melt",
    "page": "Functions",
    "title": "DataFrames.melt",
    "category": "function",
    "text": "Stacks a DataFrame; convert from a wide to long format; see stack.\n\n\n\n\n\n"
},

{
    "location": "lib/functions.html#DataFrames.stack",
    "page": "Functions",
    "title": "DataFrames.stack",
    "category": "function",
    "text": "Stacks a DataFrame; convert from a wide to long format\n\nstack(df::AbstractDataFrame, [measure_vars], [id_vars];\n      variable_name::Symbol=:variable, value_name::Symbol=:value)\nmelt(df::AbstractDataFrame, [id_vars], [measure_vars];\n     variable_name::Symbol=:variable, value_name::Symbol=:value)\n\nArguments\n\ndf : the AbstractDataFrame to be stacked\nmeasure_vars : the columns to be stacked (the measurement variables), a normal column indexing type, like a Symbol, Vector{Symbol}, Int, etc.; for melt, defaults to all variables that are not id_vars. If neither measure_vars or id_vars are given, measure_vars defaults to all floating point columns.\nid_vars : the identifier columns that are repeated during stacking, a normal column indexing type; for stack defaults to all variables that are not measure_vars\nvariable_name : the name of the new stacked column that shall hold the names of each of measure_vars\nvalue_name : the name of the new stacked column containing the values from each of measure_vars\n\nResult\n\n::DataFrame : the long-format DataFrame with column :value holding the values of the stacked columns (measure_vars), with column :variable a Vector of Symbols with the measure_vars name, and with columns for each of the id_vars.\n\nSee also stackdf and meltdf for stacking methods that return a view into the original DataFrame. See unstack for converting from long to wide format.\n\nExamples\n\nd1 = DataFrame(a = repeat([1:3;], inner = [4]),\n               b = repeat([1:4;], inner = [3]),\n               c = randn(12),\n               d = randn(12),\n               e = map(string, \'a\':\'l\'))\n\nd1s = stack(d1, [:c, :d])\nd1s2 = stack(d1, [:c, :d], [:a])\nd1m = melt(d1, [:a, :b, :e])\nd1s_name = melt(d1, [:a, :b, :e], variable_name=:somemeasure)\n\n\n\n\n\n"
},

{
    "location": "lib/functions.html#DataFrames.unstack",
    "page": "Functions",
    "title": "DataFrames.unstack",
    "category": "function",
    "text": "Unstacks a DataFrame; convert from a long to wide format\n\nunstack(df::AbstractDataFrame, rowkeys::Union{Symbol, Integer},\n        colkey::Union{Symbol, Integer}, value::Union{Symbol, Integer})\nunstack(df::AbstractDataFrame, rowkeys::AbstractVector{<:Union{Symbol, Integer}},\n        colkey::Union{Symbol, Integer}, value::Union{Symbol, Integer})\nunstack(df::AbstractDataFrame, colkey::Union{Symbol, Integer},\n        value::Union{Symbol, Integer})\nunstack(df::AbstractDataFrame)\n\nArguments\n\ndf : the AbstractDataFrame to be unstacked\nrowkeys : the column(s) with a unique key for each row, if not given, find a key by grouping on anything not a colkey or value\ncolkey : the column holding the column names in wide format, defaults to :variable\nvalue : the value column, defaults to :value\n\nResult\n\n::DataFrame : the wide-format DataFrame\n\nIf colkey contains missing values then they will be skipped and a warning will be printed.\n\nIf combination of rowkeys and colkey contains duplicate entries then last value will be retained and a warning will be printed.\n\nExamples\n\nwide = DataFrame(id = 1:12,\n                 a  = repeat([1:3;], inner = [4]),\n                 b  = repeat([1:4;], inner = [3]),\n                 c  = randn(12),\n                 d  = randn(12))\n\nlong = stack(wide)\nwide0 = unstack(long)\nwide1 = unstack(long, :variable, :value)\nwide2 = unstack(long, :id, :variable, :value)\nwide3 = unstack(long, [:id, :a], :variable, :value)\n\nNote that there are some differences between the widened results above.\n\n\n\n\n\n"
},

{
    "location": "lib/functions.html#DataFrames.stackdf",
    "page": "Functions",
    "title": "DataFrames.stackdf",
    "category": "function",
    "text": "A stacked view of a DataFrame (long format)\n\nLike stack and melt, but a view is returned rather than data copies.\n\nstackdf(df::AbstractDataFrame, [measure_vars], [id_vars];\n        variable_name::Symbol=:variable, value_name::Symbol=:value)\nmeltdf(df::AbstractDataFrame, [id_vars], [measure_vars];\n       variable_name::Symbol=:variable, value_name::Symbol=:value)\n\nArguments\n\ndf : the wide AbstractDataFrame\nmeasure_vars : the columns to be stacked (the measurement variables), a normal column indexing type, like a Symbol, Vector{Symbol}, Int, etc.; for melt, defaults to all variables that are not id_vars\nid_vars : the identifier columns that are repeated during stacking, a normal column indexing type; for stack defaults to all variables that are not measure_vars\n\nResult\n\n::DataFrame : the long-format DataFrame with column :value holding the values of the stacked columns (measure_vars), with column :variable a Vector of Symbols with the measure_vars name, and with columns for each of the id_vars.\n\nThe result is a view because the columns are special AbstractVectors that return indexed views into the original DataFrame.\n\nExamples\n\nd1 = DataFrame(a = repeat([1:3;], inner = [4]),\n               b = repeat([1:4;], inner = [3]),\n               c = randn(12),\n               d = randn(12),\n               e = map(string, \'a\':\'l\'))\n\nd1s = stackdf(d1, [:c, :d])\nd1s2 = stackdf(d1, [:c, :d], [:a])\nd1m = meltdf(d1, [:a, :b, :e])\n\n\n\n\n\n"
},

{
    "location": "lib/functions.html#DataFrames.meltdf",
    "page": "Functions",
    "title": "DataFrames.meltdf",
    "category": "function",
    "text": "A stacked view of a DataFrame (long format); see stackdf\n\n\n\n\n\n"
},

{
    "location": "lib/functions.html#Grouping,-Joining,-and-Split-Apply-Combine-1",
    "page": "Functions",
    "title": "Grouping, Joining, and Split-Apply-Combine",
    "category": "section",
    "text": "aggregate\nby\ncombine\ngroupby\ngroupindices\ngroupvars\njoin\nmap\nmelt\nstack\nunstack\nstackdf\nmeltdf"
},

{
    "location": "lib/functions.html#Basics-1",
    "page": "Functions",
    "title": "Basics",
    "category": "section",
    "text": "allowmissing!\ncategorical!\ncompletecases\ncopy\nDataFrame\nDataFrame!\ndeletecols!\ndeletecols\ndeleterows!\ndescribe\ndisallowmissing!\ndropmissing\ndropmissing!\neachrow\neachcol\neltypes\nfilter\nfilter!\nhcat\ninsertcols!\nmapcols\nnames!\nnonunique\nnrow\nncol\nrename!\nrename\nrepeat\nselect\nselect!\nshow\nsort\nsort!\nunique!\npermutecols!\nvcat\nappend!\npush!"
},

{
    "location": "lib/indexing.html#",
    "page": "Indexing",
    "title": "Indexing",
    "category": "page",
    "text": "CurrentModule = DataFrames"
},

{
    "location": "lib/indexing.html#Indexing-1",
    "page": "Indexing",
    "title": "Indexing",
    "category": "section",
    "text": "Pages = [\"indexing.md\"]"
},

{
    "location": "lib/indexing.html#General-rules-1",
    "page": "Indexing",
    "title": "General rules",
    "category": "section",
    "text": "The following rules explain target functionality of how getindex, setindex!, and view are intended to work with DataFrame, SubDataFrame and DataFrameRow objects.The rules for a valid type of index into a column are the following:a value, later denoted as col:\na Symbol;\nan Integer that is not Bool;\na vector, later denoted as cols:\na vector of Symbol (does not have to be a subtype of AbstractVector{Symbol});\na vector of Integer other than Bool (does not have to be a subtype of AbstractVector{<:Integer});\na vector of Bool that has to be a subtype of AbstractVector{Bool}.\na colon.The rules for a valid type of index into a row are the following:a value, later denoted as row:\nan Integer that is not Bool;\na vector, later denoted as rows:\na vector of Integer other than Bool (does not have to be a subtype of AbstractVector{<:Integer});\na vector of Bool that has to be a subtype of AbstractVector{Bool};\na colon.In the descriptions below df represents a DataFrame, sdf is a SubDataFrame and dfr is a DataFrameRow."
},

{
    "location": "lib/indexing.html#getindex-1",
    "page": "Indexing",
    "title": "getindex",
    "category": "section",
    "text": "The following list specifies return types of getindex operations depending on argument types.In all operations copying vectors is avoided where possible. If it is performed a description explicitly mentions that the data is copied.For performance reasons, accessing, via getindex or view, a single row and multiple cols of a DataFrame, a SubDataFrame or a DataFrameRow always returns a DataFrameRow (which is a view-like type).DataFrame:df[col] -> the vector contained in column col;\ndf[cols] -> a freshly allocated DataFrame containing the copies of vectors contained in columns cols;\ndf[row, col] -> the value contained in row row of column col, the same as df[col][row];\ndf[row, cols] -> a DataFrameRow with parent df if cols is a colon and df[cols] otherwise;\ndf[rows, col] -> a copy of the vector df[col] with only the entries corresponding to rows selected, the same as df[col][rows];\ndf[rows, cols] -> a DataFrame containing copies of columns cols with only the entries corresponding to rows selected.\n@view df[col] -> the vector contained in column col (this is equivalent to df[col]);\n@view df[cols] -> a SubDataFrame with parent df if cols is a colon and df[cols] otherwise;\n@view df[row, col] -> a 0-dimensional view into df[col], the same as view(df[col], row);\n@view df[row, cols] -> a DataFrameRow with parent df if cols is a colon and df[cols] otherwise;\n@view df[rows, col] -> a view into df[col] with rows selected, the same as view(df[col], rows);\n@view df[rows, cols] -> a SubDataFrame with rows selected with parent df if cols is a colon and df[cols] otherwise.SubDataFrame:sdf[col] -> a view of the vector contained in column col of parent(sdf) with DataFrames.rows(sdf) as a selector;\nsdf[cols] -> a SubDataFrame, with parent parent(sdf) if cols is a colon and parent(sdf)[cols] otherwise;\nsdf[row, col] -> a value contained in row row of column col;\nsdf[row, cols] -> a DataFrameRow with parent parent(sdf) if cols is a colon and parent(sdf)[cols] otherwise;\nsdf[rows, col] -> a copy of a vector sdf[col] with only rows rows selected;\nsdf[rows, cols] -> a DataFrame containing columns cols and df[rows, col] as a vector in each col in cols.\n@view sdf[col] -> a view of vector contained in column col of parent(sdf) with DataFrames.rows(sdf) as selector;\n@view sdf[cols] -> a SubDataFrame with parent parent(sdf) if cols is a colon and parent(sdf)[cols] otherwise;\n@view sdf[row, col] -> translates to view(sdf[col], row) (a 0-dimensional view into df[col]);\n@view sdf[row, cols] -> a DataFrameRow with parent parent(sdf) if cols is a colon and parent(sdf)[cols] otherwise;\n@view sdf[rows, col] -> translates to view(sdf[col], rows) (a standard view into sdf[col] vector);\n@view sdf[rows, cols] -> a SubDataFrame with parent parent(sdf) if cols is a colon and sdf[cols] otherwise.DataFrameRow:dfr[col] -> the value contained in column col of dfr;\ndfr[cols] -> a DataFrameRow with parent parent(dfr) if cols is a colon and parent(dfr)[cols] otherwise;\n@view dfr[col] -> a 0-dimensional view into parent(dfr)[DataFrames.row(dfr), col];\n@view dfr[cols] -> a DataFrameRow with parent parent(dfr) if cols is a colon and parent(dfr)[cols] otherwise;"
},

{
    "location": "lib/indexing.html#setindex!-1",
    "page": "Indexing",
    "title": "setindex!",
    "category": "section",
    "text": "Under construction"
},

{
    "location": "lib/indexing.html#Broadcasting-1",
    "page": "Indexing",
    "title": "Broadcasting",
    "category": "section",
    "text": "It is possible to assign a value to AbstractDataFrame and DataFrameRow objects using the .= operator. In such an operation AbstractDataFrame is considered as two-dimensional and DataFrameRow as single-dimensional.note: Note\nThe rule above means that, similar to single-dimensional objects in Base (e.g. vectors), DataFrameRow is considered to be column-oriented.If column indexing using Symbol names is performed the order of columns in the operation is specified by the order of names.df[col] .= value is allowed when col is a Symbol even if col is not present in the DataFrame under the condition that df is not empty: a new column will be created. On the contrary, df.col .= value is not allowed if col is not present in df."
},

]}
