<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Functions · DataFrames.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../index.html"><img class="logo" src="../assets/logo.png" alt="DataFrames.jl logo"/></a><h1>DataFrames.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../index.html">Introduction</a></li><li><span class="toctext">User Guide</span><ul><li><a class="toctext" href="../man/getting_started.html">Getting Started</a></li><li><a class="toctext" href="../man/joins.html">Joins</a></li><li><a class="toctext" href="../man/split_apply_combine.html">Split-apply-combine</a></li><li><a class="toctext" href="../man/reshaping_and_pivoting.html">Reshaping</a></li><li><a class="toctext" href="../man/sorting.html">Sorting</a></li><li><a class="toctext" href="../man/categorical.html">Categorical Data</a></li><li><a class="toctext" href="../man/missing.html">Missing Data</a></li><li><a class="toctext" href="../man/querying_frameworks.html">Data manipulation frameworks</a></li></ul></li><li><span class="toctext">API</span><ul><li><a class="toctext" href="types.html">Types</a></li><li class="current"><a class="toctext" href="functions.html">Functions</a><ul class="internal"><li><a class="toctext" href="#Grouping,-Joining,-and-Split-Apply-Combine-1">Grouping, Joining, and Split-Apply-Combine</a></li><li><a class="toctext" href="#Basics-1">Basics</a></li></ul></li><li><a class="toctext" href="indexing.html">Indexing</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>API</li><li><a href="functions.html">Functions</a></li></ul><a class="edit-page" href="https://github.com/JuliaData/DataFrames.jl/blob/master/docs/src/lib/functions.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Functions</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Functions-1" href="#Functions-1">Functions</a></h1><ul><li><a href="functions.html#Base.append!"><code>Base.append!</code></a></li><li><a href="functions.html#Base.copy"><code>Base.copy</code></a></li><li><a href="functions.html#Base.filter"><code>Base.filter</code></a></li><li><a href="functions.html#Base.filter!"><code>Base.filter!</code></a></li><li><a href="functions.html#Base.hcat"><code>Base.hcat</code></a></li><li><a href="functions.html#Base.join"><code>Base.join</code></a></li><li><a href="functions.html#Base.map"><code>Base.map</code></a></li><li><a href="functions.html#Base.push!"><code>Base.push!</code></a></li><li><a href="functions.html#Base.repeat"><code>Base.repeat</code></a></li><li><a href="functions.html#Base.show"><code>Base.show</code></a></li><li><a href="functions.html#Base.sort"><code>Base.sort</code></a></li><li><a href="functions.html#Base.sort!"><code>Base.sort!</code></a></li><li><a href="functions.html#Base.unique!"><code>Base.unique!</code></a></li><li><a href="functions.html#Base.vcat"><code>Base.vcat</code></a></li><li><a href="functions.html#DataFrames.DataFrame!"><code>DataFrames.DataFrame!</code></a></li><li><a href="functions.html#DataFrames.aggregate"><code>DataFrames.aggregate</code></a></li><li><a href="functions.html#DataFrames.allowmissing!"><code>DataFrames.allowmissing!</code></a></li><li><a href="functions.html#DataFrames.by"><code>DataFrames.by</code></a></li><li><a href="functions.html#DataFrames.categorical!"><code>DataFrames.categorical!</code></a></li><li><a href="functions.html#DataFrames.combine"><code>DataFrames.combine</code></a></li><li><a href="functions.html#DataFrames.completecases"><code>DataFrames.completecases</code></a></li><li><a href="functions.html#DataFrames.deletecols"><code>DataFrames.deletecols</code></a></li><li><a href="functions.html#DataFrames.deletecols!"><code>DataFrames.deletecols!</code></a></li><li><a href="functions.html#DataFrames.deleterows!"><code>DataFrames.deleterows!</code></a></li><li><a href="functions.html#DataFrames.disallowmissing!"><code>DataFrames.disallowmissing!</code></a></li><li><a href="functions.html#DataFrames.dropmissing"><code>DataFrames.dropmissing</code></a></li><li><a href="functions.html#DataFrames.dropmissing!"><code>DataFrames.dropmissing!</code></a></li><li><a href="functions.html#DataFrames.eachcol"><code>DataFrames.eachcol</code></a></li><li><a href="functions.html#DataFrames.eachrow"><code>DataFrames.eachrow</code></a></li><li><a href="functions.html#DataFrames.eltypes"><code>DataFrames.eltypes</code></a></li><li><a href="functions.html#DataFrames.groupby"><code>DataFrames.groupby</code></a></li><li><a href="functions.html#DataFrames.groupindices"><code>DataFrames.groupindices</code></a></li><li><a href="functions.html#DataFrames.groupvars"><code>DataFrames.groupvars</code></a></li><li><a href="functions.html#DataFrames.insertcols!"><code>DataFrames.insertcols!</code></a></li><li><a href="functions.html#DataFrames.mapcols"><code>DataFrames.mapcols</code></a></li><li><a href="functions.html#DataFrames.melt"><code>DataFrames.melt</code></a></li><li><a href="functions.html#DataFrames.meltdf"><code>DataFrames.meltdf</code></a></li><li><a href="functions.html#DataFrames.names!"><code>DataFrames.names!</code></a></li><li><a href="functions.html#DataFrames.ncol"><code>DataFrames.ncol</code></a></li><li><a href="functions.html#DataFrames.nonunique"><code>DataFrames.nonunique</code></a></li><li><a href="functions.html#DataFrames.nrow"><code>DataFrames.nrow</code></a></li><li><a href="functions.html#DataFrames.permutecols!"><code>DataFrames.permutecols!</code></a></li><li><a href="functions.html#DataFrames.rename"><code>DataFrames.rename</code></a></li><li><a href="functions.html#DataFrames.rename!"><code>DataFrames.rename!</code></a></li><li><a href="functions.html#DataFrames.select"><code>DataFrames.select</code></a></li><li><a href="functions.html#DataFrames.select!"><code>DataFrames.select!</code></a></li><li><a href="functions.html#DataFrames.stack"><code>DataFrames.stack</code></a></li><li><a href="functions.html#DataFrames.stackdf"><code>DataFrames.stackdf</code></a></li><li><a href="functions.html#DataFrames.unstack"><code>DataFrames.unstack</code></a></li><li><a href="functions.html#StatsBase.describe"><code>StatsBase.describe</code></a></li></ul><h2><a class="nav-anchor" id="Grouping,-Joining,-and-Split-Apply-Combine-1" href="#Grouping,-Joining,-and-Split-Apply-Combine-1">Grouping, Joining, and Split-Apply-Combine</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataFrames.aggregate" href="#DataFrames.aggregate"><code>DataFrames.aggregate</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Split-apply-combine that applies a set of functions over columns of an <code>AbstractDataFrame</code> or <a href="types.html#DataFrames.GroupedDataFrame"><code>GroupedDataFrame</code></a></p><pre><code class="language-julia">aggregate(df::AbstractDataFrame, cols, fs)
aggregate(gd::GroupedDataFrame, fs)</code></pre><p><strong>Arguments</strong></p><ul><li><code>df</code> : an <code>AbstractDataFrame</code></li><li><code>gd</code> : a <code>GroupedDataFrame</code></li><li><code>cols</code> : a column indicator (<code>Symbol</code>, <code>Int</code>, <code>Vector{Symbol}</code>, etc.)</li><li><code>fs</code> : a function or vector of functions to be applied to vectors within groups; expects each argument to be a column vector</li></ul><p>Each <code>fs</code> should return a value or vector. All returns must be the same length.</p><p><strong>Returns</strong></p><ul><li><code>::DataFrame</code></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Statistics

julia&gt; df = DataFrame(a = repeat([1, 2, 3, 4], outer=[2]),
                      b = repeat([2, 1], outer=[4]),
                      c = 1:8);

julia&gt; aggregate(df, :a, sum)
4×3 DataFrame
│ Row │ a     │ b_sum │ c_sum │
│     │ Int64 │ Int64 │ Int64 │
├─────┼───────┼───────┼───────┤
│ 1   │ 1     │ 4     │ 6     │
│ 2   │ 2     │ 2     │ 8     │
│ 3   │ 3     │ 4     │ 10    │
│ 4   │ 4     │ 2     │ 12    │

julia&gt; aggregate(df, :a, [sum, x-&gt;mean(skipmissing(x))])
4×5 DataFrame
│ Row │ a     │ b_sum │ c_sum │ b_function │ c_function │
│     │ Int64 │ Int64 │ Int64 │ Float64    │ Float64    │
├─────┼───────┼───────┼───────┼────────────┼────────────┤
│ 1   │ 1     │ 4     │ 6     │ 2.0        │ 3.0        │
│ 2   │ 2     │ 2     │ 8     │ 1.0        │ 4.0        │
│ 3   │ 3     │ 4     │ 10    │ 2.0        │ 5.0        │
│ 4   │ 4     │ 2     │ 12    │ 1.0        │ 6.0        │

julia&gt; aggregate(groupby(df, :a), [sum, x-&gt;mean(skipmissing(x))])
4×5 DataFrame
│ Row │ a     │ b_sum │ c_sum │ b_function │ c_function │
│     │ Int64 │ Int64 │ Int64 │ Float64    │ Float64    │
├─────┼───────┼───────┼───────┼────────────┼────────────┤
│ 1   │ 1     │ 4     │ 6     │ 2.0        │ 3.0        │
│ 2   │ 2     │ 2     │ 8     │ 1.0        │ 4.0        │
│ 3   │ 3     │ 4     │ 10    │ 2.0        │ 5.0        │
│ 4   │ 4     │ 2     │ 12    │ 1.0        │ 6.0        │</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/25e23b7afdab1210bc22955b9243e31a989d7388/src/groupeddataframe/grouping.jl#L1079-L1142">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataFrames.by" href="#DataFrames.by"><code>DataFrames.by</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">by(df::AbstractDataFrame, keys, cols =&gt; f...; sort::Bool = false)
by(df::AbstractDataFrame, keys; (colname = cols =&gt; f)..., sort::Bool = false)
by(df::AbstractDataFrame, keys, f; sort::Bool = false)
by(f, df::AbstractDataFrame, keys; sort::Bool = false)</code></pre><p>Split-apply-combine in one step: apply <code>f</code> to each grouping in <code>df</code> based on grouping columns <code>keys</code>, and return a <code>DataFrame</code>.</p><p><code>keys</code> can be either a single column index, or a vector thereof.</p><p>If the last argument(s) consist(s) in one or more <code>cols =&gt; f</code> pair(s), or if <code>colname = cols =&gt; f</code> keyword arguments are provided, <code>cols</code> must be a column name or index, or a vector or tuple thereof, and <code>f</code> must be a callable. A pair or a (named) tuple of pairs can also be provided as the first or last argument. If <code>cols</code> is a single column index, <code>f</code> is called with a <code>SubArray</code> view into that column for each group; else, <code>f</code> is called with a named tuple holding <code>SubArray</code> views into these columns.</p><p>If the last argument is a callable <code>f</code>, it is passed a <a href="types.html#DataFrames.SubDataFrame"><code>SubDataFrame</code></a> view for each group, and the returned <code>DataFrame</code> then consists of the returned rows plus the grouping columns. Note that this second form is much slower than the first one due to type instability. A method is defined with <code>f</code> as the first argument, so do-block notation can be used.</p><p><code>f</code> can return a single value, a row or multiple rows. The type of the returned value determines the shape of the resulting data frame:</p><ul><li>A single value gives a data frame with a single column and one row per group.</li><li>A named tuple of single values or a <a href="types.html#DataFrames.DataFrameRow"><code>DataFrameRow</code></a> gives a data frame with one column for each field and one row per group.</li><li>A vector gives a data frame with a single column and as many rows for each group as the length of the returned vector for that group.</li><li>A data frame, a named tuple of vectors or a matrix gives a data frame with the same columns and as many rows for each group as the rows returned for that group.</li></ul><p><code>f</code> must always return the same kind of object (as defined in the above list) for all groups, and if a named tuple or data frame, with the same fields or columns. Named tuples cannot mix single values and vectors. Due to type instability, returning a single value or a named tuple is dramatically faster than returning a data frame.</p><p>As a special case, if multiple pairs are passed as last arguments, each function is required to return a single value or vector, which will produce each a separate column.</p><p>In all cases, the resulting data frame contains all the grouping columns in addition to those generated by the application of <code>f</code>. Column names are automatically generated when necessary: for functions operating on a single column and returning a single value or vector, the function name is appended to the input colummn name; for other functions, columns are called <code>x1</code>, <code>x2</code> and so on. The resulting data frame will be sorted on <code>keys</code> if <code>sort=true</code>. Otherwise, ordering of rows is undefined.</p><p>Optimized methods are used when standard summary functions (<code>sum</code>, <code>prod</code>, <code>minimum</code>, <code>maximum</code>, <code>mean</code>, <code>var</code>, <code>std</code>, <code>first</code>, <code>last</code> and <code>length) are specified using the pair syntax (e.g.</code>col =&gt; sum<code>). When computing the</code>sum<code>or</code>mean<code>over floating point columns, results will be less accurate than the standard [</code>sum<code>](@ref) function (which uses pairwise summation). Use</code>col =&gt; x -&gt; sum(x)` to avoid the optimized method and use the slower, more accurate one.</p><p><code>by(d, cols, f)</code> is equivalent to <code>combine(f, groupby(d, cols))</code> and to the less efficient <code>combine(map(f, groupby(d, cols)))</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; df = DataFrame(a = repeat([1, 2, 3, 4], outer=[2]),
                      b = repeat([2, 1], outer=[4]),
                      c = 1:8);

julia&gt; by(df, :a, :c =&gt; sum)
4×2 DataFrame
│ Row │ a     │ c_sum │
│     │ Int64 │ Int64 │
├─────┼───────┼───────┤
│ 1   │ 1     │ 6     │
│ 2   │ 2     │ 8     │
│ 3   │ 3     │ 10    │
│ 4   │ 4     │ 12    │

julia&gt; by(df, :a, d -&gt; sum(d.c)) # Slower variant
4×2 DataFrame
│ Row │ a     │ x1    │
│     │ Int64 │ Int64 │
├─────┼───────┼───────┤
│ 1   │ 1     │ 6     │
│ 2   │ 2     │ 8     │
│ 3   │ 3     │ 10    │
│ 4   │ 4     │ 12    │

julia&gt; by(df, :a) do d # do syntax for the slower variant
           sum(d.c)
       end
4×2 DataFrame
│ Row │ a     │ x1    │
│     │ Int64 │ Int64 │
├─────┼───────┼───────┤
│ 1   │ 1     │ 6     │
│ 2   │ 2     │ 8     │
│ 3   │ 3     │ 10    │
│ 4   │ 4     │ 12    │

julia&gt; by(df, :a, :c =&gt; x -&gt; 2 .* x)
8×2 DataFrame
│ Row │ a     │ c_function │
│     │ Int64 │ Int64      │
├─────┼───────┼────────────┤
│ 1   │ 1     │ 2          │
│ 2   │ 1     │ 10         │
│ 3   │ 2     │ 4          │
│ 4   │ 2     │ 12         │
│ 5   │ 3     │ 6          │
│ 6   │ 3     │ 14         │
│ 7   │ 4     │ 8          │
│ 8   │ 4     │ 16         │

julia&gt; by(df, :a, c_sum = :c =&gt; sum, c_sum2 = :c =&gt; x -&gt; sum(x.^2))
4×3 DataFrame
│ Row │ a     │ c_sum │ c_sum2 │
│     │ Int64 │ Int64 │ Int64  │
├─────┼───────┼───────┼────────┤
│ 1   │ 1     │ 6     │ 26     │
│ 2   │ 2     │ 8     │ 40     │
│ 3   │ 3     │ 10    │ 58     │
│ 4   │ 4     │ 12    │ 80     │

julia&gt; by(df, :a, (:b, :c) =&gt; x -&gt; (minb = minimum(x.b), sumc = sum(x.c)))
4×3 DataFrame
│ Row │ a     │ minb  │ sumc  │
│     │ Int64 │ Int64 │ Int64 │
├─────┼───────┼───────┼───────┤
│ 1   │ 1     │ 2     │ 6     │
│ 2   │ 2     │ 1     │ 8     │
│ 3   │ 3     │ 2     │ 10    │
│ 4   │ 4     │ 1     │ 12    │</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/25e23b7afdab1210bc22955b9243e31a989d7388/src/groupeddataframe/grouping.jl#L926-L1062">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataFrames.combine" href="#DataFrames.combine"><code>DataFrames.combine</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">combine(gd::GroupedDataFrame, cols =&gt; f...)
combine(gd::GroupedDataFrame; (colname = cols =&gt; f)...)
combine(gd::GroupedDataFrame, f)
combine(f, gd::GroupedDataFrame)</code></pre><p>Transform a <a href="types.html#DataFrames.GroupedDataFrame"><code>GroupedDataFrame</code></a> into a <code>DataFrame</code>.</p><p>If the last argument(s) consist(s) in one or more <code>cols =&gt; f</code> pair(s), or if <code>colname = cols =&gt; f</code> keyword arguments are provided, <code>cols</code> must be a column name or index, or a vector or tuple thereof, and <code>f</code> must be a callable. A pair or a (named) tuple of pairs can also be provided as the first or last argument. If <code>cols</code> is a single column index, <code>f</code> is called with a <code>SubArray</code> view into that column for each group; else, <code>f</code> is called with a named tuple holding <code>SubArray</code> views into these columns.</p><p>If the last argument is a callable <code>f</code>, it is passed a <a href="types.html#DataFrames.SubDataFrame"><code>SubDataFrame</code></a> view for each group, and the returned <code>DataFrame</code> then consists of the returned rows plus the grouping columns. Note that this second form is much slower than the first one due to type instability. A method is defined with <code>f</code> as the first argument, so do-block notation can be used.</p><p><code>f</code> can return a single value, a row or multiple rows. The type of the returned value determines the shape of the resulting data frame:</p><ul><li>A single value gives a data frame with a single column and one row per group.</li><li>A named tuple of single values or a <a href="types.html#DataFrames.DataFrameRow"><code>DataFrameRow</code></a> gives a data frame with one column for each field and one row per group.</li><li>A vector gives a data frame with a single column and as many rows for each group as the length of the returned vector for that group.</li><li>A data frame, a named tuple of vectors or a matrix gives a data frame with the same columns and as many rows for each group as the rows returned for that group.</li></ul><p><code>f</code> must always return the same kind of object (as defined in the above list) for all groups, and if a named tuple or data frame, with the same fields or columns. Named tuples cannot mix single values and vectors. Due to type instability, returning a single value or a named tuple is dramatically faster than returning a data frame.</p><p>As a special case, if a tuple or vector of pairs is passed as the first argument, each function is required to return a single value or vector, which will produce each a separate column.</p><p>In all cases, the resulting data frame contains all the grouping columns in addition to those generated by the application of <code>f</code>. Column names are automatically generated when necessary: for functions operating on a single column and returning a single value or vector, the function name is appended to the input column name; for other functions, columns are called <code>x1</code>, <code>x2</code> and so on. The resulting data frame will be sorted if <code>sort=true</code> was passed to the <a href="functions.html#DataFrames.groupby"><code>groupby</code></a> call from which <code>gd</code> was constructed. Otherwise, ordering of rows is undefined.</p><p>Optimized methods are used when standard summary functions (<code>sum</code>, <code>prod</code>, <code>minimum</code>, <code>maximum</code>, <code>mean</code>, <code>var</code>, <code>std</code>, <code>first</code>, <code>last</code> and <code>length) are specified using the pair syntax (e.g.</code>col =&gt; sum<code>). When computing the</code>sum<code>or</code>mean<code>over floating point columns, results will be less accurate than the standard [</code>sum<code>](@ref) function (which uses pairwise summation). Use</code>col =&gt; x -&gt; sum(x)` to avoid the optimized method and use the slower, more accurate one.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; df = DataFrame(a = repeat([1, 2, 3, 4], outer=[2]),
                      b = repeat([2, 1], outer=[4]),
                      c = 1:8);

julia&gt; gd = groupby(df, :a);

julia&gt; combine(gd, :c =&gt; sum)
4×2 DataFrame
│ Row │ a     │ c_sum │
│     │ Int64 │ Int64 │
├─────┼───────┼───────┤
│ 1   │ 1     │ 6     │
│ 2   │ 2     │ 8     │
│ 3   │ 3     │ 10    │
│ 4   │ 4     │ 12    │

julia&gt; combine(:c =&gt; sum, gd)
4×2 DataFrame
│ Row │ a     │ c_sum │
│     │ Int64 │ Int64 │
├─────┼───────┼───────┤
│ 1   │ 1     │ 6     │
│ 2   │ 2     │ 8     │
│ 3   │ 3     │ 10    │
│ 4   │ 4     │ 12    │

julia&gt; combine(df -&gt; sum(df.c), gd) # Slower variant
4×2 DataFrame
│ Row │ a     │ x1    │
│     │ Int64 │ Int64 │
├─────┼───────┼───────┤
│ 1   │ 1     │ 6     │
│ 2   │ 2     │ 8     │
│ 3   │ 3     │ 10    │
│ 4   │ 4     │ 12    │</code></pre><p>See <a href="functions.html#DataFrames.by"><code>by</code></a> for more examples.</p><p><strong>See also</strong></p><p><a href="functions.html#DataFrames.by"><code>by(f, df, cols)</code></a> is a shorthand for <code>combine(f, groupby(df, cols))</code>.</p><p><a href="functions.html#Base.map"><code>map</code></a>: <code>combine(f, groupby(df, cols))</code> is a more efficient equivalent of <code>combine(map(f, groupby(df, cols)))</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/25e23b7afdab1210bc22955b9243e31a989d7388/src/groupeddataframe/grouping.jl#L324-L430">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataFrames.groupby" href="#DataFrames.groupby"><code>DataFrames.groupby</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>A view of an <code>AbstractDataFrame</code> split into row groups</p><pre><code class="language-julia">groupby(d::AbstractDataFrame, cols; sort = false, skipmissing = false)
groupby(cols; sort = false, skipmissing = false)</code></pre><p><strong>Arguments</strong></p><ul><li><code>df</code> : an <code>AbstractDataFrame</code> to split (optional, see <a href="#returns">Returns</a>)</li><li><code>cols</code> : data table columns to group by</li><li><code>sort</code> : whether to sort rows according to the values of the grouping columns <code>cols</code></li><li><code>skipmissing</code> : whether to skip rows with <code>missing</code> values in one of the grouping columns <code>cols</code></li></ul><p><strong>Returns</strong></p><p>A <code>GroupedDataFrame</code> : a grouped view into <code>df</code></p><p><strong>Details</strong></p><p>An iterator over a <code>GroupedDataFrame</code> returns a <code>SubDataFrame</code> view for each grouping into <code>df</code>. Within each group, the order of rows in <code>df</code> is preserved.</p><p>A <code>GroupedDataFrame</code> also supports indexing by groups, <code>map</code> (which applies a function to each group) and <code>combine</code> (which applies a function to each group and combines the result into a data frame).</p><p>See the following for additional split-apply-combine operations:</p><ul><li><code>by</code> : split-apply-combine using functions</li><li><code>aggregate</code> : split-apply-combine; applies functions in the form of a cross product</li><li><code>map</code> : apply a function to each group of a <code>GroupedDataFrame</code> (without combining)</li><li><code>combine</code> : combine a <code>GroupedDataFrame</code>, optionally applying a function to each group</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; df = DataFrame(a = repeat([1, 2, 3, 4], outer=[2]),
                      b = repeat([2, 1], outer=[4]),
                      c = 1:8);

julia&gt; gd = groupby(df, :a)
GroupedDataFrame with 4 groups based on key: a
First Group (2 rows): a = 1
│ Row │ a     │ b     │ c     │
│     │ Int64 │ Int64 │ Int64 │
├─────┼───────┼───────┼───────┤
│ 1   │ 1     │ 2     │ 1     │
│ 2   │ 1     │ 2     │ 5     │
⋮
Last Group (2 rows): a = 4
│ Row │ a     │ b     │ c     │
│     │ Int64 │ Int64 │ Int64 │
├─────┼───────┼───────┼───────┤
│ 1   │ 4     │ 1     │ 4     │
│ 2   │ 4     │ 1     │ 8     │

julia&gt; gd[1]
2×3 SubDataFrame
│ Row │ a     │ b     │ c     │
│     │ Int64 │ Int64 │ Int64 │
├─────┼───────┼───────┼───────┤
│ 1   │ 1     │ 2     │ 1     │
│ 2   │ 1     │ 2     │ 5     │

julia&gt; last(gd)
2×3 SubDataFrame
│ Row │ a     │ b     │ c     │
│     │ Int64 │ Int64 │ Int64 │
├─────┼───────┼───────┼───────┤
│ 1   │ 4     │ 1     │ 4     │
│ 2   │ 4     │ 1     │ 8     │

julia&gt; for g in gd
           println(g)
       end
2×3 SubDataFrame
│ Row │ a     │ b     │ c     │
│     │ Int64 │ Int64 │ Int64 │
├─────┼───────┼───────┼───────┤
│ 1   │ 1     │ 2     │ 1     │
│ 2   │ 1     │ 2     │ 5     │
2×3 SubDataFrame
│ Row │ a     │ b     │ c     │
│     │ Int64 │ Int64 │ Int64 │
├─────┼───────┼───────┼───────┤
│ 1   │ 2     │ 1     │ 2     │
│ 2   │ 2     │ 1     │ 6     │
2×3 SubDataFrame
│ Row │ a     │ b     │ c     │
│     │ Int64 │ Int64 │ Int64 │
├─────┼───────┼───────┼───────┤
│ 1   │ 3     │ 2     │ 3     │
│ 2   │ 3     │ 2     │ 7     │
2×3 SubDataFrame
│ Row │ a     │ b     │ c     │
│     │ Int64 │ Int64 │ Int64 │
├─────┼───────┼───────┼───────┤
│ 1   │ 4     │ 1     │ 4     │
│ 2   │ 4     │ 1     │ 8     │</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/25e23b7afdab1210bc22955b9243e31a989d7388/src/groupeddataframe/grouping.jl#L29-L134">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataFrames.groupindices" href="#DataFrames.groupindices"><code>DataFrames.groupindices</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">groupindices(gd::GroupedDataFrame)</code></pre><p>Return a vector of group indices for each row of <code>parent(gd)</code>.</p><p>Rows appearing in group <code>gd[i]</code> are attributed index <code>i</code>. Rows not present in any group are attributed <code>missing</code> (this can happen if <code>skipmissing=true</code> was passed when creating <code>gd</code>, or if <code>gd</code> is a subset from a larger <a href="types.html#DataFrames.GroupedDataFrame"><code>GroupedDataFrame</code></a>).</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/25e23b7afdab1210bc22955b9243e31a989d7388/src/groupeddataframe/grouping.jl#L1199-L1207">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataFrames.groupvars" href="#DataFrames.groupvars"><code>DataFrames.groupvars</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">groupvars(gd::GroupedDataFrame)</code></pre><p>Return a vector of column names in <code>parent(gd)</code> used for grouping.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/25e23b7afdab1210bc22955b9243e31a989d7388/src/groupeddataframe/grouping.jl#L1210-L1214">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.join" href="#Base.join"><code>Base.join</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">join(df1, df2; on = Symbol[], kind = :inner, makeunique = false,
     indicator = nothing, validate = (false, false))</code></pre><p>Join two <code>DataFrame</code> objects</p><p><strong>Arguments</strong></p><ul><li><code>df1</code>, <code>df2</code> : the two AbstractDataFrames to be joined</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><p><code>on</code> : A column, or vector of columns to join df1 and df2 on. If the column(s)   that df1 and df2 will be joined on have different names, then the columns   should be <code>(left, right)</code> tuples or <code>left =&gt; right</code> pairs, or a vector of   such tuples or pairs. <code>on</code> is a required argument for all joins except for   <code>kind = :cross</code></p></li><li><p><code>kind</code> : the type of join, options include:</p><ul><li><code>:inner</code> : only include rows with keys that match in both <code>df1</code> and <code>df2</code>, the default</li><li><code>:outer</code> : include all rows from <code>df1</code> and <code>df2</code></li><li><code>:left</code> : include all rows from <code>df1</code></li><li><code>:right</code> : include all rows from <code>df2</code></li><li><code>:semi</code> : return rows of <code>df1</code> that match with the keys in <code>df2</code></li><li><code>:anti</code> : return rows of <code>df1</code> that do not match with the keys in <code>df2</code></li><li><code>:cross</code> : a full Cartesian product of the key combinations; every row of <code>df1</code> is matched with every row of <code>df2</code></li></ul></li></ul><ul><li><p><code>makeunique</code> : if <code>false</code> (the default), an error will be raised if duplicate names are found in columns not joined on; if <code>true</code>, duplicate names will be suffixed with <code>_i</code> (<code>i</code> starting at 1 for the first duplicate).</p></li><li><p><code>indicator</code> : Default: <code>nothing</code>. If a <code>Symbol</code>, adds categorical indicator  column named <code>Symbol</code> for whether a row appeared in only <code>df1</code> (<code>&quot;left_only&quot;</code>),  only <code>df2</code> (<code>&quot;right_only&quot;</code>) or in both (<code>&quot;both&quot;</code>). If <code>Symbol</code> is already in use,  the column name will be modified if <code>makeunique=true</code>.</p></li><li><p><code>validate</code> : whether to check that columns passed as the <code>on</code> argument  define unique keys in each input data frame (according to <a href="lib/@ref"><code>isequal</code></a>).  Can be a tuple or a pair, with the first element indicating whether to  run check for <code>df1</code> and the second element for <code>df2</code>.  By default no check is performed.</p></li></ul><p>For the three join operations that may introduce missing values (<code>:outer</code>, <code>:left</code>, and <code>:right</code>), all columns of the returned data table will support missing values.</p><p>When merging <code>on</code> categorical columns that differ in the ordering of their levels, the ordering of the left <code>DataFrame</code> takes precedence over the ordering of the right <code>DataFrame</code></p><p><strong>Result</strong></p><ul><li><code>::DataFrame</code> : the joined DataFrame</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia">name = DataFrame(ID = [1, 2, 3], Name = [&quot;John Doe&quot;, &quot;Jane Doe&quot;, &quot;Joe Blogs&quot;])
job = DataFrame(ID = [1, 2, 4], Job = [&quot;Lawyer&quot;, &quot;Doctor&quot;, &quot;Farmer&quot;])

join(name, job, on = :ID)
join(name, job, on = :ID, kind = :outer)
join(name, job, on = :ID, kind = :left)
join(name, job, on = :ID, kind = :right)
join(name, job, on = :ID, kind = :semi)
join(name, job, on = :ID, kind = :anti)
join(name, job, kind = :cross)

job2 = DataFrame(identifier = [1, 2, 4], Job = [&quot;Lawyer&quot;, &quot;Doctor&quot;, &quot;Farmer&quot;])
join(name, job2, on = (:ID, :identifier))
join(name, job2, on = :ID =&gt; :identifier)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/25e23b7afdab1210bc22955b9243e31a989d7388/src/abstractdataframe/join.jl#L216-L292">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.map" href="#Base.map"><code>Base.map</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">map(cols =&gt; f, gd::GroupedDataFrame)
map(f, gd::GroupedDataFrame)</code></pre><p>Apply a function to each group of rows and return a <a href="types.html#DataFrames.GroupedDataFrame"><code>GroupedDataFrame</code></a>.</p><p>If the first argument is a <code>cols =&gt; f</code> pair, <code>cols</code> must be a column name or index, or a vector or tuple thereof, and <code>f</code> must be a callable. If <code>cols</code> is a single column index, <code>f</code> is called with a <code>SubArray</code> view into that column for each group; else, <code>f</code> is called with a named tuple holding <code>SubArray</code> views into these columns.</p><p>If the first argument is a vector, tuple or named tuple of such pairs, each pair is handled as described above. If a named tuple, field names are used to name each generated column.</p><p>If the first argument is a callable, it is passed a <code>SubDataFrame</code> view for each group, and the returned <code>DataFrame</code> then consists of the returned rows plus the grouping columns. Note that this second form is much slower than the first one due to type instability.</p><p><code>f</code> can return a single value, a row or multiple rows. The type of the returned value determines the shape of the resulting data frame:</p><ul><li>A single value gives a data frame with a single column and one row per group.</li><li>A named tuple of single values or a <a href="types.html#DataFrames.DataFrameRow"><code>DataFrameRow</code></a> gives a data frame with one column for each field and one row per group.</li><li>A vector gives a data frame with a single column and as many rows for each group as the length of the returned vector for that group.</li><li>A data frame, a named tuple of vectors or a matrix gives a data frame with the same columns and as many rows for each group as the rows returned for that group.</li></ul><p><code>f</code> must always return the same kind of object (as defined in the above list) for all groups, and if a named tuple or data frame, with the same fields or columns. Named tuples cannot mix single values and vectors. Due to type instability, returning a single value or a named tuple is dramatically faster than returning a data frame.</p><p>As a special case, if a tuple or vector of pairs is passed as the first argument, each function is required to return a single value or vector, which will produce each a separate column.</p><p>In all cases, the resulting <code>GroupedDataFrame</code> contains all the grouping columns in addition to those generated by the application of <code>f</code>. Column names are automatically generated when necessary: for functions operating on a single column and returning a single value or vector, the function name is appended to the input column name; for other functions, columns are called <code>x1</code>, <code>x2</code> and so on.</p><p>Optimized methods are used when standard summary functions (<code>sum</code>, <code>prod</code>, <code>minimum</code>, <code>maximum</code>, <code>mean</code>, <code>var</code>, <code>std</code>, <code>first</code>, <code>last</code> and <code>length) are specified using the pair syntax (e.g.</code>col =&gt; sum<code>). When computing the</code>sum<code>or</code>mean<code>over floating point columns, results will be less accurate than the standard [</code>sum<code>](@ref) function (which uses pairwise summation). Use</code>col =&gt; x -&gt; sum(x)` to avoid the optimized method and use the slower, more accurate one.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; df = DataFrame(a = repeat([1, 2, 3, 4], outer=[2]),
                      b = repeat([2, 1], outer=[4]),
                      c = 1:8);

julia&gt; gd = groupby(df, :a);

julia&gt; map(:c =&gt; sum, gd)
GroupedDataFrame{DataFrame} with 4 groups based on key: :a
First Group: 1 row
│ Row │ a     │ c_sum │
│     │ Int64 │ Int64 │
├─────┼───────┼───────┤
│ 1   │ 1     │ 6     │
⋮
Last Group: 1 row
│ Row │ a     │ c_sum │
│     │ Int64 │ Int64 │
├─────┼───────┼───────┤
│ 1   │ 4     │ 12    │

julia&gt; map(df -&gt; sum(df.c), gd) # Slower variant
GroupedDataFrame{DataFrame} with 4 groups based on key: :a
First Group: 1 row
│ Row │ a     │ x1    │
│     │ Int64 │ Int64 │
├─────┼───────┼───────┤
│ 1   │ 1     │ 6     │
⋮
Last Group: 1 row
│ Row │ a     │ x1    │
│     │ Int64 │ Int64 │
├─────┼───────┼───────┤
│ 1   │ 4     │ 12    │</code></pre><p>See <a href="functions.html#DataFrames.by"><code>by</code></a> for more examples.</p><p><strong>See also</strong></p><p><code>combine(f, gd)</code> returns a <code>DataFrame</code> rather than a <code>GroupedDataFrame</code></p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/25e23b7afdab1210bc22955b9243e31a989d7388/src/groupeddataframe/grouping.jl#L196-L292">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataFrames.melt" href="#DataFrames.melt"><code>DataFrames.melt</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Stacks a DataFrame; convert from a wide to long format; see <code>stack</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/25e23b7afdab1210bc22955b9243e31a989d7388/src/abstractdataframe/reshape.jl#L121-L124">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataFrames.stack" href="#DataFrames.stack"><code>DataFrames.stack</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Stacks a DataFrame; convert from a wide to long format</p><pre><code class="language-julia">stack(df::AbstractDataFrame, [measure_vars], [id_vars];
      variable_name::Symbol=:variable, value_name::Symbol=:value)
melt(df::AbstractDataFrame, [id_vars], [measure_vars];
     variable_name::Symbol=:variable, value_name::Symbol=:value)</code></pre><p><strong>Arguments</strong></p><ul><li><p><code>df</code> : the AbstractDataFrame to be stacked</p></li><li><p><code>measure_vars</code> : the columns to be stacked (the measurement variables), a normal column indexing type, like a Symbol, Vector{Symbol}, Int, etc.; for <code>melt</code>, defaults to all variables that are not <code>id_vars</code>. If neither <code>measure_vars</code> or <code>id_vars</code> are given, <code>measure_vars</code> defaults to all floating point columns.</p></li><li><p><code>id_vars</code> : the identifier columns that are repeated during stacking, a normal column indexing type; for <code>stack</code> defaults to all variables that are not <code>measure_vars</code></p></li><li><p><code>variable_name</code> : the name of the new stacked column that shall hold the names of each of <code>measure_vars</code></p></li><li><p><code>value_name</code> : the name of the new stacked column containing the values from each of <code>measure_vars</code></p></li></ul><p><strong>Result</strong></p><ul><li><code>::DataFrame</code> : the long-format DataFrame with column <code>:value</code> holding the values of the stacked columns (<code>measure_vars</code>), with column <code>:variable</code> a Vector of Symbols with the <code>measure_vars</code> name, and with columns for each of the <code>id_vars</code>.</li></ul><p>See also <code>stackdf</code> and <code>meltdf</code> for stacking methods that return a view into the original DataFrame. See <code>unstack</code> for converting from long to wide format.</p><p><strong>Examples</strong></p><pre><code class="language-julia">d1 = DataFrame(a = repeat([1:3;], inner = [4]),
               b = repeat([1:4;], inner = [3]),
               c = randn(12),
               d = randn(12),
               e = map(string, &#39;a&#39;:&#39;l&#39;))

d1s = stack(d1, [:c, :d])
d1s2 = stack(d1, [:c, :d], [:a])
d1m = melt(d1, [:a, :b, :e])
d1s_name = melt(d1, [:a, :b, :e], variable_name=:somemeasure)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/25e23b7afdab1210bc22955b9243e31a989d7388/src/abstractdataframe/reshape.jl#L16-L76">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataFrames.unstack" href="#DataFrames.unstack"><code>DataFrames.unstack</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Unstacks a DataFrame; convert from a long to wide format</p><pre><code class="language-julia">unstack(df::AbstractDataFrame, rowkeys::Union{Symbol, Integer},
        colkey::Union{Symbol, Integer}, value::Union{Symbol, Integer})
unstack(df::AbstractDataFrame, rowkeys::AbstractVector{&lt;:Union{Symbol, Integer}},
        colkey::Union{Symbol, Integer}, value::Union{Symbol, Integer})
unstack(df::AbstractDataFrame, colkey::Union{Symbol, Integer},
        value::Union{Symbol, Integer})
unstack(df::AbstractDataFrame)</code></pre><p><strong>Arguments</strong></p><ul><li><p><code>df</code> : the AbstractDataFrame to be unstacked</p></li><li><p><code>rowkeys</code> : the column(s) with a unique key for each row, if not given, find a key by grouping on anything not a <code>colkey</code> or <code>value</code></p></li><li><p><code>colkey</code> : the column holding the column names in wide format, defaults to <code>:variable</code></p></li><li><p><code>value</code> : the value column, defaults to <code>:value</code></p></li></ul><p><strong>Result</strong></p><ul><li><code>::DataFrame</code> : the wide-format DataFrame</li></ul><p>If <code>colkey</code> contains <code>missing</code> values then they will be skipped and a warning will be printed.</p><p>If combination of <code>rowkeys</code> and <code>colkey</code> contains duplicate entries then last <code>value</code> will be retained and a warning will be printed.</p><p><strong>Examples</strong></p><pre><code class="language-julia">wide = DataFrame(id = 1:12,
                 a  = repeat([1:3;], inner = [4]),
                 b  = repeat([1:4;], inner = [3]),
                 c  = randn(12),
                 d  = randn(12))

long = stack(wide)
wide0 = unstack(long)
wide1 = unstack(long, :variable, :value)
wide2 = unstack(long, :id, :variable, :value)
wide3 = unstack(long, [:id, :a], :variable, :value)</code></pre><p>Note that there are some differences between the widened results above.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/25e23b7afdab1210bc22955b9243e31a989d7388/src/abstractdataframe/reshape.jl#L149-L199">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataFrames.stackdf" href="#DataFrames.stackdf"><code>DataFrames.stackdf</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>A stacked view of a DataFrame (long format)</p><p>Like <code>stack</code> and <code>melt</code>, but a view is returned rather than data copies.</p><pre><code class="language-julia">stackdf(df::AbstractDataFrame, [measure_vars], [id_vars];
        variable_name::Symbol=:variable, value_name::Symbol=:value)
meltdf(df::AbstractDataFrame, [id_vars], [measure_vars];
       variable_name::Symbol=:variable, value_name::Symbol=:value)</code></pre><p><strong>Arguments</strong></p><ul><li><p><code>df</code> : the wide AbstractDataFrame</p></li><li><p><code>measure_vars</code> : the columns to be stacked (the measurement variables), a normal column indexing type, like a Symbol, Vector{Symbol}, Int, etc.; for <code>melt</code>, defaults to all variables that are not <code>id_vars</code></p></li><li><p><code>id_vars</code> : the identifier columns that are repeated during stacking, a normal column indexing type; for <code>stack</code> defaults to all variables that are not <code>measure_vars</code></p></li></ul><p><strong>Result</strong></p><ul><li><code>::DataFrame</code> : the long-format DataFrame with column <code>:value</code> holding the values of the stacked columns (<code>measure_vars</code>), with column <code>:variable</code> a Vector of Symbols with the <code>measure_vars</code> name, and with columns for each of the <code>id_vars</code>.</li></ul><p>The result is a view because the columns are special AbstractVectors that return indexed views into the original DataFrame.</p><p><strong>Examples</strong></p><pre><code class="language-julia">d1 = DataFrame(a = repeat([1:3;], inner = [4]),
               b = repeat([1:4;], inner = [3]),
               c = randn(12),
               d = randn(12),
               e = map(string, &#39;a&#39;:&#39;l&#39;))

d1s = stackdf(d1, [:c, :d])
d1s2 = stackdf(d1, [:c, :d], [:a])
d1m = meltdf(d1, [:a, :b, :e])</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/25e23b7afdab1210bc22955b9243e31a989d7388/src/abstractdataframe/reshape.jl#L459-L509">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataFrames.meltdf" href="#DataFrames.meltdf"><code>DataFrames.meltdf</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>A stacked view of a DataFrame (long format); see <code>stackdf</code></p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/DataFrames.jl/blob/25e23b7afdab1210bc22955b9243e31a989d7388/src/abstractdataframe/reshape.jl#L549-L551">source</a></section><h2><a class="nav-anchor" id="Basics-1" href="#Basics-1">Basics</a></h2><pre><code class="language-none">allowmissing!
categorical!
completecases
copy
DataFrame
DataFrame!
deletecols!
deletecols
deleterows!
describe
disallowmissing!
dropmissing
dropmissing!
eachrow
eachcol
eltypes
filter
filter!
hcat
insertcols!
mapcols
names!
nonunique
nrow
ncol
rename!
rename
repeat
select
select!
show
sort
sort!
unique!
permutecols!
vcat
append!
push!</code></pre><footer><hr/><a class="previous" href="types.html"><span class="direction">Previous</span><span class="title">Types</span></a><a class="next" href="indexing.html"><span class="direction">Next</span><span class="title">Indexing</span></a></footer></article></body></html>
